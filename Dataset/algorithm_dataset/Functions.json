[{"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_threshold_graph(G):\n\"\"\"\n    Returns `True` if `G` is a threshold graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph instance\n        An instance of `Graph`, `DiGraph`, `MultiGraph` or `MultiDiGraph`\n\n    Returns\n    -------\n    bool\n        `True` if `G` is a threshold graph, `False` otherwise.\n\n    Examples\n    --------\n    >>> from networkx.algorithms.threshold import is_threshold_graph\n    >>> G = nx.path_graph(3)\n    >>> is_threshold_graph(G)\n    True\n    >>> G = nx.barbell_graph(3, 3)\n    >>> is_threshold_graph(G)\n    False\n\n    References\n    ----------\n    .. [1] Threshold graphs: https://en.wikipedia.org/wiki/Threshold_graph\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=None, returns_graph=True)\ndef threshold_graph(creation_sequence, create_using=None):\n\"\"\"\n    Create a threshold graph from the creation sequence or compact\n    creation_sequence.\n\n    The input sequence can be a\n\n    creation sequence (e.g. ['d','i','d','d','d','i'])\n    labeled creation sequence (e.g. [(0,'d'),(2,'d'),(1,'i')])\n    compact creation sequence (e.g. [2,1,1,2,0])\n\n    Use cs=creation_sequence(degree_sequence,labeled=True)\n    to convert a degree sequence to a creation sequence.\n\n    Returns None if the sequence is not valid\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef find_threshold_graph(G, create_using=None):\n\"\"\"\n    Returns a threshold subgraph that is close to largest in `G`.\n\n    The threshold graph will contain the largest degree node in G.\n\n    Parameters\n    ----------\n    G : NetworkX graph instance\n        An instance of `Graph`, or `MultiDiGraph`\n    create_using : NetworkX graph class or `None` (default), optional\n        Type of graph to use when constructing the threshold graph.\n        If `None`, infer the appropriate graph type from the input.\n\n    Returns\n    -------\n    graph :\n        A graph instance representing the threshold graph\n\n    Examples\n    --------\n    >>> from networkx.algorithms.threshold import find_threshold_graph\n    >>> G = nx.barbell_graph(3, 3)\n    >>> T = find_threshold_graph(G)\n    >>> T.nodes  # may vary\n    NodeView((7, 8, 5, 6))\n\n    References\n    ----------\n    .. [1] Threshold graphs: https://en.wikipedia.org/wiki/Threshold_graph\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef all_pairs_lowest_common_ancestor(G, pairs=None):\n\"\"\"Return the lowest common ancestor of all pairs or the provided pairs\n\n    Parameters\n    ----------\n    G : NetworkX directed graph\n\n    pairs : iterable of pairs of nodes, optional (default: all pairs)\n        The pairs of nodes of interest.\n        If None, will find the LCA of all pairs of nodes.\n\n    Yields\n    ------\n    ((node1, node2), lca) : 2-tuple\n        Where lca is least common ancestor of node1 and node2.\n        Note that for the default case, the order of the node pair is not considered,\n        e.g. you will not get both ``(a, b)`` and ``(b, a)``\n\n    Raises\n    ------\n    NetworkXPointlessConcept\n        If `G` is null.\n    NetworkXError\n        If `G` is not a DAG.\n\n    Examples\n    --------\n    The default behavior is to yield the lowest common ancestor for all\n    possible combinations of nodes in `G`, including self-pairings:\n\n    >>> G = nx.DiGraph([(0, 1), (0, 3), (1, 2)])\n    >>> dict(nx.all_pairs_lowest_common_ancestor(G))\n    {(0, 0): 0, (0, 1): 0, (0, 3): 0, (0, 2): 0, (1, 1): 1, (1, 3): 0, (1, 2): 1, (3, 3): 3, (3, 2): 0, (2, 2): 2}\n\n    The pairs argument can be used to limit the output to only the\n    specified node pairings:\n\n    >>> dict(nx.all_pairs_lowest_common_ancestor(G, pairs=[(1, 2), (2, 3)]))\n    {(1, 2): 1, (2, 3): 0}\n\n    Notes\n    -----\n    Only defined on non-null directed acyclic graphs.\n\n    See Also\n    --------\n    lowest_common_ancestor\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef tree_all_pairs_lowest_common_ancestor(G, root=None, pairs=None):\n\"\"\"Yield the lowest common ancestor for sets of pairs in a tree.\n\n    Parameters\n    ----------\n    G : NetworkX directed graph (must be a tree)\n\n    root : node, optional (default: None)\n        The root of the subtree to operate on.\n        If None, assume the entire graph has exactly one source and use that.\n\n    pairs : iterable or iterator of pairs of nodes, optional (default: None)\n        The pairs of interest. If None, Defaults to all pairs of nodes\n        under `root` that have a lowest common ancestor.\n\n    Returns\n    -------\n    lcas : generator of tuples `((u, v), lca)` where `u` and `v` are nodes\n        in `pairs` and `lca` is their lowest common ancestor.\n\n    Examples\n    --------\n    >>> import pprint\n    >>> G = nx.DiGraph([(1, 3), (2, 4), (1, 2)])\n    >>> pprint.pprint(dict(nx.tree_all_pairs_lowest_common_ancestor(G)))\n    {(1, 1): 1,\n     (2, 1): 1,\n     (2, 2): 2,\n     (3, 1): 1,\n     (3, 2): 1,\n     (3, 3): 3,\n     (3, 4): 1,\n     (4, 1): 1,\n     (4, 2): 2,\n     (4, 4): 4}\n\n    We can also use `pairs` argument to specify the pairs of nodes for which we\n    want to compute lowest common ancestors. Here is an example:\n\n    >>> dict(nx.tree_all_pairs_lowest_common_ancestor(G, pairs=[(1, 4), (2, 3)]))\n    {(2, 3): 1, (1, 4): 1}\n\n    Notes\n    -----\n    Only defined on non-null trees represented with directed edges from\n    parents to children. Uses Tarjan's off-line lowest-common-ancestors\n    algorithm. Runs in time $O(4 \\times (V + E + P))$ time, where 4 is the largest\n    value of the inverse Ackermann function likely to ever come up in actual\n    use, and $P$ is the number of pairs requested (or $V^2$ if all are needed).\n\n    Tarjan, R. E. (1979), \"Applications of path compression on balanced trees\",\n    Journal of the ACM 26 (4): 690-715, doi:10.1145/322154.322161.\n\n    See Also\n    --------\n    all_pairs_lowest_common_ancestor: similar routine for general DAGs\n    lowest_common_ancestor: just a single pair for general DAGs\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\", returns_graph=True)\ndef spanner(G, stretch, weight=None, seed=None):\n\"\"\"Returns a spanner of the given graph with the given stretch.\n\n    A spanner of a graph G = (V, E) with stretch t is a subgraph\n    H = (V, E_S) such that E_S is a subset of E and the distance between\n    any pair of nodes in H is at most t times the distance between the\n    nodes in G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        An undirected simple graph.\n\n    stretch : float\n        The stretch of the spanner.\n\n    weight : object\n        The edge attribute to use as distance.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    NetworkX graph\n        A spanner of the given graph with the given stretch.\n\n    Raises\n    ------\n    ValueError\n        If a stretch less than 1 is given.\n\n    Notes\n    -----\n    This function implements the spanner algorithm by Baswana and Sen,\n    see [1].\n\n    This algorithm is a randomized las vegas algorithm: The expected\n    running time is O(km) where k = (stretch + 1) // 2 and m is the\n    number of edges in G. The returned graph is always a spanner of the\n    given graph with the specified stretch. For weighted graphs the\n    number of edges in the spanner is O(k * n^(1 + 1 / k)) where k is\n    defined as above and n is the number of nodes in G. For unweighted\n    graphs the number of edges is O(n^(1 + 1 / k) + kn).\n\n    References\n    ----------\n    [1] S. Baswana, S. Sen. A Simple and Linear Time Randomized\n    Algorithm for Computing Sparse Spanners in Weighted Graphs.\n    Random Struct. Algorithms 30(4): 532-563 (2007).\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef s_metric(G):\n\"\"\"Returns the s-metric [1]_ of graph.\n\n    The s-metric is defined as the sum of the products ``deg(u) * deg(v)``\n    for every edge ``(u, v)`` in `G`.\n\n    Parameters\n    ----------\n    G : graph\n        The graph used to compute the s-metric.\n\n    Returns\n    -------\n    s : float\n        The s-metric of the graph.\n\n    References\n    ----------\n    .. [1] Lun Li, David Alderson, John C. Doyle, and Walter Willinger,\n           Towards a Theory of Scale-Free Graphs:\n           Definition, Properties, and  Implications (Extended Version), 2005.\n           https://arxiv.org/abs/cond-mat/0501169\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef rich_club_coefficient(G, normalized=True, Q=100, seed=None):\n\"\"\"Returns the rich-club coefficient of the graph `G`.\n\n    For each degree *k*, the *rich-club coefficient* is the ratio of the\n    number of actual to the number of potential edges for nodes with\n    degree greater than *k*:\n\n    .. math::\n\n        \\phi(k) = \\frac{2 E_k}{N_k (N_k - 1)}\n\n    where `N_k` is the number of nodes with degree larger than *k*, and\n    `E_k` is the number of edges among those nodes.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph with neither parallel edges nor self-loops.\n    normalized : bool (optional)\n        Normalize using randomized network as in [1]_\n    Q : float (optional, default=100)\n        If `normalized` is True, perform `Q * m` double-edge\n        swaps, where `m` is the number of edges in `G`, to use as a\n        null-model for normalization.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    rc : dictionary\n       A dictionary, keyed by degree, with rich-club coefficient values.\n\n    Raises\n    ------\n    NetworkXError\n        If `G` has fewer than four nodes and ``normalized=True``.\n        A randomly sampled graph for normalization cannot be generated in this case.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\n    >>> rc = nx.rich_club_coefficient(G, normalized=False, seed=42)\n    >>> rc[0]\n    0.4\n\n    Notes\n    -----\n    The rich club definition and algorithm are found in [1]_.  This\n    algorithm ignores any edge weights and is not defined for directed\n    graphs or graphs with parallel edges or self loops.\n\n    Normalization is done by computing the rich club coefficient for a randomly\n    sampled graph with the same degree distribution as `G` by\n    repeatedly swapping the endpoints of existing edges. For graphs with fewer than 4\n    nodes, it is not possible to generate a random graph with a prescribed\n    degree distribution, as the degree distribution fully determines the graph\n    (hence making the coefficients trivially normalized to 1).\n    This function raises an exception in this case.\n\n    Estimates for appropriate values of `Q` are found in [2]_.\n\n    References\n    ----------\n    .. [1] Julian J. McAuley, Luciano da Fontoura Costa,\n       and Tib\u00e9rio S. Caetano,\n       \"The rich-club phenomenon across complex network hierarchies\",\n       Applied Physics Letters Vol 91 Issue 8, August 2007.\n       https://arxiv.org/abs/physics/0701290\n    .. [2] R. Milo, N. Kashtan, S. Itzkovitz, M. E. J. Newman, U. Alon,\n       \"Uniform generation of random graphs with arbitrary degree\n       sequences\", 2006. https://arxiv.org/abs/cond-mat/0312028\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_regular(G):\n\"\"\"Determines whether the graph ``G`` is a regular graph.\n\n    A regular graph is a graph where each vertex has the same degree. A\n    regular digraph is a graph where the indegree and outdegree of each\n    vertex are equal.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    Returns\n    -------\n    bool\n        Whether the given graph or digraph is regular.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4), (4, 1)])\n    >>> nx.is_regular(G)\n    True\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(preserve_edge_attrs=True, returns_graph=True)\ndef k_factor(G, k, matching_weight=\"weight\"):\n\"\"\"Compute a k-factor of G\n\n    A k-factor of a graph is a spanning k-regular subgraph.\n    A spanning k-regular subgraph of G is a subgraph that contains\n    each vertex of G and a subset of the edges of G such that each\n    vertex has degree k.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n      Undirected graph\n\n    matching_weight: string, optional (default='weight')\n       Edge data key corresponding to the edge weight.\n       Used for finding the max-weighted perfect matching.\n       If key not found, uses 1 as weight.\n\n    Returns\n    -------\n    G2 : NetworkX graph\n        A k-factor of G\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (2, 3), (3, 4), (4, 1)])\n    >>> G2 = nx.k_factor(G, k=1)\n    >>> G2.edges()\n    EdgeView([(1, 2), (3, 4)])\n\n    References\n    ----------\n    .. [1] \"An algorithm for computing simple k-factors.\",\n       Meijer, Henk, Yurai N\u00fa\u00f1ez-Rodr\u00edguez, and David Rappaport,\n       Information processing letters, 2009.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=None)\ndef is_graphical(sequence, method=\"eg\"):\n\"\"\"Returns True if sequence is a valid degree sequence.\n\n    A degree sequence is valid if some graph can realize it.\n\n    Parameters\n    ----------\n    sequence : list or iterable container\n        A sequence of integer node degrees\n\n    method : \"eg\" | \"hh\"  (default: 'eg')\n        The method used to validate the degree sequence.\n        \"eg\" corresponds to the Erd\u0151s-Gallai algorithm\n        [EG1960]_, [choudum1986]_, and\n        \"hh\" to the Havel-Hakimi algorithm\n        [havel1955]_, [hakimi1962]_, [CL1996]_.\n\n    Returns\n    -------\n    valid : bool\n        True if the sequence is a valid degree sequence and False if not.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> sequence = (d for n, d in G.degree())\n    >>> nx.is_graphical(sequence)\n    True\n\n    To test a non-graphical sequence:\n    >>> sequence_list = [d for n, d in G.degree()]\n    >>> sequence_list[-1] += 1\n    >>> nx.is_graphical(sequence_list)\n    False\n\n    References\n    ----------\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\n    .. [choudum1986] S.A. Choudum. \"A simple proof of the Erd\u0151s-Gallai theorem on\n       graph sequences.\" Bulletin of the Australian Mathematical Society, 33,\n       pp 67-70, 1986. https://doi.org/10.1017/S0004972700002872\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\n       Casopis Pest. Mat. 80, 477-480, 1955.\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\n       Chapman and Hall/CRC, 1996.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=None)\ndef is_valid_degree_sequence_havel_hakimi(deg_sequence):\n\"\"\"Returns True if deg_sequence can be realized by a simple graph.\n\n    The validation proceeds using the Havel-Hakimi theorem\n    [havel1955]_, [hakimi1962]_, [CL1996]_.\n    Worst-case run time is $O(s)$ where $s$ is the sum of the sequence.\n\n    Parameters\n    ----------\n    deg_sequence : list\n        A list of integers where each element specifies the degree of a node\n        in a graph.\n\n    Returns\n    -------\n    valid : bool\n        True if deg_sequence is graphical and False if not.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n    >>> sequence = (d for _, d in G.degree())\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence)\n    True\n\n    To test a non-valid sequence:\n    >>> sequence_list = [d for _, d in G.degree()]\n    >>> sequence_list[-1] += 1\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\n    False\n\n    Notes\n    -----\n    The ZZ condition says that for the sequence d if\n\n    .. math::\n        |d| >= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}\n\n    then d is graphical.  This was shown in Theorem 6 in [1]_.\n\n    References\n    ----------\n    .. [1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\n       Casopis Pest. Mat. 80, 477-480, 1955.\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\n       Chapman and Hall/CRC, 1996.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=None)\ndef is_multigraphical(sequence):\n\"\"\"Returns True if some multigraph can realize the sequence.\n\n    Parameters\n    ----------\n    sequence : list\n        A list of integers\n\n    Returns\n    -------\n    valid : bool\n        True if deg_sequence is a multigraphic degree sequence and False if not.\n\n    Examples\n    --------\n    >>> G = nx.MultiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n    >>> sequence = (d for _, d in G.degree())\n    >>> nx.is_multigraphical(sequence)\n    True\n\n    To test a non-multigraphical sequence:\n    >>> sequence_list = [d for _, d in G.degree()]\n    >>> sequence_list[-1] += 1\n    >>> nx.is_multigraphical(sequence_list)\n    False\n\n    Notes\n    -----\n    The worst-case run time is $O(n)$ where $n$ is the length of the sequence.\n\n    References\n    ----------\n    .. [1] S. L. Hakimi. \"On the realizability of a set of integers as\n       degrees of the vertices of a linear graph\", J. SIAM, 10, pp. 496-506\n       (1962).\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(graphs=None)\ndef is_digraphical(in_sequence, out_sequence):\n\"\"\"Returns True if some directed graph can realize the in- and out-degree\n    sequences.\n\n    Parameters\n    ----------\n    in_sequence : list or iterable container\n        A sequence of integer node in-degrees\n\n    out_sequence : list or iterable container\n        A sequence of integer node out-degrees\n\n    Returns\n    -------\n    valid : bool\n      True if in and out-sequences are digraphic False if not.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n    >>> in_seq = (d for n, d in G.in_degree())\n    >>> out_seq = (d for n, d in G.out_degree())\n    >>> nx.is_digraphical(in_seq, out_seq)\n    True\n\n    To test a non-digraphical scenario:\n    >>> in_seq_list = [d for n, d in G.in_degree()]\n    >>> in_seq_list[-1] += 1\n    >>> nx.is_digraphical(in_seq_list, out_seq)\n    False\n\n    Notes\n    -----\n    This algorithm is from Kleitman and Wang [1]_.\n    The worst case runtime is $O(s \\times \\log n)$ where $s$ and $n$ are the\n    sum and length of the sequences respectively.\n\n    References\n    ----------\n    .. [1] D.J. Kleitman and D.L. Wang\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\n       and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef random_reference(G, niter=1, connectivity=True, seed=None):\n\"\"\"Compute a random graph by swapping edges of a given graph.\n\n    Parameters\n    ----------\n    G : graph\n        An undirected graph with 4 or more nodes.\n\n    niter : integer (optional, default=1)\n        An edge is rewired approximately `niter` times.\n\n    connectivity : boolean (optional, default=True)\n        When True, ensure connectivity for the randomized graph.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : graph\n        The randomized graph.\n\n    Raises\n    ------\n    NetworkXError\n        If there are fewer than 4 nodes or 2 edges in `G`\n\n    Notes\n    -----\n    The implementation is adapted from the algorithm by Maslov and Sneppen\n    (2002) [1]_.\n\n    References\n    ----------\n    .. [1] Maslov, Sergei, and Kim Sneppen.\n           \"Specificity and stability in topology of protein networks.\"\n           Science 296.5569 (2002): 910-913.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef sigma(G, niter=100, nrand=10, seed=None):\n\"\"\"Returns the small-world coefficient (sigma) of the given graph.\n\n    The small-world coefficient is defined as:\n    sigma = C/Cr / L/Lr\n    where C and L are respectively the average clustering coefficient and\n    average shortest path length of G. Cr and Lr are respectively the average\n    clustering coefficient and average shortest path length of an equivalent\n    random graph.\n\n    A graph is commonly classified as small-world if sigma>1.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        An undirected graph.\n    niter : integer (optional, default=100)\n        Approximate number of rewiring per edge to compute the equivalent\n        random graph.\n    nrand : integer (optional, default=10)\n        Number of random graphs generated to compute the average clustering\n        coefficient (Cr) and average shortest path length (Lr).\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    sigma : float\n        The small-world coefficient of G.\n\n    Notes\n    -----\n    The implementation is adapted from Humphries et al. [1]_ [2]_.\n\n    References\n    ----------\n    .. [1] The brainstem reticular formation is a small-world, not scale-free,\n           network M. D. Humphries, K. Gurney and T. J. Prescott,\n           Proc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.\n    .. [2] Humphries and Gurney (2008).\n           \"Network 'Small-World-Ness': A Quantitative Method for Determining\n           Canonical Network Equivalence\".\n           PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef bridges(G, root=None):\n\"\"\"Generate all bridges in a graph.\n\n    A *bridge* in a graph is an edge whose removal causes the number of\n    connected components of the graph to increase.  Equivalently, a bridge is an\n    edge that does not belong to any cycle. Bridges are also known as cut-edges,\n    isthmuses, or cut arcs.\n\n    Parameters\n    ----------\n    G : undirected graph\n\n    root : node (optional)\n       A node in the graph `G`. If specified, only the bridges in the\n       connected component containing this node will be returned.\n\n    Yields\n    ------\n    e : edge\n       An edge in the graph whose removal disconnects the graph (or\n       causes the number of connected components to increase).\n\n    Raises\n    ------\n    NodeNotFound\n       If `root` is not in the graph `G`.\n\n    NetworkXNotImplemented\n        If `G` is a directed graph.\n\n    Examples\n    --------\n    The barbell graph with parameter zero has a single bridge:\n\n    >>> G = nx.barbell_graph(10, 0)\n    >>> list(nx.bridges(G))\n    [(9, 10)]\n\n    Notes\n    -----\n    This is an implementation of the algorithm described in [1]_.  An edge is a\n    bridge if and only if it is not contained in any chain. Chains are found\n    using the :func:`networkx.chain_decomposition` function.\n\n    The algorithm described in [1]_ requires a simple graph. If the provided\n    graph is a multigraph, we convert it to a simple graph and verify that any\n    bridges discovered by the chain decomposition algorithm are not multi-edges.\n\n    Ignoring polylogarithmic factors, the worst-case time complexity is the\n    same as the :func:`networkx.chain_decomposition` function,\n    $O(m + n)$, where $n$ is the number of nodes in the graph and $m$ is\n    the number of edges.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29#Bridge-Finding_with_Chain_Decompositions\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef local_bridges(G, with_span=True, weight=None):\n\"\"\"Iterate over local bridges of `G` optionally computing the span\n\n    A *local bridge* is an edge whose endpoints have no common neighbors.\n    That is, the edge is not part of a triangle in the graph.\n\n    The *span* of a *local bridge* is the shortest path length between\n    the endpoints if the local bridge is removed.\n\n    Parameters\n    ----------\n    G : undirected graph\n\n    with_span : bool\n        If True, yield a 3-tuple `(u, v, span)`\n\n    weight : function, string or None (default: None)\n        If function, used to compute edge weights for the span.\n        If string, the edge data attribute used in calculating span.\n        If None, all edges have weight 1.\n\n    Yields\n    ------\n    e : edge\n        The local bridges as an edge 2-tuple of nodes `(u, v)` or\n        as a 3-tuple `(u, v, span)` when `with_span is True`.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is a directed graph or multigraph.\n\n    Examples\n    --------\n    A cycle graph has every edge a local bridge with span N-1.\n\n       >>> G = nx.cycle_graph(9)\n       >>> (0, 8, 8) in set(nx.local_bridges(G))\n       True\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef reciprocity(G, nodes=None):\n\"\"\"Compute the reciprocity in a directed graph.\n\n    The reciprocity of a directed graph is defined as the ratio\n    of the number of edges pointing in both directions to the total\n    number of edges in the graph.\n    Formally, $r = |{(u,v) \\in G|(v,u) \\in G}| / |{(u,v) \\in G}|$.\n\n    The reciprocity of a single node u is defined similarly,\n    it is the ratio of the number of edges in both directions to\n    the total number of edges attached to node u.\n\n    Parameters\n    ----------\n    G : graph\n       A networkx directed graph\n    nodes : container of nodes, optional (default=whole graph)\n       Compute reciprocity for nodes in this container.\n\n    Returns\n    -------\n    out : dictionary\n       Reciprocity keyed by node label.\n\n    Notes\n    -----\n    The reciprocity is not defined for isolated nodes.\n    In such cases this function will return None.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef overall_reciprocity(G):\n\"\"\"Compute the reciprocity for the whole graph.\n\n    See the doc of reciprocity for the definition.\n\n    Parameters\n    ----------\n    G : graph\n       A networkx graph\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef closeness_vitality(G, node=None, weight=None, wiener_index=None):\n\"\"\"Returns the closeness vitality for nodes in the graph.\n\n    The *closeness vitality* of a node, defined in Section 3.6.2 of [1],\n    is the change in the sum of distances between all node pairs when\n    excluding that node.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A strongly-connected graph.\n\n    weight : string\n        The name of the edge attribute used as weight. This is passed\n        directly to the :func:`~networkx.wiener_index` function.\n\n    node : object\n        If specified, only the closeness vitality for this node will be\n        returned. Otherwise, a dictionary mapping each node to its\n        closeness vitality will be returned.\n\n    Other parameters\n    ----------------\n    wiener_index : number\n        If you have already computed the Wiener index of the graph\n        `G`, you can provide that value here. Otherwise, it will be\n        computed for you.\n\n    Returns\n    -------\n    dictionary or float\n        If `node` is None, this function returns a dictionary\n        with nodes as keys and closeness vitality as the\n        value. Otherwise, it returns only the closeness vitality for the\n        specified `node`.\n\n        The closeness vitality of a node may be negative infinity if\n        removing that node would disconnect the graph.\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(3)\n    >>> nx.closeness_vitality(G)\n    {0: 2.0, 1: 2.0, 2: 2.0}\n\n    See Also\n    --------\n    closeness_centrality\n\n    References\n    ----------\n    .. [1] Ulrik Brandes, Thomas Erlebach (eds.).\n           *Network Analysis: Methodological Foundations*.\n           Springer, 2005.\n           <http://books.google.com/books?id=TTNhSm7HYrIC>\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef cut_size(G, S, T=None, weight=None):\n\"\"\"Returns the size of the cut between two sets of nodes.\n\n    A *cut* is a partition of the nodes of a graph into two sets. The\n    *cut size* is the sum of the weights of the edges \"between\" the two\n    sets of nodes.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    S : collection\n        A collection of nodes in `G`.\n\n    T : collection\n        A collection of nodes in `G`. If not specified, this is taken to\n        be the set complement of `S`.\n\n    weight : object\n        Edge attribute key to use as weight. If not specified, edges\n        have weight one.\n\n    Returns\n    -------\n    number\n        Total weight of all edges from nodes in set `S` to nodes in\n        set `T` (and, in the case of directed graphs, all edges from\n        nodes in `T` to nodes in `S`).\n\n    Examples\n    --------\n    In the graph with two cliques joined by a single edges, the natural\n    bipartition of the graph into two blocks, one for each clique,\n    yields a cut of weight one::\n\n        >>> G = nx.barbell_graph(3, 0)\n        >>> S = {0, 1, 2}\n        >>> T = {3, 4, 5}\n        >>> nx.cut_size(G, S, T)\n        1\n\n    Each parallel edge in a multigraph is counted when determining the\n    cut size::\n\n        >>> G = nx.MultiGraph([\"ab\", \"ab\"])\n        >>> S = {\"a\"}\n        >>> T = {\"b\"}\n        >>> nx.cut_size(G, S, T)\n        2\n\n    Notes\n    -----\n    In a multigraph, the cut size is the total weight of edges including\n    multiplicity.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef normalized_cut_size(G, S, T=None, weight=None):\n\"\"\"Returns the normalized size of the cut between two sets of nodes.\n\n    The *normalized cut size* is the cut size times the sum of the\n    reciprocal sizes of the volumes of the two sets. [1]\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    S : collection\n        A collection of nodes in `G`.\n\n    T : collection\n        A collection of nodes in `G`.\n\n    weight : object\n        Edge attribute key to use as weight. If not specified, edges\n        have weight one.\n\n    Returns\n    -------\n    number\n        The normalized cut size between the two sets `S` and `T`.\n\n    Notes\n    -----\n    In a multigraph, the cut size is the total weight of edges including\n    multiplicity.\n\n    See also\n    --------\n    conductance\n    cut_size\n    edge_expansion\n    volume\n\n    References\n    ----------\n    .. [1] David Gleich.\n           *Hierarchical Directed Spectral Graph Partitioning*.\n           <https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef edge_expansion(G, S, T=None, weight=None):\n\"\"\"Returns the edge expansion between two node sets.\n\n    The *edge expansion* is the quotient of the cut size and the smaller\n    of the cardinalities of the two sets. [1]\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    S : collection\n        A collection of nodes in `G`.\n\n    T : collection\n        A collection of nodes in `G`.\n\n    weight : object\n        Edge attribute key to use as weight. If not specified, edges\n        have weight one.\n\n    Returns\n    -------\n    number\n        The edge expansion between the two sets `S` and `T`.\n\n    See also\n    --------\n    boundary_expansion\n    mixing_expansion\n    node_expansion\n\n    References\n    ----------\n    .. [1] Fan Chung.\n           *Spectral Graph Theory*.\n           (CBMS Regional Conference Series in Mathematics, No. 92),\n           American Mathematical Society, 1997, ISBN 0-8218-0315-8\n           <http://www.math.ucsd.edu/~fan/research/revised.html>\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef node_expansion(G, S):\n\"\"\"Returns the node expansion of the set `S`.\n\n    The *node expansion* is the quotient of the size of the node\n    boundary of *S* and the cardinality of *S*. [1]\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    S : collection\n        A collection of nodes in `G`.\n\n    Returns\n    -------\n    number\n        The node expansion of the set `S`.\n\n    See also\n    --------\n    boundary_expansion\n    edge_expansion\n    mixing_expansion\n\n    References\n    ----------\n    .. [1] Vadhan, Salil P.\n           \"Pseudorandomness.\"\n           *Foundations and Trends\n           in Theoretical Computer Science* 7.1\u20133 (2011): 1\u2013336.\n           <https://doi.org/10.1561/0400000010>\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef communicability(G):\n\"\"\"Returns communicability between all pairs of nodes in G.\n\n    The communicability between pairs of nodes in G is the sum of\n    walks of different lengths starting at node u and ending at node v.\n\n    Parameters\n    ----------\n    G: graph\n\n    Returns\n    -------\n    comm: dictionary of dictionaries\n        Dictionary of dictionaries keyed by nodes with communicability\n        as the value.\n\n    Raises\n    ------\n    NetworkXError\n       If the graph is not undirected and simple.\n\n    See Also\n    --------\n    communicability_exp:\n       Communicability between all pairs of nodes in G  using spectral\n       decomposition.\n    communicability_betweenness_centrality:\n       Communicability betweenness centrality for each node in G.\n\n    Notes\n    -----\n    This algorithm uses a spectral decomposition of the adjacency matrix.\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\n    the powers  of the adjacency matrix and the number of walks in the graph,\n    the communicability  between nodes `u` and `v` based on the graph spectrum\n    is [1]_\n\n    .. math::\n        C(u,v)=\\sum_{j=1}^{n}\\phi_{j}(u)\\phi_{j}(v)e^{\\lambda_{j}},\n\n    where `\\phi_{j}(u)` is the `u\\rm{th}` element of the `j\\rm{th}` orthonormal\n    eigenvector of the adjacency matrix associated with the eigenvalue\n    `\\lambda_{j}`.\n\n    References\n    ----------\n    .. [1] Ernesto Estrada, Naomichi Hatano,\n       \"Communicability in complex networks\",\n       Phys. Rev. E 77, 036111 (2008).\n       https://arxiv.org/abs/0707.0756\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\n    >>> c = nx.communicability(G)\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_planar(G):\n\"\"\"Returns True if and only if `G` is planar.\n\n    A graph is *planar* iff it can be drawn in a plane without\n    any edge intersections.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    Returns\n    -------\n    bool\n       Whether the graph is planar.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2)])\n    >>> nx.is_planar(G)\n    True\n    >>> nx.is_planar(nx.complete_graph(5))\n    False\n\n    See Also\n    --------\n    check_planarity :\n        Check if graph is planar *and* return a `PlanarEmbedding` instance if True.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef check_planarity_recursive(G, counterexample=False):\n\"\"\"Recursive version of :meth:`check_planarity`.\"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef get_counterexample_recursive(G):\n\"\"\"Recursive version of :meth:`get_counterexample`.\"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef non_randomness(G, k=None, weight=\"weight\"):\n\"\"\"Compute the non-randomness of graph G.\n\n    The first returned value nr is the sum of non-randomness values of all\n    edges within the graph (where the non-randomness of an edge tends to be\n    small when the two nodes linked by that edge are from two different\n    communities).\n\n    The second computed value nr_rd is a relative measure that indicates\n    to what extent graph G is different from random graphs in terms\n    of probability. When it is close to 0, the graph tends to be more\n    likely generated by an Erdos Renyi model.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Graph must be symmetric, connected, and without self-loops.\n\n    k : int\n        The number of communities in G.\n        If k is not set, the function will use a default community\n        detection algorithm to set it.\n\n    weight : string or None, optional (default=None)\n        The name of an edge attribute that holds the numerical value used\n        as a weight. If None, then each edge has weight 1, i.e., the graph is\n        binary.\n\n    Returns\n    -------\n    non-randomness : (float, float) tuple\n        Non-randomness, Relative non-randomness w.r.t.\n        Erdos Renyi random graphs.\n\n    Raises\n    ------\n    NetworkXException\n        if the input graph is not connected.\n    NetworkXError\n        if the input graph contains self-loops or if graph has no edges.\n\n    Examples\n    --------\n    >>> G = nx.karate_club_graph()\n    >>> nr, nr_rd = nx.non_randomness(G, 2)\n    >>> nr, nr_rd = nx.non_randomness(G, 2, \"weight\")\n\n    Notes\n    -----\n    This computes Eq. (4.4) and (4.5) in Ref. [1]_.\n\n    If a weight field is passed, this algorithm will use the eigenvalues\n    of the weighted adjacency matrix to compute Eq. (4.4) and (4.5).\n\n    References\n    ----------\n    .. [1] Xiaowei Ying and Xintao Wu,\n           On Randomness Measures for Social Networks,\n           SIAM International Conference on Data Mining. 2009\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef enumerate_all_cliques(G):\n\"\"\"Returns all cliques in an undirected graph.\n\n    This function returns an iterator over cliques, each of which is a\n    list of nodes. The iteration is ordered by cardinality of the\n    cliques: first all cliques of size one, then all cliques of size\n    two, etc.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        An undirected graph.\n\n    Returns\n    -------\n    iterator\n        An iterator over cliques, each of which is a list of nodes in\n        `G`. The cliques are ordered according to size.\n\n    Notes\n    -----\n    To obtain a list of all cliques, use\n    `list(enumerate_all_cliques(G))`. However, be aware that in the\n    worst-case, the length of this list can be exponential in the number\n    of nodes in the graph (for example, when the graph is the complete\n    graph). This function avoids storing all cliques in memory by only\n    keeping current candidate node lists in memory during its search.\n\n    The implementation is adapted from the algorithm by Zhang, et\n    al. (2005) [1]_ to output all cliques discovered.\n\n    This algorithm ignores self-loops and parallel edges, since cliques\n    are not conventionally defined with such edges.\n\n    References\n    ----------\n    .. [1] Yun Zhang, Abu-Khzam, F.N., Baldwin, N.E., Chesler, E.J.,\n           Langston, M.A., Samatova, N.F.,\n           \"Genome-Scale Computational Approaches to Memory-Intensive\n           Applications in Systems Biology\".\n           *Supercomputing*, 2005. Proceedings of the ACM/IEEE SC 2005\n           Conference, pp. 12, 12--18 Nov. 2005.\n           <https://doi.org/10.1109/SC.2005.29>.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef find_cliques_recursive(G, nodes=None):\n\"\"\"Returns all maximal cliques in a graph.\n\n    For each node *v*, a *maximal clique for v* is a largest complete\n    subgraph containing *v*. The largest maximal clique is sometimes\n    called the *maximum clique*.\n\n    This function returns an iterator over cliques, each of which is a\n    list of nodes. It is a recursive implementation, so may suffer from\n    recursion depth issues, but is included for pedagogical reasons.\n    For a non-recursive implementation, see :func:`find_cliques`.\n\n    This function accepts a list of `nodes` and only the maximal cliques\n    containing all of these `nodes` are returned. It can considerably speed up\n    the running time if some specific cliques are desired.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nodes : list, optional (default=None)\n        If provided, only yield *maximal cliques* containing all nodes in `nodes`.\n        If `nodes` isn't a clique itself, a ValueError is raised.\n\n    Returns\n    -------\n    iterator\n        An iterator over maximal cliques, each of which is a list of\n        nodes in `G`. If `nodes` is provided, only the maximal cliques\n        containing all the nodes in `nodes` are yielded. The order of\n        cliques is arbitrary.\n\n    Raises\n    ------\n    ValueError\n        If `nodes` is not a clique.\n\n    See Also\n    --------\n    find_cliques\n        An iterative version of the same algorithm. See docstring for examples.\n\n    Notes\n    -----\n    To obtain a list of all maximal cliques, use\n    `list(find_cliques_recursive(G))`. However, be aware that in the\n    worst-case, the length of this list can be exponential in the number\n    of nodes in the graph. This function avoids storing all cliques in memory\n    by only keeping current candidate node lists in memory during its search.\n\n    This implementation is based on the algorithm published by Bron and\n    Kerbosch (1973) [1]_, as adapted by Tomita, Tanaka and Takahashi\n    (2006) [2]_ and discussed in Cazals and Karande (2008) [3]_. For a\n    non-recursive implementation, see :func:`find_cliques`.\n\n    This algorithm ignores self-loops and parallel edges, since cliques\n    are not conventionally defined with such edges.\n\n    References\n    ----------\n    .. [1] Bron, C. and Kerbosch, J.\n       \"Algorithm 457: finding all cliques of an undirected graph\".\n       *Communications of the ACM* 16, 9 (Sep. 1973), 575--577.\n       <http://portal.acm.org/citation.cfm?doid=362342.362367>\n\n    .. [2] Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n       \"The worst-case time complexity for generating all maximal\n       cliques and computational experiments\",\n       *Theoretical Computer Science*, Volume 363, Issue 1,\n       Computing and Combinatorics,\n       10th Annual International Conference on\n       Computing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28--42\n       <https://doi.org/10.1016/j.tcs.2006.06.015>\n\n    .. [3] F. Cazals, C. Karande,\n       \"A note on the problem of reporting maximal cliques\",\n       *Theoretical Computer Science*,\n       Volume 407, Issues 1--3, 6 November 2008, Pages 564--568,\n       <https://doi.org/10.1016/j.tcs.2008.05.010>\n\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef make_clique_bipartite(G, fpos=None, create_using=None, name=None):\n\"\"\"Returns the bipartite clique graph corresponding to `G`.\n\n    In the returned bipartite graph, the \"bottom\" nodes are the nodes of\n    `G` and the \"top\" nodes represent the maximal cliques of `G`.\n    There is an edge from node *v* to clique *C* in the returned graph\n    if and only if *v* is an element of *C*.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        An undirected graph.\n\n    fpos : bool\n        If True or not None, the returned graph will have an\n        additional attribute, `pos`, a dictionary mapping node to\n        position in the Euclidean plane.\n\n    create_using : NetworkX graph constructor, optional (default=nx.Graph)\n       Graph type to create. If graph instance, then cleared before populated.\n\n    Returns\n    -------\n    NetworkX graph\n        A bipartite graph whose \"bottom\" set is the nodes of the graph\n        `G`, whose \"top\" set is the cliques of `G`, and whose edges\n        join nodes of `G` to the cliques that contain them.\n\n        The nodes of the graph `G` have the node attribute\n        'bipartite' set to 1 and the nodes representing cliques\n        have the node attribute 'bipartite' set to 0, as is the\n        convention for bipartite graphs in NetworkX.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(node_attrs=\"weight\")\ndef max_weight_clique(G, weight=\"weight\"):\n\"\"\"Find a maximum weight clique in G.\n\n    A *clique* in a graph is a set of nodes such that every two distinct nodes\n    are adjacent.  The *weight* of a clique is the sum of the weights of its\n    nodes.  A *maximum weight clique* of graph G is a clique C in G such that\n    no clique in G has weight greater than the weight of C.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph\n    weight : string or None, optional (default='weight')\n        The node attribute that holds the integer value used as a weight.\n        If None, then each node has weight 1.\n\n    Returns\n    -------\n    clique : list\n        the nodes of a maximum weight clique\n    weight : int\n        the weight of a maximum weight clique\n\n    Notes\n    -----\n    The implementation is recursive, and therefore it may run into recursion\n    depth issues if G contains a clique whose number of nodes is close to the\n    recursion depth limit.\n\n    At each search node, the algorithm greedily constructs a weighted\n    independent set cover of part of the graph in order to find a small set of\n    nodes on which to branch.  The algorithm is very similar to the algorithm\n    of Tavares et al. [1]_, other than the fact that the NetworkX version does\n    not use bitsets.  This style of algorithm for maximum weight clique (and\n    maximum weight independent set, which is the same problem but on the\n    complement graph) has a decades-long history.  See Algorithm B of Warren\n    and Hicks [2]_ and the references in that paper.\n\n    References\n    ----------\n    .. [1] Tavares, W.A., Neto, M.B.C., Rodrigues, C.D., Michelon, P.: Um\n           algoritmo de branch and bound para o problema da clique m\u00e1xima\n           ponderada.  Proceedings of XLVII SBPO 1 (2015).\n\n    .. [2] Warren, Jeffrey S, Hicks, Illya V.: Combinatorial Branch-and-Bound\n           for the Maximum Weight Independent Set Problem.  Technical Report,\n           Texas A&M University (2016).\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_chordal(G):\n\"\"\"Checks whether G is a chordal graph.\n\n    A graph is chordal if every cycle of length at least 4 has a chord\n    (an edge joining two nodes not adjacent in the cycle).\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph.\n\n    Returns\n    -------\n    chordal : bool\n      True if G is a chordal graph and False otherwise.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\n\n    Examples\n    --------\n    >>> e = [\n    ...     (1, 2),\n    ...     (1, 3),\n    ...     (2, 3),\n    ...     (2, 4),\n    ...     (3, 4),\n    ...     (3, 5),\n    ...     (3, 6),\n    ...     (4, 5),\n    ...     (4, 6),\n    ...     (5, 6),\n    ... ]\n    >>> G = nx.Graph(e)\n    >>> nx.is_chordal(G)\n    True\n\n    Notes\n    -----\n    The routine tries to go through every node following maximum cardinality\n    search. It returns False when it finds that the separator for any node\n    is not a clique.  Based on the algorithms in [1]_.\n\n    Self loops are ignored.\n\n    References\n    ----------\n    .. [1] R. E. Tarjan and M. Yannakakis, Simple linear-time algorithms\n       to test chordality of graphs, test acyclicity of hypergraphs, and\n       selectively reduce acyclic hypergraphs, SIAM J. Comput., 13 (1984),\n       pp. 566\u2013579.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef chordal_graph_cliques(G):\n\"\"\"Returns all maximal cliques of a chordal graph.\n\n    The algorithm breaks the graph in connected components and performs a\n    maximum cardinality search in each component to get the cliques.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    Yields\n    ------\n    frozenset of nodes\n        Maximal cliques, each of which is a frozenset of\n        nodes in `G`. The order of cliques is arbitrary.\n\n    Raises\n    ------\n    NetworkXError\n        The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\n        The algorithm can only be applied to chordal graphs. If the input\n        graph is found to be non-chordal, a :exc:`NetworkXError` is raised.\n\n    Examples\n    --------\n    >>> e = [\n    ...     (1, 2),\n    ...     (1, 3),\n    ...     (2, 3),\n    ...     (2, 4),\n    ...     (3, 4),\n    ...     (3, 5),\n    ...     (3, 6),\n    ...     (4, 5),\n    ...     (4, 6),\n    ...     (5, 6),\n    ...     (7, 8),\n    ... ]\n    >>> G = nx.Graph(e)\n    >>> G.add_node(9)\n    >>> cliques = [c for c in chordal_graph_cliques(G)]\n    >>> cliques[0]\n    frozenset({1, 2, 3})\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef complete_to_chordal_graph(G):\n\"\"\"Return a copy of G completed to a chordal graph\n\n    Adds edges to a copy of G to create a chordal graph. A graph G=(V,E) is\n    called chordal if for each cycle with length bigger than 3, there exist\n    two non-adjacent nodes connected by an edge (called a chord).\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph\n\n    Returns\n    -------\n    H : NetworkX graph\n        The chordal enhancement of G\n    alpha : Dictionary\n            The elimination ordering of nodes of G\n\n    Notes\n    -----\n    There are different approaches to calculate the chordal\n    enhancement of a graph. The algorithm used here is called\n    MCS-M and gives at least minimal (local) triangulation of graph. Note\n    that this triangulation is not necessarily a global minimum.\n\n    https://en.wikipedia.org/wiki/Chordal_graph\n\n    References\n    ----------\n    .. [1] Berry, Anne & Blair, Jean & Heggernes, Pinar & Peyton, Barry. (2004)\n           Maximum Cardinality Search for Computing Minimal Triangulations of\n           Graphs.  Algorithmica. 39. 287-298. 10.1007/s00453-004-1084-3.\n\n    Examples\n    --------\n    >>> from networkx.algorithms.chordal import complete_to_chordal_graph\n    >>> G = nx.wheel_graph(10)\n    >>> H, alpha = complete_to_chordal_graph(G)\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef min_edge_cover(G, matching_algorithm=None):\n\"\"\"Returns the min cardinality edge cover of the graph as a set of edges.\n\n    A smallest edge cover can be found in polynomial time by finding\n    a maximum matching and extending it greedily so that all nodes\n    are covered. This function follows that process. A maximum matching\n    algorithm can be specified for the first step of the algorithm.\n    The resulting set may return a set with one 2-tuple for each edge,\n    (the usual case) or with both 2-tuples `(u, v)` and `(v, u)` for\n    each edge. The latter is only done when a bipartite matching algorithm\n    is specified as `matching_algorithm`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        An undirected graph.\n\n    matching_algorithm : function\n        A function that returns a maximum cardinality matching for `G`.\n        The function must take one input, the graph `G`, and return\n        either a set of edges (with only one direction for the pair of nodes)\n        or a dictionary mapping each node to its mate. If not specified,\n        :func:`~networkx.algorithms.matching.max_weight_matching` is used.\n        Common bipartite matching functions include\n        :func:`~networkx.algorithms.bipartite.matching.hopcroft_karp_matching`\n        or\n        :func:`~networkx.algorithms.bipartite.matching.eppstein_matching`.\n\n    Returns\n    -------\n    min_cover : set\n\n        A set of the edges in a minimum edge cover in the form of tuples.\n        It contains only one of the equivalent 2-tuples `(u, v)` and `(v, u)`\n        for each edge. If a bipartite method is used to compute the matching,\n        the returned set contains both the 2-tuples `(u, v)` and `(v, u)`\n        for each edge of a minimum edge cover.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> sorted(nx.min_edge_cover(G))\n    [(2, 1), (3, 0)]\n\n    Notes\n    -----\n    An edge cover of a graph is a set of edges such that every node of\n    the graph is incident to at least one edge of the set.\n    The minimum edge cover is an edge covering of smallest cardinality.\n\n    Due to its implementation, the worst-case running time of this algorithm\n    is bounded by the worst-case running time of the function\n    ``matching_algorithm``.\n\n    Minimum edge cover for `G` can also be found using the `min_edge_covering`\n    function in :mod:`networkx.algorithms.bipartite.covering` which is\n    simply this function with a default matching algorithm of\n    :func:`~networkx.algorithms.bipartite.matching.hopcraft_karp_matching`\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef is_tournament(G):\n\"\"\"Returns True if and only if `G` is a tournament.\n\n    A tournament is a directed graph, with neither self-loops nor\n    multi-edges, in which there is exactly one directed edge joining\n    each pair of distinct nodes.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A directed graph representing a tournament.\n\n    Returns\n    -------\n    bool\n        Whether the given graph is a tournament graph.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(0, 1), (1, 2), (2, 0)])\n    >>> nx.is_tournament(G)\n    True\n\n    Notes\n    -----\n    Some definitions require a self-loop on each node, but that is not\n    the convention used here.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(graphs=None, returns_graph=True)\ndef random_tournament(n, seed=None):\n\"\"\"Returns a random tournament graph on `n` nodes.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes in the returned graph.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : DiGraph\n        A tournament on `n` nodes, with exactly one directed edge joining\n        each pair of distinct nodes.\n\n    Notes\n    -----\n    This algorithm adds, for each pair of distinct nodes, an edge with\n    uniformly random orientation. In other words, `\\binom{n}{2}` flips\n    of an unbiased coin decide the orientations of the edges in the\n    graph.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(preserve_edge_attrs={\"G\": {\"weight\": 1}})\ndef tournament_matrix(G):\n\"\"\"Returns the tournament matrix for the given tournament graph.\n\n    This function requires SciPy.\n\n    The *tournament matrix* of a tournament graph with edge set *E* is\n    the matrix *T* defined by\n\n    .. math::\n\n       T_{i j} =\n       \\begin{cases}\n       +1 & \\text{if } (i, j) \\in E \\\\\n       -1 & \\text{if } (j, i) \\in E \\\\\n       0 & \\text{if } i == j.\n       \\end{cases}\n\n    An equivalent definition is `T = A - A^T`, where *A* is the\n    adjacency matrix of the graph `G`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A directed graph representing a tournament.\n\n    Returns\n    -------\n    SciPy sparse array\n        The tournament matrix of the tournament graph `G`.\n\n    Raises\n    ------\n    ImportError\n        If SciPy is not available.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(name=\"tournament_is_strongly_connected\")\ndef is_strongly_connected(G):\n\"\"\"Decides whether the given tournament is strongly connected.\n\n    This function is more theoretically efficient than the\n    :func:`~networkx.algorithms.components.is_strongly_connected`\n    function.\n\n    The given graph **must** be a tournament, otherwise this function's\n    behavior is undefined.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A directed graph representing a tournament.\n\n    Returns\n    -------\n    bool\n        Whether the tournament is strongly connected.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 0)])\n    >>> nx.is_tournament(G)\n    True\n    >>> nx.tournament.is_strongly_connected(G)\n    True\n    >>> G.remove_edge(3, 0)\n    >>> G.add_edge(0, 3)\n    >>> nx.is_tournament(G)\n    True\n    >>> nx.tournament.is_strongly_connected(G)\n    False\n\n    Notes\n    -----\n    Although this function is more theoretically efficient than the\n    generic strong connectivity function, a speedup requires the use of\n    parallelism. Though it may in the future, the current implementation\n    does not use parallelism, thus you may not see much of a speedup.\n\n    This algorithm comes from [1].\n\n    References\n    ----------\n    .. [1] Tantau, Till.\n           \"A note on the complexity of the reachability problem for\n           tournaments.\"\n           *Electronic Colloquium on Computational Complexity*. 2001.\n           <http://eccc.hpi-web.de/report/2001/092/>\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef flow_hierarchy(G, weight=None):\n\"\"\"Returns the flow hierarchy of a directed network.\n\n    Flow hierarchy is defined as the fraction of edges not participating\n    in cycles in a directed graph [1]_.\n\n    Parameters\n    ----------\n    G : DiGraph or MultiDiGraph\n       A directed graph\n\n    weight : string, optional (default=None)\n       Attribute to use for edge weights. If None the weight defaults to 1.\n\n    Returns\n    -------\n    h : float\n       Flow hierarchy value\n\n    Raises\n    ------\n    NetworkXError\n       If `G` is not a directed graph or if `G` has no edges.\n\n    Notes\n    -----\n    The algorithm described in [1]_ computes the flow hierarchy through\n    exponentiation of the adjacency matrix.  This function implements an\n    alternative approach that finds strongly connected components.\n    An edge is in a cycle if and only if it is in a strongly connected\n    component, which can be found in $O(m)$ time using Tarjan's algorithm.\n\n    References\n    ----------\n    .. [1] Luo, J.; Magee, C.L. (2011),\n       Detecting evolving patterns of self-organizing networks by flow\n       hierarchy measurement, Complexity, Volume 16 Issue 6 53-61.\n       DOI: 10.1002/cplx.20368\n       http://web.mit.edu/~cmagee/www/documents/28-DetectingEvolvingPatterns_FlowHierarchy.pdf\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef core_number(G):\n\"\"\"Returns the core number for each node.\n\n    A k-core is a maximal subgraph that contains nodes of degree k or more.\n\n    The core number of a node is the largest value k of a k-core containing\n    that node.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       An undirected or directed graph\n\n    Returns\n    -------\n    core_number : dictionary\n       A dictionary keyed by node to the core number.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is a multigraph or contains self loops.\n\n    Notes\n    -----\n    For directed graphs the node degree is defined to be the\n    in-degree + out-degree.\n\n    Examples\n    --------\n    >>> degrees = [0, 1, 2, 2, 2, 2, 3]\n    >>> H = nx.havel_hakimi_graph(degrees)\n    >>> nx.core_number(H)\n    {0: 1, 1: 2, 2: 2, 3: 2, 4: 1, 5: 2, 6: 0}\n    >>> G = nx.DiGraph()\n    >>> G.add_edges_from([(1, 2), (2, 1), (2, 3), (2, 4), (3, 4), (4, 3)])\n    >>> nx.core_number(G)\n    {1: 2, 2: 2, 3: 2, 4: 2}\n\n    References\n    ----------\n    .. [1] An O(m) Algorithm for Cores Decomposition of Networks\n       Vladimir Batagelj and Matjaz Zaversnik, 2003.\n       https://arxiv.org/abs/cs.DS/0310049\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)\ndef k_core(G, k=None, core_number=None):\n\"\"\"Returns the k-core of G.\n\n    A k-core is a maximal subgraph that contains nodes of degree `k` or more.\n\n    .. deprecated:: 3.3\n       `k_core` will not accept `MultiGraph` objects in version 3.5.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n      A graph or directed graph\n    k : int, optional\n      The order of the core. If not specified return the main core.\n    core_number : dictionary, optional\n      Precomputed core numbers for the graph G.\n\n    Returns\n    -------\n    G : NetworkX graph\n      The k-core subgraph\n\n    Raises\n    ------\n    NetworkXNotImplemented\n      The k-core is not defined for multigraphs or graphs with self loops.\n\n    Notes\n    -----\n    The main core is the core with `k` as the largest core_number.\n\n    For directed graphs the node degree is defined to be the\n    in-degree + out-degree.\n\n    Graph, node, and edge attributes are copied to the subgraph.\n\n    Examples\n    --------\n    >>> degrees = [0, 1, 2, 2, 2, 2, 3]\n    >>> H = nx.havel_hakimi_graph(degrees)\n    >>> H.degree\n    DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n    >>> nx.k_core(H).nodes\n    NodeView((1, 2, 3, 5))\n\n    See Also\n    --------\n    core_number\n\n    References\n    ----------\n    .. [1] An O(m) Algorithm for Cores Decomposition of Networks\n       Vladimir Batagelj and Matjaz Zaversnik,  2003.\n       https://arxiv.org/abs/cs.DS/0310049\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)\ndef k_crust(G, k=None, core_number=None):\n\"\"\"Returns the k-crust of G.\n\n    The k-crust is the graph G with the edges of the k-core removed\n    and isolated nodes found after the removal of edges are also removed.\n\n    .. deprecated:: 3.3\n       `k_crust` will not accept `MultiGraph` objects in version 3.5.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       A graph or directed graph.\n    k : int, optional\n      The order of the shell. If not specified return the main crust.\n    core_number : dictionary, optional\n      Precomputed core numbers for the graph G.\n\n    Returns\n    -------\n    G : NetworkX graph\n       The k-crust subgraph\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        The k-crust is not implemented for multigraphs or graphs with self loops.\n\n    Notes\n    -----\n    This definition of k-crust is different than the definition in [1]_.\n    The k-crust in [1]_ is equivalent to the k+1 crust of this algorithm.\n\n    For directed graphs the node degree is defined to be the\n    in-degree + out-degree.\n\n    Graph, node, and edge attributes are copied to the subgraph.\n\n    Examples\n    --------\n    >>> degrees = [0, 1, 2, 2, 2, 2, 3]\n    >>> H = nx.havel_hakimi_graph(degrees)\n    >>> H.degree\n    DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n    >>> nx.k_crust(H, k=1).nodes\n    NodeView((0, 4, 6))\n\n    See Also\n    --------\n    core_number\n\n    References\n    ----------\n    .. [1] A model of Internet topology using k-shell decomposition\n       Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\n       and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154\n       http://www.pnas.org/content/104/27/11150.full\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)\ndef k_truss(G, k):\n\"\"\"Returns the k-truss of `G`.\n\n    The k-truss is the maximal induced subgraph of `G` which contains at least\n    three vertices where every edge is incident to at least `k-2` triangles.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n      An undirected graph\n    k : int\n      The order of the truss\n\n    Returns\n    -------\n    H : NetworkX graph\n      The k-truss subgraph\n\n    Raises\n    ------\n    NetworkXNotImplemented\n      If `G` is a multigraph or directed graph or if it contains self loops.\n\n    Notes\n    -----\n    A k-clique is a (k-2)-truss and a k-truss is a (k+1)-core.\n\n    Graph, node, and edge attributes are copied to the subgraph.\n\n    K-trusses were originally defined in [2] which states that the k-truss\n    is the maximal induced subgraph where each edge belongs to at least\n    `k-2` triangles. A more recent paper, [1], uses a slightly different\n    definition requiring that each edge belong to at least `k` triangles.\n    This implementation uses the original definition of `k-2` triangles.\n\n    Examples\n    --------\n    >>> degrees = [0, 1, 2, 2, 2, 2, 3]\n    >>> H = nx.havel_hakimi_graph(degrees)\n    >>> H.degree\n    DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n    >>> nx.k_truss(H, k=2).nodes\n    NodeView((0, 1, 2, 3, 4, 5))\n\n    References\n    ----------\n    .. [1] Bounds and Algorithms for k-truss. Paul Burkhardt, Vance Faber,\n       David G. Harris, 2018. https://arxiv.org/abs/1806.05523v2\n    .. [2] Trusses: Cohesive Subgraphs for Social Network Analysis. Jonathan\n       Cohen, 2005.\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef descendants(G, source):\n\"\"\"Returns all nodes reachable from `source` in `G`.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n    source : node in `G`\n\n    Returns\n    -------\n    set()\n        The descendants of `source` in `G`\n\n    Raises\n    ------\n    NetworkXError\n        If node `source` is not in `G`.\n\n    Examples\n    --------\n    >>> DG = nx.path_graph(5, create_using=nx.DiGraph)\n    >>> sorted(nx.descendants(DG, 2))\n    [3, 4]\n\n    The `source` node is not a descendant of itself, but can be included manually:\n\n    >>> sorted(nx.descendants(DG, 2) | {2})\n    [2, 3, 4]\n\n    See also\n    --------\n    ancestors\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef has_cycle(G):\n\"\"\"Decides whether the directed graph has a cycle.\"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef topological_generations(G):\n\"\"\"Stratifies a DAG into generations.\n\n    A topological generation is node collection in which ancestors of a node in each\n    generation are guaranteed to be in a previous generation, and any descendants of\n    a node are guaranteed to be in a following generation. Nodes are guaranteed to\n    be in the earliest possible generation that they can belong to.\n\n    Parameters\n    ----------\n    G : NetworkX digraph\n        A directed acyclic graph (DAG)\n\n    Yields\n    ------\n    sets of nodes\n        Yields sets of nodes representing each generation.\n\n    Raises\n    ------\n    NetworkXError\n        Generations are defined for directed graphs only. If the graph\n        `G` is undirected, a :exc:`NetworkXError` is raised.\n\n    NetworkXUnfeasible\n        If `G` is not a directed acyclic graph (DAG) no topological generations\n        exist and a :exc:`NetworkXUnfeasible` exception is raised.  This can also\n        be raised if `G` is changed while the returned iterator is being processed\n\n    RuntimeError\n        If `G` is changed while the returned iterator is being processed.\n\n    Examples\n    --------\n    >>> DG = nx.DiGraph([(2, 1), (3, 1)])\n    >>> [sorted(generation) for generation in nx.topological_generations(DG)]\n    [[2, 3], [1]]\n\n    Notes\n    -----\n    The generation in which a node resides can also be determined by taking the\n    max-path-distance from the node to the farthest leaf node. That value can\n    be obtained with this function using `enumerate(topological_generations(G))`.\n\n    See also\n    --------\n    topological_sort\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef lexicographical_topological_sort(G, key=None):\n\"\"\"Generate the nodes in the unique lexicographical topological sort order.\n\n    Generates a unique ordering of nodes by first sorting topologically (for which there are often\n    multiple valid orderings) and then additionally by sorting lexicographically.\n\n    A topological sort arranges the nodes of a directed graph so that the\n    upstream node of each directed edge precedes the downstream node.\n    It is always possible to find a solution for directed graphs that have no cycles.\n    There may be more than one valid solution.\n\n    Lexicographical sorting is just sorting alphabetically. It is used here to break ties in the\n    topological sort and to determine a single, unique ordering.  This can be useful in comparing\n    sort results.\n\n    The lexicographical order can be customized by providing a function to the `key=` parameter.\n    The definition of the key function is the same as used in python's built-in `sort()`.\n    The function takes a single argument and returns a key to use for sorting purposes.\n\n    Lexicographical sorting can fail if the node names are un-sortable. See the example below.\n    The solution is to provide a function to the `key=` argument that returns sortable keys.\n\n\n    Parameters\n    ----------\n    G : NetworkX digraph\n        A directed acyclic graph (DAG)\n\n    key : function, optional\n        A function of one argument that converts a node name to a comparison key.\n        It defines and resolves ambiguities in the sort order.  Defaults to the identity function.\n\n    Yields\n    ------\n    nodes\n        Yields the nodes of G in lexicographical topological sort order.\n\n    Raises\n    ------\n    NetworkXError\n        Topological sort is defined for directed graphs only. If the graph `G`\n        is undirected, a :exc:`NetworkXError` is raised.\n\n    NetworkXUnfeasible\n        If `G` is not a directed acyclic graph (DAG) no topological sort exists\n        and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be\n        raised if `G` is changed while the returned iterator is being processed\n\n    RuntimeError\n        If `G` is changed while the returned iterator is being processed.\n\n    TypeError\n        Results from un-sortable node names.\n        Consider using `key=` parameter to resolve ambiguities in the sort order.\n\n    Examples\n    --------\n    >>> DG = nx.DiGraph([(2, 1), (2, 5), (1, 3), (1, 4), (5, 4)])\n    >>> list(nx.lexicographical_topological_sort(DG))\n    [2, 1, 3, 5, 4]\n    >>> list(nx.lexicographical_topological_sort(DG, key=lambda x: -x))\n    [2, 5, 1, 4, 3]\n\n    The sort will fail for any graph with integer and string nodes. Comparison of integer to strings\n    is not defined in python.  Is 3 greater or less than 'red'?\n\n    >>> DG = nx.DiGraph([(1, \"red\"), (3, \"red\"), (1, \"green\"), (2, \"blue\")])\n    >>> list(nx.lexicographical_topological_sort(DG))\n    Traceback (most recent call last):\n    ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    ...\n\n    Incomparable nodes can be resolved using a `key` function. This example function\n    allows comparison of integers and strings by returning a tuple where the first\n    element is True for `str`, False otherwise. The second element is the node name.\n    This groups the strings and integers separately so they can be compared only among themselves.\n\n    >>> key = lambda node: (isinstance(node, str), node)\n    >>> list(nx.lexicographical_topological_sort(DG, key=key))\n    [1, 2, 3, 'blue', 'green', 'red']\n\n    Notes\n    -----\n    This algorithm is based on a description and proof in\n    \"Introduction to Algorithms: A Creative Approach\" [1]_ .\n\n    See also\n    --------\n    topological_sort\n\n    References\n    ----------\n    .. [1] Manber, U. (1989).\n       *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef is_aperiodic(G):\n\"\"\"Returns True if `G` is aperiodic.\n\n    A directed graph is aperiodic if there is no integer k > 1 that\n    divides the length of every cycle in the graph.\n\n    Parameters\n    ----------\n    G : NetworkX DiGraph\n        A directed graph\n\n    Returns\n    -------\n    bool\n        True if the graph is aperiodic False otherwise\n\n    Raises\n    ------\n    NetworkXError\n        If `G` is not directed\n\n    Examples\n    --------\n    A graph consisting of one cycle, the length of which is 2. Therefore ``k = 2``\n    divides the length of every cycle in the graph and thus the graph\n    is *not aperiodic*::\n\n        >>> DG = nx.DiGraph([(1, 2), (2, 1)])\n        >>> nx.is_aperiodic(DG)\n        False\n\n    A graph consisting of two cycles: one of length 2 and the other of length 3.\n    The cycle lengths are coprime, so there is no single value of k where ``k > 1``\n    that divides each cycle length and therefore the graph is *aperiodic*::\n\n        >>> DG = nx.DiGraph([(1, 2), (2, 3), (3, 1), (1, 4), (4, 1)])\n        >>> nx.is_aperiodic(DG)\n        True\n\n    A graph consisting of two cycles: one of length 2 and the other of length 4.\n    The lengths of the cycles share a common factor ``k = 2``, and therefore\n    the graph is *not aperiodic*::\n\n        >>> DG = nx.DiGraph([(1, 2), (2, 1), (3, 4), (4, 5), (5, 6), (6, 3)])\n        >>> nx.is_aperiodic(DG)\n        False\n\n    An acyclic graph, therefore the graph is *not aperiodic*::\n\n        >>> DG = nx.DiGraph([(1, 2), (2, 3)])\n        >>> nx.is_aperiodic(DG)\n        False\n\n    Notes\n    -----\n    This uses the method outlined in [1]_, which runs in $O(m)$ time\n    given $m$ edges in `G`. Note that a graph is not aperiodic if it is\n    acyclic as every integer trivial divides length 0 cycles.\n\n    References\n    ----------\n    .. [1] Jarvis, J. P.; Shier, D. R. (1996),\n       \"Graph-theoretic analysis of finite Markov chains,\"\n       in Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:\n       A Multidisciplinary Approach, CRC Press.\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)\ndef transitive_closure_dag(G, topo_order=None):\n\"\"\"Returns the transitive closure of a directed acyclic graph.\n\n    This function is faster than the function `transitive_closure`, but fails\n    if the graph has a cycle.\n\n    The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\n    for all v, w in V there is an edge (v, w) in E+ if and only if there\n    is a non-null path from v to w in G.\n\n    Parameters\n    ----------\n    G : NetworkX DiGraph\n        A directed acyclic graph (DAG)\n\n    topo_order: list or tuple, optional\n        A topological order for G (if None, the function will compute one)\n\n    Returns\n    -------\n    NetworkX DiGraph\n        The transitive closure of `G`\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is not directed\n    NetworkXUnfeasible\n        If `G` has a cycle\n\n    Examples\n    --------\n    >>> DG = nx.DiGraph([(1, 2), (2, 3)])\n    >>> TC = nx.transitive_closure_dag(DG)\n    >>> TC.edges()\n    OutEdgeView([(1, 2), (1, 3), (2, 3)])\n\n    Notes\n    -----\n    This algorithm is probably simple enough to be well-known but I didn't find\n    a mention in the literature.\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef antichains(G, topo_order=None):\n\"\"\"Generates antichains from a directed acyclic graph (DAG).\n\n    An antichain is a subset of a partially ordered set such that any\n    two elements in the subset are incomparable.\n\n    Parameters\n    ----------\n    G : NetworkX DiGraph\n        A directed acyclic graph (DAG)\n\n    topo_order: list or tuple, optional\n        A topological order for G (if None, the function will compute one)\n\n    Yields\n    ------\n    antichain : list\n        a list of nodes in `G` representing an antichain\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is not directed\n\n    NetworkXUnfeasible\n        If `G` contains a cycle\n\n    Examples\n    --------\n    >>> DG = nx.DiGraph([(1, 2), (1, 3)])\n    >>> list(nx.antichains(DG))\n    [[], [3], [2], [2, 3], [1]]\n\n    Notes\n    -----\n    This function was originally developed by Peter Jipsen and Franco Saliola\n    for the SAGE project. It's included in NetworkX with permission from the\n    authors. Original SAGE code at:\n\n    https://github.com/sagemath/sage/blob/master/src/sage/combinat/posets/hasse_diagram.py\n\n    References\n    ----------\n    .. [1] Free Lattices, by R. Freese, J. Jezek and J. B. Nation,\n       AMS, Vol 42, 1995, p. 226.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"weight\": \"default_weight\"})\ndef dag_longest_path_length(G, weight=\"weight\", default_weight=1):\n\"\"\"Returns the longest path length in a DAG\n\n    Parameters\n    ----------\n    G : NetworkX DiGraph\n        A directed acyclic graph (DAG)\n\n    weight : string, optional\n        Edge data key to use for weight\n\n    default_weight : int, optional\n        The weight of edges that do not have a weight attribute\n\n    Returns\n    -------\n    int\n        Longest path length\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is not directed\n\n    Examples\n    --------\n    >>> DG = nx.DiGraph(\n    ...     [(0, 1, {\"cost\": 1}), (1, 2, {\"cost\": 1}), (0, 2, {\"cost\": 42})]\n    ... )\n    >>> list(nx.all_simple_paths(DG, 0, 2))\n    [[0, 1, 2], [0, 2]]\n    >>> nx.dag_longest_path_length(DG)\n    2\n    >>> nx.dag_longest_path_length(DG, weight=\"cost\")\n    42\n\n    See also\n    --------\n    dag_longest_path\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef dag_to_branching(G):\n\"\"\"Returns a branching representing all (overlapping) paths from\n    root nodes to leaf nodes in the given directed acyclic graph.\n\n    As described in :mod:`networkx.algorithms.tree.recognition`, a\n    *branching* is a directed forest in which each node has at most one\n    parent. In other words, a branching is a disjoint union of\n    *arborescences*. For this function, each node of in-degree zero in\n    `G` becomes a root of one of the arborescences, and there will be\n    one leaf node for each distinct path from that root to a leaf node\n    in `G`.\n\n    Each node `v` in `G` with *k* parents becomes *k* distinct nodes in\n    the returned branching, one for each parent, and the sub-DAG rooted\n    at `v` is duplicated for each copy. The algorithm then recurses on\n    the children of each copy of `v`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A directed acyclic graph.\n\n    Returns\n    -------\n    DiGraph\n        The branching in which there is a bijection between root-to-leaf\n        paths in `G` (in which multiple paths may share the same leaf)\n        and root-to-leaf paths in the branching (in which there is a\n        unique path from a root to a leaf).\n\n        Each node has an attribute 'source' whose value is the original\n        node to which this node corresponds. No other graph, node, or\n        edge attributes are copied into this new graph.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is not directed, or if `G` is a multigraph.\n\n    HasACycle\n        If `G` is not acyclic.\n\n    Examples\n    --------\n    To examine which nodes in the returned branching were produced by\n    which original node in the directed acyclic graph, we can collect\n    the mapping from source node to new nodes into a dictionary. For\n    example, consider the directed diamond graph::\n\n        >>> from collections import defaultdict\n        >>> from operator import itemgetter\n        >>>\n        >>> G = nx.DiGraph(nx.utils.pairwise(\"abd\"))\n        >>> G.add_edges_from(nx.utils.pairwise(\"acd\"))\n        >>> B = nx.dag_to_branching(G)\n        >>>\n        >>> sources = defaultdict(set)\n        >>> for v, source in B.nodes(data=\"source\"):\n        ...     sources[source].add(v)\n        >>> len(sources[\"a\"])\n        1\n        >>> len(sources[\"d\"])\n        2\n\n    To copy node attributes from the original graph to the new graph,\n    you can use a dictionary like the one constructed in the above\n    example::\n\n        >>> for source, nodes in sources.items():\n        ...     for v in nodes:\n        ...         B.nodes[v].update(G.nodes[source])\n\n    Notes\n    -----\n    This function is not idempotent in the sense that the node labels in\n    the returned branching may be uniquely generated each time the\n    function is invoked. In fact, the node labels may not be integers;\n    in order to relabel the nodes to be more readable, you can use the\n    :func:`networkx.convert_node_labels_to_integers` function.\n\n    The current implementation of this function uses\n    :func:`networkx.prefix_tree`, so it is subject to the limitations of\n    that function.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef v_structures(G):\n\"\"\"Yields 3-node tuples that represent the v-structures in `G`.\n\n    Colliders are triples in the directed acyclic graph (DAG) where two parent nodes\n    point to the same child node. V-structures are colliders where the two parent\n    nodes are not adjacent. In a causal graph setting, the parents do not directly\n    depend on each other, but conditioning on the child node provides an association.\n\n    Parameters\n    ----------\n    G : graph\n        A networkx `~networkx.DiGraph`.\n\n    Yields\n    ------\n    A 3-tuple representation of a v-structure\n        Each v-structure is a 3-tuple with the parent, collider, and other parent.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is an undirected graph.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (0, 4), (3, 1), (2, 4), (0, 5), (4, 5), (1, 5)])\n    >>> nx.is_directed_acyclic_graph(G)\n    True\n    >>> list(nx.dag.v_structures(G))\n    [(0, 4, 2), (0, 5, 1), (4, 5, 1)]\n\n    See Also\n    --------\n    colliders\n\n    Notes\n    -----\n    This function was written to be used on DAGs, however it works on cyclic graphs\n    too. Since colliders are referred to in the cyclic causal graph literature\n    [2]_ we allow cyclic graphs in this function. It is suggested that you test if\n    your input graph is acyclic as in the example if you want that property.\n\n    References\n    ----------\n    .. [1]  `Pearl's PRIMER <https://bayes.cs.ucla.edu/PRIMER/primer-ch2.pdf>`_\n            Ch-2 page 50: v-structures def.\n    .. [2] A Hyttinen, P.O. Hoyer, F. Eberhardt, M J \u0308arvisalo, (2013)\n           \"Discovering cyclic causal models with latent variables:\n           a general SAT-based procedure\", UAI'13: Proceedings of the Twenty-Ninth\n           Conference on Uncertainty in Artificial Intelligence, pg 301\u2013310,\n           `doi:10.5555/3023638.3023669 <https://dl.acm.org/doi/10.5555/3023638.3023669>`_\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(node_attrs=\"label_name\")\ndef harmonic_function(G, max_iter=30, label_name=\"label\"):\n\"\"\"Node classification by Harmonic function\n\n    Function for computing Harmonic function algorithm by Zhu et al.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n    max_iter : int\n        maximum number of iterations allowed\n    label_name : string\n        name of target labels to predict\n\n    Returns\n    -------\n    predicted : list\n        List of length ``len(G)`` with the predicted labels for each node.\n\n    Raises\n    ------\n    NetworkXError\n        If no nodes in `G` have attribute `label_name`.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import node_classification\n    >>> G = nx.path_graph(4)\n    >>> G.nodes[0][\"label\"] = \"A\"\n    >>> G.nodes[3][\"label\"] = \"B\"\n    >>> G.nodes(data=True)\n    NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\n    >>> G.edges()\n    EdgeView([(0, 1), (1, 2), (2, 3)])\n    >>> predicted = node_classification.harmonic_function(G)\n    >>> predicted\n    ['A', 'A', 'B', 'B']\n\n    References\n    ----------\n    Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\n    Semi-supervised learning using gaussian fields and harmonic functions.\n    In ICML (Vol. 3, pp. 912-919).\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_isolate(G, n):\n\"\"\"Determines whether a node is an isolate.\n\n    An *isolate* is a node with no neighbors (that is, with degree\n    zero). For directed graphs, this means no in-neighbors and no\n    out-neighbors.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    n : node\n        A node in `G`.\n\n    Returns\n    -------\n    is_isolate : bool\n       True if and only if `n` has no neighbors.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> G.add_edge(1, 2)\n    >>> G.add_node(3)\n    >>> nx.is_isolate(G, 2)\n    False\n    >>> nx.is_isolate(G, 3)\n    True\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef number_of_isolates(G):\n\"\"\"Returns the number of isolates in the graph.\n\n    An *isolate* is a node with no neighbors (that is, with degree\n    zero). For directed graphs, this means no in-neighbors and no\n    out-neighbors.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    Returns\n    -------\n    int\n        The number of degree zero nodes in the graph `G`.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef eccentricity(G, v=None, sp=None, weight=None):\n\"\"\"Returns the eccentricity of nodes in G.\n\n    The eccentricity of a node v is the maximum distance from v to\n    all other nodes in G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       A graph\n\n    v : node, optional\n       Return value of specified node\n\n    sp : dict of dicts, optional\n       All pairs shortest path lengths as a dictionary of dictionaries\n\n    weight : string, function, or None (default=None)\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number.\n\n        If this is None, every edge has weight/distance/cost 1.\n\n        Weights stored as floating point values can lead to small round-off\n        errors in distances. Use integer weights to avoid this.\n\n        Weights should be positive, since they are distances.\n\n    Returns\n    -------\n    ecc : dictionary\n       A dictionary of eccentricity values keyed by node.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n    >>> dict(nx.eccentricity(G))\n    {1: 2, 2: 3, 3: 2, 4: 2, 5: 3}\n\n    >>> dict(\n    ...     nx.eccentricity(G, v=[1, 5])\n    ... )  # This returns the eccentricity of node 1 & 5\n    {1: 2, 5: 3}\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef harmonic_diameter(G, sp=None):\n\"\"\"Returns the harmonic diameter of the graph G.\n\n    The harmonic diameter of a graph is the harmonic mean of the distances\n    between all pairs of distinct vertices. Graphs that are not strongly\n    connected have infinite diameter and mean distance, making such\n    measures not useful. Restricting the diameter or mean distance to\n    finite distances yields paradoxical values (e.g., a perfect match\n    would have diameter one). The harmonic mean handles gracefully\n    infinite distances (e.g., a perfect match has harmonic diameter equal\n    to the number of vertices minus one), making it possible to assign a\n    meaningful value to all graphs.\n\n    Note that in [1] the harmonic diameter is called \"connectivity length\":\n    however, \"harmonic diameter\" is a more standard name from the\n    theory of metric spaces. The name \"harmonic mean distance\" is perhaps\n    a more descriptive name, but is not used in the literature, so we use the\n    name \"harmonic diameter\" here.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       A graph\n\n    sp : dict of dicts, optional\n       All-pairs shortest path lengths as a dictionary of dictionaries\n\n    Returns\n    -------\n    hd : float\n       Harmonic diameter of graph\n\n    References\n    ----------\n    .. [1] Massimo Marchiori and Vito Latora, \"Harmony in the small-world\".\n           *Physica A: Statistical Mechanics and Its Applications*\n           285(3-4), pages 539-546, 2000.\n           <https://doi.org/10.1016/S0378-4371(00)00311-3>\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef radius(G, e=None, usebounds=False, weight=None):\n\"\"\"Returns the radius of the graph G.\n\n    The radius is the minimum eccentricity.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       A graph\n\n    e : eccentricity dictionary, optional\n      A precomputed dictionary of eccentricities.\n\n    weight : string, function, or None\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number.\n\n        If this is None, every edge has weight/distance/cost 1.\n\n        Weights stored as floating point values can lead to small round-off\n        errors in distances. Use integer weights to avoid this.\n\n        Weights should be positive, since they are distances.\n\n    Returns\n    -------\n    r : integer\n       Radius of graph\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n    >>> nx.radius(G)\n    2\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\", mutates_input={\"attr\": 2})\ndef barycenter(G, weight=None, attr=None, sp=None):\n\"\"\"Calculate barycenter of a connected graph, optionally with edge weights.\n\n    The :dfn:`barycenter` a\n    :func:`connected <networkx.algorithms.components.is_connected>` graph\n    :math:`G` is the subgraph induced by the set of its nodes :math:`v`\n    minimizing the objective function\n\n    .. math::\n\n        \\sum_{u \\in V(G)} d_G(u, v),\n\n    where :math:`d_G` is the (possibly weighted) :func:`path length\n    <networkx.algorithms.shortest_paths.generic.shortest_path_length>`.\n    The barycenter is also called the :dfn:`median`. See [West01]_, p. 78.\n\n    Parameters\n    ----------\n    G : :class:`networkx.Graph`\n        The connected graph :math:`G`.\n    weight : :class:`str`, optional\n        Passed through to\n        :func:`~networkx.algorithms.shortest_paths.generic.shortest_path_length`.\n    attr : :class:`str`, optional\n        If given, write the value of the objective function to each node's\n        `attr` attribute. Otherwise do not store the value.\n    sp : dict of dicts, optional\n       All pairs shortest path lengths as a dictionary of dictionaries\n\n    Returns\n    -------\n    list\n        Nodes of `G` that induce the barycenter of `G`.\n\n    Raises\n    ------\n    NetworkXNoPath\n        If `G` is disconnected. `G` may appear disconnected to\n        :func:`barycenter` if `sp` is given but is missing shortest path\n        lengths for any pairs.\n    ValueError\n        If `sp` and `weight` are both given.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n    >>> nx.barycenter(G)\n    [1, 3, 4]\n\n    See Also\n    --------\n    center\n    periphery\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef effective_graph_resistance(G, weight=None, invert_weight=True):\n\"\"\"Returns the Effective graph resistance of G.\n\n    Also known as the Kirchhoff index.\n\n    The effective graph resistance is defined as the sum\n    of the resistance distance of every node pair in G [1]_.\n\n    If weight is not provided, then a weight of 1 is used for all edges.\n\n    The effective graph resistance of a disconnected graph is infinite.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       A graph\n\n    weight : string or None, optional (default=None)\n       The edge data key used to compute the effective graph resistance.\n       If None, then each edge has weight 1.\n\n    invert_weight : boolean (default=True)\n        Proper calculation of resistance distance requires building the\n        Laplacian matrix with the reciprocal of the weight. Not required\n        if the weight is already inverted. Weight cannot be zero.\n\n    Returns\n    -------\n    RG : float\n        The effective graph resistance of `G`.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is a directed graph.\n\n    NetworkXError\n        If `G` does not contain any nodes.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n    >>> round(nx.effective_graph_resistance(G), 10)\n    10.25\n\n    Notes\n    -----\n    The implementation is based on Theorem 2.2 in [2]_. Self-loops are ignored.\n    Multi-edges are contracted in one edge with weight equal to the harmonic sum of the weights.\n\n    References\n    ----------\n    .. [1] Wolfram\n       \"Kirchhoff Index.\"\n       https://mathworld.wolfram.com/KirchhoffIndex.html\n    .. [2] W. Ellens, F. M. Spieksma, P. Van Mieghem, A. Jamakovic, R. E. Kooij.\n        Effective graph resistance.\n        Lin. Alg. Appl. 435:2491-2506, 2011.\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef triadic_census(G, nodelist=None):\n\"\"\"Determines the triadic census of a directed graph.\n\n    The triadic census is a count of how many of the 16 possible types of\n    triads are present in a directed graph. If a list of nodes is passed, then\n    only those triads are taken into account which have elements of nodelist in them.\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n    nodelist : list\n        List of nodes for which you want to calculate triadic census\n\n    Returns\n    -------\n    census : dict\n       Dictionary with triad type as keys and number of occurrences as values.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\n    >>> triadic_census = nx.triadic_census(G)\n    >>> for key, value in triadic_census.items():\n    ...     print(f\"{key}: {value}\")\n    003: 0\n    012: 0\n    102: 0\n    021D: 0\n    021U: 0\n    021C: 0\n    111D: 0\n    111U: 0\n    030T: 2\n    030C: 2\n    201: 0\n    120D: 0\n    120U: 0\n    120C: 0\n    210: 0\n    300: 0\n\n    Notes\n    -----\n    This algorithm has complexity $O(m)$ where $m$ is the number of edges in\n    the graph.\n\n    For undirected graphs, the triadic census can be computed by first converting\n    the graph into a directed graph using the ``G.to_directed()`` method.\n    After this conversion, only the triad types 003, 102, 201 and 300 will be\n    present in the undirected scenario.\n\n    Raises\n    ------\n    ValueError\n        If `nodelist` contains duplicate nodes or nodes not in `G`.\n        If you want to ignore this you can preprocess with `set(nodelist) & G.nodes`\n\n    See also\n    --------\n    triad_graph\n\n    References\n    ----------\n    .. [1] Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\n        algorithm for large sparse networks with small maximum degree,\n        University of Ljubljana,\n        http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef all_triplets(G):\n\"\"\"Returns a generator of all possible sets of 3 nodes in a DiGraph.\n\n    .. deprecated:: 3.3\n\n       all_triplets is deprecated and will be removed in NetworkX version 3.5.\n       Use `itertools.combinations` instead::\n\n          all_triplets = itertools.combinations(G, 3)\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n\n    Returns\n    -------\n    triplets : generator of 3-tuples\n       Generator of tuples of 3 nodes\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\n    >>> list(nx.all_triplets(G))\n    [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef triads_by_type(G):\n\"\"\"Returns a list of all triads for each triad type in a directed graph.\n    There are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\n    nodes, they will be classified as a particular triad type if their connections\n    are as follows:\n\n    - 003: 1, 2, 3\n    - 012: 1 -> 2, 3\n    - 102: 1 <-> 2, 3\n    - 021D: 1 <- 2 -> 3\n    - 021U: 1 -> 2 <- 3\n    - 021C: 1 -> 2 -> 3\n    - 111D: 1 <-> 2 <- 3\n    - 111U: 1 <-> 2 -> 3\n    - 030T: 1 -> 2 -> 3, 1 -> 3\n    - 030C: 1 <- 2 <- 3, 1 -> 3\n    - 201: 1 <-> 2 <-> 3\n    - 120D: 1 <- 2 -> 3, 1 <-> 3\n    - 120U: 1 -> 2 <- 3, 1 <-> 3\n    - 120C: 1 -> 2 -> 3, 1 <-> 3\n    - 210: 1 -> 2 <-> 3, 1 <-> 3\n    - 300: 1 <-> 2 <-> 3, 1 <-> 3\n\n    Refer to the :doc:`example gallery </auto_examples/graph/plot_triad_types>`\n    for visual examples of the triad types.\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n\n    Returns\n    -------\n    tri_by_type : dict\n       Dictionary with triad types as keys and lists of triads as values.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\n    >>> dict = nx.triads_by_type(G)\n    >>> dict[\"120C\"][0].edges()\n    OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\n    >>> dict[\"012\"][0].edges()\n    OutEdgeView([(1, 2)])\n\n    References\n    ----------\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\n        Oxford.\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)\ndef random_triad(G, seed=None):\n\"\"\"Returns a random triad from a directed graph.\n\n    .. deprecated:: 3.3\n\n       random_triad is deprecated and will be removed in version 3.5.\n       Use random sampling directly instead::\n\n          G.subgraph(random.sample(list(G), 3))\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G2 : subgraph\n       A randomly selected triad (order-3 NetworkX DiGraph)\n\n    Raises\n    ------\n    NetworkXError\n        If the input Graph has less than 3 nodes.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\n    >>> triad = nx.random_triad(G, seed=1)\n    >>> triad.edges\n    OutEdgeView([(1, 2)])\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef find_asteroidal_triple(G):\n\"\"\"Find an asteroidal triple in the given graph.\n\n    An asteroidal triple is a triple of non-adjacent vertices such that\n    there exists a path between any two of them which avoids the closed\n    neighborhood of the third. It checks all independent triples of vertices\n    and whether they are an asteroidal triple or not. This is done with the\n    help of a data structure called a component structure.\n    A component structure encodes information about which vertices belongs to\n    the same connected component when the closed neighborhood of a given vertex\n    is removed from the graph. The algorithm used to check is the trivial\n    one, outlined in [1]_, which has a runtime of\n    :math:`O(|V||\\overline{E} + |V||E|)`, where the second term is the\n    creation of the component structure.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        The graph to check whether is AT-free or not\n\n    Returns\n    -------\n    list or None\n        An asteroidal triple is returned as a list of nodes. If no asteroidal\n        triple exists, i.e. the graph is AT-free, then None is returned.\n        The returned value depends on the certificate parameter. The default\n        option is a bool which is True if the graph is AT-free, i.e. the\n        given graph contains no asteroidal triples, and False otherwise, i.e.\n        if the graph contains at least one asteroidal triple.\n\n    Notes\n    -----\n    The component structure and the algorithm is described in [1]_. The current\n    implementation implements the trivial algorithm for simple graphs.\n\n    References\n    ----------\n    .. [1] Ekkehard K\u00f6hler,\n       \"Recognizing Graphs without asteroidal triples\",\n       Journal of Discrete Algorithms 2, pages 439-452, 2004.\n       https://www.sciencedirect.com/science/article/pii/S157086670400019X\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef create_component_structure(G):\n\"\"\"Create component structure for G.\n\n    A *component structure* is an `nxn` array, denoted `c`, where `n` is\n    the number of vertices,  where each row and column corresponds to a vertex.\n\n    .. math::\n        c_{uv} = \\begin{cases} 0, if v \\in N[u] \\\\\n            k, if v \\in component k of G \\setminus N[u] \\end{cases}\n\n    Where `k` is an arbitrary label for each component. The structure is used\n    to simplify the detection of asteroidal triples.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        Undirected, simple graph.\n\n    Returns\n    -------\n    component_structure : dictionary\n        A dictionary of dictionaries, keyed by pairs of vertices.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(mutates_input={\"not copy\": 3}, returns_graph=True)\ndef dedensify(G, threshold, prefix=None, copy=True):\n\"\"\"Compresses neighborhoods around high-degree nodes\n\n    Reduces the number of edges to high-degree nodes by adding compressor nodes\n    that summarize multiple edges of the same type to high-degree nodes (nodes\n    with a degree greater than a given threshold).  Dedensification also has\n    the added benefit of reducing the number of edges around high-degree nodes.\n    The implementation currently supports graphs with a single edge type.\n\n    Parameters\n    ----------\n    G: graph\n       A networkx graph\n    threshold: int\n       Minimum degree threshold of a node to be considered a high degree node.\n       The threshold must be greater than or equal to 2.\n    prefix: str or None, optional (default: None)\n       An optional prefix for denoting compressor nodes\n    copy: bool, optional (default: True)\n       Indicates if dedensification should be done inplace\n\n    Returns\n    -------\n    dedensified networkx graph : (graph, set)\n        2-tuple of the dedensified graph and set of compressor nodes\n\n    Notes\n    -----\n    According to the algorithm in [1]_, removes edges in a graph by\n    compressing/decompressing the neighborhoods around high degree nodes by\n    adding compressor nodes that summarize multiple edges of the same type\n    to high-degree nodes.  Dedensification will only add a compressor node when\n    doing so will reduce the total number of edges in the given graph. This\n    implementation currently supports graphs with a single edge type.\n\n    Examples\n    --------\n    Dedensification will only add compressor nodes when doing so would result\n    in fewer edges::\n\n        >>> original_graph = nx.DiGraph()\n        >>> original_graph.add_nodes_from(\n        ...     [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"A\", \"B\", \"C\"]\n        ... )\n        >>> original_graph.add_edges_from(\n        ...     [\n        ...         (\"1\", \"C\"), (\"1\", \"B\"),\n        ...         (\"2\", \"C\"), (\"2\", \"B\"), (\"2\", \"A\"),\n        ...         (\"3\", \"B\"), (\"3\", \"A\"), (\"3\", \"6\"),\n        ...         (\"4\", \"C\"), (\"4\", \"B\"), (\"4\", \"A\"),\n        ...         (\"5\", \"B\"), (\"5\", \"A\"),\n        ...         (\"6\", \"5\"),\n        ...         (\"A\", \"6\")\n        ...     ]\n        ... )\n        >>> c_graph, c_nodes = nx.dedensify(original_graph, threshold=2)\n        >>> original_graph.number_of_edges()\n        15\n        >>> c_graph.number_of_edges()\n        14\n\n    A dedensified, directed graph can be \"densified\" to reconstruct the\n    original graph::\n\n        >>> original_graph = nx.DiGraph()\n        >>> original_graph.add_nodes_from(\n        ...     [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"A\", \"B\", \"C\"]\n        ... )\n        >>> original_graph.add_edges_from(\n        ...     [\n        ...         (\"1\", \"C\"), (\"1\", \"B\"),\n        ...         (\"2\", \"C\"), (\"2\", \"B\"), (\"2\", \"A\"),\n        ...         (\"3\", \"B\"), (\"3\", \"A\"), (\"3\", \"6\"),\n        ...         (\"4\", \"C\"), (\"4\", \"B\"), (\"4\", \"A\"),\n        ...         (\"5\", \"B\"), (\"5\", \"A\"),\n        ...         (\"6\", \"5\"),\n        ...         (\"A\", \"6\")\n        ...     ]\n        ... )\n        >>> c_graph, c_nodes = nx.dedensify(original_graph, threshold=2)\n        >>> # re-densifies the compressed graph into the original graph\n        >>> for c_node in c_nodes:\n        ...     all_neighbors = set(nx.all_neighbors(c_graph, c_node))\n        ...     out_neighbors = set(c_graph.neighbors(c_node))\n        ...     for out_neighbor in out_neighbors:\n        ...         c_graph.remove_edge(c_node, out_neighbor)\n        ...     in_neighbors = all_neighbors - out_neighbors\n        ...     for in_neighbor in in_neighbors:\n        ...         c_graph.remove_edge(in_neighbor, c_node)\n        ...         for out_neighbor in out_neighbors:\n        ...             c_graph.add_edge(in_neighbor, out_neighbor)\n        ...     c_graph.remove_node(c_node)\n        ...\n        >>> nx.is_isomorphic(original_graph, c_graph)\n        True\n\n    References\n    ----------\n    .. [1] Maccioni, A., & Abadi, D. J. (2016, August).\n       Scalable pattern matching over compressed graphs via dedensification.\n       In Proceedings of the 22nd ACM SIGKDD International Conference on\n       Knowledge Discovery and Data Mining (pp. 1755-1764).\n       http://www.cs.umd.edu/~abadi/papers/graph-dedense.pdf\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable("}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef moral_graph(G):\n\"\"\"Return the Moral Graph\n\n    Returns the moralized graph of a given directed graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Directed graph\n\n    Returns\n    -------\n    H : NetworkX graph\n        The undirected moralized graph of G\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is undirected.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (2, 5), (3, 4), (4, 3)])\n    >>> G_moral = nx.moral_graph(G)\n    >>> G_moral.edges()\n    EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])\n\n    Notes\n    -----\n    A moral graph is an undirected graph H = (V, E) generated from a\n    directed Graph, where if a node has more than one parent node, edges\n    between these parent nodes are inserted and all directed edges become\n    undirected.\n\n    https://en.wikipedia.org/wiki/Moral_graph\n\n    References\n    ----------\n    .. [1] Wray L. Buntine. 1995. Chain graphs for learning.\n           In Proceedings of the Eleventh conference on Uncertainty\n           in artificial intelligence (UAI'95)\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef tutte_polynomial(G):\n\"\"\"Returns the Tutte polynomial of `G`\n\n    This function computes the Tutte polynomial via an iterative version of\n    the deletion-contraction algorithm.\n\n    The Tutte polynomial `T_G(x, y)` is a fundamental graph polynomial invariant in\n    two variables. It encodes a wide array of information related to the\n    edge-connectivity of a graph; \"Many problems about graphs can be reduced to\n    problems of finding and evaluating the Tutte polynomial at certain values\" [1]_.\n    In fact, every deletion-contraction-expressible feature of a graph is a\n    specialization of the Tutte polynomial [2]_ (see Notes for examples).\n\n    There are several equivalent definitions; here are three:\n\n    Def 1 (rank-nullity expansion): For `G` an undirected graph, `n(G)` the\n    number of vertices of `G`, `E` the edge set of `G`, `V` the vertex set of\n    `G`, and `c(A)` the number of connected components of the graph with vertex\n    set `V` and edge set `A` [3]_:\n\n    .. math::\n\n        T_G(x, y) = \\sum_{A \\in E} (x-1)^{c(A) - c(E)} (y-1)^{c(A) + |A| - n(G)}\n\n    Def 2 (spanning tree expansion): Let `G` be an undirected graph, `T` a spanning\n    tree of `G`, and `E` the edge set of `G`. Let `E` have an arbitrary strict\n    linear order `L`. Let `B_e` be the unique minimal nonempty edge cut of\n    $E \\setminus T \\cup {e}$. An edge `e` is internally active with respect to\n    `T` and `L` if `e` is the least edge in `B_e` according to the linear order\n    `L`. The internal activity of `T` (denoted `i(T)`) is the number of edges\n    in $E \\setminus T$ that are internally active with respect to `T` and `L`.\n    Let `P_e` be the unique path in $T \\cup {e}$ whose source and target vertex\n    are the same. An edge `e` is externally active with respect to `T` and `L`\n    if `e` is the least edge in `P_e` according to the linear order `L`. The\n    external activity of `T` (denoted `e(T)`) is the number of edges in\n    $E \\setminus T$ that are externally active with respect to `T` and `L`.\n    Then [4]_ [5]_:\n\n    .. math::\n\n        T_G(x, y) = \\sum_{T \\text{ a spanning tree of } G} x^{i(T)} y^{e(T)}\n\n    Def 3 (deletion-contraction recurrence): For `G` an undirected graph, `G-e`\n    the graph obtained from `G` by deleting edge `e`, `G/e` the graph obtained\n    from `G` by contracting edge `e`, `k(G)` the number of cut-edges of `G`,\n    and `l(G)` the number of self-loops of `G`:\n\n    .. math::\n        T_G(x, y) = \\begin{cases}\n    \t   x^{k(G)} y^{l(G)}, & \\text{if all edges are cut-edges or self-loops} \\\\\n           T_{G-e}(x, y) + T_{G/e}(x, y), & \\text{otherwise, for an arbitrary edge $e$ not a cut-edge or loop}\n        \\end{cases}\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    Returns\n    -------\n    instance of `sympy.core.add.Add`\n        A Sympy expression representing the Tutte polynomial for `G`.\n\n    Examples\n    --------\n    >>> C = nx.cycle_graph(5)\n    >>> nx.tutte_polynomial(C)\n    x**4 + x**3 + x**2 + x + y\n\n    >>> D = nx.diamond_graph()\n    >>> nx.tutte_polynomial(D)\n    x**3 + 2*x**2 + 2*x*y + x + y**2 + y\n\n    Notes\n    -----\n    Some specializations of the Tutte polynomial:\n\n    - `T_G(1, 1)` counts the number of spanning trees of `G`\n    - `T_G(1, 2)` counts the number of connected spanning subgraphs of `G`\n    - `T_G(2, 1)` counts the number of spanning forests in `G`\n    - `T_G(0, 2)` counts the number of strong orientations of `G`\n    - `T_G(2, 0)` counts the number of acyclic orientations of `G`\n\n    Edge contraction is defined and deletion-contraction is introduced in [6]_.\n    Combinatorial meaning of the coefficients is introduced in [7]_.\n    Universality, properties, and applications are discussed in [8]_.\n\n    Practically, up-front computation of the Tutte polynomial may be useful when\n    users wish to repeatedly calculate edge-connectivity-related information\n    about one or more graphs.\n\n    References\n    ----------\n    .. [1] M. Brandt,\n       \"The Tutte Polynomial.\"\n       Talking About Combinatorial Objects Seminar, 2015\n       https://math.berkeley.edu/~brandtm/talks/tutte.pdf\n    .. [2] A. Bj\u00f6rklund, T. Husfeldt, P. Kaski, M. Koivisto,\n       \"Computing the Tutte polynomial in vertex-exponential time\"\n       49th Annual IEEE Symposium on Foundations of Computer Science, 2008\n       https://ieeexplore.ieee.org/abstract/document/4691000\n    .. [3] Y. Shi, M. Dehmer, X. Li, I. Gutman,\n       \"Graph Polynomials,\" p. 14\n    .. [4] Y. Shi, M. Dehmer, X. Li, I. Gutman,\n       \"Graph Polynomials,\" p. 46\n    .. [5] A. Ne\u0161etril, J. Goodall,\n       \"Graph invariants, homomorphisms, and the Tutte polynomial\"\n       https://iuuk.mff.cuni.cz/~andrew/Tutte.pdf\n    .. [6] D. B. West,\n       \"Introduction to Graph Theory,\" p. 84\n    .. [7] G. Coutinho,\n       \"A brief introduction to the Tutte polynomial\"\n       Structural Analysis of Complex Networks, 2011\n       https://homepages.dcc.ufmg.br/~gabriel/seminars/coutinho_tuttepolynomial_seminar.pdf\n    .. [8] J. A. Ellis-Monaghan, C. Merino,\n       \"Graph polynomials and their applications I: The Tutte polynomial\"\n       Structural Analysis of Complex Networks, 2011\n       https://arxiv.org/pdf/0803.3079.pdf\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef dominating_set(G, start_with=None):\n\"\"\"Finds a dominating set for the graph G.\n\n    A *dominating set* for a graph with node set *V* is a subset *D* of\n    *V* such that every node not in *D* is adjacent to at least one\n    member of *D* [1]_.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    start_with : node (default=None)\n        Node to use as a starting point for the algorithm.\n\n    Returns\n    -------\n    D : set\n        A dominating set for G.\n\n    Notes\n    -----\n    This function is an implementation of algorithm 7 in [2]_ which\n    finds some dominating set, not necessarily the smallest one.\n\n    See also\n    --------\n    is_dominating_set\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Dominating_set\n\n    .. [2] Abdol-Hossein Esfahanian. Connectivity Algorithms.\n        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef resource_allocation_index(G, ebunch=None):\n\"\"\"Compute the resource allocation index of all node pairs in ebunch.\n\n    Resource allocation index of `u` and `v` is defined as\n\n    .. math::\n\n        \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{1}{|\\Gamma(w)|}\n\n    where $\\Gamma(u)$ denotes the set of neighbors of $u$.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX undirected graph.\n\n    ebunch : iterable of node pairs, optional (default = None)\n        Resource allocation index will be computed for each pair of\n        nodes given in the iterable. The pairs must be given as\n        2-tuples (u, v) where u and v are nodes in the graph. If ebunch\n        is None then all nonexistent edges in the graph will be used.\n        Default value: None.\n\n    Returns\n    -------\n    piter : iterator\n        An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n        pair of nodes and p is their resource allocation index.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\n    NodeNotFound\n        If `ebunch` has a node that is not in `G`.\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> preds = nx.resource_allocation_index(G, [(0, 1), (2, 3)])\n    >>> for u, v, p in preds:\n    ...     print(f\"({u}, {v}) -> {p:.8f}\")\n    (0, 1) -> 0.75000000\n    (2, 3) -> 0.75000000\n\n    References\n    ----------\n    .. [1] T. Zhou, L. Lu, Y.-C. Zhang.\n       Predicting missing links via local information.\n       Eur. Phys. J. B 71 (2009) 623.\n       https://arxiv.org/pdf/0901.0553.pdf\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef adamic_adar_index(G, ebunch=None):\n\"\"\"Compute the Adamic-Adar index of all node pairs in ebunch.\n\n    Adamic-Adar index of `u` and `v` is defined as\n\n    .. math::\n\n        \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{1}{\\log |\\Gamma(w)|}\n\n    where $\\Gamma(u)$ denotes the set of neighbors of $u$.\n    This index leads to zero-division for nodes only connected via self-loops.\n    It is intended to be used when no self-loops are present.\n\n    Parameters\n    ----------\n    G : graph\n        NetworkX undirected graph.\n\n    ebunch : iterable of node pairs, optional (default = None)\n        Adamic-Adar index will be computed for each pair of nodes given\n        in the iterable. The pairs must be given as 2-tuples (u, v)\n        where u and v are nodes in the graph. If ebunch is None then all\n        nonexistent edges in the graph will be used.\n        Default value: None.\n\n    Returns\n    -------\n    piter : iterator\n        An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n        pair of nodes and p is their Adamic-Adar index.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\n    NodeNotFound\n        If `ebunch` has a node that is not in `G`.\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> preds = nx.adamic_adar_index(G, [(0, 1), (2, 3)])\n    >>> for u, v, p in preds:\n    ...     print(f\"({u}, {v}) -> {p:.8f}\")\n    (0, 1) -> 2.16404256\n    (2, 3) -> 2.16404256\n\n    References\n    ----------\n    .. [1] D. Liben-Nowell, J. Kleinberg.\n           The Link Prediction Problem for Social Networks (2004).\n           http://www.cs.cornell.edu/home/kleinber/link-pred.pdf\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef preferential_attachment(G, ebunch=None):\n\"\"\"Compute the preferential attachment score of all node pairs in ebunch.\n\n    Preferential attachment score of `u` and `v` is defined as\n\n    .. math::\n\n        |\\Gamma(u)| |\\Gamma(v)|\n\n    where $\\Gamma(u)$ denotes the set of neighbors of $u$.\n\n    Parameters\n    ----------\n    G : graph\n        NetworkX undirected graph.\n\n    ebunch : iterable of node pairs, optional (default = None)\n        Preferential attachment score will be computed for each pair of\n        nodes given in the iterable. The pairs must be given as\n        2-tuples (u, v) where u and v are nodes in the graph. If ebunch\n        is None then all nonexistent edges in the graph will be used.\n        Default value: None.\n\n    Returns\n    -------\n    piter : iterator\n        An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n        pair of nodes and p is their preferential attachment score.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\n    NodeNotFound\n        If `ebunch` has a node that is not in `G`.\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> preds = nx.preferential_attachment(G, [(0, 1), (2, 3)])\n    >>> for u, v, p in preds:\n    ...     print(f\"({u}, {v}) -> {p}\")\n    (0, 1) -> 16\n    (2, 3) -> 16\n\n    References\n    ----------\n    .. [1] D. Liben-Nowell, J. Kleinberg.\n           The Link Prediction Problem for Social Networks (2004).\n           http://www.cs.cornell.edu/home/kleinber/link-pred.pdf\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(node_attrs=\"community\")\ndef ra_index_soundarajan_hopcroft(G, ebunch=None, community=\"community\"):\n\"\"\"Compute the resource allocation index of all node pairs in\n    ebunch using community information.\n\n    For two nodes $u$ and $v$, this function computes the resource\n    allocation index considering only common neighbors belonging to the\n    same community as $u$ and $v$. Mathematically,\n\n    .. math::\n\n        \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{f(w)}{|\\Gamma(w)|}\n\n    where $f(w)$ equals 1 if $w$ belongs to the same community as $u$\n    and $v$ or 0 otherwise and $\\Gamma(u)$ denotes the set of\n    neighbors of $u$.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX undirected graph.\n\n    ebunch : iterable of node pairs, optional (default = None)\n        The score will be computed for each pair of nodes given in the\n        iterable. The pairs must be given as 2-tuples (u, v) where u\n        and v are nodes in the graph. If ebunch is None then all\n        nonexistent edges in the graph will be used.\n        Default value: None.\n\n    community : string, optional (default = 'community')\n        Nodes attribute name containing the community information.\n        G[u][community] identifies which community u belongs to. Each\n        node belongs to at most one community. Default value: 'community'.\n\n    Returns\n    -------\n    piter : iterator\n        An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n        pair of nodes and p is their score.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\n    NetworkXAlgorithmError\n        If no community information is available for a node in `ebunch` or in `G` (if `ebunch` is `None`).\n\n    NodeNotFound\n        If `ebunch` has a node that is not in `G`.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3)])\n    >>> G.nodes[0][\"community\"] = 0\n    >>> G.nodes[1][\"community\"] = 0\n    >>> G.nodes[2][\"community\"] = 1\n    >>> G.nodes[3][\"community\"] = 0\n    >>> preds = nx.ra_index_soundarajan_hopcroft(G, [(0, 3)])\n    >>> for u, v, p in preds:\n    ...     print(f\"({u}, {v}) -> {p:.8f}\")\n    (0, 3) -> 0.50000000\n\n    References\n    ----------\n    .. [1] Sucheta Soundarajan and John Hopcroft.\n       Using community information to improve the precision of link\n       prediction methods.\n       In Proceedings of the 21st international conference companion on\n       World Wide Web (WWW '12 Companion). ACM, New York, NY, USA, 607-608.\n       http://doi.acm.org/10.1145/2187980.2188150\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(mutates_input=True, returns_graph=True)\ndef directed_edge_swap(G, *, nswap=1, max_tries=100, seed=None):\n\"\"\"Swap three edges in a directed graph while keeping the node degrees fixed.\n\n    A directed edge swap swaps three edges such that a -> b -> c -> d becomes\n    a -> c -> b -> d. This pattern of swapping allows all possible states with the\n    same in- and out-degree distribution in a directed graph to be reached.\n\n    If the swap would create parallel edges (e.g. if a -> c already existed in the\n    previous example), another attempt is made to find a suitable trio of edges.\n\n    Parameters\n    ----------\n    G : DiGraph\n       A directed graph\n\n    nswap : integer (optional, default=1)\n       Number of three-edge (directed) swaps to perform\n\n    max_tries : integer (optional, default=100)\n       Maximum number of attempts to swap edges\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : DiGraph\n       The graph after the edges are swapped.\n\n    Raises\n    ------\n    NetworkXError\n        If `G` is not directed, or\n        If nswap > max_tries, or\n        If there are fewer than 4 nodes or 3 edges in `G`.\n    NetworkXAlgorithmError\n        If the number of swap attempts exceeds `max_tries` before `nswap` swaps are made\n\n    Notes\n    -----\n    Does not enforce any connectivity constraints.\n\n    The graph G is modified in place.\n\n    A later swap is allowed to undo a previous swap.\n\n    References\n    ----------\n    .. [1] Erd\u0151s, P\u00e9ter L., et al. \u201cA Simple Havel-Hakimi Type Algorithm to Realize\n           Graphical Degree Sequences of Directed Graphs.\u201d ArXiv:0905.4913 [Math],\n           Jan. 2010. https://doi.org/10.48550/arXiv.0905.4913.\n           Published  2010 in Elec. J. Combinatorics (17(1)). R66.\n           http://www.combinatorics.org/Volume_17/PDF/v17i1r66.pdf\n    .. [2] \u201cCombinatorics - Reaching All Possible Simple Directed Graphs with a given\n           Degree Sequence with 2-Edge Swaps.\u201d Mathematics Stack Exchange,\n           https://math.stackexchange.com/questions/22272/. Accessed 30 May 2022.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(mutates_input=True)\ndef connected_double_edge_swap(G, nswap=1, _window_threshold=3, seed=None):\n\"\"\"Attempts the specified number of double-edge swaps in the graph `G`.\n\n    A double-edge swap removes two randomly chosen edges `(u, v)` and `(x,\n    y)` and creates the new edges `(u, x)` and `(v, y)`::\n\n     u--v            u  v\n            becomes  |  |\n     x--y            x  y\n\n    If either `(u, x)` or `(v, y)` already exist, then no swap is performed\n    so the actual number of swapped edges is always *at most* `nswap`.\n\n    Parameters\n    ----------\n    G : graph\n       An undirected graph\n\n    nswap : integer (optional, default=1)\n       Number of double-edge swaps to perform\n\n    _window_threshold : integer\n\n       The window size below which connectedness of the graph will be checked\n       after each swap.\n\n       The \"window\" in this function is a dynamically updated integer that\n       represents the number of swap attempts to make before checking if the\n       graph remains connected. It is an optimization used to decrease the\n       running time of the algorithm in exchange for increased complexity of\n       implementation.\n\n       If the window size is below this threshold, then the algorithm checks\n       after each swap if the graph remains connected by checking if there is a\n       path joining the two nodes whose edge was just removed. If the window\n       size is above this threshold, then the algorithm performs do all the\n       swaps in the window and only then check if the graph is still connected.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    int\n       The number of successful swaps\n\n    Raises\n    ------\n\n    NetworkXError\n\n       If the input graph is not connected, or if the graph has fewer than four\n       nodes.\n\n    Notes\n    -----\n\n    The initial graph `G` must be connected, and the resulting graph is\n    connected. The graph `G` is modified in place.\n\n    References\n    ----------\n    .. [1] C. Gkantsidis and M. Mihail and E. Zegura,\n           The Markov chain simulation method for generating connected\n           power law random graphs, 2003.\n           http://citeseer.ist.psu.edu/gkantsidis03markov.html\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_eulerian(G):\n\"\"\"Returns True if and only if `G` is Eulerian.\n\n    A graph is *Eulerian* if it has an Eulerian circuit. An *Eulerian\n    circuit* is a closed walk that includes each edge of a graph exactly\n    once.\n\n    Graphs with isolated vertices (i.e. vertices with zero degree) are not\n    considered to have Eulerian circuits. Therefore, if the graph is not\n    connected (or not strongly connected, for directed graphs), this function\n    returns False.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       A graph, either directed or undirected.\n\n    Examples\n    --------\n    >>> nx.is_eulerian(nx.DiGraph({0: [3], 1: [2], 2: [3], 3: [0, 1]}))\n    True\n    >>> nx.is_eulerian(nx.complete_graph(5))\n    True\n    >>> nx.is_eulerian(nx.petersen_graph())\n    False\n\n    If you prefer to allow graphs with isolated vertices to have Eulerian circuits,\n    you can first remove such vertices and then call `is_eulerian` as below example shows.\n\n    >>> G = nx.Graph([(0, 1), (1, 2), (0, 2)])\n    >>> G.add_node(3)\n    >>> nx.is_eulerian(G)\n    False\n\n    >>> G.remove_nodes_from(list(nx.isolates(G)))\n    >>> nx.is_eulerian(G)\n    True\n\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef eulerian_circuit(G, source=None, keys=False):\n\"\"\"Returns an iterator over the edges of an Eulerian circuit in `G`.\n\n    An *Eulerian circuit* is a closed walk that includes each edge of a\n    graph exactly once.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       A graph, either directed or undirected.\n\n    source : node, optional\n       Starting node for circuit.\n\n    keys : bool\n       If False, edges generated by this function will be of the form\n       ``(u, v)``. Otherwise, edges will be of the form ``(u, v, k)``.\n       This option is ignored unless `G` is a multigraph.\n\n    Returns\n    -------\n    edges : iterator\n       An iterator over edges in the Eulerian circuit.\n\n    Raises\n    ------\n    NetworkXError\n       If the graph is not Eulerian.\n\n    See Also\n    --------\n    is_eulerian\n\n    Notes\n    -----\n    This is a linear time implementation of an algorithm adapted from [1]_.\n\n    For general information about Euler tours, see [2]_.\n\n    References\n    ----------\n    .. [1] J. Edmonds, E. L. Johnson.\n       Matching, Euler tours and the Chinese postman.\n       Mathematical programming, Volume 5, Issue 1 (1973), 111-114.\n    .. [2] https://en.wikipedia.org/wiki/Eulerian_path\n\n    Examples\n    --------\n    To get an Eulerian circuit in an undirected graph::\n\n        >>> G = nx.complete_graph(3)\n        >>> list(nx.eulerian_circuit(G))\n        [(0, 2), (2, 1), (1, 0)]\n        >>> list(nx.eulerian_circuit(G, source=1))\n        [(1, 2), (2, 0), (0, 1)]\n\n    To get the sequence of vertices in an Eulerian circuit::\n\n        >>> [u for u, v in nx.eulerian_circuit(G)]\n        [0, 2, 1]\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef eulerian_path(G, source=None, keys=False):\n\"\"\"Return an iterator over the edges of an Eulerian path in `G`.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        The graph in which to look for an eulerian path.\n    source : node or None (default: None)\n        The node at which to start the search. None means search over all\n        starting nodes.\n    keys : Bool (default: False)\n        Indicates whether to yield edge 3-tuples (u, v, edge_key).\n        The default yields edge 2-tuples\n\n    Yields\n    ------\n    Edge tuples along the eulerian path.\n\n    Warning: If `source` provided is not the start node of an Euler path\n    will raise error even if an Euler Path exists.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef maximal_matching(G):\n\"\"\"Find a maximal matching in the graph.\n\n    A matching is a subset of edges in which no node occurs more than once.\n    A maximal matching cannot add more edges and still be a matching.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph\n\n    Returns\n    -------\n    matching : set\n        A maximal matching of the graph.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5)])\n    >>> sorted(nx.maximal_matching(G))\n    [(1, 2), (3, 5)]\n\n    Notes\n    -----\n    The algorithm greedily selects a maximal matching M of the graph G\n    (i.e. no superset of M exists). It runs in $O(|E|)$ time.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_matching(G, matching):\n\"\"\"Return True if ``matching`` is a valid matching of ``G``\n\n    A *matching* in a graph is a set of edges in which no two distinct\n    edges share a common endpoint. Each node is incident to at most one\n    edge in the matching. The edges are said to be independent.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    matching : dict or set\n        A dictionary or set representing a matching. If a dictionary, it\n        must have ``matching[u] == v`` and ``matching[v] == u`` for each\n        edge ``(u, v)`` in the matching. If a set, it must have elements\n        of the form ``(u, v)``, where ``(u, v)`` is an edge in the\n        matching.\n\n    Returns\n    -------\n    bool\n        Whether the given set or dictionary represents a valid matching\n        in the graph.\n\n    Raises\n    ------\n    NetworkXError\n        If the proposed matching has an edge to a node not in G.\n        Or if the matching is not a collection of 2-tuple edges.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5)])\n    >>> nx.is_maximal_matching(G, {1: 3, 2: 4})  # using dict to represent matching\n    True\n\n    >>> nx.is_matching(G, {(1, 3), (2, 4)})  # using set to represent matching\n    True\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_perfect_matching(G, matching):\n\"\"\"Return True if ``matching`` is a perfect matching for ``G``\n\n    A *perfect matching* in a graph is a matching in which exactly one edge\n    is incident upon each vertex.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    matching : dict or set\n        A dictionary or set representing a matching. If a dictionary, it\n        must have ``matching[u] == v`` and ``matching[v] == u`` for each\n        edge ``(u, v)`` in the matching. If a set, it must have elements\n        of the form ``(u, v)``, where ``(u, v)`` is an edge in the\n        matching.\n\n    Returns\n    -------\n    bool\n        Whether the given set or dictionary represents a valid perfect\n        matching in the graph.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5), (4, 6)])\n    >>> my_match = {1: 2, 3: 5, 4: 6}\n    >>> nx.is_perfect_matching(G, my_match)\n    True\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef max_weight_matching(G, maxcardinality=False, weight=\"weight\"):\n\"\"\"Compute a maximum-weighted matching of G.\n\n    A matching is a subset of edges in which no node occurs more than once.\n    The weight of a matching is the sum of the weights of its edges.\n    A maximal matching cannot add more edges and still be a matching.\n    The cardinality of a matching is the number of matched edges.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n      Undirected graph\n\n    maxcardinality: bool, optional (default=False)\n       If maxcardinality is True, compute the maximum-cardinality matching\n       with maximum weight among all maximum-cardinality matchings.\n\n    weight: string, optional (default='weight')\n       Edge data key corresponding to the edge weight.\n       If key not found, uses 1 as weight.\n\n\n    Returns\n    -------\n    matching : set\n        A maximal matching of the graph.\n\n     Examples\n    --------\n    >>> G = nx.Graph()\n    >>> edges = [(1, 2, 6), (1, 3, 2), (2, 3, 1), (2, 4, 7), (3, 5, 9), (4, 5, 3)]\n    >>> G.add_weighted_edges_from(edges)\n    >>> sorted(nx.max_weight_matching(G))\n    [(2, 4), (5, 3)]\n\n    Notes\n    -----\n    If G has edges with weight attributes the edge data are used as\n    weight values else the weights are assumed to be 1.\n\n    This function takes time O(number_of_nodes ** 3).\n\n    If all edge weights are integers, the algorithm uses only integer\n    computations.  If floating point weights are used, the algorithm\n    could return a slightly suboptimal matching due to numeric\n    precision errors.\n\n    This method is based on the \"blossom\" method for finding augmenting\n    paths and the \"primal-dual\" method for finding a matching of maximum\n    weight, both methods invented by Jack Edmonds [1]_.\n\n    Bipartite graphs can also be matched using the functions present in\n    :mod:`networkx.algorithms.bipartite.matching`.\n\n    References\n    ----------\n    .. [1] \"Efficient Algorithms for Finding Maximum Matching in Graphs\",\n       Zvi Galil, ACM Computing Surveys, 1986.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(edge_attrs={\"edge_attr\": None}, node_attrs=\"node_attr\")"}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef cycle_basis(G, root=None):\n\"\"\"Returns a list of cycles which form a basis for cycles of G.\n\n    A basis for cycles of a network is a minimal collection of\n    cycles such that any cycle in the network can be written\n    as a sum of cycles in the basis.  Here summation of cycles\n    is defined as \"exclusive or\" of the edges. Cycle bases are\n    useful, e.g. when deriving equations for electric circuits\n    using Kirchhoff's Laws.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n    root : node, optional\n       Specify starting node for basis.\n\n    Returns\n    -------\n    A list of cycle lists.  Each cycle list is a list of nodes\n    which forms a cycle (loop) in G.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> nx.add_cycle(G, [0, 1, 2, 3])\n    >>> nx.add_cycle(G, [0, 3, 4, 5])\n    >>> nx.cycle_basis(G, 0)\n    [[3, 4, 5, 0], [1, 2, 3, 0]]\n\n    Notes\n    -----\n    This is adapted from algorithm CACM 491 [1]_.\n\n    References\n    ----------\n    .. [1] Paton, K. An algorithm for finding a fundamental set of\n       cycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.\n\n    See Also\n    --------\n    simple_cycles\n    minimum_cycle_basis\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef chordless_cycles(G, length_bound=None):\n\"\"\"Find simple chordless cycles of a graph.\n\n    A `simple cycle` is a closed path where no node appears twice.  In a simple\n    cycle, a `chord` is an additional edge between two nodes in the cycle.  A\n    `chordless cycle` is a simple cycle without chords.  Said differently, a\n    chordless cycle is a cycle C in a graph G where the number of edges in the\n    induced graph G[C] is equal to the length of `C`.\n\n    Note that some care must be taken in the case that G is not a simple graph\n    nor a simple digraph.  Some authors limit the definition of chordless cycles\n    to have a prescribed minimum length; we do not.\n\n        1. We interpret self-loops to be chordless cycles, except in multigraphs\n           with multiple loops in parallel.  Likewise, in a chordless cycle of\n           length greater than 1, there can be no nodes with self-loops.\n\n        2. We interpret directed two-cycles to be chordless cycles, except in\n           multi-digraphs when any edge in a two-cycle has a parallel copy.\n\n        3. We interpret parallel pairs of undirected edges as two-cycles, except\n           when a third (or more) parallel edge exists between the two nodes.\n\n        4. Generalizing the above, edges with parallel clones may not occur in\n           chordless cycles.\n\n    In a directed graph, two chordless cycles are distinct if they are not\n    cyclic permutations of each other.  In an undirected graph, two chordless\n    cycles are distinct if they are not cyclic permutations of each other nor of\n    the other's reversal.\n\n    Optionally, the cycles are bounded in length.\n\n    We use an algorithm strongly inspired by that of Dias et al [1]_.  It has\n    been modified in the following ways:\n\n        1. Recursion is avoided, per Python's limitations\n\n        2. The labeling function is not necessary, because the starting paths\n            are chosen (and deleted from the host graph) to prevent multiple\n            occurrences of the same path\n\n        3. The search is optionally bounded at a specified length\n\n        4. Support for directed graphs is provided by extending cycles along\n            forward edges, and blocking nodes along forward and reverse edges\n\n        5. Support for multigraphs is provided by omitting digons from the set\n            of forward edges\n\n    Parameters\n    ----------\n    G : NetworkX DiGraph\n       A directed graph\n\n    length_bound : int or None, optional (default=None)\n       If length_bound is an int, generate all simple cycles of G with length at\n       most length_bound.  Otherwise, generate all simple cycles of G.\n\n    Yields\n    ------\n    list of nodes\n       Each cycle is represented by a list of nodes along the cycle.\n\n    Examples\n    --------\n    >>> sorted(list(nx.chordless_cycles(nx.complete_graph(4))))\n    [[1, 0, 2], [1, 0, 3], [2, 0, 3], [2, 1, 3]]\n\n    Notes\n    -----\n    When length_bound is None, and the graph is simple, the time complexity is\n    $O((n+e)(c+1))$ for $n$ nodes, $e$ edges and $c$ chordless cycles.\n\n    Raises\n    ------\n    ValueError\n        when length_bound < 0.\n\n    References\n    ----------\n    .. [1] Efficient enumeration of chordless cycles\n       E. Dias and D. Castonguay and H. Longo and W.A.R. Jradi\n       https://arxiv.org/abs/1309.1051\n\n    See Also\n    --------\n    simple_cycles\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(mutates_input=True)\ndef recursive_simple_cycles(G):\n\"\"\"Find simple cycles (elementary circuits) of a directed graph.\n\n    A `simple cycle`, or `elementary circuit`, is a closed path where\n    no node appears twice. Two elementary circuits are distinct if they\n    are not cyclic permutations of each other.\n\n    This version uses a recursive algorithm to build a list of cycles.\n    You should probably use the iterator version called simple_cycles().\n    Warning: This recursive version uses lots of RAM!\n    It appears in NetworkX for pedagogical value.\n\n    Parameters\n    ----------\n    G : NetworkX DiGraph\n       A directed graph\n\n    Returns\n    -------\n    A list of cycles, where each cycle is represented by a list of nodes\n    along the cycle.\n\n    Example:\n\n    >>> edges = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 0), (2, 1), (2, 2)]\n    >>> G = nx.DiGraph(edges)\n    >>> nx.recursive_simple_cycles(G)\n    [[0], [2], [0, 1, 2], [0, 2], [1, 2]]\n\n    Notes\n    -----\n    The implementation follows pp. 79-80 in [1]_.\n\n    The time complexity is $O((n+e)(c+1))$ for $n$ nodes, $e$ edges and $c$\n    elementary circuits.\n\n    References\n    ----------\n    .. [1] Finding all the elementary circuits of a directed graph.\n       D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.\n       https://doi.org/10.1137/0204007\n\n    See Also\n    --------\n    simple_cycles, cycle_basis\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef minimum_cycle_basis(G, weight=None):\n\"\"\"Returns a minimum weight cycle basis for G\n\n    Minimum weight means a cycle basis for which the total weight\n    (length for unweighted graphs) of all the cycles is minimum.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n    weight: string\n        name of the edge attribute to use for edge weights\n\n    Returns\n    -------\n    A list of cycle lists.  Each cycle list is a list of nodes\n    which forms a cycle (loop) in G. Note that the nodes are not\n    necessarily returned in a order by which they appear in the cycle\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> nx.add_cycle(G, [0, 1, 2, 3])\n    >>> nx.add_cycle(G, [0, 3, 4, 5])\n    >>> nx.minimum_cycle_basis(G)\n    [[5, 4, 3, 0], [3, 2, 1, 0]]\n\n    References:\n        [1] Kavitha, Telikepalli, et al. \"An O(m^2n) Algorithm for\n        Minimum Cycle Basis of Graphs.\"\n        http://link.springer.com/article/10.1007/s00453-007-9064-z\n        [2] de Pina, J. 1995. Applications of shortest path methods.\n        Ph.D. thesis, University of Amsterdam, Netherlands\n\n    See Also\n    --------\n    simple_cycles, cycle_basis\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef girth(G):\n\"\"\"Returns the girth of the graph.\n\n    The girth of a graph is the length of its shortest cycle, or infinity if\n    the graph is acyclic. The algorithm follows the description given on the\n    Wikipedia page [1]_, and runs in time O(mn) on a graph with m edges and n\n    nodes.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n\n    Returns\n    -------\n    int or math.inf\n\n    Examples\n    --------\n    All examples below (except P_5) can easily be checked using Wikipedia,\n    which has a page for each of these famous graphs.\n\n    >>> nx.girth(nx.chvatal_graph())\n    4\n    >>> nx.girth(nx.tutte_graph())\n    4\n    >>> nx.girth(nx.petersen_graph())\n    5\n    >>> nx.girth(nx.heawood_graph())\n    6\n    >>> nx.girth(nx.pappus_graph())\n    6\n    >>> nx.girth(nx.path_graph(5))\n    inf\n\n    References\n    ----------\n    .. [1] `Wikipedia: Girth <https://en.wikipedia.org/wiki/Girth_(graph_theory)>`_\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef voronoi_cells(G, center_nodes, weight=\"weight\"):\n\"\"\"Returns the Voronoi cells centered at `center_nodes` with respect\n    to the shortest-path distance metric.\n\n    If $C$ is a set of nodes in the graph and $c$ is an element of $C$,\n    the *Voronoi cell* centered at a node $c$ is the set of all nodes\n    $v$ that are closer to $c$ than to any other center node in $C$ with\n    respect to the shortest-path distance metric. [1]_\n\n    For directed graphs, this will compute the \"outward\" Voronoi cells,\n    as defined in [1]_, in which distance is measured from the center\n    nodes to the target node. For the \"inward\" Voronoi cells, use the\n    :meth:`DiGraph.reverse` method to reverse the orientation of the\n    edges before invoking this function on the directed graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    center_nodes : set\n        A nonempty set of nodes in the graph `G` that represent the\n        center of the Voronoi cells.\n\n    weight : string or function\n        The edge attribute (or an arbitrary function) representing the\n        weight of an edge. This keyword argument is as described in the\n        documentation for :func:`~networkx.multi_source_dijkstra_path`,\n        for example.\n\n    Returns\n    -------\n    dictionary\n        A mapping from center node to set of all nodes in the graph\n        closer to that center node than to any other center node. The\n        keys of the dictionary are the element of `center_nodes`, and\n        the values of the dictionary form a partition of the nodes of\n        `G`.\n\n    Examples\n    --------\n    To get only the partition of the graph induced by the Voronoi cells,\n    take the collection of all values in the returned dictionary::\n\n        >>> G = nx.path_graph(6)\n        >>> center_nodes = {0, 3}\n        >>> cells = nx.voronoi_cells(G, center_nodes)\n        >>> partition = set(map(frozenset, cells.values()))\n        >>> sorted(map(sorted, partition))\n        [[0, 1], [2, 3, 4, 5]]\n\n    Raises\n    ------\n    ValueError\n        If `center_nodes` is empty.\n\n    References\n    ----------\n    .. [1] Erwig, Martin. (2000),\"The graph Voronoi diagram with applications.\"\n        *Networks*, 36: 156--163.\n        https://doi.org/10.1002/1097-0037(200010)36:3<156::AID-NET2>3.0.CO;2-L\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef number_of_walks(G, walk_length):\n\"\"\"Returns the number of walks connecting each pair of nodes in `G`\n\n    A *walk* is a sequence of nodes in which each adjacent pair of nodes\n    in the sequence is adjacent in the graph. A walk can repeat the same\n    edge and go in the opposite direction just as people can walk on a\n    set of paths, but standing still is not counted as part of the walk.\n\n    This function only counts the walks with `walk_length` edges. Note that\n    the number of nodes in the walk sequence is one more than `walk_length`.\n    The number of walks can grow very quickly on a larger graph\n    and with a larger walk length.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    walk_length : int\n        A nonnegative integer representing the length of a walk.\n\n    Returns\n    -------\n    dict\n        A dictionary of dictionaries in which outer keys are source\n        nodes, inner keys are target nodes, and inner values are the\n        number of walks of length `walk_length` connecting those nodes.\n\n    Raises\n    ------\n    ValueError\n        If `walk_length` is negative\n\n    Examples\n    --------\n\n    >>> G = nx.Graph([(0, 1), (1, 2)])\n    >>> walks = nx.number_of_walks(G, 2)\n    >>> walks\n    {0: {0: 1, 1: 0, 2: 1}, 1: {0: 0, 1: 2, 2: 0}, 2: {0: 1, 1: 0, 2: 1}}\n    >>> total_walks = sum(sum(tgts.values()) for _, tgts in walks.items())\n\n    You can also get the number of walks from a specific source node using the\n    returned dictionary. For example, number of walks of length 1 from node 0\n    can be found as follows:\n\n    >>> walks = nx.number_of_walks(G, 1)\n    >>> walks[0]\n    {0: 0, 1: 1, 2: 0}\n    >>> sum(walks[0].values())  # walks from 0 of length 1\n    1\n\n    Similarly, a target node can also be specified:\n\n    >>> walks[0][1]\n    1\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef kl_connected_subgraph(G, k, l, low_memory=False, same_as_graph=False):\n\"\"\"Returns the maximum locally `(k, l)`-connected subgraph of `G`.\n\n    A graph is locally `(k, l)`-connected if for each edge `(u, v)` in the\n    graph there are at least `l` edge-disjoint paths of length at most `k`\n    joining `u` to `v`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        The graph in which to find a maximum locally `(k, l)`-connected\n        subgraph.\n\n    k : integer\n        The maximum length of paths to consider. A higher number means a looser\n        connectivity requirement.\n\n    l : integer\n        The number of edge-disjoint paths. A higher number means a stricter\n        connectivity requirement.\n\n    low_memory : bool\n        If this is True, this function uses an algorithm that uses slightly\n        more time but less memory.\n\n    same_as_graph : bool\n        If True then return a tuple of the form `(H, is_same)`,\n        where `H` is the maximum locally `(k, l)`-connected subgraph and\n        `is_same` is a Boolean representing whether `G` is locally `(k,\n        l)`-connected (and hence, whether `H` is simply a copy of the input\n        graph `G`).\n\n    Returns\n    -------\n    NetworkX graph or two-tuple\n        If `same_as_graph` is True, then this function returns a\n        two-tuple as described above. Otherwise, it returns only the maximum\n        locally `(k, l)`-connected subgraph.\n\n    See also\n    --------\n    is_kl_connected\n\n    References\n    ----------\n    .. [1] Chung, Fan and Linyuan Lu. \"The Small World Phenomenon in Hybrid\n           Power Law Graphs.\" *Complex Networks*. Springer Berlin Heidelberg,\n           2004. 89--104.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(node_attrs={\"time\": None, \"weight\": 1})\ndef cd_index(G, node, time_delta, *, time=\"time\", weight=None):\n\"\"\"Compute the CD index for `node` within the graph `G`.\n\n    Calculates the CD index for the given node of the graph,\n    considering only its predecessors who have the `time` attribute\n    smaller than or equal to the `time` attribute of the `node`\n    plus `time_delta`.\n\n    Parameters\n    ----------\n    G : graph\n       A directed networkx graph whose nodes have `time` attributes and optionally\n       `weight` attributes (if a weight is not given, it is considered 1).\n    node : node\n       The node for which the CD index is calculated.\n    time_delta : numeric or timedelta\n       Amount of time after the `time` attribute of the `node`. The value of\n       `time_delta` must support comparison with the `time` node attribute. For\n       example, if the `time` attribute of the nodes are `datetime.datetime`\n       objects, then `time_delta` should be a `datetime.timedelta` object.\n    time : string (Optional, default is \"time\")\n        The name of the node attribute that will be used for the calculations.\n    weight : string (Optional, default is None)\n        The name of the node attribute used as weight.\n\n    Returns\n    -------\n    float\n       The CD index calculated for the node `node` within the graph `G`.\n\n    Raises\n    ------\n    NetworkXError\n       If not all nodes have a `time` attribute or\n       `time_delta` and `time` attribute types are not compatible or\n       `n` equals 0.\n\n    NetworkXNotImplemented\n        If `G` is a non-directed graph or a multigraph.\n\n    Examples\n    --------\n    >>> from datetime import datetime, timedelta\n    >>> G = nx.DiGraph()\n    >>> nodes = {\n    ...     1: {\"time\": datetime(2015, 1, 1)},\n    ...     2: {\"time\": datetime(2012, 1, 1), \"weight\": 4},\n    ...     3: {\"time\": datetime(2010, 1, 1)},\n    ...     4: {\"time\": datetime(2008, 1, 1)},\n    ...     5: {\"time\": datetime(2014, 1, 1)},\n    ... }\n    >>> G.add_nodes_from([(n, nodes[n]) for n in nodes])\n    >>> edges = [(1, 3), (1, 4), (2, 3), (3, 4), (3, 5)]\n    >>> G.add_edges_from(edges)\n    >>> delta = timedelta(days=5 * 365)\n    >>> nx.cd_index(G, 3, time_delta=delta, time=\"time\")\n    0.5\n    >>> nx.cd_index(G, 3, time_delta=delta, time=\"time\", weight=\"weight\")\n    0.12\n\n    Integers can also be used for the time values:\n    >>> node_times = {1: 2015, 2: 2012, 3: 2010, 4: 2008, 5: 2014}\n    >>> nx.set_node_attributes(G, node_times, \"new_time\")\n    >>> nx.cd_index(G, 3, time_delta=4, time=\"new_time\")\n    0.5\n    >>> nx.cd_index(G, 3, time_delta=4, time=\"new_time\", weight=\"weight\")\n    0.12\n\n    Notes\n    -----\n    This method implements the algorithm for calculating the CD index,\n    as described in the paper by Funk and Owen-Smith [1]_. The CD index\n    is used in order to check how consolidating or destabilizing a patent\n    is, hence the nodes of the graph represent patents and the edges show\n    the citations between these patents. The mathematical model is given\n    below:\n\n    .. math::\n        CD_{t}=\\frac{1}{n_{t}}\\sum_{i=1}^{n}\\frac{-2f_{it}b_{it}+f_{it}}{w_{it}},\n\n    where `f_{it}` equals 1 if `i` cites the focal patent else 0, `b_{it}` equals\n    1 if `i` cites any of the focal patents successors else 0, `n_{t}` is the number\n    of forward citations in `i` and `w_{it}` is a matrix of weight for patent `i`\n    at time `t`.\n\n    The `datetime.timedelta` package can lead to off-by-one issues when converting\n    from years to days. In the example above `timedelta(days=5 * 365)` looks like\n    5 years, but it isn't because of leap year days. So it gives the same result\n    as `timedelta(days=4 * 365)`. But using `timedelta(days=5 * 365 + 1)` gives\n    a 5 year delta **for this choice of years** but may not if the 5 year gap has\n    more than 1 leap year. To avoid these issues, use integers to represent years,\n    or be very careful when you convert units of time.\n\n    References\n    ----------\n    .. [1] Funk, Russell J., and Jason Owen-Smith.\n           \"A dynamic network measure of technological change.\"\n           Management science 63, no. 3 (2017): 791-817.\n           http://russellfunk.org/cdindex/static/papers/funk_ms_2017.pdf\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef chain_decomposition(G, root=None):\n\"\"\"Returns the chain decomposition of a graph.\n\n    The *chain decomposition* of a graph with respect a depth-first\n    search tree is a set of cycles or paths derived from the set of\n    fundamental cycles of the tree in the following manner. Consider\n    each fundamental cycle with respect to the given tree, represented\n    as a list of edges beginning with the nontree edge oriented away\n    from the root of the tree. For each fundamental cycle, if it\n    overlaps with any previous fundamental cycle, just take the initial\n    non-overlapping segment, which is a path instead of a cycle. Each\n    cycle or path is called a *chain*. For more information, see [1]_.\n\n    Parameters\n    ----------\n    G : undirected graph\n\n    root : node (optional)\n       A node in the graph `G`. If specified, only the chain\n       decomposition for the connected component containing this node\n       will be returned. This node indicates the root of the depth-first\n       search tree.\n\n    Yields\n    ------\n    chain : list\n       A list of edges representing a chain. There is no guarantee on\n       the orientation of the edges in each chain (for example, if a\n       chain includes the edge joining nodes 1 and 2, the chain may\n       include either (1, 2) or (2, 1)).\n\n    Raises\n    ------\n    NodeNotFound\n       If `root` is not in the graph `G`.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (1, 4), (3, 4), (3, 5), (4, 5)])\n    >>> list(nx.chain_decomposition(G))\n    [[(4, 5), (5, 3), (3, 4)]]\n\n    Notes\n    -----\n    The worst-case running time of this implementation is linear in the\n    number of nodes and number of edges [1]_.\n\n    References\n    ----------\n    .. [1] Jens M. Schmidt (2013). \"A simple test on 2-vertex-\n       and 2-edge-connectivity.\" *Information Processing Letters*,\n       113, 241\u2013244. Elsevier. <https://doi.org/10.1016/j.ipl.2013.01.016>\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef efficiency(G, u, v):\n\"\"\"Returns the efficiency of a pair of nodes in a graph.\n\n    The *efficiency* of a pair of nodes is the multiplicative inverse of the\n    shortest path distance between the nodes [1]_. Returns 0 if no path\n    between nodes.\n\n    Parameters\n    ----------\n    G : :class:`networkx.Graph`\n        An undirected graph for which to compute the average local efficiency.\n    u, v : node\n        Nodes in the graph ``G``.\n\n    Returns\n    -------\n    float\n        Multiplicative inverse of the shortest path distance between the nodes.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> nx.efficiency(G, 2, 3)  # this gives efficiency for node 2 and 3\n    0.5\n\n    Notes\n    -----\n    Edge weights are ignored when computing the shortest path distances.\n\n    See also\n    --------\n    local_efficiency\n    global_efficiency\n\n    References\n    ----------\n    .. [1] Latora, Vito, and Massimo Marchiori.\n           \"Efficient behavior of small-world networks.\"\n           *Physical Review Letters* 87.19 (2001): 198701.\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef local_efficiency(G):\n\"\"\"Returns the average local efficiency of the graph.\n\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\n    inverse of the shortest path distance between the nodes. The *local\n    efficiency* of a node in the graph is the average global efficiency of the\n    subgraph induced by the neighbors of the node. The *average local\n    efficiency* is the average of the local efficiencies of each node [1]_.\n\n    Parameters\n    ----------\n    G : :class:`networkx.Graph`\n        An undirected graph for which to compute the average local efficiency.\n\n    Returns\n    -------\n    float\n        The average local efficiency of the graph.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> nx.local_efficiency(G)\n    0.9166666666666667\n\n    Notes\n    -----\n    Edge weights are ignored when computing the shortest path distances.\n\n    See also\n    --------\n    global_efficiency\n\n    References\n    ----------\n    .. [1] Latora, Vito, and Massimo Marchiori.\n           \"Efficient behavior of small-world networks.\"\n           *Physical Review Letters* 87.19 (2001): 198701.\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_distance_regular(G):\n\"\"\"Returns True if the graph is distance regular, False otherwise.\n\n    A connected graph G is distance-regular if for any nodes x,y\n    and any integers i,j=0,1,...,d (where d is the graph\n    diameter), the number of vertices at distance i from x and\n    distance j from y depends only on i,j and the graph distance\n    between x and y, independently of the choice of x and y.\n\n    Parameters\n    ----------\n    G: Networkx graph (undirected)\n\n    Returns\n    -------\n    bool\n      True if the graph is Distance Regular, False otherwise\n\n    Examples\n    --------\n    >>> G = nx.hypercube_graph(6)\n    >>> nx.is_distance_regular(G)\n    True\n\n    See Also\n    --------\n    intersection_array, global_parameters\n\n    Notes\n    -----\n    For undirected and simple graphs only\n\n    References\n    ----------\n    .. [1] Brouwer, A. E.; Cohen, A. M.; and Neumaier, A.\n        Distance-Regular Graphs. New York: Springer-Verlag, 1989.\n    .. [2] Weisstein, Eric W. \"Distance-Regular Graph.\"\n        http://mathworld.wolfram.com/Distance-RegularGraph.html\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef intersection_array(G):\n\"\"\"Returns the intersection array of a distance-regular graph.\n\n    Given a distance-regular graph G with integers b_i, c_i,i = 0,....,d\n    such that for any 2 vertices x,y in G at a distance i=d(x,y), there\n    are exactly c_i neighbors of y at a distance of i-1 from x and b_i\n    neighbors of y at a distance of i+1 from x.\n\n    A distance regular graph's intersection array is given by,\n    [b_0,b_1,.....b_{d-1};c_1,c_2,.....c_d]\n\n    Parameters\n    ----------\n    G: Networkx graph (undirected)\n\n    Returns\n    -------\n    b,c: tuple of lists\n\n    Examples\n    --------\n    >>> G = nx.icosahedral_graph()\n    >>> nx.intersection_array(G)\n    ([5, 2, 1], [1, 2, 5])\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Intersection Array.\"\n       From MathWorld--A Wolfram Web Resource.\n       http://mathworld.wolfram.com/IntersectionArray.html\n\n    See Also\n    --------\n    global_parameters\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef tree_broadcast_center(G):\n\"\"\"Return the Broadcast Center of the tree `G`.\n\n    The broadcast center of a graph G denotes the set of nodes having\n    minimum broadcast time [1]_. This is a linear algorithm for determining\n    the broadcast center of a tree with ``N`` nodes, as a by-product it also\n    determines the broadcast time from the broadcast center.\n\n    Parameters\n    ----------\n    G : undirected graph\n        The graph should be an undirected tree\n\n    Returns\n    -------\n    BC : (int, set) tuple\n        minimum broadcast number of the tree, set of broadcast centers\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the graph is directed or is a multigraph.\n\n    References\n    ----------\n    .. [1] Slater, P.J., Cockayne, E.J., Hedetniemi, S.T,\n       Information dissemination in trees. SIAM J.Comput. 10(4), 692\u2013701 (1981)\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef is_d_separator(G, x, y, z):\n\"\"\"Return whether node sets `x` and `y` are d-separated by `z`.\n\n    Parameters\n    ----------\n    G : nx.DiGraph\n        A NetworkX DAG.\n\n    x : node or set of nodes\n        First node or set of nodes in `G`.\n\n    y : node or set of nodes\n        Second node or set of nodes in `G`.\n\n    z : node or set of nodes\n        Potential separator (set of conditioning nodes in `G`). Can be empty set.\n\n    Returns\n    -------\n    b : bool\n        A boolean that is true if `x` is d-separated from `y` given `z` in `G`.\n\n    Raises\n    ------\n    NetworkXError\n        The *d-separation* test is commonly used on disjoint sets of\n        nodes in acyclic directed graphs.  Accordingly, the algorithm\n        raises a :exc:`NetworkXError` if the node sets are not\n        disjoint or if the input graph is not a DAG.\n\n    NodeNotFound\n        If any of the input nodes are not found in the graph,\n        a :exc:`NodeNotFound` exception is raised\n\n    Notes\n    -----\n    A d-separating set in a DAG is a set of nodes that\n    blocks all paths between the two sets. Nodes in `z`\n    block a path if they are part of the path and are not a collider,\n    or a descendant of a collider. Also colliders that are not in `z`\n    block a path. A collider structure along a path\n    is ``... -> c <- ...`` where ``c`` is the collider node.\n\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef is_minimal_d_separator(G, x, y, z, *, included=None, restricted=None):\n\"\"\"Determine if `z` is a minimal d-separator for `x` and `y`.\n\n    A d-separator, `z`, in a DAG is a set of nodes that blocks\n    all paths from nodes in set `x` to nodes in set `y`.\n    A minimal d-separator is a d-separator `z` such that removing\n    any subset of nodes makes it no longer a d-separator.\n\n    Note: This function checks whether `z` is a d-separator AND is\n    minimal. One can use the function `is_d_separator` to only check if\n    `z` is a d-separator. See examples below.\n\n    Parameters\n    ----------\n    G : nx.DiGraph\n        A NetworkX DAG.\n    x : node | set\n        A node or set of nodes in the graph.\n    y : node | set\n        A node or set of nodes in the graph.\n    z : node | set\n        The node or set of nodes to check if it is a minimal d-separating set.\n        The function :func:`is_d_separator` is called inside this function\n        to verify that `z` is in fact a d-separator.\n    included : set | node | None\n        A node or set of nodes which must be included in the found separating set,\n        default is ``None``, which means the empty set.\n    restricted : set | node | None\n        Restricted node or set of nodes to consider. Only these nodes can be in\n        the found separating set, default is ``None`` meaning all nodes in ``G``.\n\n    Returns\n    -------\n    bool\n        Whether or not the set `z` is a minimal d-separator subject to\n        `restricted` nodes and `included` node constraints.\n\n    Examples\n    --------\n    >>> G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)\n    >>> G.add_node(4)\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1})\n    True\n    >>> # since {1} is the minimal d-separator, {1, 3, 4} is not minimal\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})\n    False\n    >>> # alternatively, if we only want to check that {1, 3, 4} is a d-separator\n    >>> nx.is_d_separator(G, 0, 2, {1, 3, 4})\n    True\n\n    Raises\n    ------\n    NetworkXError\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\n\n    NodeNotFound\n        If any of the input nodes are not found in the graph,\n        a :exc:`NodeNotFound` exception is raised.\n\n    References\n    ----------\n    .. [1] van der Zander, Benito, and Maciej Li\u015bkiewicz. \"Finding\n        minimal d-separators in linear time and applications.\" In\n        Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.\n\n    Notes\n    -----\n    This function works on verifying that a set is minimal and\n    d-separating between two nodes. Uses criterion (a), (b), (c) on\n    page 4 of [1]_. a) closure(`x`) and `y` are disjoint. b) `z` contains\n    all nodes from `included` and is contained in the `restricted`\n    nodes and in the union of ancestors of `x`, `y`, and `included`.\n    c) the nodes in `z` not in `included` are contained in both\n    closure(x) and closure(y). The closure of a set is the set of nodes\n    connected to the set by a directed path in G.\n\n    The complexity is :math:`O(m)`, where :math:`m` stands for the\n    number of edges in the subgraph of G consisting of only the\n    ancestors of `x` and `y`.\n\n    For full details, see [1]_.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef triangles(G, nodes=None):\n\"\"\"Compute the number of triangles.\n\n    Finds the number of triangles that include a node as one vertex.\n\n    Parameters\n    ----------\n    G : graph\n       A networkx graph\n\n    nodes : node, iterable of nodes, or None (default=None)\n        If a singleton node, return the number of triangles for that node.\n        If an iterable, compute the number of triangles for each of those nodes.\n        If `None` (the default) compute the number of triangles for all nodes in `G`.\n\n    Returns\n    -------\n    out : dict or int\n       If `nodes` is a container of nodes, returns number of triangles keyed by node (dict).\n       If `nodes` is a specific node, returns number of triangles for the node (int).\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> print(nx.triangles(G, 0))\n    6\n    >>> print(nx.triangles(G))\n    {0: 6, 1: 6, 2: 6, 3: 6, 4: 6}\n    >>> print(list(nx.triangles(G, [0, 1]).values()))\n    [6, 6]\n\n    Notes\n    -----\n    Self loops are ignored.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef average_clustering(G, nodes=None, weight=None, count_zeros=True):\n\"\"\"Compute the average clustering coefficient for the graph G.\n\n    The clustering coefficient for the graph is the average,\n\n    .. math::\n\n       C = \\frac{1}{n}\\sum_{v \\in G} c_v,\n\n    where :math:`n` is the number of nodes in `G`.\n\n    Parameters\n    ----------\n    G : graph\n\n    nodes : container of nodes, optional (default=all nodes in G)\n       Compute average clustering for nodes in this container.\n\n    weight : string or None, optional (default=None)\n       The edge attribute that holds the numerical value used as a weight.\n       If None, then each edge has weight 1.\n\n    count_zeros : bool\n       If False include only the nodes with nonzero clustering in the average.\n\n    Returns\n    -------\n    avg : float\n       Average clustering\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> print(nx.average_clustering(G))\n    1.0\n\n    Notes\n    -----\n    This is a space saving routine; it might be faster\n    to use the clustering function to get a list and then take the average.\n\n    Self loops are ignored.\n\n    References\n    ----------\n    .. [1] Generalizations of the clustering coefficient to weighted\n       complex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\n       K. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).\n       http://jponnela.com/web_documents/a9.pdf\n    .. [2] Marcus Kaiser,  Mean clustering coefficients: the role of isolated\n       nodes and leafs on clustering measures for small-world networks.\n       https://arxiv.org/abs/0802.2512\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef transitivity(G):\n\"\"\"Compute graph transitivity, the fraction of all possible triangles\n    present in G.\n\n    Possible triangles are identified by the number of \"triads\"\n    (two edges with a shared vertex).\n\n    The transitivity is\n\n    .. math::\n\n        T = 3\\frac{\\#triangles}{\\#triads}.\n\n    Parameters\n    ----------\n    G : graph\n\n    Returns\n    -------\n    out : float\n       Transitivity\n\n    Notes\n    -----\n    Self loops are ignored.\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> print(nx.transitivity(G))\n    1.0\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef generalized_degree(G, nodes=None):\n\"\"\"Compute the generalized degree for nodes.\n\n    For each node, the generalized degree shows how many edges of given\n    triangle multiplicity the node is connected to. The triangle multiplicity\n    of an edge is the number of triangles an edge participates in. The\n    generalized degree of node :math:`i` can be written as a vector\n    :math:`\\mathbf{k}_i=(k_i^{(0)}, \\dotsc, k_i^{(N-2)})` where\n    :math:`k_i^{(j)}` is the number of edges attached to node :math:`i` that\n    participate in :math:`j` triangles.\n\n    Parameters\n    ----------\n    G : graph\n\n    nodes : container of nodes, optional (default=all nodes in G)\n       Compute the generalized degree for nodes in this container.\n\n    Returns\n    -------\n    out : Counter, or dictionary of Counters\n       Generalized degree of specified nodes. The Counter is keyed by edge\n       triangle multiplicity.\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> print(nx.generalized_degree(G, 0))\n    Counter({3: 4})\n    >>> print(nx.generalized_degree(G))\n    {0: Counter({3: 4}), 1: Counter({3: 4}), 2: Counter({3: 4}), 3: Counter({3: 4}), 4: Counter({3: 4})}\n\n    To recover the number of triangles attached to a node:\n\n    >>> k1 = nx.generalized_degree(G, 0)\n    >>> sum([k * v for k, v in k1.items()]) / 2 == nx.triangles(G, 0)\n    True\n\n    Notes\n    -----\n    Self loops are ignored.\n\n    In a network of N nodes, the highest triangle multiplicity an edge can have\n    is N-2.\n\n    The return value does not include a `zero` entry if no edges of a\n    particular triangle multiplicity are present.\n\n    The number of triangles node :math:`i` is attached to can be recovered from\n    the generalized degree :math:`\\mathbf{k}_i=(k_i^{(0)}, \\dotsc,\n    k_i^{(N-2)})` by :math:`(k_i^{(1)}+2k_i^{(2)}+\\dotsc +(N-2)k_i^{(N-2)})/2`.\n\n    References\n    ----------\n    .. [1] Networks with arbitrary edge multiplicities by V. Zlati\u0107,\n        D. Garlaschelli and G. Caldarelli, EPL (Europhysics Letters),\n        Volume 97, Number 2 (2012).\n        https://iopscience.iop.org/article/10.1209/0295-5075/97/28005\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_simple_path(G, nodes):\n\"\"\"Returns True if and only if `nodes` form a simple path in `G`.\n\n    A *simple path* in a graph is a nonempty sequence of nodes in which\n    no node appears more than once in the sequence, and each adjacent\n    pair of nodes in the sequence is adjacent in the graph.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX graph.\n    nodes : list\n        A list of one or more nodes in the graph `G`.\n\n    Returns\n    -------\n    bool\n        Whether the given list of nodes represents a simple path in `G`.\n\n    Notes\n    -----\n    An empty list of nodes is not a path but a list of one node is a\n    path. Here's an explanation why.\n\n    This function operates on *node paths*. One could also consider\n    *edge paths*. There is a bijection between node paths and edge\n    paths.\n\n    The *length of a path* is the number of edges in the path, so a list\n    of nodes of length *n* corresponds to a path of length *n* - 1.\n    Thus the smallest edge path would be a list of zero edges, the empty\n    path. This corresponds to a list of one node.\n\n    To convert between a node path and an edge path, you can use code\n    like the following::\n\n        >>> from networkx.utils import pairwise\n        >>> nodes = [0, 1, 2, 3]\n        >>> edges = list(pairwise(nodes))\n        >>> edges\n        [(0, 1), (1, 2), (2, 3)]\n        >>> nodes = [edges[0][0]] + [v for u, v in edges]\n        >>> nodes\n        [0, 1, 2, 3]\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(4)\n    >>> nx.is_simple_path(G, [2, 3, 0])\n    True\n    >>> nx.is_simple_path(G, [0, 2])\n    False\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef all_simple_edge_paths(G, source, target, cutoff=None):\n\"\"\"Generate lists of edges for all simple paths in G from source to target.\n\n    A simple path is a path with no repeated nodes.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n       Starting node for path\n\n    target : nodes\n       Single node or iterable of nodes at which to end path\n\n    cutoff : integer, optional\n        Depth to stop the search. Only paths of length <= cutoff are returned.\n\n    Returns\n    -------\n    path_generator: generator\n       A generator that produces lists of simple paths.  If there are no paths\n       between the source and target within the given cutoff the generator\n       produces no output.\n       For multigraphs, the list of edges have elements of the form `(u,v,k)`.\n       Where `k` corresponds to the edge key.\n\n    Examples\n    --------\n\n    Print the simple path edges of a Graph::\n\n        >>> g = nx.Graph([(1, 2), (2, 4), (1, 3), (3, 4)])\n        >>> for path in sorted(nx.all_simple_edge_paths(g, 1, 4)):\n        ...     print(path)\n        [(1, 2), (2, 4)]\n        [(1, 3), (3, 4)]\n\n    Print the simple path edges of a MultiGraph. Returned edges come with\n    their associated keys::\n\n        >>> mg = nx.MultiGraph()\n        >>> mg.add_edge(1, 2, key=\"k0\")\n        'k0'\n        >>> mg.add_edge(1, 2, key=\"k1\")\n        'k1'\n        >>> mg.add_edge(2, 3, key=\"k0\")\n        'k0'\n        >>> for path in sorted(nx.all_simple_edge_paths(mg, 1, 3)):\n        ...     print(path)\n        [(1, 2, 'k0'), (2, 3, 'k0')]\n        [(1, 2, 'k1'), (2, 3, 'k0')]\n\n    When ``source`` is one of the targets, the empty path starting and ending at\n    ``source`` without traversing any edge is considered a valid simple edge path\n    and is included in the results:\n\n        >>> G = nx.Graph()\n        >>> G.add_node(0)\n        >>> paths = list(nx.all_simple_edge_paths(G, 0, 0))\n        >>> for path in paths:\n        ...     print(path)\n        []\n        >>> len(paths)\n        1\n\n\n    Notes\n    -----\n    This algorithm uses a modified depth-first search to generate the\n    paths [1]_.  A single path can be found in $O(V+E)$ time but the\n    number of simple paths in a graph can be very large, e.g. $O(n!)$ in\n    the complete graph of order $n$.\n\n    References\n    ----------\n    .. [1] R. Sedgewick, \"Algorithms in C, Part 5: Graph Algorithms\",\n       Addison Wesley Professional, 3rd ed., 2001.\n\n    See Also\n    --------\n    all_shortest_paths, shortest_path, all_simple_paths\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef shortest_simple_paths(G, source, target, weight=None):\n\"\"\"Generate all simple paths in the graph G from source to target,\n       starting from shortest ones.\n\n    A simple path is a path with no repeated nodes.\n\n    If a weighted shortest path search is to be used, no negative weights\n    are allowed.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n       Starting node for path\n\n    target : node\n       Ending node for path\n\n    weight : string or function\n        If it is a string, it is the name of the edge attribute to be\n        used as a weight.\n\n        If it is a function, the weight of an edge is the value returned\n        by the function. The function must accept exactly three positional\n        arguments: the two endpoints of an edge and the dictionary of edge\n        attributes for that edge. The function must return a number or None.\n        The weight function can be used to hide edges by returning None.\n        So ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\n        will find the shortest red path.\n\n        If None all edges are considered to have unit weight. Default\n        value None.\n\n    Returns\n    -------\n    path_generator: generator\n       A generator that produces lists of simple paths, in order from\n       shortest to longest.\n\n    Raises\n    ------\n    NetworkXNoPath\n       If no path exists between source and target.\n\n    NetworkXError\n       If source or target nodes are not in the input graph.\n\n    NetworkXNotImplemented\n       If the input graph is a Multi[Di]Graph.\n\n    Examples\n    --------\n\n    >>> G = nx.cycle_graph(7)\n    >>> paths = list(nx.shortest_simple_paths(G, 0, 3))\n    >>> print(paths)\n    [[0, 1, 2, 3], [0, 6, 5, 4, 3]]\n\n    You can use this function to efficiently compute the k shortest/best\n    paths between two nodes.\n\n    >>> from itertools import islice\n    >>> def k_shortest_paths(G, source, target, k, weight=None):\n    ...     return list(\n    ...         islice(nx.shortest_simple_paths(G, source, target, weight=weight), k)\n    ...     )\n    >>> for path in k_shortest_paths(G, 0, 3, 2):\n    ...     print(path)\n    [0, 1, 2, 3]\n    [0, 6, 5, 4, 3]\n\n    Notes\n    -----\n    This procedure is based on algorithm by Jin Y. Yen [1]_.  Finding\n    the first $K$ paths requires $O(KN^3)$ operations.\n\n    See Also\n    --------\n    all_shortest_paths\n    shortest_path\n    all_simple_paths\n\n    References\n    ----------\n    .. [1] Jin Y. Yen, \"Finding the K Shortest Loopless Paths in a\n       Network\", Management Science, Vol. 17, No. 11, Theory Series\n       (Jul., 1971), pp. 712-716.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(edge_attrs={\"data\": \"default\"}, preserve_edge_attrs=\"data\")\ndef edge_boundary(G, nbunch1, nbunch2=None, data=False, keys=False, default=None):\n\"\"\"Returns the edge boundary of `nbunch1`.\n\n    The *edge boundary* of a set *S* with respect to a set *T* is the\n    set of edges (*u*, *v*) such that *u* is in *S* and *v* is in *T*.\n    If *T* is not specified, it is assumed to be the set of all nodes\n    not in *S*.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nbunch1 : iterable\n        Iterable of nodes in the graph representing the set of nodes\n        whose edge boundary will be returned. (This is the set *S* from\n        the definition above.)\n\n    nbunch2 : iterable\n        Iterable of nodes representing the target (or \"exterior\") set of\n        nodes. (This is the set *T* from the definition above.) If not\n        specified, this is assumed to be the set of all nodes in `G`\n        not in `nbunch1`.\n\n    keys : bool\n        This parameter has the same meaning as in\n        :meth:`MultiGraph.edges`.\n\n    data : bool or object\n        This parameter has the same meaning as in\n        :meth:`MultiGraph.edges`.\n\n    default : object\n        This parameter has the same meaning as in\n        :meth:`MultiGraph.edges`.\n\n    Returns\n    -------\n    iterator\n        An iterator over the edges in the boundary of `nbunch1` with\n        respect to `nbunch2`. If `keys`, `data`, or `default`\n        are specified and `G` is a multigraph, then edges are returned\n        with keys and/or data, as in :meth:`MultiGraph.edges`.\n\n    Examples\n    --------\n    >>> G = nx.wheel_graph(6)\n\n    When nbunch2=None:\n\n    >>> list(nx.edge_boundary(G, (1, 3)))\n    [(1, 0), (1, 2), (1, 5), (3, 0), (3, 2), (3, 4)]\n\n    When nbunch2 is given:\n\n    >>> list(nx.edge_boundary(G, (1, 3), (2, 0)))\n    [(1, 0), (1, 2), (3, 0), (3, 2)]\n\n    Notes\n    -----\n    Any element of `nbunch` that is not in the graph `G` will be\n    ignored.\n\n    `nbunch1` and `nbunch2` are usually meant to be disjoint, but in\n    the interest of speed and generality, that is not required here.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef mutual_weight(G, u, v, weight=None):\n\"\"\"Returns the sum of the weights of the edge from `u` to `v` and\n    the edge from `v` to `u` in `G`.\n\n    `weight` is the edge data key that represents the edge weight. If\n    the specified key is `None` or is not in the edge data for an edge,\n    that edge is assumed to have weight 1.\n\n    Pre-conditions: `u` and `v` must both be in `G`.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef effective_size(G, nodes=None, weight=None):\n\"\"\"Returns the effective size of all nodes in the graph ``G``.\n\n    The *effective size* of a node's ego network is based on the concept\n    of redundancy. A person's ego network has redundancy to the extent\n    that her contacts are connected to each other as well. The\n    nonredundant part of a person's relationships is the effective\n    size of her ego network [1]_.  Formally, the effective size of a\n    node $u$, denoted $e(u)$, is defined by\n\n    .. math::\n\n       e(u) = \\sum_{v \\in N(u) \\setminus \\{u\\}}\n       \\left(1 - \\sum_{w \\in N(v)} p_{uw} m_{vw}\\right)\n\n    where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the\n    normalized mutual weight of the (directed or undirected) edges\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$\n    is the mutual weight of $v$ and $w$ divided by $v$ highest mutual\n    weight with any of its neighbors. The *mutual weight* of $u$ and $v$\n    is the sum of the weights of edges joining them (edge weights are\n    assumed to be one if the graph is unweighted).\n\n    For the case of unweighted and undirected graphs, Borgatti proposed\n    a simplified formula to compute effective size [2]_\n\n    .. math::\n\n       e(u) = n - \\frac{2t}{n}\n\n    where `t` is the number of ties in the ego network (not including\n    ties to ego) and `n` is the number of nodes (excluding ego).\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        The graph containing ``v``. Directed graphs are treated like\n        undirected graphs when computing neighbors of ``v``.\n\n    nodes : container, optional\n        Container of nodes in the graph ``G`` to compute the effective size.\n        If None, the effective size of every node is computed.\n\n    weight : None or string, optional\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n\n    Returns\n    -------\n    dict\n        Dictionary with nodes as keys and the effective size of the node as values.\n\n    Notes\n    -----\n    Burt also defined the related concept of *efficiency* of a node's ego\n    network, which is its effective size divided by the degree of that\n    node [1]_. So you can easily compute efficiency:\n\n    >>> G = nx.DiGraph()\n    >>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])\n    >>> esize = nx.effective_size(G)\n    >>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}\n\n    See also\n    --------\n    constraint\n\n    References\n    ----------\n    .. [1] Burt, Ronald S.\n           *Structural Holes: The Social Structure of Competition.*\n           Cambridge: Harvard University Press, 1995.\n\n    .. [2] Borgatti, S.\n           \"Structural Holes: Unpacking Burt's Redundancy Measures\"\n           CONNECTIONS 20(1):35-38.\n           http://www.analytictech.com/connections/v20(1)/holes.htm\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef local_constraint(G, u, v, weight=None):\n\"\"\"Returns the local constraint on the node ``u`` with respect to\n    the node ``v`` in the graph ``G``.\n\n    Formally, the *local constraint on u with respect to v*, denoted\n    $\\ell(u, v)$, is defined by\n\n    .. math::\n\n       \\ell(u, v) = \\left(p_{uv} + \\sum_{w \\in N(v)} p_{uw} p_{wv}\\right)^2,\n\n    where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the\n    normalized mutual weight of the (directed or undirected) edges\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual\n    weight* of $u$ and $v$ is the sum of the weights of edges joining\n    them (edge weights are assumed to be one if the graph is\n    unweighted).\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        The graph containing ``u`` and ``v``. This can be either\n        directed or undirected.\n\n    u : node\n        A node in the graph ``G``.\n\n    v : node\n        A node in the graph ``G``.\n\n    weight : None or string, optional\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n\n    Returns\n    -------\n    float\n        The constraint of the node ``v`` in the graph ``G``.\n\n    See also\n    --------\n    constraint\n\n    References\n    ----------\n    .. [1] Burt, Ronald S.\n           \"Structural holes and good ideas\".\n           American Journal of Sociology (110): 349\u2013399.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable("}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef wiener_index(G, weight=None):\n\"\"\"Returns the Wiener index of the given graph.\n\n    The *Wiener index* of a graph is the sum of the shortest-path\n    (weighted) distances between each pair of reachable nodes.\n    For pairs of nodes in undirected graphs, only one orientation\n    of the pair is counted.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : string or None, optional (default: None)\n        If None, every edge has weight 1.\n        If a string, use this edge attribute as the edge weight.\n        Any edge attribute not present defaults to 1.\n        The edge weights are used to computing shortest-path distances.\n\n    Returns\n    -------\n    number\n        The Wiener index of the graph `G`.\n\n    Raises\n    ------\n    NetworkXError\n        If the graph `G` is not connected.\n\n    Notes\n    -----\n    If a pair of nodes is not reachable, the distance is assumed to be\n    infinity. This means that for graphs that are not\n    strongly-connected, this function returns ``inf``.\n\n    The Wiener index is not usually defined for directed graphs, however\n    this function uses the natural generalization of the Wiener index to\n    directed graphs.\n\n    Examples\n    --------\n    The Wiener index of the (unweighted) complete graph on *n* nodes\n    equals the number of pairs of the *n* nodes, since each pair of\n    nodes is at distance one::\n\n        >>> n = 10\n        >>> G = nx.complete_graph(n)\n        >>> nx.wiener_index(G) == n * (n - 1) / 2\n        True\n\n    Graphs that are not strongly-connected have infinite Wiener index::\n\n        >>> G = nx.empty_graph(2)\n        >>> nx.wiener_index(G)\n        inf\n\n    References\n    ----------\n    .. [1] `Wikipedia: Wiener Index <https://en.wikipedia.org/wiki/Wiener_index>`_\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef gutman_index(G, weight=None):\n\"\"\"Returns the Gutman Index for the graph `G`.\n\n    The *Gutman Index* measures the topology of networks, especially for molecule\n    networks of atoms connected by bonds [1]_. It is also called the Schultz Index\n    of the second kind [2]_.\n\n    Consider an undirected graph `G` with node set ``V``.\n    The Gutman Index of a graph is the sum over all (unordered) pairs of nodes\n    of nodes ``(u, v)``, with distance ``dist(u, v)`` and degrees ``deg(u)``\n    and ``deg(v)``, of ``dist(u, v) * deg(u) * deg(v)``\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : string or None, optional (default: None)\n        If None, every edge has weight 1.\n        If a string, use this edge attribute as the edge weight.\n        Any edge attribute not present defaults to 1.\n        The edge weights are used to computing shortest-path distances.\n\n    Returns\n    -------\n    number\n        The Gutman Index of the graph `G`.\n\n    Examples\n    --------\n    The Gutman Index of the (unweighted) complete graph on *n* nodes\n    equals the number of pairs of the *n* nodes times ``(n - 1) * (n - 1)``,\n    since each pair of nodes is at distance one and the product of degree of two\n    vertices is ``(n - 1) * (n - 1)``.\n\n    >>> n = 10\n    >>> G = nx.complete_graph(n)\n    >>> nx.gutman_index(G) == (n * (n - 1) / 2) * ((n - 1) * (n - 1))\n    True\n\n    Graphs that are disconnected\n\n    >>> G = nx.empty_graph(2)\n    >>> nx.gutman_index(G)\n    inf\n\n    References\n    ----------\n    .. [1] M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\n           Croatica Chemica Acta, 71 (1998), 21-51.\n           https://hrcak.srce.hr/132323\n    .. [2] I. Gutman, Selected properties of the Schultz molecular topological index,\n           J. Chem. Inf. Comput. Sci. 34 (1994), 1087\u20131089.\n           https://doi.org/10.1021/ci00021a009\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef maximal_independent_set(G, nodes=None, seed=None):\n\"\"\"Returns a random maximal independent set guaranteed to contain\n    a given set of nodes.\n\n    An independent set is a set of nodes such that the subgraph\n    of G induced by these nodes contains no edges. A maximal\n    independent set is an independent set such that it is not possible\n    to add a new node and still get an independent set.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nodes : list or iterable\n       Nodes that must be part of the independent set. This set of nodes\n       must be independent.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    indep_nodes : list\n       List of nodes that are part of a maximal independent set.\n\n    Raises\n    ------\n    NetworkXUnfeasible\n       If the nodes in the provided list are not part of the graph or\n       do not form an independent set, an exception is raised.\n\n    NetworkXNotImplemented\n        If `G` is directed.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> nx.maximal_independent_set(G)  # doctest: +SKIP\n    [4, 0, 2]\n    >>> nx.maximal_independent_set(G, [1])  # doctest: +SKIP\n    [1, 3]\n\n    Notes\n    -----\n    This algorithm does not solve the maximum independent set problem.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef immediate_dominators(G, start):\n\"\"\"Returns the immediate dominators of all nodes of a directed graph.\n\n    Parameters\n    ----------\n    G : a DiGraph or MultiDiGraph\n        The graph where dominance is to be computed.\n\n    start : node\n        The start node of dominance computation.\n\n    Returns\n    -------\n    idom : dict keyed by nodes\n        A dict containing the immediate dominators of each node reachable from\n        `start`.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is undirected.\n\n    NetworkXError\n        If `start` is not in `G`.\n\n    Notes\n    -----\n    Except for `start`, the immediate dominators are the parents of their\n    corresponding nodes in the dominator tree.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 5), (3, 4), (4, 5)])\n    >>> sorted(nx.immediate_dominators(G, 1).items())\n    [(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]\n\n    References\n    ----------\n    .. [1] Cooper, Keith D., Harvey, Timothy J. and Kennedy, Ken.\n           \"A simple, fast dominance algorithm.\" (2006).\n           https://hdl.handle.net/1911/96345\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=_G_H, preserve_all_attrs=True, returns_graph=True)\ndef union(G, H, rename=()):\n\"\"\"Combine graphs G and H. The names of nodes must be unique.\n\n    A name collision between the graphs will raise an exception.\n\n    A renaming facility is provided to avoid name collisions.\n\n\n    Parameters\n    ----------\n    G, H : graph\n       A NetworkX graph\n\n    rename : iterable , optional\n       Node names of G and H can be changed by specifying the tuple\n       rename=('G-','H-') (for example).  Node \"u\" in G is then renamed\n       \"G-u\" and \"v\" in H is renamed \"H-v\".\n\n    Returns\n    -------\n    U : A union graph with the same type as G.\n\n    See Also\n    --------\n    compose\n    :func:`~networkx.Graph.update`\n    disjoint_union\n\n    Notes\n    -----\n    To combine graphs that have common nodes, consider compose(G, H)\n    or the method, Graph.update().\n\n    disjoint_union() is similar to union() except that it avoids name clashes\n    by relabeling the nodes with sequential integers.\n\n    Edge and node attributes are propagated from G and H to the union graph.\n    Graph attributes are also propagated, but if they are present in both G and H,\n    then the value from H is used.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2)])\n    >>> H = nx.Graph([(0, 1), (0, 3), (1, 3), (1, 2)])\n    >>> U = nx.union(G, H, rename=(\"G\", \"H\"))\n    >>> U.nodes\n    NodeView(('G0', 'G1', 'G2', 'H0', 'H1', 'H3', 'H2'))\n    >>> U.edges\n    EdgeView([('G0', 'G1'), ('G0', 'G2'), ('G1', 'G2'), ('H0', 'H1'), ('H0', 'H3'), ('H1', 'H3'), ('H1', 'H2')])\n\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=_G_H, returns_graph=True)\ndef intersection(G, H):\n\"\"\"Returns a new graph that contains only the nodes and the edges that exist in\n    both G and H.\n\n    Parameters\n    ----------\n    G,H : graph\n       A NetworkX graph. G and H can have different node sets but must be both graphs or both multigraphs.\n\n    Raises\n    ------\n    NetworkXError\n        If one is a MultiGraph and the other one is a graph.\n\n    Returns\n    -------\n    GH : A new graph with the same type as G.\n\n    Notes\n    -----\n    Attributes from the graph, nodes, and edges are not copied to the new\n    graph.  If you want a new graph of the intersection of G and H\n    with the attributes (including edge data) from G use remove_nodes_from()\n    as follows\n\n    >>> G = nx.path_graph(3)\n    >>> H = nx.path_graph(5)\n    >>> R = G.copy()\n    >>> R.remove_nodes_from(n for n in G if n not in H)\n    >>> R.remove_edges_from(e for e in G.edges if e not in H.edges)\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2)])\n    >>> H = nx.Graph([(0, 3), (1, 2), (2, 3)])\n    >>> R = nx.intersection(G, H)\n    >>> R.nodes\n    NodeView((0, 1, 2))\n    >>> R.edges\n    EdgeView([(1, 2)])\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=_G_H, returns_graph=True)\ndef symmetric_difference(G, H):\n\"\"\"Returns new graph with edges that exist in either G or H but not both.\n\n    The node sets of H and G must be the same.\n\n    Parameters\n    ----------\n    G,H : graph\n       A NetworkX graph.  G and H must have the same node sets.\n\n    Returns\n    -------\n    D : A new graph with the same type as G.\n\n    Notes\n    -----\n    Attributes from the graph, nodes, and edges are not copied to the new\n    graph.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3)])\n    >>> H = nx.Graph([(0, 1), (1, 2), (0, 3)])\n    >>> R = nx.symmetric_difference(G, H)\n    >>> R.nodes\n    NodeView((0, 1, 2, 3))\n    >>> R.edges\n    EdgeView([(0, 2), (0, 3), (1, 3)])\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=_G_H, preserve_all_attrs=True, returns_graph=True)\ndef full_join(G, H, rename=(None, None)):\n\"\"\"Returns the full join of graphs G and H.\n\n    Full join is the union of G and H in which all edges between\n    G and H are added.\n    The node sets of G and H must be disjoint,\n    otherwise an exception is raised.\n\n    Parameters\n    ----------\n    G, H : graph\n       A NetworkX graph\n\n    rename : tuple , default=(None, None)\n       Node names of G and H can be changed by specifying the tuple\n       rename=('G-','H-') (for example).  Node \"u\" in G is then renamed\n       \"G-u\" and \"v\" in H is renamed \"H-v\".\n\n    Returns\n    -------\n    U : The full join graph with the same type as G.\n\n    Notes\n    -----\n    It is recommended that G and H be either both directed or both undirected.\n\n    If G is directed, then edges from G to H are added as well as from H to G.\n\n    Note that full_join() does not produce parallel edges for MultiGraphs.\n\n    The full join operation of graphs G and H is the same as getting\n    their complement, performing a disjoint union, and finally getting\n    the complement of the resulting graph.\n\n    Graph, edge, and node attributes are propagated from G and H\n    to the union graph.  If a graph attribute is present in both\n    G and H the value from H is used.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2)])\n    >>> H = nx.Graph([(3, 4)])\n    >>> R = nx.full_join(G, H, rename=(\"G\", \"H\"))\n    >>> R.nodes\n    NodeView(('G0', 'G1', 'G2', 'H3', 'H4'))\n    >>> R.edges\n    EdgeView([('G0', 'G1'), ('G0', 'G2'), ('G0', 'H3'), ('G0', 'H4'), ('G1', 'H3'), ('G1', 'H4'), ('G2', 'H3'), ('G2', 'H4'), ('H3', 'H4')])\n\n    See Also\n    --------\n    union\n    disjoint_union\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=\"[graphs]\", preserve_all_attrs=True, returns_graph=True)\ndef union_all(graphs, rename=()):\n\"\"\"Returns the union of all graphs.\n\n    The graphs must be disjoint, otherwise an exception is raised.\n\n    Parameters\n    ----------\n    graphs : iterable\n       Iterable of NetworkX graphs\n\n    rename : iterable , optional\n       Node names of graphs can be changed by specifying the tuple\n       rename=('G-','H-') (for example).  Node \"u\" in G is then renamed\n       \"G-u\" and \"v\" in H is renamed \"H-v\". Infinite generators (like itertools.count)\n       are also supported.\n\n    Returns\n    -------\n    U : a graph with the same type as the first graph in list\n\n    Raises\n    ------\n    ValueError\n       If `graphs` is an empty list.\n\n    NetworkXError\n        In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\n\n    Notes\n    -----\n    For operating on mixed type graphs, they should be converted to the same type.\n    >>> G = nx.Graph()\n    >>> H = nx.DiGraph()\n    >>> GH = union_all([nx.DiGraph(G), H])\n\n    To force a disjoint union with node relabeling, use\n    disjoint_union_all(G,H) or convert_node_labels_to integers().\n\n    Graph, edge, and node attributes are propagated to the union graph.\n    If a graph attribute is present in multiple graphs, then the value\n    from the last graph in the list with that attribute is used.\n\n    Examples\n    --------\n    >>> G1 = nx.Graph([(1, 2), (2, 3)])\n    >>> G2 = nx.Graph([(4, 5), (5, 6)])\n    >>> result_graph = nx.union_all([G1, G2])\n    >>> result_graph.nodes()\n    NodeView((1, 2, 3, 4, 5, 6))\n    >>> result_graph.edges()\n    EdgeView([(1, 2), (2, 3), (4, 5), (5, 6)])\n\n    See Also\n    --------\n    union\n    disjoint_union_all\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=\"[graphs]\", preserve_all_attrs=True, returns_graph=True)\ndef compose_all(graphs):\n\"\"\"Returns the composition of all graphs.\n\n    Composition is the simple union of the node sets and edge sets.\n    The node sets of the supplied graphs need not be disjoint.\n\n    Parameters\n    ----------\n    graphs : iterable\n       Iterable of NetworkX graphs\n\n    Returns\n    -------\n    C : A graph with the same type as the first graph in list\n\n    Raises\n    ------\n    ValueError\n       If `graphs` is an empty list.\n\n    NetworkXError\n        In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\n\n    Examples\n    --------\n    >>> G1 = nx.Graph([(1, 2), (2, 3)])\n    >>> G2 = nx.Graph([(3, 4), (5, 6)])\n    >>> C = nx.compose_all([G1, G2])\n    >>> list(C.nodes())\n    [1, 2, 3, 4, 5, 6]\n    >>> list(C.edges())\n    [(1, 2), (2, 3), (3, 4), (5, 6)]\n\n    Notes\n    -----\n    For operating on mixed type graphs, they should be converted to the same type.\n\n    Graph, edge, and node attributes are propagated to the union graph.\n    If a graph attribute is present in multiple graphs, then the value\n    from the last graph in the list with that attribute is used.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=_G_H, preserve_node_attrs=True, returns_graph=True)\ndef tensor_product(G, H):\n\"\"\"Returns the tensor product of G and H.\n\n    The tensor product $P$ of the graphs $G$ and $H$ has a node set that\n    is the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.\n    $P$ has an edge $((u,v), (x,y))$ if and only if $(u,x)$ is an edge in $G$\n    and $(v,y)$ is an edge in $H$.\n\n    Tensor product is sometimes also referred to as the categorical product,\n    direct product, cardinal product or conjunction.\n\n\n    Parameters\n    ----------\n    G, H: graphs\n     Networkx graphs.\n\n    Returns\n    -------\n    P: NetworkX graph\n     The tensor product of G and H. P will be a multi-graph if either G\n     or H is a multi-graph, will be a directed if G and H are directed,\n     and undirected if G and H are undirected.\n\n    Raises\n    ------\n    NetworkXError\n     If G and H are not both directed or both undirected.\n\n    Notes\n    -----\n    Node attributes in P are two-tuple of the G and H node attributes.\n    Missing attributes are assigned None.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> H = nx.Graph()\n    >>> G.add_node(0, a1=True)\n    >>> H.add_node(\"a\", a2=\"Spam\")\n    >>> P = nx.tensor_product(G, H)\n    >>> list(P)\n    [(0, 'a')]\n\n    Edge attributes and edge keys (for multigraphs) are also copied to the\n    new product graph\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=_G_H, preserve_node_attrs=True, returns_graph=True)\ndef lexicographic_product(G, H):\n\"\"\"Returns the lexicographic product of G and H.\n\n    The lexicographical product $P$ of the graphs $G$ and $H$ has a node set\n    that is the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.\n    $P$ has an edge $((u,v), (x,y))$ if and only if $(u,v)$ is an edge in $G$\n    or $u==v$ and $(x,y)$ is an edge in $H$.\n\n    Parameters\n    ----------\n    G, H: graphs\n     Networkx graphs.\n\n    Returns\n    -------\n    P: NetworkX graph\n     The Cartesian product of G and H. P will be a multi-graph if either G\n     or H is a multi-graph. Will be a directed if G and H are directed,\n     and undirected if G and H are undirected.\n\n    Raises\n    ------\n    NetworkXError\n     If G and H are not both directed or both undirected.\n\n    Notes\n    -----\n    Node attributes in P are two-tuple of the G and H node attributes.\n    Missing attributes are assigned None.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> H = nx.Graph()\n    >>> G.add_node(0, a1=True)\n    >>> H.add_node(\"a\", a2=\"Spam\")\n    >>> P = nx.lexicographic_product(G, H)\n    >>> list(P)\n    [(0, 'a')]\n\n    Edge attributes and edge keys (for multigraphs) are also copied to the\n    new product graph\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef power(G, k):\n\"\"\"Returns the specified power of a graph.\n\n    The $k$th power of a simple graph $G$, denoted $G^k$, is a\n    graph on the same set of nodes in which two distinct nodes $u$ and\n    $v$ are adjacent in $G^k$ if and only if the shortest path\n    distance between $u$ and $v$ in $G$ is at most $k$.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX simple graph object.\n\n    k : positive integer\n        The power to which to raise the graph `G`.\n\n    Returns\n    -------\n    NetworkX simple graph\n        `G` to the power `k`.\n\n    Raises\n    ------\n    ValueError\n        If the exponent `k` is not positive.\n\n    NetworkXNotImplemented\n        If `G` is not a simple graph.\n\n    Examples\n    --------\n    The number of edges will never decrease when taking successive\n    powers:\n\n    >>> G = nx.path_graph(4)\n    >>> list(nx.power(G, 2).edges)\n    [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3)]\n    >>> list(nx.power(G, 3).edges)\n    [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n\n    The `k` th power of a cycle graph on *n* nodes is the complete graph\n    on *n* nodes, if `k` is at least ``n // 2``:\n\n    >>> G = nx.cycle_graph(5)\n    >>> H = nx.complete_graph(5)\n    >>> nx.is_isomorphic(nx.power(G, 2), H)\n    True\n    >>> G = nx.cycle_graph(8)\n    >>> H = nx.complete_graph(8)\n    >>> nx.is_isomorphic(nx.power(G, 4), H)\n    True\n\n    References\n    ----------\n    .. [1] J. A. Bondy, U. S. R. Murty, *Graph Theory*. Springer, 2008.\n\n    Notes\n    -----\n    This definition of \"power graph\" comes from Exercise 3.1.6 of\n    *Graph Theory* by Bondy and Murty [1]_.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=_G_H, returns_graph=True)\ndef corona_product(G, H):\n\"\"\"Returns the Corona product of G and H.\n\n    The corona product of $G$ and $H$ is the graph $C = G \\circ H$ obtained by\n    taking one copy of $G$, called the center graph, $|V(G)|$ copies of $H$,\n    called the outer graph, and making the $i$-th vertex of $G$ adjacent to\n    every vertex of the $i$-th copy of $H$, where $1 \u2264 i \u2264 |V(G)|$.\n\n    Parameters\n    ----------\n    G, H: NetworkX graphs\n        The graphs to take the carona product of.\n        `G` is the center graph and `H` is the outer graph\n\n    Returns\n    -------\n    C: NetworkX graph\n        The Corona product of G and H.\n\n    Raises\n    ------\n    NetworkXError\n        If G and H are not both directed or both undirected.\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(4)\n    >>> H = nx.path_graph(2)\n    >>> C = nx.corona_product(G, H)\n    >>> list(C)\n    [0, 1, 2, 3, (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\n    >>> print(C)\n    Graph with 12 nodes and 16 edges\n\n    References\n    ----------\n    [1] M. Tavakoli, F. Rahbarnia, and A. R. Ashrafi,\n        \"Studying the corona product of graphs under some graph invariants,\"\n        Transactions on Combinatorics, vol. 3, no. 3, pp. 43\u201349, Sep. 2014,\n        doi: 10.22108/toc.2014.5542.\n    [2] A. Faraji, \"Corona Product in Graph Theory,\" Ali Faraji, May 11, 2021.\n        https://blog.alifaraji.ir/math/graph-theory/corona-product.html (accessed Dec. 07, 2021).\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef complement(G):\n\"\"\"Returns the graph complement of G.\n\n    Parameters\n    ----------\n    G : graph\n       A NetworkX graph\n\n    Returns\n    -------\n    GC : A new graph.\n\n    Notes\n    -----\n    Note that `complement` does not create self-loops and also\n    does not produce parallel edges for MultiGraphs.\n\n    Graph, node, and edge data are not propagated to the new graph.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)])\n    >>> G_complement = nx.complement(G)\n    >>> G_complement.edges()  # This shows the edges of the complemented graph\n    EdgeView([(1, 4), (1, 5), (2, 4), (2, 5), (4, 5)])\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs={\"G\": 0, \"auxiliary?\": 4}, preserve_graph_attrs={\"auxiliary\"})\ndef node_connectivity(G, s=None, t=None, flow_func=None):\n\"\"\"Returns node connectivity for a graph or digraph G.\n\n    Node connectivity is equal to the minimum number of nodes that\n    must be removed to disconnect G or render it trivial. If source\n    and target nodes are provided, this function returns the local node\n    connectivity: the minimum number of nodes that must be removed to break\n    all paths from source to target in G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph\n\n    s : node\n        Source node. Optional. Default value: None.\n\n    t : node\n        Target node. Optional. Default value: None.\n\n    flow_func : function\n        A function for computing the maximum flow among a pair of nodes.\n        The function has to accept at least three parameters: a Digraph,\n        a source node, and a target node. And return a residual network\n        that follows NetworkX conventions (see :meth:`maximum_flow` for\n        details). If flow_func is None, the default maximum flow function\n        (:meth:`edmonds_karp`) is used. See below for details. The\n        choice of the default function may change from version\n        to version and should not be relied on. Default value: None.\n\n    Returns\n    -------\n    K : integer\n        Node connectivity of G, or local node connectivity if source\n        and target are provided.\n\n    Examples\n    --------\n    >>> # Platonic icosahedral graph is 5-node-connected\n    >>> G = nx.icosahedral_graph()\n    >>> nx.node_connectivity(G)\n    5\n\n    You can use alternative flow algorithms for the underlying maximum\n    flow computation. In dense networks the algorithm\n    :meth:`shortest_augmenting_path` will usually perform better\n    than the default :meth:`edmonds_karp`, which is faster for\n    sparse networks with highly skewed degree distributions. Alternative\n    flow functions have to be explicitly imported from the flow package.\n\n    >>> from networkx.algorithms.flow import shortest_augmenting_path\n    >>> nx.node_connectivity(G, flow_func=shortest_augmenting_path)\n    5\n\n    If you specify a pair of nodes (source and target) as parameters,\n    this function returns the value of local node connectivity.\n\n    >>> nx.node_connectivity(G, 3, 7)\n    5\n\n    If you need to perform several local computations among different\n    pairs of nodes on the same graph, it is recommended that you reuse\n    the data structures used in the maximum flow computations. See\n    :meth:`local_node_connectivity` for details.\n\n    Notes\n    -----\n    This is a flow based implementation of node connectivity. The\n    algorithm works by solving $O((n-\\delta-1+\\delta(\\delta-1)/2))$\n    maximum flow problems on an auxiliary digraph. Where $\\delta$\n    is the minimum degree of G. For details about the auxiliary\n    digraph and the computation of local node connectivity see\n    :meth:`local_node_connectivity`. This implementation is based\n    on algorithm 11 in [1]_.\n\n    See also\n    --------\n    :meth:`local_node_connectivity`\n    :meth:`edge_connectivity`\n    :meth:`maximum_flow`\n    :meth:`edmonds_karp`\n    :meth:`preflow_push`\n    :meth:`shortest_augmenting_path`\n\n    References\n    ----------\n    .. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.\n        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef all_pairs_node_connectivity(G, nbunch=None, flow_func=None):\n\"\"\"Compute node connectivity between all pairs of nodes of G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph\n\n    nbunch: container\n        Container of nodes. If provided node connectivity will be computed\n        only over pairs of nodes in nbunch.\n\n    flow_func : function\n        A function for computing the maximum flow among a pair of nodes.\n        The function has to accept at least three parameters: a Digraph,\n        a source node, and a target node. And return a residual network\n        that follows NetworkX conventions (see :meth:`maximum_flow` for\n        details). If flow_func is None, the default maximum flow function\n        (:meth:`edmonds_karp`) is used. See below for details. The\n        choice of the default function may change from version\n        to version and should not be relied on. Default value: None.\n\n    Returns\n    -------\n    all_pairs : dict\n        A dictionary with node connectivity between all pairs of nodes\n        in G, or in nbunch if provided.\n\n    See also\n    --------\n    :meth:`local_node_connectivity`\n    :meth:`edge_connectivity`\n    :meth:`local_edge_connectivity`\n    :meth:`maximum_flow`\n    :meth:`edmonds_karp`\n    :meth:`preflow_push`\n    :meth:`shortest_augmenting_path`\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef build_auxiliary_node_connectivity(G):\n\"\"\"Creates a directed graph D from an undirected graph G to compute flow\n    based node connectivity.\n\n    For an undirected graph G having `n` nodes and `m` edges we derive a\n    directed graph D with `2n` nodes and `2m+n` arcs by replacing each\n    original node `v` with two nodes `vA`, `vB` linked by an (internal)\n    arc in D. Then for each edge (`u`, `v`) in G we add two arcs (`uB`, `vA`)\n    and (`vB`, `uA`) in D. Finally we set the attribute capacity = 1 for each\n    arc in D [1]_.\n\n    For a directed graph having `n` nodes and `m` arcs we derive a\n    directed graph D with `2n` nodes and `m+n` arcs by replacing each\n    original node `v` with two nodes `vA`, `vB` linked by an (internal)\n    arc (`vA`, `vB`) in D. Then for each arc (`u`, `v`) in G we add one\n    arc (`uB`, `vA`) in D. Finally we set the attribute capacity = 1 for\n    each arc in D.\n\n    A dictionary with a mapping between nodes in the original graph and the\n    auxiliary digraph is stored as a graph attribute: D.graph['mapping'].\n\n    References\n    ----------\n    .. [1] Kammer, Frank and Hanjo Taubig. Graph Connectivity. in Brandes and\n        Erlebach, 'Network Analysis: Methodological Foundations', Lecture\n        Notes in Computer Science, Volume 3418, Springer-Verlag, 2005.\n        https://doi.org/10.1007/978-3-540-31955-9_7\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(\ndef minimum_st_edge_cut(G, s, t, flow_func=None, auxiliary=None, residual=None):\n\"\"\"Returns the edges of the cut-set of a minimum (s, t)-cut.\n\n    This function returns the set of edges of minimum cardinality that,\n    if removed, would destroy all paths among source and target in G.\n    Edge weights are not considered. See :meth:`minimum_cut` for\n    computing minimum cuts considering edge weights.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    s : node\n        Source node for the flow.\n\n    t : node\n        Sink node for the flow.\n\n    auxiliary : NetworkX DiGraph\n        Auxiliary digraph to compute flow based node connectivity. It has\n        to have a graph attribute called mapping with a dictionary mapping\n        node names in G and in the auxiliary digraph. If provided\n        it will be reused instead of recreated. Default value: None.\n\n    flow_func : function\n        A function for computing the maximum flow among a pair of nodes.\n        The function has to accept at least three parameters: a Digraph,\n        a source node, and a target node. And return a residual network\n        that follows NetworkX conventions (see :meth:`maximum_flow` for\n        details). If flow_func is None, the default maximum flow function\n        (:meth:`edmonds_karp`) is used. See :meth:`node_connectivity` for\n        details. The choice of the default function may change from version\n        to version and should not be relied on. Default value: None.\n\n    residual : NetworkX DiGraph\n        Residual network to compute maximum flow. If provided it will be\n        reused instead of recreated. Default value: None.\n\n    Returns\n    -------\n    cutset : set\n        Set of edges that, if removed from the graph, will disconnect it.\n\n    See also\n    --------\n    :meth:`minimum_cut`\n    :meth:`minimum_node_cut`\n    :meth:`minimum_edge_cut`\n    :meth:`stoer_wagner`\n    :meth:`node_connectivity`\n    :meth:`edge_connectivity`\n    :meth:`maximum_flow`\n    :meth:`edmonds_karp`\n    :meth:`preflow_push`\n    :meth:`shortest_augmenting_path`\n\n    Examples\n    --------\n    This function is not imported in the base NetworkX namespace, so you\n    have to explicitly import it from the connectivity package:\n\n    >>> from networkx.algorithms.connectivity import minimum_st_edge_cut\n\n    We use in this example the platonic icosahedral graph, which has edge\n    connectivity 5.\n\n    >>> G = nx.icosahedral_graph()\n    >>> len(minimum_st_edge_cut(G, 0, 6))\n    5\n\n    If you need to compute local edge cuts on several pairs of\n    nodes in the same graph, it is recommended that you reuse the\n    data structures that NetworkX uses in the computation: the\n    auxiliary digraph for edge connectivity, and the residual\n    network for the underlying maximum flow computation.\n\n    Example of how to compute local edge cuts among all pairs of\n    nodes of the platonic icosahedral graph reusing the data\n    structures.\n\n    >>> import itertools\n    >>> # You also have to explicitly import the function for\n    >>> # building the auxiliary digraph from the connectivity package\n    >>> from networkx.algorithms.connectivity import build_auxiliary_edge_connectivity\n    >>> H = build_auxiliary_edge_connectivity(G)\n    >>> # And the function for building the residual network from the\n    >>> # flow package\n    >>> from networkx.algorithms.flow import build_residual_network\n    >>> # Note that the auxiliary digraph has an edge attribute named capacity\n    >>> R = build_residual_network(H, \"capacity\")\n    >>> result = dict.fromkeys(G, dict())\n    >>> # Reuse the auxiliary digraph and the residual network by passing them\n    >>> # as parameters\n    >>> for u, v in itertools.combinations(G, 2):\n    ...     k = len(minimum_st_edge_cut(G, u, v, auxiliary=H, residual=R))\n    ...     result[u][v] = k\n    >>> all(result[u][v] == 5 for u, v in itertools.combinations(G, 2))\n    True\n\n    You can also use alternative flow algorithms for computing edge\n    cuts. For instance, in dense networks the algorithm\n    :meth:`shortest_augmenting_path` will usually perform better than\n    the default :meth:`edmonds_karp` which is faster for sparse\n    networks with highly skewed degree distributions. Alternative flow\n    functions have to be explicitly imported from the flow package.\n\n    >>> from networkx.algorithms.flow import shortest_augmenting_path\n    >>> len(minimum_st_edge_cut(G, 0, 6, flow_func=shortest_augmenting_path))\n    5\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef minimum_node_cut(G, s=None, t=None, flow_func=None):\n\"\"\"Returns a set of nodes of minimum cardinality that disconnects G.\n\n    If source and target nodes are provided, this function returns the\n    set of nodes of minimum cardinality that, if removed, would destroy\n    all paths among source and target in G. If not, it returns a set\n    of nodes of minimum cardinality that disconnects G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    s : node\n        Source node. Optional. Default value: None.\n\n    t : node\n        Target node. Optional. Default value: None.\n\n    flow_func : function\n        A function for computing the maximum flow among a pair of nodes.\n        The function has to accept at least three parameters: a Digraph,\n        a source node, and a target node. And return a residual network\n        that follows NetworkX conventions (see :meth:`maximum_flow` for\n        details). If flow_func is None, the default maximum flow function\n        (:meth:`edmonds_karp`) is used. See below for details. The\n        choice of the default function may change from version\n        to version and should not be relied on. Default value: None.\n\n    Returns\n    -------\n    cutset : set\n        Set of nodes that, if removed, would disconnect G. If source\n        and target nodes are provided, the set contains the nodes that\n        if removed, would destroy all paths between source and target.\n\n    Examples\n    --------\n    >>> # Platonic icosahedral graph has node connectivity 5\n    >>> G = nx.icosahedral_graph()\n    >>> node_cut = nx.minimum_node_cut(G)\n    >>> len(node_cut)\n    5\n\n    You can use alternative flow algorithms for the underlying maximum\n    flow computation. In dense networks the algorithm\n    :meth:`shortest_augmenting_path` will usually perform better\n    than the default :meth:`edmonds_karp`, which is faster for\n    sparse networks with highly skewed degree distributions. Alternative\n    flow functions have to be explicitly imported from the flow package.\n\n    >>> from networkx.algorithms.flow import shortest_augmenting_path\n    >>> node_cut == nx.minimum_node_cut(G, flow_func=shortest_augmenting_path)\n    True\n\n    If you specify a pair of nodes (source and target) as parameters,\n    this function returns a local st node cut.\n\n    >>> len(nx.minimum_node_cut(G, 3, 7))\n    5\n\n    If you need to perform several local st cuts among different\n    pairs of nodes on the same graph, it is recommended that you reuse\n    the data structures used in the maximum flow computations. See\n    :meth:`minimum_st_node_cut` for details.\n\n    Notes\n    -----\n    This is a flow based implementation of minimum node cut. The algorithm\n    is based in solving a number of maximum flow computations to determine\n    the capacity of the minimum cut on an auxiliary directed network that\n    corresponds to the minimum node cut of G. It handles both directed\n    and undirected graphs. This implementation is based on algorithm 11\n    in [1]_.\n\n    See also\n    --------\n    :meth:`minimum_st_node_cut`\n    :meth:`minimum_cut`\n    :meth:`minimum_edge_cut`\n    :meth:`stoer_wagner`\n    :meth:`node_connectivity`\n    :meth:`edge_connectivity`\n    :meth:`maximum_flow`\n    :meth:`edmonds_karp`\n    :meth:`preflow_push`\n    :meth:`shortest_augmenting_path`\n\n    References\n    ----------\n    .. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.\n        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef all_node_cuts(G, k=None, flow_func=None):\n\"\"\"Returns all minimum k cutsets of an undirected graph G.\n\n    This implementation is based on Kanevsky's algorithm [1]_ for finding all\n    minimum-size node cut-sets of an undirected graph G; ie the set (or sets)\n    of nodes of cardinality equal to the node connectivity of G. Thus if\n    removed, would break G into two or more connected components.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph\n\n    k : Integer\n        Node connectivity of the input graph. If k is None, then it is\n        computed. Default value: None.\n\n    flow_func : function\n        Function to perform the underlying flow computations. Default value is\n        :func:`~networkx.algorithms.flow.edmonds_karp`. This function performs\n        better in sparse graphs with right tailed degree distributions.\n        :func:`~networkx.algorithms.flow.shortest_augmenting_path` will\n        perform better in denser graphs.\n\n\n    Returns\n    -------\n    cuts : a generator of node cutsets\n        Each node cutset has cardinality equal to the node connectivity of\n        the input graph.\n\n    Examples\n    --------\n    >>> # A two-dimensional grid graph has 4 cutsets of cardinality 2\n    >>> G = nx.grid_2d_graph(5, 5)\n    >>> cutsets = list(nx.all_node_cuts(G))\n    >>> len(cutsets)\n    4\n    >>> all(2 == len(cutset) for cutset in cutsets)\n    True\n    >>> nx.node_connectivity(G)\n    2\n\n    Notes\n    -----\n    This implementation is based on the sequential algorithm for finding all\n    minimum-size separating vertex sets in a graph [1]_. The main idea is to\n    compute minimum cuts using local maximum flow computations among a set\n    of nodes of highest degree and all other non-adjacent nodes in the Graph.\n    Once we find a minimum cut, we add an edge between the high degree\n    node and the target node of the local maximum flow computation to make\n    sure that we will not find that minimum cut again.\n\n    See also\n    --------\n    node_connectivity\n    edmonds_karp\n    shortest_augmenting_path\n\n    References\n    ----------\n    .. [1]  Kanevsky, A. (1993). Finding all minimum-size separating vertex\n            sets in a graph. Networks 23(6), 533--541.\n            http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_k_edge_connected(G, k):\n\"\"\"Tests to see if a graph is k-edge-connected.\n\n    Is it impossible to disconnect the graph by removing fewer than k edges?\n    If so, then G is k-edge-connected.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       An undirected graph.\n\n    k : integer\n        edge connectivity to test for\n\n    Returns\n    -------\n    boolean\n        True if G is k-edge-connected.\n\n    See Also\n    --------\n    :func:`is_locally_k_edge_connected`\n\n    Examples\n    --------\n    >>> G = nx.barbell_graph(10, 0)\n    >>> nx.is_k_edge_connected(G, k=1)\n    True\n    >>> nx.is_k_edge_connected(G, k=2)\n    False\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef k_edge_augmentation(G, k, avail=None, weight=None, partial=False):\n\"\"\"Finds set of edges to k-edge-connect G.\n\n    Adding edges from the augmentation to G make it impossible to disconnect G\n    unless k or more edges are removed. This function uses the most efficient\n    function available (depending on the value of k and if the problem is\n    weighted or unweighted) to search for a minimum weight subset of available\n    edges that k-edge-connects G. In general, finding a k-edge-augmentation is\n    NP-hard, so solutions are not guaranteed to be minimal. Furthermore, a\n    k-edge-augmentation may not exist.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       An undirected graph.\n\n    k : integer\n        Desired edge connectivity\n\n    avail : dict or a set of 2 or 3 tuples\n        The available edges that can be used in the augmentation.\n\n        If unspecified, then all edges in the complement of G are available.\n        Otherwise, each item is an available edge (with an optional weight).\n\n        In the unweighted case, each item is an edge ``(u, v)``.\n\n        In the weighted case, each item is a 3-tuple ``(u, v, d)`` or a dict\n        with items ``(u, v): d``.  The third item, ``d``, can be a dictionary\n        or a real number.  If ``d`` is a dictionary ``d[weight]``\n        correspondings to the weight.\n\n    weight : string\n        key to use to find weights if ``avail`` is a set of 3-tuples where the\n        third item in each tuple is a dictionary.\n\n    partial : boolean\n        If partial is True and no feasible k-edge-augmentation exists, then all\n        a partial k-edge-augmentation is generated. Adding the edges in a\n        partial augmentation to G, minimizes the number of k-edge-connected\n        components and maximizes the edge connectivity between those\n        components. For details, see :func:`partial_k_edge_augmentation`.\n\n    Yields\n    ------\n    edge : tuple\n        Edges that, once added to G, would cause G to become k-edge-connected.\n        If partial is False, an error is raised if this is not possible.\n        Otherwise, generated edges form a partial augmentation, which\n        k-edge-connects any part of G where it is possible, and maximally\n        connects the remaining parts.\n\n    Raises\n    ------\n    NetworkXUnfeasible\n        If partial is False and no k-edge-augmentation exists.\n\n    NetworkXNotImplemented\n        If the input graph is directed or a multigraph.\n\n    ValueError:\n        If k is less than 1\n\n    Notes\n    -----\n    When k=1 this returns an optimal solution.\n\n    When k=2 and ``avail`` is None, this returns an optimal solution.\n    Otherwise when k=2, this returns a 2-approximation of the optimal solution.\n\n    For k>3, this problem is NP-hard and this uses a randomized algorithm that\n        produces a feasible solution, but provides no guarantees on the\n        solution weight.\n\n    Examples\n    --------\n    >>> # Unweighted cases\n    >>> G = nx.path_graph((1, 2, 3, 4))\n    >>> G.add_node(5)\n    >>> sorted(nx.k_edge_augmentation(G, k=1))\n    [(1, 5)]\n    >>> sorted(nx.k_edge_augmentation(G, k=2))\n    [(1, 5), (5, 4)]\n    >>> sorted(nx.k_edge_augmentation(G, k=3))\n    [(1, 4), (1, 5), (2, 5), (3, 5), (4, 5)]\n    >>> complement = list(nx.k_edge_augmentation(G, k=5, partial=True))\n    >>> G.add_edges_from(complement)\n    >>> nx.edge_connectivity(G)\n    4\n\n    >>> # Weighted cases\n    >>> G = nx.path_graph((1, 2, 3, 4))\n    >>> G.add_node(5)\n    >>> # avail can be a tuple with a dict\n    >>> avail = [(1, 5, {\"weight\": 11}), (2, 5, {\"weight\": 10})]\n    >>> sorted(nx.k_edge_augmentation(G, k=1, avail=avail, weight=\"weight\"))\n    [(2, 5)]\n    >>> # or avail can be a 3-tuple with a real number\n    >>> avail = [(1, 5, 11), (2, 5, 10), (4, 3, 1), (4, 5, 51)]\n    >>> sorted(nx.k_edge_augmentation(G, k=2, avail=avail))\n    [(1, 5), (2, 5), (4, 5)]\n    >>> # or avail can be a dict\n    >>> avail = {(1, 5): 11, (2, 5): 10, (4, 3): 1, (4, 5): 51}\n    >>> sorted(nx.k_edge_augmentation(G, k=2, avail=avail))\n    [(1, 5), (2, 5), (4, 5)]\n    >>> # If augmentation is infeasible, then a partial solution can be found\n    >>> avail = {(1, 5): 11}\n    >>> sorted(nx.k_edge_augmentation(G, k=2, avail=avail, partial=True))\n    [(1, 5)]\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable\ndef one_edge_augmentation(G, avail=None, weight=None, partial=False):\n\"\"\"Finds minimum weight set of edges to connect G.\n\n    Equivalent to :func:`k_edge_augmentation` when k=1. Adding the resulting\n    edges to G will make it 1-edge-connected. The solution is optimal for both\n    weighted and non-weighted variants.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       An undirected graph.\n\n    avail : dict or a set of 2 or 3 tuples\n        For more details, see :func:`k_edge_augmentation`.\n\n    weight : string\n        key to use to find weights if ``avail`` is a set of 3-tuples.\n        For more details, see :func:`k_edge_augmentation`.\n\n    partial : boolean\n        If partial is True and no feasible k-edge-augmentation exists, then the\n        augmenting edges minimize the number of connected components.\n\n    Yields\n    ------\n    edge : tuple\n        Edges in the one-augmentation of G\n\n    Raises\n    ------\n    NetworkXUnfeasible\n        If partial is False and no one-edge-augmentation exists.\n\n    Notes\n    -----\n    Uses either :func:`unconstrained_one_edge_augmentation` or\n    :func:`weighted_one_edge_augmentation` depending on whether ``avail`` is\n    specified. Both algorithms are based on finding a minimum spanning tree.\n    As such both algorithms find optimal solutions and run in linear time.\n\n    See Also\n    --------\n    :func:`k_edge_augmentation`\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef unconstrained_one_edge_augmentation(G):\n\"\"\"Finds the smallest set of edges to connect G.\n\n    This is a variant of the unweighted MST problem.\n    If G is not empty, a feasible solution always exists.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       An undirected graph.\n\n    Yields\n    ------\n    edge : tuple\n        Edges in the one-edge-augmentation of G\n\n    See Also\n    --------\n    :func:`one_edge_augmentation`\n    :func:`k_edge_augmentation`\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (2, 3), (4, 5)])\n    >>> G.add_nodes_from([6, 7, 8])\n    >>> sorted(unconstrained_one_edge_augmentation(G))\n    [(1, 4), (4, 6), (6, 7), (7, 8)]\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef unconstrained_bridge_augmentation(G):\n\"\"\"Finds an optimal 2-edge-augmentation of G using the fewest edges.\n\n    This is an implementation of the algorithm detailed in [1]_.\n    The basic idea is to construct a meta-graph of bridge-ccs, connect leaf\n    nodes of the trees to connect the entire graph, and finally connect the\n    leafs of the tree in dfs-preorder to bridge connect the entire graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       An undirected graph.\n\n    Yields\n    ------\n    edge : tuple\n        Edges in the bridge augmentation of G\n\n    Notes\n    -----\n    Input: a graph G.\n    First find the bridge components of G and collapse each bridge-cc into a\n    node of a metagraph graph C, which is guaranteed to be a forest of trees.\n\n    C contains p \"leafs\" --- nodes with exactly one incident edge.\n    C contains q \"isolated nodes\" --- nodes with no incident edges.\n\n    Theorem: If p + q > 1, then at least :math:`ceil(p / 2) + q` edges are\n        needed to bridge connect C. This algorithm achieves this min number.\n\n    The method first adds enough edges to make G into a tree and then pairs\n    leafs in a simple fashion.\n\n    Let n be the number of trees in C. Let v(i) be an isolated vertex in the\n    i-th tree if one exists, otherwise it is a pair of distinct leafs nodes\n    in the i-th tree. Alternating edges from these sets (i.e.  adding edges\n    A1 = [(v(i)[0], v(i + 1)[1]), v(i + 1)[0], v(i + 2)[1])...]) connects C\n    into a tree T. This tree has p' = p + 2q - 2(n -1) leafs and no isolated\n    vertices. A1 has n - 1 edges. The next step finds ceil(p' / 2) edges to\n    biconnect any tree with p' leafs.\n\n    Convert T into an arborescence T' by picking an arbitrary root node with\n    degree >= 2 and directing all edges away from the root. Note the\n    implementation implicitly constructs T'.\n\n    The leafs of T are the nodes with no existing edges in T'.\n    Order the leafs of T' by DFS preorder. Then break this list in half\n    and add the zipped pairs to A2.\n\n    The set A = A1 + A2 is the minimum augmentation in the metagraph.\n\n    To convert this to edges in the original graph\n\n    References\n    ----------\n    .. [1] Eswaran, Kapali P., and R. Endre Tarjan. (1975) Augmentation problems.\n        http://epubs.siam.org/doi/abs/10.1137/0205044\n\n    See Also\n    --------\n    :func:`bridge_augmentation`\n    :func:`k_edge_augmentation`\n\n    Examples\n    --------\n    >>> G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))\n    >>> sorted(unconstrained_bridge_augmentation(G))\n    [(1, 7)]\n    >>> G = nx.path_graph((1, 2, 3, 2, 4, 5, 6, 7))\n    >>> sorted(unconstrained_bridge_augmentation(G))\n    [(1, 3), (3, 7)]\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2)])\n    >>> G.add_node(4)\n    >>> sorted(unconstrained_bridge_augmentation(G))\n    [(1, 4), (4, 0)]\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef collapse(G, grouped_nodes):\n\"\"\"Collapses each group of nodes into a single node.\n\n    This is similar to condensation, but works on undirected graphs.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n\n    grouped_nodes:  list or generator\n       Grouping of nodes to collapse. The grouping must be disjoint.\n       If grouped_nodes are strongly_connected_components then this is\n       equivalent to :func:`condensation`.\n\n    Returns\n    -------\n    C : NetworkX Graph\n       The collapsed graph C of G with respect to the node grouping.  The node\n       labels are integers corresponding to the index of the component in the\n       list of grouped_nodes.  C has a graph attribute named 'mapping' with a\n       dictionary mapping the original nodes to the nodes in C to which they\n       belong.  Each node in C also has a node attribute 'members' with the set\n       of original nodes in G that form the group that the node in C\n       represents.\n\n    Examples\n    --------\n    >>> # Collapses a graph using disjoint groups, but not necessarily connected\n    >>> G = nx.Graph([(1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 6), (5, 7)])\n    >>> G.add_node(\"A\")\n    >>> grouped_nodes = [{0, 1, 2, 3}, {5, 6, 7}]\n    >>> C = collapse(G, grouped_nodes)\n    >>> members = nx.get_node_attributes(C, \"members\")\n    >>> sorted(members.keys())\n    [0, 1, 2, 3]\n    >>> member_values = set(map(frozenset, members.values()))\n    >>> assert {0, 1, 2, 3} in member_values\n    >>> assert {4} in member_values\n    >>> assert {5, 6, 7} in member_values\n    >>> assert {\"A\"} in member_values\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable\ndef greedy_k_edge_augmentation(G, k, avail=None, weight=None, seed=None):\n\"\"\"Greedy algorithm for finding a k-edge-augmentation\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       An undirected graph.\n\n    k : integer\n        Desired edge connectivity\n\n    avail : dict or a set of 2 or 3 tuples\n        For more details, see :func:`k_edge_augmentation`.\n\n    weight : string\n        key to use to find weights if ``avail`` is a set of 3-tuples.\n        For more details, see :func:`k_edge_augmentation`.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Yields\n    ------\n    edge : tuple\n        Edges in the greedy augmentation of G\n\n    Notes\n    -----\n    The algorithm is simple. Edges are incrementally added between parts of the\n    graph that are not yet locally k-edge-connected. Then edges are from the\n    augmenting set are pruned as long as local-edge-connectivity is not broken.\n\n    This algorithm is greedy and does not provide optimality guarantees. It\n    exists only to provide :func:`k_edge_augmentation` with the ability to\n    generate a feasible solution for arbitrary k.\n\n    See Also\n    --------\n    :func:`k_edge_augmentation`\n\n    Examples\n    --------\n    >>> G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))\n    >>> sorted(greedy_k_edge_augmentation(G, k=2))\n    [(1, 7)]\n    >>> sorted(greedy_k_edge_augmentation(G, k=1, avail=[]))\n    []\n    >>> G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))\n    >>> avail = {(u, v): 1 for (u, v) in complement_edges(G)}\n    >>> # randomized pruning process can produce different solutions\n    >>> sorted(greedy_k_edge_augmentation(G, k=4, avail=avail, seed=2))\n    [(1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (2, 4), (2, 6), (3, 7), (5, 7)]\n    >>> sorted(greedy_k_edge_augmentation(G, k=4, avail=avail, seed=3))\n    [(1, 3), (1, 5), (1, 6), (2, 4), (2, 6), (3, 7), (4, 7), (5, 7)]\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef k_edge_components(G, k):\n\"\"\"Generates nodes in each maximal k-edge-connected component in G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    k : Integer\n        Desired edge connectivity\n\n    Returns\n    -------\n    k_edge_components : a generator of k-edge-ccs. Each set of returned nodes\n       will have k-edge-connectivity in the graph G.\n\n    See Also\n    --------\n    :func:`local_edge_connectivity`\n    :func:`k_edge_subgraphs` : similar to this function, but the subgraph\n        defined by the nodes must also have k-edge-connectivity.\n    :func:`k_components` : similar to this function, but uses node-connectivity\n        instead of edge-connectivity\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is a multigraph.\n\n    ValueError:\n        If k is less than 1\n\n    Notes\n    -----\n    Attempts to use the most efficient implementation available based on k.\n    If k=1, this is simply connected components for directed graphs and\n    connected components for undirected graphs.\n    If k=2 on an efficient bridge connected component algorithm from _[1] is\n    run based on the chain decomposition.\n    Otherwise, the algorithm from _[2] is used.\n\n    Examples\n    --------\n    >>> import itertools as it\n    >>> from networkx.utils import pairwise\n    >>> paths = [\n    ...     (1, 2, 4, 3, 1, 4),\n    ...     (5, 6, 7, 8, 5, 7, 8, 6),\n    ... ]\n    >>> G = nx.Graph()\n    >>> G.add_nodes_from(it.chain(*paths))\n    >>> G.add_edges_from(it.chain(*[pairwise(path) for path in paths]))\n    >>> # note this returns {1, 4} unlike k_edge_subgraphs\n    >>> sorted(map(sorted, nx.k_edge_components(G, k=3)))\n    [[1, 4], [2], [3], [5, 6, 7, 8]]\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29\n    .. [2] Wang, Tianhao, et al. (2015) A simple algorithm for finding all\n        k-edge-connected components.\n        http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef bridge_components(G):\n\"\"\"Finds all bridge-connected components G.\n\n    Parameters\n    ----------\n    G : NetworkX undirected graph\n\n    Returns\n    -------\n    bridge_components : a generator of 2-edge-connected components\n\n\n    See Also\n    --------\n    :func:`k_edge_subgraphs` : this function is a special case for an\n        undirected graph where k=2.\n    :func:`biconnected_components` : similar to this function, but is defined\n        using 2-node-connectivity instead of 2-edge-connectivity.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is directed or a multigraph.\n\n    Notes\n    -----\n    Bridge-connected components are also known as 2-edge-connected components.\n\n    Examples\n    --------\n    >>> # The barbell graph with parameter zero has a single bridge\n    >>> G = nx.barbell_graph(5, 0)\n    >>> from networkx.algorithms.connectivity.edge_kcomponents import bridge_components\n    >>> sorted(map(sorted, bridge_components(G)))\n    [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef general_k_edge_subgraphs(G, k):\n\"\"\"General algorithm to find all maximal k-edge-connected subgraphs in `G`.\n\n    Parameters\n    ----------\n    G : nx.Graph\n       Graph in which all maximal k-edge-connected subgraphs will be found.\n\n    k : int\n\n    Yields\n    ------\n    k_edge_subgraphs : Graph instances that are k-edge-subgraphs\n        Each k-edge-subgraph contains a maximal set of nodes that defines a\n        subgraph of `G` that is k-edge-connected.\n\n    Notes\n    -----\n    Implementation of the basic algorithm from [1]_.  The basic idea is to find\n    a global minimum cut of the graph. If the cut value is at least k, then the\n    graph is a k-edge-connected subgraph and can be added to the results.\n    Otherwise, the cut is used to split the graph in two and the procedure is\n    applied recursively. If the graph is just a single node, then it is also\n    added to the results. At the end, each result is either guaranteed to be\n    a single node or a subgraph of G that is k-edge-connected.\n\n    This implementation contains optimizations for reducing the number of calls\n    to max-flow, but there are other optimizations in [1]_ that could be\n    implemented.\n\n    References\n    ----------\n    .. [1] Zhou, Liu, et al. (2012) Finding maximal k-edge-connected subgraphs\n        from a large graph.  ACM International Conference on Extending Database\n        Technology 2012 480-\u2013491.\n        https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf\n\n    Examples\n    --------\n    >>> from networkx.utils import pairwise\n    >>> paths = [\n    ...     (11, 12, 13, 14, 11, 13, 14, 12),  # a 4-clique\n    ...     (21, 22, 23, 24, 21, 23, 24, 22),  # another 4-clique\n    ...     # connect the cliques with high degree but low connectivity\n    ...     (50, 13),\n    ...     (12, 50, 22),\n    ...     (13, 102, 23),\n    ...     (14, 101, 24),\n    ... ]\n    >>> G = nx.Graph(it.chain(*[pairwise(path) for path in paths]))\n    >>> sorted(len(k_sg) for k_sg in k_edge_subgraphs(G, k=3))\n    [1, 1, 1, 4, 4]\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef stoer_wagner(G, weight=\"weight\", heap=BinaryHeap):\n\"\"\"Returns the weighted minimum edge cut using the Stoer-Wagner algorithm.\n\n    Determine the minimum edge cut of a connected graph using the\n    Stoer-Wagner algorithm. In weighted cases, all weights must be\n    nonnegative.\n\n    The running time of the algorithm depends on the type of heaps used:\n\n    ============== =============================================\n    Type of heap   Running time\n    ============== =============================================\n    Binary heap    $O(n (m + n) \\log n)$\n    Fibonacci heap $O(nm + n^2 \\log n)$\n    Pairing heap   $O(2^{2 \\sqrt{\\log \\log n}} nm + n^2 \\log n)$\n    ============== =============================================\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Edges of the graph are expected to have an attribute named by the\n        weight parameter below. If this attribute is not present, the edge is\n        considered to have unit weight.\n\n    weight : string\n        Name of the weight attribute of the edges. If the attribute is not\n        present, unit weight is assumed. Default value: 'weight'.\n\n    heap : class\n        Type of heap to be used in the algorithm. It should be a subclass of\n        :class:`MinHeap` or implement a compatible interface.\n\n        If a stock heap implementation is to be used, :class:`BinaryHeap` is\n        recommended over :class:`PairingHeap` for Python implementations without\n        optimized attribute accesses (e.g., CPython) despite a slower\n        asymptotic running time. For Python implementations with optimized\n        attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\n        performance. Default value: :class:`BinaryHeap`.\n\n    Returns\n    -------\n    cut_value : integer or float\n        The sum of weights of edges in a minimum cut.\n\n    partition : pair of node lists\n        A partitioning of the nodes that defines a minimum cut.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the graph is directed or a multigraph.\n\n    NetworkXError\n        If the graph has less than two nodes, is not connected or has a\n        negative-weighted edge.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> G.add_edge(\"x\", \"a\", weight=3)\n    >>> G.add_edge(\"x\", \"b\", weight=1)\n    >>> G.add_edge(\"a\", \"c\", weight=3)\n    >>> G.add_edge(\"b\", \"c\", weight=5)\n    >>> G.add_edge(\"b\", \"d\", weight=4)\n    >>> G.add_edge(\"d\", \"e\", weight=2)\n    >>> G.add_edge(\"c\", \"y\", weight=2)\n    >>> G.add_edge(\"e\", \"y\", weight=3)\n    >>> cut_value, partition = nx.stoer_wagner(G)\n    >>> cut_value\n    4\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(\ndef _unique_everseen(iterable):"}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef k_components(G, flow_func=None):\n\"\"\"Returns the k-component structure of a graph G.\n\n    A `k`-component is a maximal subgraph of a graph G that has, at least,\n    node connectivity `k`: we need to remove at least `k` nodes to break it\n    into more components. `k`-components have an inherent hierarchical\n    structure because they are nested in terms of connectivity: a connected\n    graph can contain several 2-components, each of which can contain\n    one or more 3-components, and so forth.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    flow_func : function\n        Function to perform the underlying flow computations. Default value\n        :meth:`edmonds_karp`. This function performs better in sparse graphs with\n        right tailed degree distributions. :meth:`shortest_augmenting_path` will\n        perform better in denser graphs.\n\n    Returns\n    -------\n    k_components : dict\n        Dictionary with all connectivity levels `k` in the input Graph as keys\n        and a list of sets of nodes that form a k-component of level `k` as\n        values.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is directed.\n\n    Examples\n    --------\n    >>> # Petersen graph has 10 nodes and it is triconnected, thus all\n    >>> # nodes are in a single component on all three connectivity levels\n    >>> G = nx.petersen_graph()\n    >>> k_components = nx.k_components(G)\n\n    Notes\n    -----\n    Moody and White [1]_ (appendix A) provide an algorithm for identifying\n    k-components in a graph, which is based on Kanevsky's algorithm [2]_\n    for finding all minimum-size node cut-sets of a graph (implemented in\n    :meth:`all_node_cuts` function):\n\n        1. Compute node connectivity, k, of the input graph G.\n\n        2. Identify all k-cutsets at the current level of connectivity using\n           Kanevsky's algorithm.\n\n        3. Generate new graph components based on the removal of\n           these cutsets. Nodes in a cutset belong to both sides\n           of the induced cut.\n\n        4. If the graph is neither complete nor trivial, return to 1;\n           else end.\n\n    This implementation also uses some heuristics (see [3]_ for details)\n    to speed up the computation.\n\n    See also\n    --------\n    node_connectivity\n    all_node_cuts\n    biconnected_components : special case of this function when k=2\n    k_edge_components : similar to this function, but uses edge-connectivity\n        instead of node-connectivity\n\n    References\n    ----------\n    .. [1]  Moody, J. and D. White (2003). Social cohesion and embeddedness:\n            A hierarchical conception of social groups.\n            American Sociological Review 68(1), 103--28.\n            http://www2.asanet.org/journals/ASRFeb03MoodyWhite.pdf\n\n    .. [2]  Kanevsky, A. (1993). Finding all minimum-size separating vertex\n            sets in a graph. Networks 23(6), 533--541.\n            http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract\n\n    .. [3]  Torrents, J. and F. Ferraro (2015). Structural Cohesion:\n            Visualization and Heuristics for Fast Computation.\n            https://arxiv.org/pdf/1503.04476v1\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef weakly_connected_components(G):\n\"\"\"Generate weakly connected components of G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A directed graph\n\n    Returns\n    -------\n    comp : generator of sets\n        A generator of sets of nodes, one for each weakly connected\n        component of G.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    Generate a sorted list of weakly connected components, largest first.\n\n    >>> G = nx.path_graph(4, create_using=nx.DiGraph())\n    >>> nx.add_path(G, [10, 11, 12])\n    >>> [\n    ...     len(c)\n    ...     for c in sorted(nx.weakly_connected_components(G), key=len, reverse=True)\n    ... ]\n    [4, 3]\n\n    If you only want the largest component, it's more efficient to\n    use max instead of sort:\n\n    >>> largest_cc = max(nx.weakly_connected_components(G), key=len)\n\n    See Also\n    --------\n    connected_components\n    strongly_connected_components\n\n    Notes\n    -----\n    For directed graphs only.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef is_weakly_connected(G):\n\"\"\"Test directed graph for weak connectivity.\n\n    A directed graph is weakly connected if and only if the graph\n    is connected when the direction of the edge between nodes is ignored.\n\n    Note that if a graph is strongly connected (i.e. the graph is connected\n    even when we account for directionality), it is by definition weakly\n    connected as well.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        A directed graph.\n\n    Returns\n    -------\n    connected : bool\n        True if the graph is weakly connected, False otherwise.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(0, 1), (2, 1)])\n    >>> G.add_node(3)\n    >>> nx.is_weakly_connected(G)  # node 3 is not connected to the graph\n    False\n    >>> G.add_edge(2, 3)\n    >>> nx.is_weakly_connected(G)\n    True\n\n    See Also\n    --------\n    is_strongly_connected\n    is_semiconnected\n    is_connected\n    is_biconnected\n    weakly_connected_components\n\n    Notes\n    -----\n    For directed graphs only.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_biconnected(G):\n\"\"\"Returns True if the graph is biconnected, False otherwise.\n\n    A graph is biconnected if, and only if, it cannot be disconnected by\n    removing only one node (and all edges incident on that node).  If\n    removing a node increases the number of disconnected components\n    in the graph, that node is called an articulation point, or cut\n    vertex.  A biconnected graph has no articulation points.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        An undirected graph.\n\n    Returns\n    -------\n    biconnected : bool\n        True if the graph is biconnected, False otherwise.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is not undirected.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> print(nx.is_biconnected(G))\n    False\n    >>> G.add_edge(0, 3)\n    >>> print(nx.is_biconnected(G))\n    True\n\n    See Also\n    --------\n    biconnected_components\n    articulation_points\n    biconnected_component_edges\n    is_strongly_connected\n    is_weakly_connected\n    is_connected\n    is_semiconnected\n\n    Notes\n    -----\n    The algorithm to find articulation points and biconnected\n    components is implemented using a non-recursive depth-first-search\n    (DFS) that keeps track of the highest level that back edges reach\n    in the DFS tree.  A node `n` is an articulation point if, and only\n    if, there exists a subtree rooted at `n` such that there is no\n    back edge from any successor of `n` that links to a predecessor of\n    `n` in the DFS tree.  By keeping track of all the edges traversed\n    by the DFS we can obtain the biconnected components because all\n    edges of a bicomponent will be traversed consecutively between\n    articulation points.\n\n    References\n    ----------\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\n       \"Efficient algorithms for graph manipulation\".\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef biconnected_components(G):\n\"\"\"Returns a generator of sets of nodes, one set for each biconnected\n    component of the graph\n\n    Biconnected components are maximal subgraphs such that the removal of a\n    node (and all edges incident on that node) will not disconnect the\n    subgraph. Note that nodes may be part of more than one biconnected\n    component.  Those nodes are articulation points, or cut vertices.  The\n    removal of articulation points will increase the number of connected\n    components of the graph.\n\n    Notice that by convention a dyad is considered a biconnected component.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        An undirected graph.\n\n    Returns\n    -------\n    nodes : generator\n        Generator of sets of nodes, one set for each biconnected component.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is not undirected.\n\n    Examples\n    --------\n    >>> G = nx.lollipop_graph(5, 1)\n    >>> print(nx.is_biconnected(G))\n    False\n    >>> bicomponents = list(nx.biconnected_components(G))\n    >>> len(bicomponents)\n    2\n    >>> G.add_edge(0, 5)\n    >>> print(nx.is_biconnected(G))\n    True\n    >>> bicomponents = list(nx.biconnected_components(G))\n    >>> len(bicomponents)\n    1\n\n    You can generate a sorted list of biconnected components, largest\n    first, using sort.\n\n    >>> G.remove_edge(0, 5)\n    >>> [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]\n    [5, 2]\n\n    If you only want the largest connected component, it's more\n    efficient to use max instead of sort.\n\n    >>> Gc = max(nx.biconnected_components(G), key=len)\n\n    To create the components as subgraphs use:\n    ``(G.subgraph(c).copy() for c in biconnected_components(G))``\n\n    See Also\n    --------\n    is_biconnected\n    articulation_points\n    biconnected_component_edges\n    k_components : this function is a special case where k=2\n    bridge_components : similar to this function, but is defined using\n        2-edge-connectivity instead of 2-node-connectivity.\n\n    Notes\n    -----\n    The algorithm to find articulation points and biconnected\n    components is implemented using a non-recursive depth-first-search\n    (DFS) that keeps track of the highest level that back edges reach\n    in the DFS tree.  A node `n` is an articulation point if, and only\n    if, there exists a subtree rooted at `n` such that there is no\n    back edge from any successor of `n` that links to a predecessor of\n    `n` in the DFS tree.  By keeping track of all the edges traversed\n    by the DFS we can obtain the biconnected components because all\n    edges of a bicomponent will be traversed consecutively between\n    articulation points.\n\n    References\n    ----------\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\n           \"Efficient algorithms for graph manipulation\".\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef attracting_components(G):\n\"\"\"Generates the attracting components in `G`.\n\n    An attracting component in a directed graph `G` is a strongly connected\n    component with the property that a random walker on the graph will never\n    leave the component, once it enters the component.\n\n    The nodes in attracting components can also be thought of as recurrent\n    nodes.  If a random walker enters the attractor containing the node, then\n    the node will be visited infinitely often.\n\n    To obtain induced subgraphs on each component use:\n    ``(G.subgraph(c).copy() for c in attracting_components(G))``\n\n    Parameters\n    ----------\n    G : DiGraph, MultiDiGraph\n        The graph to be analyzed.\n\n    Returns\n    -------\n    attractors : generator of sets\n        A generator of sets of nodes, one for each attracting component of G.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is undirected.\n\n    See Also\n    --------\n    number_attracting_components\n    is_attracting_component\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef is_attracting_component(G):\n\"\"\"Returns True if `G` consists of a single attracting component.\n\n    Parameters\n    ----------\n    G : DiGraph, MultiDiGraph\n        The graph to be analyzed.\n\n    Returns\n    -------\n    attracting : bool\n        True if `G` has a single attracting component. Otherwise, False.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is undirected.\n\n    See Also\n    --------\n    attracting_components\n    number_attracting_components\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef connected_components(G):\n\"\"\"Generate connected components.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       An undirected graph\n\n    Returns\n    -------\n    comp : generator of sets\n       A generator of sets of nodes, one for each component of G.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is directed.\n\n    Examples\n    --------\n    Generate a sorted list of connected components, largest first.\n\n    >>> G = nx.path_graph(4)\n    >>> nx.add_path(G, [10, 11, 12])\n    >>> [len(c) for c in sorted(nx.connected_components(G), key=len, reverse=True)]\n    [4, 3]\n\n    If you only want the largest connected component, it's more\n    efficient to use max instead of sort.\n\n    >>> largest_cc = max(nx.connected_components(G), key=len)\n\n    To create the induced subgraph of each component use:\n\n    >>> S = [G.subgraph(c).copy() for c in nx.connected_components(G)]\n\n    See Also\n    --------\n    strongly_connected_components\n    weakly_connected_components\n\n    Notes\n    -----\n    For undirected graphs only.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_connected(G):\n\"\"\"Returns True if the graph is connected, False otherwise.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n       An undirected graph.\n\n    Returns\n    -------\n    connected : bool\n      True if the graph is connected, false otherwise.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is directed.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> print(nx.is_connected(G))\n    True\n\n    See Also\n    --------\n    is_strongly_connected\n    is_weakly_connected\n    is_semiconnected\n    is_biconnected\n    connected_components\n\n    Notes\n    -----\n    For undirected graphs only.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef strongly_connected_components(G):\n\"\"\"Generate nodes in strongly connected components of graph.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        A directed graph.\n\n    Returns\n    -------\n    comp : generator of sets\n        A generator of sets of nodes, one for each strongly connected\n        component of G.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    Generate a sorted list of strongly connected components, largest first.\n\n    >>> G = nx.cycle_graph(4, create_using=nx.DiGraph())\n    >>> nx.add_cycle(G, [10, 11, 12])\n    >>> [\n    ...     len(c)\n    ...     for c in sorted(nx.strongly_connected_components(G), key=len, reverse=True)\n    ... ]\n    [4, 3]\n\n    If you only want the largest component, it's more efficient to\n    use max instead of sort.\n\n    >>> largest = max(nx.strongly_connected_components(G), key=len)\n\n    See Also\n    --------\n    connected_components\n    weakly_connected_components\n    kosaraju_strongly_connected_components\n\n    Notes\n    -----\n    Uses Tarjan's algorithm[1]_ with Nuutila's modifications[2]_.\n    Nonrecursive version of algorithm.\n\n    References\n    ----------\n    .. [1] Depth-first search and linear graph algorithms, R. Tarjan\n       SIAM Journal of Computing 1(2):146-160, (1972).\n\n    .. [2] On finding the strongly connected components in a directed graph.\n       E. Nuutila and E. Soisalon-Soinen\n       Information Processing Letters 49(1): 9-14, (1994)..\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef number_strongly_connected_components(G):\n\"\"\"Returns number of strongly connected components in graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n       A directed graph.\n\n    Returns\n    -------\n    n : integer\n       Number of strongly connected components\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph(\n    ...     [(0, 1), (1, 2), (2, 0), (2, 3), (4, 5), (3, 4), (5, 6), (6, 3), (6, 7)]\n    ... )\n    >>> nx.number_strongly_connected_components(G)\n    3\n\n    See Also\n    --------\n    strongly_connected_components\n    number_connected_components\n    number_weakly_connected_components\n\n    Notes\n    -----\n    For directed graphs only.\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef condensation(G, scc=None):\n\"\"\"Returns the condensation of G.\n\n    The condensation of G is the graph with each of the strongly connected\n    components contracted into a single node.\n\n    Parameters\n    ----------\n    G : NetworkX DiGraph\n       A directed graph.\n\n    scc:  list or generator (optional, default=None)\n       Strongly connected components. If provided, the elements in\n       `scc` must partition the nodes in `G`. If not provided, it will be\n       calculated as scc=nx.strongly_connected_components(G).\n\n    Returns\n    -------\n    C : NetworkX DiGraph\n       The condensation graph C of G.  The node labels are integers\n       corresponding to the index of the component in the list of\n       strongly connected components of G.  C has a graph attribute named\n       'mapping' with a dictionary mapping the original nodes to the\n       nodes in C to which they belong.  Each node in C also has a node\n       attribute 'members' with the set of original nodes in G that\n       form the SCC that the node in C represents.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    Contracting two sets of strongly connected nodes into two distinct SCC\n    using the barbell graph.\n\n    >>> G = nx.barbell_graph(4, 0)\n    >>> G.remove_edge(3, 4)\n    >>> G = nx.DiGraph(G)\n    >>> H = nx.condensation(G)\n    >>> H.nodes.data()\n    NodeDataView({0: {'members': {0, 1, 2, 3}}, 1: {'members': {4, 5, 6, 7}}})\n    >>> H.graph[\"mapping\"]\n    {0: 0, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1}\n\n    Contracting a complete graph into one single SCC.\n\n    >>> G = nx.complete_graph(7, create_using=nx.DiGraph)\n    >>> H = nx.condensation(G)\n    >>> H.nodes\n    NodeView((0,))\n    >>> H.nodes.data()\n    NodeDataView({0: {'members': {0, 1, 2, 3, 4, 5, 6}}})\n\n    Notes\n    -----\n    After contracting all strongly connected components to a single node,\n    the resulting graph is a directed acyclic graph.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef is_semiconnected(G):\n\"\"\"Returns True if the graph is semiconnected, False otherwise.\n\n    A graph is semiconnected if and only if for any pair of nodes, either one\n    is reachable from the other, or they are mutually reachable.\n\n    This function uses a theorem that states that a DAG is semiconnected\n    if for any topological sort, for node $v_n$ in that sort, there is an\n    edge $(v_i, v_{i+1})$. That allows us to check if a non-DAG `G` is\n    semiconnected by condensing the graph: i.e. constructing a new graph `H`\n    with nodes being the strongly connected components of `G`, and edges\n    (scc_1, scc_2) if there is a edge $(v_1, v_2)$ in `G` for some\n    $v_1 \\in scc_1$ and $v_2 \\in scc_2$. That results in a DAG, so we compute\n    the topological sort of `H` and check if for every $n$ there is an edge\n    $(scc_n, scc_{n+1})$.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A directed graph.\n\n    Returns\n    -------\n    semiconnected : bool\n        True if the graph is semiconnected, False otherwise.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is undirected.\n\n    NetworkXPointlessConcept\n        If the graph is empty.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4, create_using=nx.DiGraph())\n    >>> print(nx.is_semiconnected(G))\n    True\n    >>> G = nx.DiGraph([(1, 2), (3, 2)])\n    >>> print(nx.is_semiconnected(G))\n    False\n\n    See Also\n    --------\n    is_strongly_connected\n    is_weakly_connected\n    is_connected\n    is_biconnected\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "# This additionally tests the @nx._dispatchable mechanism, treating"}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\", returns_graph=True)\ndef contracted_nodes(G, u, v, self_loops=True, copy=True):\n\"\"\"Returns the graph that results from contracting `u` and `v`.\n\n    Node contraction identifies the two nodes as a single node incident to any\n    edge that was incident to the original two nodes.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        The graph whose nodes will be contracted.\n\n    u, v : nodes\n        Must be nodes in `G`.\n\n    self_loops : Boolean\n        If this is True, any edges joining `u` and `v` in `G` become\n        self-loops on the new node in the returned graph.\n\n    copy : Boolean\n        If this is True (default True), make a copy of\n        `G` and return that instead of directly changing `G`.\n\n\n    Returns\n    -------\n    Networkx graph\n        If Copy is True,\n        A new graph object of the same type as `G` (leaving `G` unmodified)\n        with `u` and `v` identified in a single node. The right node `v`\n        will be merged into the node `u`, so only `u` will appear in the\n        returned graph.\n        If copy is False,\n        Modifies `G` with `u` and `v` identified in a single node.\n        The right node `v` will be merged into the node `u`, so\n        only `u` will appear in the returned graph.\n\n    Notes\n    -----\n    For multigraphs, the edge keys for the realigned edges may\n    not be the same as the edge keys for the old edges. This is\n    natural because edge keys are unique only within each pair of nodes.\n\n    For non-multigraphs where `u` and `v` are adjacent to a third node\n    `w`, the edge (`v`, `w`) will be contracted into the edge (`u`,\n    `w`) with its attributes stored into a \"contraction\" attribute.\n\n    This function is also available as `identified_nodes`.\n\n    Examples\n    --------\n    Contracting two nonadjacent nodes of the cycle graph on four nodes `C_4`\n    yields the path graph (ignoring parallel edges):\n\n    >>> G = nx.cycle_graph(4)\n    >>> M = nx.contracted_nodes(G, 1, 3)\n    >>> P3 = nx.path_graph(3)\n    >>> nx.is_isomorphic(M, P3)\n    True\n\n    >>> G = nx.MultiGraph(P3)\n    >>> M = nx.contracted_nodes(G, 0, 2)\n    >>> M.edges\n    MultiEdgeView([(0, 1, 0), (0, 1, 1)])\n\n    >>> G = nx.Graph([(1, 2), (2, 2)])\n    >>> H = nx.contracted_nodes(G, 1, 2, self_loops=False)\n    >>> list(H.nodes())\n    [1]\n    >>> list(H.edges())\n    [(1, 1)]\n\n    In a ``MultiDiGraph`` with a self loop, the in and out edges will\n    be treated separately as edges, so while contracting a node which\n    has a self loop the contraction will add multiple edges:\n\n    >>> G = nx.MultiDiGraph([(1, 2), (2, 2)])\n    >>> H = nx.contracted_nodes(G, 1, 2)\n    >>> list(H.edges())  # edge 1->2, 2->2, 2<-2 from the original Graph G\n    [(1, 1), (1, 1), (1, 1)]\n    >>> H = nx.contracted_nodes(G, 1, 2, self_loops=False)\n    >>> list(H.edges())  # edge 2->2, 2<-2 from the original Graph G\n    [(1, 1), (1, 1)]\n\n    See Also\n    --------\n    contracted_edge\n    quotient_graph\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef edge_dfs(G, source=None, orientation=None):\n\"\"\"A directed, depth-first-search of edges in `G`, beginning at `source`.\n\n    Yield the edges of G in a depth-first-search order continuing until\n    all edges are generated.\n\n    Parameters\n    ----------\n    G : graph\n        A directed/undirected graph/multigraph.\n\n    source : node, list of nodes\n        The node from which the traversal begins. If None, then a source\n        is chosen arbitrarily and repeatedly until all edges from each node in\n        the graph are searched.\n\n    orientation : None | 'original' | 'reverse' | 'ignore' (default: None)\n        For directed graphs and directed multigraphs, edge traversals need not\n        respect the original orientation of the edges.\n        When set to 'reverse' every edge is traversed in the reverse direction.\n        When set to 'ignore', every edge is treated as undirected.\n        When set to 'original', every edge is treated as directed.\n        In all three cases, the yielded edge tuples add a last entry to\n        indicate the direction in which that edge was traversed.\n        If orientation is None, the yielded edge has no direction indicated.\n        The direction is respected, but not reported.\n\n    Yields\n    ------\n    edge : directed edge\n        A directed edge indicating the path taken by the depth-first traversal.\n        For graphs, `edge` is of the form `(u, v)` where `u` and `v`\n        are the tail and head of the edge as determined by the traversal.\n        For multigraphs, `edge` is of the form `(u, v, key)`, where `key` is\n        the key of the edge. When the graph is directed, then `u` and `v`\n        are always in the order of the actual directed edge.\n        If orientation is not None then the edge tuple is extended to include\n        the direction of traversal ('forward' or 'reverse') on that edge.\n\n    Examples\n    --------\n    >>> nodes = [0, 1, 2, 3]\n    >>> edges = [(0, 1), (1, 0), (1, 0), (2, 1), (3, 1)]\n\n    >>> list(nx.edge_dfs(nx.Graph(edges), nodes))\n    [(0, 1), (1, 2), (1, 3)]\n\n    >>> list(nx.edge_dfs(nx.DiGraph(edges), nodes))\n    [(0, 1), (1, 0), (2, 1), (3, 1)]\n\n    >>> list(nx.edge_dfs(nx.MultiGraph(edges), nodes))\n    [(0, 1, 0), (1, 0, 1), (0, 1, 2), (1, 2, 0), (1, 3, 0)]\n\n    >>> list(nx.edge_dfs(nx.MultiDiGraph(edges), nodes))\n    [(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 1, 0), (3, 1, 0)]\n\n    >>> list(nx.edge_dfs(nx.DiGraph(edges), nodes, orientation=\"ignore\"))\n    [(0, 1, 'forward'), (1, 0, 'forward'), (2, 1, 'reverse'), (3, 1, 'reverse')]\n\n    >>> list(nx.edge_dfs(nx.MultiDiGraph(edges), nodes, orientation=\"ignore\"))\n    [(0, 1, 0, 'forward'), (1, 0, 0, 'forward'), (1, 0, 1, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]\n\n    Notes\n    -----\n    The goal of this function is to visit edges. It differs from the more\n    familiar depth-first traversal of nodes, as provided by\n    :func:`~networkx.algorithms.traversal.depth_first_search.dfs_edges`, in\n    that it does not stop once every node has been visited. In a directed graph\n    with edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\n    if not for the functionality provided by this function.\n\n    See Also\n    --------\n    :func:`~networkx.algorithms.traversal.depth_first_search.dfs_edges`\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef dfs_edges(G, source=None, depth_limit=None, *, sort_neighbors=None):\n\"\"\"Iterate over edges in a depth-first-search (DFS).\n\n    Perform a depth-first-search over the nodes of `G` and yield\n    the edges in order. This may not generate all edges in `G`\n    (see `~networkx.algorithms.traversal.edgedfs.edge_dfs`).\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node, optional\n       Specify starting node for depth-first search and yield edges in\n       the component reachable from source.\n\n    depth_limit : int, optional (default=len(G))\n       Specify the maximum search depth.\n\n    sort_neighbors : function (default=None)\n        A function that takes an iterator over nodes as the input, and\n        returns an iterable of the same nodes with a custom ordering.\n        For example, `sorted` will sort the nodes in increasing order.\n\n    Yields\n    ------\n    edge: 2-tuple of nodes\n       Yields edges resulting from the depth-first-search.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> list(nx.dfs_edges(G, source=0))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n    >>> list(nx.dfs_edges(G, source=0, depth_limit=2))\n    [(0, 1), (1, 2)]\n\n    Notes\n    -----\n    If a source is not specified then a source is chosen arbitrarily and\n    repeatedly until all components in the graph are searched.\n\n    The implementation of this function is adapted from David Eppstein's\n    depth-first search function in PADS [1]_, with modifications\n    to allow depth limits based on the Wikipedia article\n    \"Depth-limited search\" [2]_.\n\n    See Also\n    --------\n    dfs_preorder_nodes\n    dfs_postorder_nodes\n    dfs_labeled_edges\n    :func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`\n    :func:`~networkx.algorithms.traversal.breadth_first_search.bfs_edges`\n\n    References\n    ----------\n    .. [1] http://www.ics.uci.edu/~eppstein/PADS\n    .. [2] https://en.wikipedia.org/wiki/Depth-limited_search\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef dfs_predecessors(G, source=None, depth_limit=None, *, sort_neighbors=None):\n\"\"\"Returns dictionary of predecessors in depth-first-search from source.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node, optional\n       Specify starting node for depth-first search.\n       Note that you will get predecessors for all nodes in the\n       component containing `source`. This input only specifies\n       where the DFS starts.\n\n    depth_limit : int, optional (default=len(G))\n       Specify the maximum search depth.\n\n    sort_neighbors : function (default=None)\n        A function that takes an iterator over nodes as the input, and\n        returns an iterable of the same nodes with a custom ordering.\n        For example, `sorted` will sort the nodes in increasing order.\n\n    Returns\n    -------\n    pred: dict\n       A dictionary with nodes as keys and predecessor nodes as values.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> nx.dfs_predecessors(G, source=0)\n    {1: 0, 2: 1, 3: 2}\n    >>> nx.dfs_predecessors(G, source=0, depth_limit=2)\n    {1: 0, 2: 1}\n\n    Notes\n    -----\n    If a source is not specified then a source is chosen arbitrarily and\n    repeatedly until all components in the graph are searched.\n\n    The implementation of this function is adapted from David Eppstein's\n    depth-first search function in `PADS`_, with modifications\n    to allow depth limits based on the Wikipedia article\n    \"`Depth-limited search`_\".\n\n    .. _PADS: http://www.ics.uci.edu/~eppstein/PADS\n    .. _Depth-limited search: https://en.wikipedia.org/wiki/Depth-limited_search\n\n    See Also\n    --------\n    dfs_preorder_nodes\n    dfs_postorder_nodes\n    dfs_labeled_edges\n    :func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`\n    :func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef dfs_postorder_nodes(G, source=None, depth_limit=None, *, sort_neighbors=None):\n\"\"\"Generate nodes in a depth-first-search post-ordering starting at source.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node, optional\n       Specify starting node for depth-first search.\n\n    depth_limit : int, optional (default=len(G))\n       Specify the maximum search depth.\n\n    sort_neighbors : function (default=None)\n        A function that takes an iterator over nodes as the input, and\n        returns an iterable of the same nodes with a custom ordering.\n        For example, `sorted` will sort the nodes in increasing order.\n\n    Returns\n    -------\n    nodes: generator\n       A generator of nodes in a depth-first-search post-ordering.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> list(nx.dfs_postorder_nodes(G, source=0))\n    [4, 3, 2, 1, 0]\n    >>> list(nx.dfs_postorder_nodes(G, source=0, depth_limit=2))\n    [1, 0]\n\n    Notes\n    -----\n    If a source is not specified then a source is chosen arbitrarily and\n    repeatedly until all components in the graph are searched.\n\n    The implementation of this function is adapted from David Eppstein's\n    depth-first search function in `PADS`_, with modifications\n    to allow depth limits based on the Wikipedia article\n    \"`Depth-limited search`_\".\n\n    .. _PADS: http://www.ics.uci.edu/~eppstein/PADS\n    .. _Depth-limited search: https://en.wikipedia.org/wiki/Depth-limited_search\n\n    See Also\n    --------\n    dfs_edges\n    dfs_preorder_nodes\n    dfs_labeled_edges\n    :func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`\n    :func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef dfs_labeled_edges(G, source=None, depth_limit=None, *, sort_neighbors=None):\n\"\"\"Iterate over edges in a depth-first-search (DFS) labeled by type.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node, optional\n       Specify starting node for depth-first search and return edges in\n       the component reachable from source.\n\n    depth_limit : int, optional (default=len(G))\n       Specify the maximum search depth.\n\n    sort_neighbors : function (default=None)\n        A function that takes an iterator over nodes as the input, and\n        returns an iterable of the same nodes with a custom ordering.\n        For example, `sorted` will sort the nodes in increasing order.\n\n    Returns\n    -------\n    edges: generator\n       A generator of triples of the form (*u*, *v*, *d*), where (*u*,\n       *v*) is the edge being explored in the depth-first search and *d*\n       is one of the strings 'forward', 'nontree', 'reverse', or 'reverse-depth_limit'.\n       A 'forward' edge is one in which *u* has been visited but *v* has\n       not. A 'nontree' edge is one in which both *u* and *v* have been\n       visited but the edge is not in the DFS tree. A 'reverse' edge is\n       one in which both *u* and *v* have been visited and the edge is in\n       the DFS tree. When the `depth_limit` is reached via a 'forward' edge,\n       a 'reverse' edge is immediately generated rather than the subtree\n       being explored. To indicate this flavor of 'reverse' edge, the string\n       yielded is 'reverse-depth_limit'.\n\n    Examples\n    --------\n\n    The labels reveal the complete transcript of the depth-first search\n    algorithm in more detail than, for example, :func:`dfs_edges`::\n\n        >>> from pprint import pprint\n        >>>\n        >>> G = nx.DiGraph([(0, 1), (1, 2), (2, 1)])\n        >>> pprint(list(nx.dfs_labeled_edges(G, source=0)))\n        [(0, 0, 'forward'),\n         (0, 1, 'forward'),\n         (1, 2, 'forward'),\n         (2, 1, 'nontree'),\n         (1, 2, 'reverse'),\n         (0, 1, 'reverse'),\n         (0, 0, 'reverse')]\n\n    Notes\n    -----\n    If a source is not specified then a source is chosen arbitrarily and\n    repeatedly until all components in the graph are searched.\n\n    The implementation of this function is adapted from David Eppstein's\n    depth-first search function in `PADS`_, with modifications\n    to allow depth limits based on the Wikipedia article\n    \"`Depth-limited search`_\".\n\n    .. _PADS: http://www.ics.uci.edu/~eppstein/PADS\n    .. _Depth-limited search: https://en.wikipedia.org/wiki/Depth-limited_search\n\n    See Also\n    --------\n    dfs_edges\n    dfs_preorder_nodes\n    dfs_postorder_nodes\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef generic_bfs_edges(G, source, neighbors=None, depth_limit=None):\n\"\"\"Iterate over edges in a breadth-first search.\n\n    The breadth-first search begins at `source` and enqueues the\n    neighbors of newly visited nodes specified by the `neighbors`\n    function.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n        Starting node for the breadth-first search; this function\n        iterates over only those edges in the component reachable from\n        this node.\n\n    neighbors : function\n        A function that takes a newly visited node of the graph as input\n        and returns an *iterator* (not just a list) of nodes that are\n        neighbors of that node with custom ordering. If not specified, this is\n        just the ``G.neighbors`` method, but in general it can be any function\n        that returns an iterator over some or all of the neighbors of a\n        given node, in any order.\n\n    depth_limit : int, optional(default=len(G))\n        Specify the maximum search depth.\n\n    Yields\n    ------\n    edge\n        Edges in the breadth-first search starting from `source`.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(7)\n    >>> list(nx.generic_bfs_edges(G, source=0))\n    [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\n    >>> list(nx.generic_bfs_edges(G, source=2))\n    [(2, 1), (2, 3), (1, 0), (3, 4), (4, 5), (5, 6)]\n    >>> list(nx.generic_bfs_edges(G, source=2, depth_limit=2))\n    [(2, 1), (2, 3), (1, 0), (3, 4)]\n\n    The `neighbors` param can be used to specify the visitation order of each\n    node's neighbors generically. In the following example, we modify the default\n    neighbor to return *odd* nodes first:\n\n    >>> def odd_first(n):\n    ...     return sorted(G.neighbors(n), key=lambda x: x % 2, reverse=True)\n\n    >>> G = nx.star_graph(5)\n    >>> list(nx.generic_bfs_edges(G, source=0))  # Default neighbor ordering\n    [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\n    >>> list(nx.generic_bfs_edges(G, source=0, neighbors=odd_first))\n    [(0, 1), (0, 3), (0, 5), (0, 2), (0, 4)]\n\n    Notes\n    -----\n    This implementation is from `PADS`_, which was in the public domain\n    when it was first accessed in July, 2004.  The modifications\n    to allow depth limits are based on the Wikipedia article\n    \"`Depth-limited-search`_\".\n\n    .. _PADS: http://www.ics.uci.edu/~eppstein/PADS/BFS.py\n    .. _Depth-limited-search: https://en.wikipedia.org/wiki/Depth-limited_search\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef bfs_tree(G, source, reverse=False, depth_limit=None, sort_neighbors=None):\n\"\"\"Returns an oriented tree constructed from of a breadth-first-search\n    starting at source.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n       Specify starting node for breadth-first search\n\n    reverse : bool, optional\n       If True traverse a directed graph in the reverse direction\n\n    depth_limit : int, optional(default=len(G))\n        Specify the maximum search depth\n\n    sort_neighbors : function (default=None)\n        A function that takes an iterator over nodes as the input, and\n        returns an iterable of the same nodes with a custom ordering.\n        For example, `sorted` will sort the nodes in increasing order.\n\n    Returns\n    -------\n    T: NetworkX DiGraph\n       An oriented tree\n\n    Examples\n    --------\n    >>> G = nx.path_graph(3)\n    >>> list(nx.bfs_tree(G, 1).edges())\n    [(1, 0), (1, 2)]\n    >>> H = nx.Graph()\n    >>> nx.add_path(H, [0, 1, 2, 3, 4, 5, 6])\n    >>> nx.add_path(H, [2, 7, 8, 9, 10])\n    >>> sorted(list(nx.bfs_tree(H, source=3, depth_limit=3).edges()))\n    [(1, 0), (2, 1), (2, 7), (3, 2), (3, 4), (4, 5), (5, 6), (7, 8)]\n\n\n    Notes\n    -----\n    Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py\n    by D. Eppstein, July 2004. The modifications\n    to allow depth limits based on the Wikipedia article\n    \"`Depth-limited-search`_\".\n\n    .. _Depth-limited-search: https://en.wikipedia.org/wiki/Depth-limited_search\n\n    See Also\n    --------\n    dfs_tree\n    bfs_edges\n    edge_bfs\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef bfs_successors(G, source, depth_limit=None, sort_neighbors=None):\n\"\"\"Returns an iterator of successors in breadth-first-search from source.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n       Specify starting node for breadth-first search\n\n    depth_limit : int, optional(default=len(G))\n        Specify the maximum search depth\n\n    sort_neighbors : function (default=None)\n        A function that takes an iterator over nodes as the input, and\n        returns an iterable of the same nodes with a custom ordering.\n        For example, `sorted` will sort the nodes in increasing order.\n\n    Returns\n    -------\n    succ: iterator\n       (node, successors) iterator where `successors` is the non-empty list of\n       successors of `node` in a breadth first search from `source`.\n       To appear in the iterator, `node` must have successors.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(3)\n    >>> dict(nx.bfs_successors(G, 0))\n    {0: [1], 1: [2]}\n    >>> H = nx.Graph()\n    >>> H.add_edges_from([(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)])\n    >>> dict(nx.bfs_successors(H, 0))\n    {0: [1, 2], 1: [3, 4], 2: [5, 6]}\n    >>> G = nx.Graph()\n    >>> nx.add_path(G, [0, 1, 2, 3, 4, 5, 6])\n    >>> nx.add_path(G, [2, 7, 8, 9, 10])\n    >>> dict(nx.bfs_successors(G, source=1, depth_limit=3))\n    {1: [0, 2], 2: [3, 7], 3: [4], 7: [8]}\n    >>> G = nx.DiGraph()\n    >>> nx.add_path(G, [0, 1, 2, 3, 4, 5])\n    >>> dict(nx.bfs_successors(G, source=3))\n    {3: [4], 4: [5]}\n\n    Notes\n    -----\n    Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py\n    by D. Eppstein, July 2004.The modifications\n    to allow depth limits based on the Wikipedia article\n    \"`Depth-limited-search`_\".\n\n    .. _Depth-limited-search: https://en.wikipedia.org/wiki/Depth-limited_search\n\n    See Also\n    --------\n    bfs_tree\n    bfs_edges\n    edge_bfs\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef bfs_labeled_edges(G, sources):\n\"\"\"Iterate over edges in a breadth-first search (BFS) labeled by type.\n\n    We generate triple of the form (*u*, *v*, *d*), where (*u*, *v*) is the\n    edge being explored in the breadth-first search and *d* is one of the\n    strings 'tree', 'forward', 'level', or 'reverse'.  A 'tree' edge is one in\n    which *v* is first discovered and placed into the layer below *u*.  A\n    'forward' edge is one in which *u* is on the layer above *v* and *v* has\n    already been discovered.  A 'level' edge is one in which both *u* and *v*\n    occur on the same layer.  A 'reverse' edge is one in which *u* is on a layer\n    below *v*.\n\n    We emit each edge exactly once.  In an undirected graph, 'reverse' edges do\n    not occur, because each is discovered either as a 'tree' or 'forward' edge.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A graph over which to find the layers using breadth-first search.\n\n    sources : node in `G` or list of nodes in `G`\n        Starting nodes for single source or multiple sources breadth-first search\n\n    Yields\n    ------\n    edges: generator\n       A generator of triples (*u*, *v*, *d*) where (*u*, *v*) is the edge being\n       explored and *d* is described above.\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(4, create_using=nx.DiGraph)\n    >>> list(nx.bfs_labeled_edges(G, 0))\n    [(0, 1, 'tree'), (1, 2, 'tree'), (2, 3, 'tree'), (3, 0, 'reverse')]\n    >>> G = nx.complete_graph(3)\n    >>> list(nx.bfs_labeled_edges(G, 0))\n    [(0, 1, 'tree'), (0, 2, 'tree'), (1, 2, 'level')]\n    >>> list(nx.bfs_labeled_edges(G, [0, 1]))\n    [(0, 1, 'level'), (0, 2, 'tree'), (1, 2, 'forward')]\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef bfs_beam_edges(G, source, value, width=None):\n\"\"\"Iterates over edges in a beam search.\n\n    The beam search is a generalized breadth-first search in which only\n    the \"best\" *w* neighbors of the current node are enqueued, where *w*\n    is the beam width and \"best\" is an application-specific\n    heuristic. In general, a beam search with a small beam width might\n    not visit each node in the graph.\n\n    .. note::\n\n       With the default value of ``width=None`` or `width` greater than the\n       maximum degree of the graph, this function equates to a slower\n       version of `~networkx.algorithms.traversal.breadth_first_search.bfs_edges`.\n       All nodes will be visited, though the order of the reported edges may\n       vary. In such cases, `value` has no effect - consider using `bfs_edges`\n       directly instead.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n        Starting node for the breadth-first search; this function\n        iterates over only those edges in the component reachable from\n        this node.\n\n    value : function\n        A function that takes a node of the graph as input and returns a\n        real number indicating how \"good\" it is. A higher value means it\n        is more likely to be visited sooner during the search. When\n        visiting a new node, only the `width` neighbors with the highest\n        `value` are enqueued (in decreasing order of `value`).\n\n    width : int (default = None)\n        The beam width for the search. This is the number of neighbors\n        (ordered by `value`) to enqueue when visiting each new node.\n\n    Yields\n    ------\n    edge\n        Edges in the beam search starting from `source`, given as a pair\n        of nodes.\n\n    Examples\n    --------\n    To give nodes with, for example, a higher centrality precedence\n    during the search, set the `value` function to return the centrality\n    value of the node:\n\n    >>> G = nx.karate_club_graph()\n    >>> centrality = nx.eigenvector_centrality(G)\n    >>> list(nx.bfs_beam_edges(G, source=0, value=centrality.get, width=3))\n    [(0, 2), (0, 1), (0, 8), (2, 32), (1, 13), (8, 33)]\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef edge_bfs(G, source=None, orientation=None):\n\"\"\"A directed, breadth-first-search of edges in `G`, beginning at `source`.\n\n    Yield the edges of G in a breadth-first-search order continuing until\n    all edges are generated.\n\n    Parameters\n    ----------\n    G : graph\n        A directed/undirected graph/multigraph.\n\n    source : node, list of nodes\n        The node from which the traversal begins. If None, then a source\n        is chosen arbitrarily and repeatedly until all edges from each node in\n        the graph are searched.\n\n    orientation : None | 'original' | 'reverse' | 'ignore' (default: None)\n        For directed graphs and directed multigraphs, edge traversals need not\n        respect the original orientation of the edges.\n        When set to 'reverse' every edge is traversed in the reverse direction.\n        When set to 'ignore', every edge is treated as undirected.\n        When set to 'original', every edge is treated as directed.\n        In all three cases, the yielded edge tuples add a last entry to\n        indicate the direction in which that edge was traversed.\n        If orientation is None, the yielded edge has no direction indicated.\n        The direction is respected, but not reported.\n\n    Yields\n    ------\n    edge : directed edge\n        A directed edge indicating the path taken by the breadth-first-search.\n        For graphs, `edge` is of the form `(u, v)` where `u` and `v`\n        are the tail and head of the edge as determined by the traversal.\n        For multigraphs, `edge` is of the form `(u, v, key)`, where `key` is\n        the key of the edge. When the graph is directed, then `u` and `v`\n        are always in the order of the actual directed edge.\n        If orientation is not None then the edge tuple is extended to include\n        the direction of traversal ('forward' or 'reverse') on that edge.\n\n    Examples\n    --------\n    >>> nodes = [0, 1, 2, 3]\n    >>> edges = [(0, 1), (1, 0), (1, 0), (2, 0), (2, 1), (3, 1)]\n\n    >>> list(nx.edge_bfs(nx.Graph(edges), nodes))\n    [(0, 1), (0, 2), (1, 2), (1, 3)]\n\n    >>> list(nx.edge_bfs(nx.DiGraph(edges), nodes))\n    [(0, 1), (1, 0), (2, 0), (2, 1), (3, 1)]\n\n    >>> list(nx.edge_bfs(nx.MultiGraph(edges), nodes))\n    [(0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 2, 0), (1, 2, 0), (1, 3, 0)]\n\n    >>> list(nx.edge_bfs(nx.MultiDiGraph(edges), nodes))\n    [(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 0, 0), (2, 1, 0), (3, 1, 0)]\n\n    >>> list(nx.edge_bfs(nx.DiGraph(edges), nodes, orientation=\"ignore\"))\n    [(0, 1, 'forward'), (1, 0, 'reverse'), (2, 0, 'reverse'), (2, 1, 'reverse'), (3, 1, 'reverse')]\n\n    >>> list(nx.edge_bfs(nx.MultiDiGraph(edges), nodes, orientation=\"ignore\"))\n    [(0, 1, 0, 'forward'), (1, 0, 0, 'reverse'), (1, 0, 1, 'reverse'), (2, 0, 0, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]\n\n    Notes\n    -----\n    The goal of this function is to visit edges. It differs from the more\n    familiar breadth-first-search of nodes, as provided by\n    :func:`networkx.algorithms.traversal.breadth_first_search.bfs_edges`, in\n    that it does not stop once every node has been visited. In a directed graph\n    with edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\n    if not for the functionality provided by this function.\n\n    The naming of this function is very similar to bfs_edges. The difference\n    is that 'edge_bfs' yields edges even if they extend back to an already\n    explored node while 'bfs_edges' yields the edges of the tree that results\n    from a breadth-first-search (BFS) so no edges are reported if they extend\n    to already explored nodes. That means 'edge_bfs' reports all edges while\n    'bfs_edges' only report those traversed by a node-based BFS. Yet another\n    description is that 'bfs_edges' reports the edges traversed during BFS\n    while 'edge_bfs' reports all edges in the order they are explored.\n\n    See Also\n    --------\n    bfs_edges\n    bfs_tree\n    edge_dfs\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "# This additionally tests the @nx._dispatchable mechanism, treating"}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef greedy_color(G, strategy=\"largest_first\", interchange=False):\n\"\"\"Color a graph using various strategies of greedy graph coloring.\n\n    Attempts to color a graph using as few colors as possible, where no\n    neighbors of a node can have same color as the node itself. The\n    given strategy determines the order in which nodes are colored.\n\n    The strategies are described in [1]_, and smallest-last is based on\n    [2]_.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    strategy : string or function(G, colors)\n       A function (or a string representing a function) that provides\n       the coloring strategy, by returning nodes in the ordering they\n       should be colored. ``G`` is the graph, and ``colors`` is a\n       dictionary of the currently assigned colors, keyed by nodes. The\n       function must return an iterable over all the nodes in ``G``.\n\n       If the strategy function is an iterator generator (that is, a\n       function with ``yield`` statements), keep in mind that the\n       ``colors`` dictionary will be updated after each ``yield``, since\n       this function chooses colors greedily.\n\n       If ``strategy`` is a string, it must be one of the following,\n       each of which represents one of the built-in strategy functions.\n\n       * ``'largest_first'``\n       * ``'random_sequential'``\n       * ``'smallest_last'``\n       * ``'independent_set'``\n       * ``'connected_sequential_bfs'``\n       * ``'connected_sequential_dfs'``\n       * ``'connected_sequential'`` (alias for the previous strategy)\n       * ``'saturation_largest_first'``\n       * ``'DSATUR'`` (alias for the previous strategy)\n\n    interchange: bool\n       Will use the color interchange algorithm described by [3]_ if set\n       to ``True``.\n\n       Note that ``saturation_largest_first`` and ``independent_set``\n       do not work with interchange. Furthermore, if you use\n       interchange with your own strategy function, you cannot rely\n       on the values in the ``colors`` argument.\n\n    Returns\n    -------\n    A dictionary with keys representing nodes and values representing\n    corresponding coloring.\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(4)\n    >>> d = nx.coloring.greedy_color(G, strategy=\"largest_first\")\n    >>> d in [{0: 0, 1: 1, 2: 0, 3: 1}, {0: 1, 1: 0, 2: 1, 3: 0}]\n    True\n\n    Raises\n    ------\n    NetworkXPointlessConcept\n        If ``strategy`` is ``saturation_largest_first`` or\n        ``independent_set`` and ``interchange`` is ``True``.\n\n    References\n    ----------\n    .. [1] Adrian Kosowski, and Krzysztof Manuszewski,\n       Classical Coloring of Graphs, Graph Colorings, 2-19, 2004.\n       ISBN 0-8218-3458-4.\n    .. [2] David W. Matula, and Leland L. Beck, \"Smallest-last\n       ordering and clustering and graph coloring algorithms.\" *J. ACM* 30,\n       3 (July 1983), 417\u2013427. <https://doi.org/10.1145/2402.322385>\n    .. [3] Maciej M. Sys\u0142o, Narsingh Deo, Janusz S. Kowalik,\n       Discrete Optimization Algorithms with Pascal Programs, 415-424, 1983.\n       ISBN 0-486-45353-7.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_coloring(G, coloring):\n\"\"\"Determine if the coloring is a valid coloring for the graph G.\"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(mutates_input=True)\ndef pad_graph(G, num_colors):\n\"\"\"Add a disconnected complete clique K_p such that the number of nodes in\n    the graph becomes a multiple of `num_colors`.\n\n    Assumes that the graph's nodes are labelled using integers.\n\n    Returns the number of nodes with each color.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef equitable_color(G, num_colors):\n\"\"\"Provides an equitable coloring for nodes of `G`.\n\n    Attempts to color a graph using `num_colors` colors, where no neighbors of\n    a node can have same color as the node itself and the number of nodes with\n    each color differ by at most 1. `num_colors` must be greater than the\n    maximum degree of `G`. The algorithm is described in [1]_ and has\n    complexity O(num_colors * n**2).\n\n    Parameters\n    ----------\n    G : networkX graph\n       The nodes of this graph will be colored.\n\n    num_colors : number of colors to use\n       This number must be at least one more than the maximum degree of nodes\n       in the graph.\n\n    Returns\n    -------\n    A dictionary with keys representing nodes and values representing\n    corresponding coloring.\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(4)\n    >>> nx.coloring.equitable_color(G, num_colors=3)  # doctest: +SKIP\n    {0: 2, 1: 1, 2: 2, 3: 0}\n\n    Raises\n    ------\n    NetworkXAlgorithmError\n        If `num_colors` is not at least the maximum degree of the graph `G`\n\n    References\n    ----------\n    .. [1] Kierstead, H. A., Kostochka, A. V., Mydlarz, M., & Szemer\u00e9di, E.\n        (2010). A fast algorithm for equitable coloring. Combinatorica, 30(2),\n        217-224.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(returns_graph=True)\ndef junction_tree(G):\n\"\"\"Returns a junction tree of a given graph.\n\n    A junction tree (or clique tree) is constructed from a (un)directed graph G.\n    The tree is constructed based on a moralized and triangulated version of G.\n    The tree's nodes consist of maximal cliques and sepsets of the revised graph.\n    The sepset of two cliques is the intersection of the nodes of these cliques,\n    e.g. the sepset of (A,B,C) and (A,C,E,F) is (A,C). These nodes are often called\n    \"variables\" in this literature. The tree is bipartite with each sepset\n    connected to its two cliques.\n\n    Junction Trees are not unique as the order of clique consideration determines\n    which sepsets are included.\n\n    The junction tree algorithm consists of five steps [1]_:\n\n    1. Moralize the graph\n    2. Triangulate the graph\n    3. Find maximal cliques\n    4. Build the tree from cliques, connecting cliques with shared\n       nodes, set edge-weight to number of shared variables\n    5. Find maximum spanning tree\n\n\n    Parameters\n    ----------\n    G : networkx.Graph\n        Directed or undirected graph.\n\n    Returns\n    -------\n    junction_tree : networkx.Graph\n        The corresponding junction tree of `G`.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        Raised if `G` is an instance of `MultiGraph` or `MultiDiGraph`.\n\n    References\n    ----------\n    .. [1] Junction tree algorithm:\n       https://en.wikipedia.org/wiki/Junction_tree_algorithm\n\n    .. [2] Finn V. Jensen and Frank Jensen. 1994. Optimal\n       junction trees. In Proceedings of the Tenth international\n       conference on Uncertainty in artificial intelligence (UAI\u201994).\n       Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 360\u2013366.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"attr\": \"default\"})\ndef branching_weight(G, attr=\"weight\", default=1):\n\"\"\"\n    Returns the total weight of a branching.\n\n    You must access this function through the networkx.algorithms.tree module.\n\n    Parameters\n    ----------\n    G : DiGraph\n        The directed graph.\n    attr : str\n        The attribute to use as weights. If None, then each edge will be\n        treated equally with a weight of 1.\n    default : float\n        When `attr` is not None, then if an edge does not have that attribute,\n        `default` specifies what value it should take.\n\n    Returns\n    -------\n    weight: int or float\n        The total weight of the branching.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph()\n    >>> G.add_weighted_edges_from([(0, 1, 2), (1, 2, 4), (2, 3, 3), (3, 4, 2)])\n    >>> nx.tree.branching_weight(G)\n    11\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(preserve_edge_attrs=True, returns_graph=True)"}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef is_arborescence(G):\n\"\"\"\n    Returns True if `G` is an arborescence.\n\n    An arborescence is a directed tree with maximum in-degree equal to 1.\n\n    Parameters\n    ----------\n    G : graph\n        The graph to test.\n\n    Returns\n    -------\n    b : bool\n        A boolean that is True if `G` is an arborescence.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(0, 1), (0, 2), (2, 3), (3, 4)])\n    >>> nx.is_arborescence(G)\n    True\n    >>> G.remove_edge(0, 1)\n    >>> G.add_edge(1, 2)  # maximum in-degree is 2\n    >>> nx.is_arborescence(G)\n    False\n\n    Notes\n    -----\n    In another convention, an arborescence is known as a *tree*.\n\n    See Also\n    --------\n    is_tree\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_forest(G):\n\"\"\"\n    Returns True if `G` is a forest.\n\n    A forest is a graph with no undirected cycles.\n\n    For directed graphs, `G` is a forest if the underlying graph is a forest.\n    The underlying graph is obtained by treating each directed edge as a single\n    undirected edge in a multigraph.\n\n    Parameters\n    ----------\n    G : graph\n        The graph to test.\n\n    Returns\n    -------\n    b : bool\n        A boolean that is True if `G` is a forest.\n\n    Raises\n    ------\n    NetworkXPointlessConcept\n        If `G` is empty.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> G.add_edges_from([(1, 2), (1, 3), (2, 4), (2, 5)])\n    >>> nx.is_forest(G)\n    True\n    >>> G.add_edge(4, 1)\n    >>> nx.is_forest(G)\n    False\n\n    Notes\n    -----\n    In another convention, a directed forest is known as a *polyforest* and\n    then *forest* corresponds to a *branching*.\n\n    See Also\n    --------\n    is_branching\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=None, returns_graph=True)\ndef join_trees(rooted_trees, *, label_attribute=None, first_label=0):\n\"\"\"Returns a new rooted tree made by joining `rooted_trees`\n\n    Constructs a new tree by joining each tree in `rooted_trees`.\n    A new root node is added and connected to each of the roots\n    of the input trees. While copying the nodes from the trees,\n    relabeling to integers occurs. If the `label_attribute` is provided,\n    the old node labels will be stored in the new tree under this attribute.\n\n    Parameters\n    ----------\n    rooted_trees : list\n        A list of pairs in which each left element is a NetworkX graph\n        object representing a tree and each right element is the root\n        node of that tree. The nodes of these trees will be relabeled to\n        integers.\n\n    label_attribute : str\n        If provided, the old node labels will be stored in the new tree\n        under this node attribute. If not provided, the original labels\n        of the nodes in the input trees are not stored.\n\n    first_label : int, optional (default=0)\n        Specifies the label for the new root node. If provided, the root node of the joined tree\n        will have this label. If not provided, the root node will default to a label of 0.\n\n    Returns\n    -------\n    NetworkX graph\n        The rooted tree resulting from joining the provided `rooted_trees`. The new tree has a root node\n        labeled as specified by `first_label` (defaulting to 0 if not provided). Subtrees from the input\n        `rooted_trees` are attached to this new root node. Each non-root node, if the `label_attribute`\n        is provided, has an attribute that indicates the original label of the node in the input tree.\n\n    Notes\n    -----\n    Trees are stored in NetworkX as NetworkX Graphs. There is no specific\n    enforcement of the fact that these are trees. Testing for each tree\n    can be done using :func:`networkx.is_tree`.\n\n    Graph, edge, and node attributes are propagated from the given\n    rooted trees to the created tree. If there are any overlapping graph\n    attributes, those from later trees will overwrite those from earlier\n    trees in the tuple of positional arguments.\n\n    Examples\n    --------\n    Join two full balanced binary trees of height *h* to get a full\n    balanced binary tree of depth *h* + 1::\n\n        >>> h = 4\n        >>> left = nx.balanced_tree(2, h)\n        >>> right = nx.balanced_tree(2, h)\n        >>> joined_tree = nx.join_trees([(left, 0), (right, 0)])\n        >>> nx.is_isomorphic(joined_tree, nx.balanced_tree(2, h + 1))\n        True\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\", preserve_edge_attrs=\"data\")\ndef prim_mst_edges(G, minimum, weight=\"weight\", keys=True, data=True, ignore_nan=False):\n\"\"\"Iterate over edges of Prim's algorithm min/max spanning tree.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        The graph holding the tree of interest.\n\n    minimum : bool (default: True)\n        Find the minimum (True) or maximum (False) spanning tree.\n\n    weight : string (default: 'weight')\n        The name of the edge attribute holding the edge weights.\n\n    keys : bool (default: True)\n        If `G` is a multigraph, `keys` controls whether edge keys ar yielded.\n        Otherwise `keys` is ignored.\n\n    data : bool (default: True)\n        Flag for whether to yield edge attribute dicts.\n        If True, yield edges `(u, v, d)`, where `d` is the attribute dict.\n        If False, yield edges `(u, v)`.\n\n    ignore_nan : bool (default: False)\n        If a NaN is found as an edge weight normally an exception is raised.\n        If `ignore_nan is True` then that edge is ignored instead.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)\ndef maximum_spanning_tree(G, weight=\"weight\", algorithm=\"kruskal\", ignore_nan=False):\n\"\"\"Returns a maximum spanning tree or forest on an undirected graph `G`.\n\n    Parameters\n    ----------\n    G : undirected graph\n        An undirected graph. If `G` is connected, then the algorithm finds a\n        spanning tree. Otherwise, a spanning forest is found.\n\n    weight : str\n       Data key to use for edge weights.\n\n    algorithm : string\n       The algorithm to use when finding a maximum spanning tree. Valid\n       choices are 'kruskal', 'prim', or 'boruvka'. The default is\n       'kruskal'.\n\n    ignore_nan : bool (default: False)\n        If a NaN is found as an edge weight normally an exception is raised.\n        If `ignore_nan is True` then that edge is ignored instead.\n\n\n    Returns\n    -------\n    G : NetworkX Graph\n       A maximum spanning tree or forest.\n\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(4)\n    >>> G.add_edge(0, 3, weight=2)\n    >>> T = nx.maximum_spanning_tree(G)\n    >>> sorted(T.edges(data=True))\n    [(0, 1, {}), (0, 3, {'weight': 2}), (1, 2, {})]\n\n\n    Notes\n    -----\n    For Bor\u016fvka's algorithm, each edge must have a weight attribute, and\n    each edge weight must be distinct.\n\n    For the other algorithms, if the graph edges do not have a weight\n    attribute a default weight of 1 will be used.\n\n    There may be more than one tree with the same minimum or maximum weight.\n    See :mod:`networkx.tree.recognition` for more detailed definitions.\n\n    Isolated nodes with self-loops are in the tree as edgeless isolated nodes.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef number_of_spanning_trees(G, *, root=None, weight=None):\n\"\"\"Returns the number of spanning trees in `G`.\n\n    A spanning tree for an undirected graph is a tree that connects\n    all nodes in the graph. For a directed graph, the analog of a\n    spanning tree is called a (spanning) arborescence. The arborescence\n    includes a unique directed path from the `root` node to each other node.\n    The graph must be weakly connected, and the root must be a node\n    that includes all nodes as successors [3]_. Note that to avoid\n    discussing sink-roots and reverse-arborescences, we have reversed\n    the edge orientation from [3]_ and use the in-degree laplacian.\n\n    This function (when `weight` is `None`) returns the number of\n    spanning trees for an undirected graph and the number of\n    arborescences from a single root node for a directed graph.\n    When `weight` is the name of an edge attribute which holds the\n    weight value of each edge, the function returns the sum over\n    all trees of the multiplicative weight of each tree. That is,\n    the weight of the tree is the product of its edge weights.\n\n    Kirchoff's Tree Matrix Theorem states that any cofactor of the\n    Laplacian matrix of a graph is the number of spanning trees in the\n    graph. (Here we use cofactors for a diagonal entry so that the\n    cofactor becomes the determinant of the matrix with one row\n    and its matching column removed.) For a weighted Laplacian matrix,\n    the cofactor is the sum across all spanning trees of the\n    multiplicative weight of each tree. That is, the weight of each\n    tree is the product of its edge weights. The theorem is also\n    known as Kirchhoff's theorem [1]_ and the Matrix-Tree theorem [2]_.\n\n    For directed graphs, a similar theorem (Tutte's Theorem) holds with\n    the cofactor chosen to be the one with row and column removed that\n    correspond to the root. The cofactor is the number of arborescences\n    with the specified node as root. And the weighted version gives the\n    sum of the arborescence weights with root `root`. The arborescence\n    weight is the product of its edge weights.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    root : node\n       A node in the directed graph `G` that has all nodes as descendants.\n       (This is ignored for undirected graphs.)\n\n    weight : string or None, optional (default=None)\n        The name of the edge attribute holding the edge weight.\n        If `None`, then each edge is assumed to have a weight of 1.\n\n    Returns\n    -------\n    Number\n        Undirected graphs:\n            The number of spanning trees of the graph `G`.\n            Or the sum of all spanning tree weights of the graph `G`\n            where the weight of a tree is the product of its edge weights.\n        Directed graphs:\n            The number of arborescences of `G` rooted at node `root`.\n            Or the sum of all arborescence weights of the graph `G` with\n            specified root where the weight of an arborescence is the product\n            of its edge weights.\n\n    Raises\n    ------\n    NetworkXPointlessConcept\n        If `G` does not contain any nodes.\n\n    NetworkXError\n        If the graph `G` is directed and the root node\n        is not specified or is not in G.\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> round(nx.number_of_spanning_trees(G))\n    125\n\n    >>> G = nx.Graph()\n    >>> G.add_edge(1, 2, weight=2)\n    >>> G.add_edge(1, 3, weight=1)\n    >>> G.add_edge(2, 3, weight=1)\n    >>> round(nx.number_of_spanning_trees(G, weight=\"weight\"))\n    5\n\n    Notes\n    -----\n    Self-loops are excluded. Multi-edges are contracted in one edge\n    equal to the sum of the weights.\n\n    References\n    ----------\n    .. [1] Wikipedia\n       \"Kirchhoff's theorem.\"\n       https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem\n    .. [2] Kirchhoff, G. R.\n        \u00dcber die Aufl\u00f6sung der Gleichungen, auf welche man\n        bei der Untersuchung der linearen Vertheilung\n        Galvanischer Str\u00f6me gef\u00fchrt wird\n        Annalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.\n    .. [3] Margoliash, J.\n        \"Matrix-Tree Theorem for Directed Graphs\"\n        https://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=\"T\")\ndef to_nested_tuple(T, root, canonical_form=False):\n\"\"\"Returns a nested tuple representation of the given tree.\n\n    The nested tuple representation of a tree is defined\n    recursively. The tree with one node and no edges is represented by\n    the empty tuple, ``()``. A tree with ``k`` subtrees is represented\n    by a tuple of length ``k`` in which each element is the nested tuple\n    representation of a subtree.\n\n    Parameters\n    ----------\n    T : NetworkX graph\n        An undirected graph object representing a tree.\n\n    root : node\n        The node in ``T`` to interpret as the root of the tree.\n\n    canonical_form : bool\n        If ``True``, each tuple is sorted so that the function returns\n        a canonical form for rooted trees. This means \"lighter\" subtrees\n        will appear as nested tuples before \"heavier\" subtrees. In this\n        way, each isomorphic rooted tree has the same nested tuple\n        representation.\n\n    Returns\n    -------\n    tuple\n        A nested tuple representation of the tree.\n\n    Notes\n    -----\n    This function is *not* the inverse of :func:`from_nested_tuple`; the\n    only guarantee is that the rooted trees are isomorphic.\n\n    See also\n    --------\n    from_nested_tuple\n    to_prufer_sequence\n\n    Examples\n    --------\n    The tree need not be a balanced binary tree::\n\n        >>> T = nx.Graph()\n        >>> T.add_edges_from([(0, 1), (0, 2), (0, 3)])\n        >>> T.add_edges_from([(1, 4), (1, 5)])\n        >>> T.add_edges_from([(3, 6), (3, 7)])\n        >>> root = 0\n        >>> nx.to_nested_tuple(T, root)\n        (((), ()), (), ((), ()))\n\n    Continuing the above example, if ``canonical_form`` is ``True``, the\n    nested tuples will be sorted::\n\n        >>> nx.to_nested_tuple(T, root, canonical_form=True)\n        ((), ((), ()), ((), ()))\n\n    Even the path graph can be interpreted as a tree::\n\n        >>> T = nx.path_graph(4)\n        >>> root = 0\n        >>> nx.to_nested_tuple(T, root)\n        ((((),),),)\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs=\"T\")\ndef to_prufer_sequence(T):\n\"\"\"Returns the Pr\u00fcfer sequence of the given tree.\n\n    A *Pr\u00fcfer sequence* is a list of *n* - 2 numbers between 0 and\n    *n* - 1, inclusive. The tree corresponding to a given Pr\u00fcfer\n    sequence can be recovered by repeatedly joining a node in the\n    sequence with a node with the smallest potential degree according to\n    the sequence.\n\n    Parameters\n    ----------\n    T : NetworkX graph\n        An undirected graph object representing a tree.\n\n    Returns\n    -------\n    list\n        The Pr\u00fcfer sequence of the given tree.\n\n    Raises\n    ------\n    NetworkXPointlessConcept\n        If the number of nodes in `T` is less than two.\n\n    NotATree\n        If `T` is not a tree.\n\n    KeyError\n        If the set of nodes in `T` is not {0, \u2026, *n* - 1}.\n\n    Notes\n    -----\n    There is a bijection from labeled trees to Pr\u00fcfer sequences. This\n    function is the inverse of the :func:`from_prufer_sequence`\n    function.\n\n    Sometimes Pr\u00fcfer sequences use nodes labeled from 1 to *n* instead\n    of from 0 to *n* - 1. This function requires nodes to be labeled in\n    the latter form. You can use :func:`~networkx.relabel_nodes` to\n    relabel the nodes of your tree to the appropriate format.\n\n    This implementation is from [1]_ and has a running time of\n    $O(n)$.\n\n    See also\n    --------\n    to_nested_tuple\n    from_prufer_sequence\n\n    References\n    ----------\n    .. [1] Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n           \"An optimal algorithm for Prufer codes.\"\n           *Journal of Software Engineering and Applications* 2.02 (2009): 111.\n           <https://doi.org/10.4236/jsea.2009.22016>\n\n    Examples\n    --------\n    There is a bijection between Pr\u00fcfer sequences and labeled trees, so\n    this function is the inverse of the :func:`from_prufer_sequence`\n    function:\n\n    >>> edges = [(0, 3), (1, 3), (2, 3), (3, 4), (4, 5)]\n    >>> tree = nx.Graph(edges)\n    >>> sequence = nx.to_prufer_sequence(tree)\n    >>> sequence\n    [3, 3, 3, 4]\n    >>> tree2 = nx.from_prufer_sequence(sequence)\n    >>> list(tree2.edges()) == edges\n    True\n\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(name=\"bipartite_degree_centrality\")\ndef degree_centrality(G, nodes):\n\"\"\"Compute the degree centrality for nodes in a bipartite network.\n\n    The degree centrality for a node `v` is the fraction of nodes\n    connected to it.\n\n    Parameters\n    ----------\n    G : graph\n       A bipartite network\n\n    nodes : list or container\n      Container with all nodes in one bipartite node set.\n\n    Returns\n    -------\n    centrality : dictionary\n       Dictionary keyed by node with bipartite degree centrality as the value.\n\n    Examples\n    --------\n    >>> G = nx.wheel_graph(5)\n    >>> top_nodes = {0, 1, 2}\n    >>> nx.bipartite.degree_centrality(G, nodes=top_nodes)\n    {0: 2.0, 1: 1.5, 2: 1.5, 3: 1.0, 4: 1.0}\n\n    See Also\n    --------\n    betweenness_centrality\n    closeness_centrality\n    :func:`~networkx.algorithms.bipartite.basic.sets`\n    :func:`~networkx.algorithms.bipartite.basic.is_bipartite`\n\n    Notes\n    -----\n    The nodes input parameter must contain all nodes in one bipartite node set,\n    but the dictionary returned contains all nodes from both bipartite node\n    sets. See :mod:`bipartite documentation <networkx.algorithms.bipartite>`\n    for further details on how bipartite graphs are handled in NetworkX.\n\n    For unipartite networks, the degree centrality values are\n    normalized by dividing by the maximum possible degree (which is\n    `n-1` where `n` is the number of nodes in G).\n\n    In the bipartite case, the maximum possible degree of a node in a\n    bipartite node set is the number of nodes in the opposite node set\n    [1]_.  The degree centrality for a node `v` in the bipartite\n    sets `U` with `n` nodes and `V` with `m` nodes is\n\n    .. math::\n\n        d_{v} = \\frac{deg(v)}{m}, \\mbox{for} v \\in U ,\n\n        d_{v} = \\frac{deg(v)}{n}, \\mbox{for} v \\in V ,\n\n\n    where `deg(v)` is the degree of node `v`.\n\n    References\n    ----------\n    .. [1] Borgatti, S.P. and Halgin, D. In press. \"Analyzing Affiliation\n        Networks\". In Carrington, P. and Scott, J. (eds) The Sage Handbook\n        of Social Network Analysis. Sage Publications.\n        https://dx.doi.org/10.4135/9781446294413.n28\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(name=\"bipartite_closeness_centrality\")\ndef closeness_centrality(G, nodes, normalized=True):\n\"\"\"Compute the closeness centrality for nodes in a bipartite network.\n\n    The closeness of a node is the distance to all other nodes in the\n    graph or in the case that the graph is not connected to all other nodes\n    in the connected component containing that node.\n\n    Parameters\n    ----------\n    G : graph\n        A bipartite network\n\n    nodes : list or container\n        Container with all nodes in one bipartite node set.\n\n    normalized : bool, optional\n      If True (default) normalize by connected component size.\n\n    Returns\n    -------\n    closeness : dictionary\n        Dictionary keyed by node with bipartite closeness centrality\n        as the value.\n\n    Examples\n    --------\n    >>> G = nx.wheel_graph(5)\n    >>> top_nodes = {0, 1, 2}\n    >>> nx.bipartite.closeness_centrality(G, nodes=top_nodes)\n    {0: 1.5, 1: 1.2, 2: 1.2, 3: 1.0, 4: 1.0}\n\n    See Also\n    --------\n    betweenness_centrality\n    degree_centrality\n    :func:`~networkx.algorithms.bipartite.basic.sets`\n    :func:`~networkx.algorithms.bipartite.basic.is_bipartite`\n\n    Notes\n    -----\n    The nodes input parameter must contain all nodes in one bipartite node set,\n    but the dictionary returned contains all nodes from both node sets.\n    See :mod:`bipartite documentation <networkx.algorithms.bipartite>`\n    for further details on how bipartite graphs are handled in NetworkX.\n\n\n    Closeness centrality is normalized by the minimum distance possible.\n    In the bipartite case the minimum distance for a node in one bipartite\n    node set is 1 from all nodes in the other node set and 2 from all\n    other nodes in its own set [1]_. Thus the closeness centrality\n    for node `v`  in the two bipartite sets `U` with\n    `n` nodes and `V` with `m` nodes is\n\n    .. math::\n\n        c_{v} = \\frac{m + 2(n - 1)}{d}, \\mbox{for} v \\in U,\n\n        c_{v} = \\frac{n + 2(m - 1)}{d}, \\mbox{for} v \\in V,\n\n    where `d` is the sum of the distances from `v` to all\n    other nodes.\n\n    Higher values of closeness  indicate higher centrality.\n\n    As in the unipartite case, setting normalized=True causes the\n    values to normalized further to n-1 / size(G)-1 where n is the\n    number of nodes in the connected part of graph containing the\n    node.  If the graph is not completely connected, this algorithm\n    computes the closeness centrality for each connected part\n    separately.\n\n    References\n    ----------\n    .. [1] Borgatti, S.P. and Halgin, D. In press. \"Analyzing Affiliation\n        Networks\". In Carrington, P. and Scott, J. (eds) The Sage Handbook\n        of Social Network Analysis. Sage Publications.\n        https://dx.doi.org/10.4135/9781446294413.n28\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable\ndef maximal_extendability(G):\n\"\"\"Computes the extendability of a graph.\n\n    The extendability of a graph is defined as the maximum $k$ for which `G`\n    is $k$-extendable. Graph `G` is $k$-extendable if and only if `G` has a\n    perfect matching and every set of $k$ independent edges can be extended\n    to a perfect matching in `G`.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        A fully-connected bipartite graph without self-loops\n\n    Returns\n    -------\n    extendability : int\n\n    Raises\n    ------\n    NetworkXError\n       If the graph `G` is disconnected.\n       If the graph `G` is not bipartite.\n       If the graph `G` does not contain a perfect matching.\n       If the residual graph of `G` is not strongly connected.\n\n    Notes\n    -----\n    Definition:\n    Let `G` be a simple, connected, undirected and bipartite graph with a perfect\n    matching M and bipartition (U,V). The residual graph of `G`, denoted by $G_M$,\n    is the graph obtained from G by directing the edges of M from V to U and the\n    edges that do not belong to M from U to V.\n\n    Lemma [1]_ :\n    Let M be a perfect matching of `G`. `G` is $k$-extendable if and only if its residual\n    graph $G_M$ is strongly connected and there are $k$ vertex-disjoint directed\n    paths between every vertex of U and every vertex of V.\n\n    Assuming that input graph `G` is undirected, simple, connected, bipartite and contains\n    a perfect matching M, this function constructs the residual graph $G_M$ of G and\n    returns the minimum value among the maximum vertex-disjoint directed paths between\n    every vertex of U and every vertex of V in $G_M$. By combining the definitions\n    and the lemma, this value represents the extendability of the graph `G`.\n\n    Time complexity O($n^3$ $m^2$)) where $n$ is the number of vertices\n    and $m$ is the number of edges.\n\n    References\n    ----------\n    .. [1] \"A polynomial algorithm for the extendability problem in bipartite graphs\",\n          J. Lakhal, L. Litzler, Information Processing Letters, 1998.\n    .. [2] \"On n-extendible graphs\", M. D. Plummer, Discrete Mathematics, 31:201\u2013210, 1980\n          https://doi.org/10.1016/0012-365X(80)90037-0\n\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(\ndef projected_graph(B, nodes, multigraph=False):\n\"\"\"Returns the projection of B onto one of its node sets.\n\n    Returns the graph G that is the projection of the bipartite graph B\n    onto the specified nodes. They retain their attributes and are connected\n    in G if they have a common neighbor in B.\n\n    Parameters\n    ----------\n    B : NetworkX graph\n      The input graph should be bipartite.\n\n    nodes : list or iterable\n      Nodes to project onto (the \"bottom\" nodes).\n\n    multigraph: bool (default=False)\n       If True return a multigraph where the multiple edges represent multiple\n       shared neighbors.  They edge key in the multigraph is assigned to the\n       label of the neighbor.\n\n    Returns\n    -------\n    Graph : NetworkX graph or multigraph\n       A graph that is the projection onto the given nodes.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> B = nx.path_graph(4)\n    >>> G = bipartite.projected_graph(B, [1, 3])\n    >>> list(G)\n    [1, 3]\n    >>> list(G.edges())\n    [(1, 3)]\n\n    If nodes `a`, and `b` are connected through both nodes 1 and 2 then\n    building a multigraph results in two edges in the projection onto\n    [`a`, `b`]:\n\n    >>> B = nx.Graph()\n    >>> B.add_edges_from([(\"a\", 1), (\"b\", 1), (\"a\", 2), (\"b\", 2)])\n    >>> G = bipartite.projected_graph(B, [\"a\", \"b\"], multigraph=True)\n    >>> print([sorted((u, v)) for u, v in G.edges()])\n    [['a', 'b'], ['a', 'b']]\n\n    Notes\n    -----\n    No attempt is made to verify that the input graph B is bipartite.\n    Returns a simple graph that is the projection of the bipartite graph B\n    onto the set of nodes given in list nodes.  If multigraph=True then\n    a multigraph is returned with an edge for every shared neighbor.\n\n    Directed graphs are allowed as input.  The output will also then\n    be a directed graph with edges if there is a directed path between\n    the nodes.\n\n    The graph and node properties are (shallow) copied to the projected graph.\n\n    See :mod:`bipartite documentation <networkx.algorithms.bipartite>`\n    for further details on how bipartite graphs are handled in NetworkX.\n\n    See Also\n    --------\n    is_bipartite,\n    is_bipartite_node_set,\n    sets,\n    weighted_projected_graph,\n    collaboration_weighted_projected_graph,\n    overlap_weighted_projected_graph,\n    generic_weighted_projected_graph\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(graphs=\"B\", returns_graph=True)\ndef collaboration_weighted_projected_graph(B, nodes):\n\"\"\"Newman's weighted projection of B onto one of its node sets.\n\n    The collaboration weighted projection is the projection of the\n    bipartite network B onto the specified nodes with weights assigned\n    using Newman's collaboration model [1]_:\n\n    .. math::\n\n        w_{u, v} = \\sum_k \\frac{\\delta_{u}^{k} \\delta_{v}^{k}}{d_k - 1}\n\n    where `u` and `v` are nodes from the bottom bipartite node set,\n    and `k` is a node of the top node set.\n    The value `d_k` is the degree of node `k` in the bipartite\n    network and `\\delta_{u}^{k}` is 1 if node `u` is\n    linked to node `k` in the original bipartite graph or 0 otherwise.\n\n    The nodes retain their attributes and are connected in the resulting\n    graph if have an edge to a common node in the original bipartite\n    graph.\n\n    Parameters\n    ----------\n    B : NetworkX graph\n      The input graph should be bipartite.\n\n    nodes : list or iterable\n      Nodes to project onto (the \"bottom\" nodes).\n\n    Returns\n    -------\n    Graph : NetworkX graph\n       A graph that is the projection onto the given nodes.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> B = nx.path_graph(5)\n    >>> B.add_edge(1, 5)\n    >>> G = bipartite.collaboration_weighted_projected_graph(B, [0, 2, 4, 5])\n    >>> list(G)\n    [0, 2, 4, 5]\n    >>> for edge in sorted(G.edges(data=True)):\n    ...     print(edge)\n    (0, 2, {'weight': 0.5})\n    (0, 5, {'weight': 0.5})\n    (2, 4, {'weight': 1.0})\n    (2, 5, {'weight': 0.5})\n\n    Notes\n    -----\n    No attempt is made to verify that the input graph B is bipartite.\n    The graph and node properties are (shallow) copied to the projected graph.\n\n    See :mod:`bipartite documentation <networkx.algorithms.bipartite>`\n    for further details on how bipartite graphs are handled in NetworkX.\n\n    See Also\n    --------\n    is_bipartite,\n    is_bipartite_node_set,\n    sets,\n    weighted_projected_graph,\n    overlap_weighted_projected_graph,\n    generic_weighted_projected_graph,\n    projected_graph\n\n    References\n    ----------\n    .. [1] Scientific collaboration networks: II.\n        Shortest paths, weighted networks, and centrality,\n        M. E. J. Newman, Phys. Rev. E 64, 016132 (2001).\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(graphs=\"B\", preserve_all_attrs=True, returns_graph=True)\ndef generic_weighted_projected_graph(B, nodes, weight_function=None):\n\"\"\"Weighted projection of B with a user-specified weight function.\n\n    The bipartite network B is projected on to the specified nodes\n    with weights computed by a user-specified function.  This function\n    must accept as a parameter the neighborhood sets of two nodes and\n    return an integer or a float.\n\n    The nodes retain their attributes and are connected in the resulting graph\n    if they have an edge to a common node in the original graph.\n\n    Parameters\n    ----------\n    B : NetworkX graph\n        The input graph should be bipartite.\n\n    nodes : list or iterable\n        Nodes to project onto (the \"bottom\" nodes).\n\n    weight_function : function\n        This function must accept as parameters the same input graph\n        that this function, and two nodes; and return an integer or a float.\n        The default function computes the number of shared neighbors.\n\n    Returns\n    -------\n    Graph : NetworkX graph\n       A graph that is the projection onto the given nodes.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> # Define some custom weight functions\n    >>> def jaccard(G, u, v):\n    ...     unbrs = set(G[u])\n    ...     vnbrs = set(G[v])\n    ...     return float(len(unbrs & vnbrs)) / len(unbrs | vnbrs)\n    >>> def my_weight(G, u, v, weight=\"weight\"):\n    ...     w = 0\n    ...     for nbr in set(G[u]) & set(G[v]):\n    ...         w += G[u][nbr].get(weight, 1) + G[v][nbr].get(weight, 1)\n    ...     return w\n    >>> # A complete bipartite graph with 4 nodes and 4 edges\n    >>> B = nx.complete_bipartite_graph(2, 2)\n    >>> # Add some arbitrary weight to the edges\n    >>> for i, (u, v) in enumerate(B.edges()):\n    ...     B.edges[u, v][\"weight\"] = i + 1\n    >>> for edge in B.edges(data=True):\n    ...     print(edge)\n    (0, 2, {'weight': 1})\n    (0, 3, {'weight': 2})\n    (1, 2, {'weight': 3})\n    (1, 3, {'weight': 4})\n    >>> # By default, the weight is the number of shared neighbors\n    >>> G = bipartite.generic_weighted_projected_graph(B, [0, 1])\n    >>> print(list(G.edges(data=True)))\n    [(0, 1, {'weight': 2})]\n    >>> # To specify a custom weight function use the weight_function parameter\n    >>> G = bipartite.generic_weighted_projected_graph(\n    ...     B, [0, 1], weight_function=jaccard\n    ... )\n    >>> print(list(G.edges(data=True)))\n    [(0, 1, {'weight': 1.0})]\n    >>> G = bipartite.generic_weighted_projected_graph(\n    ...     B, [0, 1], weight_function=my_weight\n    ... )\n    >>> print(list(G.edges(data=True)))\n    [(0, 1, {'weight': 10})]\n\n    Notes\n    -----\n    No attempt is made to verify that the input graph B is bipartite.\n    The graph and node properties are (shallow) copied to the projected graph.\n\n    See :mod:`bipartite documentation <networkx.algorithms.bipartite>`\n    for further details on how bipartite graphs are handled in NetworkX.\n\n    See Also\n    --------\n    is_bipartite,\n    is_bipartite_node_set,\n    sets,\n    weighted_projected_graph,\n    collaboration_weighted_projected_graph,\n    overlap_weighted_projected_graph,\n    projected_graph\n\n    \"\"\""}, {"gtype": "[Undirected Bipartite Graph]", "func": "@nx._dispatchable(name=\"bipartite_min_edge_cover\")\ndef min_edge_cover(G, matching_algorithm=None):\n\"\"\"Returns a set of edges which constitutes\n    the minimum edge cover of the graph.\n\n    The smallest edge cover can be found in polynomial time by finding\n    a maximum matching and extending it greedily so that all nodes\n    are covered.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        An undirected bipartite graph.\n\n    matching_algorithm : function\n        A function that returns a maximum cardinality matching in a\n        given bipartite graph. The function must take one input, the\n        graph ``G``, and return a dictionary mapping each node to its\n        mate. If not specified,\n        :func:`~networkx.algorithms.bipartite.matching.hopcroft_karp_matching`\n        will be used. Other possibilities include\n        :func:`~networkx.algorithms.bipartite.matching.eppstein_matching`,\n\n    Returns\n    -------\n    set\n        A set of the edges in a minimum edge cover of the graph, given as\n        pairs of nodes. It contains both the edges `(u, v)` and `(v, u)`\n        for given nodes `u` and `v` among the edges of minimum edge cover.\n\n    Notes\n    -----\n    An edge cover of a graph is a set of edges such that every node of\n    the graph is incident to at least one edge of the set.\n    A minimum edge cover is an edge covering of smallest cardinality.\n\n    Due to its implementation, the worst-case running time of this algorithm\n    is bounded by the worst-case running time of the function\n    ``matching_algorithm``.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef spectral_bipartivity(G, nodes=None, weight=\"weight\"):\n\"\"\"Returns the spectral bipartivity.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nodes : list or container  optional(default is all nodes)\n      Nodes to return value of spectral bipartivity contribution.\n\n    weight : string or None  optional (default = 'weight')\n      Edge data key to use for edge weights. If None, weights set to 1.\n\n    Returns\n    -------\n    sb : float or dict\n       A single number if the keyword nodes is not specified, or\n       a dictionary keyed by node with the spectral bipartivity contribution\n       of that node as the value.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> G = nx.path_graph(4)\n    >>> bipartite.spectral_bipartivity(G)\n    1.0\n\n    Notes\n    -----\n    This implementation uses Numpy (dense) matrices which are not efficient\n    for storing large sparse graphs.\n\n    See Also\n    --------\n    color\n\n    References\n    ----------\n    .. [1] E. Estrada and J. A. Rodr\u00edguez-Vel\u00e1zquez, \"Spectral measures of\n       bipartivity in complex networks\", PhysRev E 72, 046105 (2005)\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(graphs=None, returns_graph=True)\ndef complete_bipartite_graph(n1, n2, create_using=None):\n\"\"\"Returns the complete bipartite graph `K_{n_1,n_2}`.\n\n    The graph is composed of two partitions with nodes 0 to (n1 - 1)\n    in the first and nodes n1 to (n1 + n2 - 1) in the second.\n    Each node in the first is connected to each node in the second.\n\n    Parameters\n    ----------\n    n1, n2 : integer or iterable container of nodes\n        If integers, nodes are from `range(n1)` and `range(n1, n1 + n2)`.\n        If a container, the elements are the nodes.\n    create_using : NetworkX graph instance, (default: nx.Graph)\n       Return graph of this type.\n\n    Notes\n    -----\n    Nodes are the integers 0 to `n1 + n2 - 1` unless either n1 or n2 are\n    containers of nodes. If only one of n1 or n2 are integers, that\n    integer is replaced by `range` of that integer.\n\n    The nodes are assigned the attribute 'bipartite' with the value 0 or 1\n    to indicate which bipartite set the node belongs to.\n\n    This function is not imported in the main namespace.\n    To use it use nx.bipartite.complete_bipartite_graph\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(name=\"bipartite_havel_hakimi_graph\", graphs=None, returns_graph=True)\ndef havel_hakimi_graph(aseq, bseq, create_using=None):\n\"\"\"Returns a bipartite graph from two given degree sequences using a\n    Havel-Hakimi style construction.\n\n    The graph is composed of two partitions. Set A has nodes 0 to\n    (len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\n    Nodes from the set A are connected to nodes in the set B by\n    connecting the highest degree nodes in set A to the highest degree\n    nodes in set B until all stubs are connected.\n\n    Parameters\n    ----------\n    aseq : list\n       Degree sequence for node set A.\n    bseq : list\n       Degree sequence for node set B.\n    create_using : NetworkX graph instance, optional\n       Return graph of this type.\n\n    Notes\n    -----\n    The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\n    If no graph type is specified use MultiGraph with parallel edges.\n    If you want a graph with no parallel edges use create_using=Graph()\n    but then the resulting degree sequences might not be exact.\n\n    The nodes are assigned the attribute 'bipartite' with the value 0 or 1\n    to indicate which bipartite set the node belongs to.\n\n    This function is not imported in the main namespace.\n    To use it use nx.bipartite.havel_hakimi_graph\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(graphs=None, returns_graph=True)\ndef alternating_havel_hakimi_graph(aseq, bseq, create_using=None):\n\"\"\"Returns a bipartite graph from two given degree sequences using\n    an alternating Havel-Hakimi style construction.\n\n    The graph is composed of two partitions. Set A has nodes 0 to\n    (len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\n    Nodes from the set A are connected to nodes in the set B by\n    connecting the highest degree nodes in set A to alternatively the\n    highest and the lowest degree nodes in set B until all stubs are\n    connected.\n\n    Parameters\n    ----------\n    aseq : list\n       Degree sequence for node set A.\n    bseq : list\n       Degree sequence for node set B.\n    create_using : NetworkX graph instance, optional\n       Return graph of this type.\n\n    Notes\n    -----\n    The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\n    If no graph type is specified use MultiGraph with parallel edges.\n    If you want a graph with no parallel edges use create_using=Graph()\n    but then the resulting degree sequences might not be exact.\n\n    The nodes are assigned the attribute 'bipartite' with the value 0 or 1\n    to indicate which bipartite set the node belongs to.\n\n    This function is not imported in the main namespace.\n    To use it use nx.bipartite.alternating_havel_hakimi_graph\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(graphs=None, returns_graph=True)\ndef random_graph(n, m, p, seed=None, directed=False):\n\"\"\"Returns a bipartite random graph.\n\n    This is a bipartite version of the binomial (Erd\u0151s-R\u00e9nyi) graph.\n    The graph is composed of two partitions. Set A has nodes 0 to\n    (n - 1) and set B has nodes n to (n + m - 1).\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes in the first bipartite set.\n    m : int\n        The number of nodes in the second bipartite set.\n    p : float\n        Probability for edge creation.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    directed : bool, optional (default=False)\n        If True return a directed graph\n\n    Notes\n    -----\n    The bipartite random graph algorithm chooses each of the n*m (undirected)\n    or 2*nm (directed) possible edges with probability p.\n\n    This algorithm is $O(n+m)$ where $m$ is the expected number of edges.\n\n    The nodes are assigned the attribute 'bipartite' with the value 0 or 1\n    to indicate which bipartite set the node belongs to.\n\n    This function is not imported in the main namespace.\n    To use it use nx.bipartite.random_graph\n\n    See Also\n    --------\n    gnp_random_graph, configuration_model\n\n    References\n    ----------\n    .. [1] Vladimir Batagelj and Ulrik Brandes,\n       \"Efficient generation of large random networks\",\n       Phys. Rev. E, 71, 036113, 2005.\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable\ndef node_redundancy(G, nodes=None):\n\"\"\"Computes the node redundancy coefficients for the nodes in the bipartite\n    graph `G`.\n\n    The redundancy coefficient of a node `v` is the fraction of pairs of\n    neighbors of `v` that are both linked to other nodes. In a one-mode\n    projection these nodes would be linked together even if `v` were\n    not there.\n\n    More formally, for any vertex `v`, the *redundancy coefficient of `v`* is\n    defined by\n\n    .. math::\n\n        rc(v) = \\frac{|\\{\\{u, w\\} \\subseteq N(v),\n        \\: \\exists v' \\neq  v,\\: (v',u) \\in E\\:\n        \\mathrm{and}\\: (v',w) \\in E\\}|}{ \\frac{|N(v)|(|N(v)|-1)}{2}},\n\n    where `N(v)` is the set of neighbors of `v` in `G`.\n\n    Parameters\n    ----------\n    G : graph\n        A bipartite graph\n\n    nodes : list or iterable (optional)\n        Compute redundancy for these nodes. The default is all nodes in G.\n\n    Returns\n    -------\n    redundancy : dictionary\n        A dictionary keyed by node with the node redundancy value.\n\n    Examples\n    --------\n    Compute the redundancy coefficient of each node in a graph::\n\n        >>> from networkx.algorithms import bipartite\n        >>> G = nx.cycle_graph(4)\n        >>> rc = bipartite.node_redundancy(G)\n        >>> rc[0]\n        1.0\n\n    Compute the average redundancy for the graph::\n\n        >>> from networkx.algorithms import bipartite\n        >>> G = nx.cycle_graph(4)\n        >>> rc = bipartite.node_redundancy(G)\n        >>> sum(rc.values()) / len(G)\n        1.0\n\n    Compute the average redundancy for a set of nodes::\n\n        >>> from networkx.algorithms import bipartite\n        >>> G = nx.cycle_graph(4)\n        >>> rc = bipartite.node_redundancy(G)\n        >>> nodes = [0, 2]\n        >>> sum(rc[n] for n in nodes) / len(nodes)\n        1.0\n\n    Raises\n    ------\n    NetworkXError\n        If any of the nodes in the graph (or in `nodes`, if specified) has\n        (out-)degree less than two (which would result in division by zero,\n        according to the definition of the redundancy coefficient).\n\n    References\n    ----------\n    .. [1] Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\n       Basic notions for the analysis of large two-mode networks.\n       Social Networks 30(1), 31--48.\n\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(name=\"bipartite_parse_edgelist\", graphs=None, returns_graph=True)"}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable\ndef hopcroft_karp_matching(G, top_nodes=None):\n\"\"\"Returns the maximum cardinality matching of the bipartite graph `G`.\n\n    A matching is a set of edges that do not share any nodes. A maximum\n    cardinality matching is a matching with the most edges possible. It\n    is not always unique. Finding a matching in a bipartite graph can be\n    treated as a networkx flow problem.\n\n    The functions ``hopcroft_karp_matching`` and ``maximum_matching``\n    are aliases of the same function.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n      Undirected bipartite graph\n\n    top_nodes : container of nodes\n\n      Container with all nodes in one bipartite node set. If not supplied\n      it will be computed. But if more than one solution exists an exception\n      will be raised.\n\n    Returns\n    -------\n    matches : dictionary\n\n      The matching is returned as a dictionary, `matches`, such that\n      ``matches[v] == w`` if node `v` is matched to node `w`. Unmatched\n      nodes do not occur as a key in `matches`.\n\n    Raises\n    ------\n    AmbiguousSolution\n      Raised if the input bipartite graph is disconnected and no container\n      with all nodes in one bipartite set is provided. When determining\n      the nodes in each bipartite set more than one valid solution is\n      possible if the input graph is disconnected.\n\n    Notes\n    -----\n    This function is implemented with the `Hopcroft--Karp matching algorithm\n    <https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm>`_ for\n    bipartite graphs.\n\n    See :mod:`bipartite documentation <networkx.algorithms.bipartite>`\n    for further details on how bipartite graphs are handled in NetworkX.\n\n    See Also\n    --------\n    maximum_matching\n    hopcroft_karp_matching\n    eppstein_matching\n\n    References\n    ----------\n    .. [1] John E. Hopcroft and Richard M. Karp. \"An n^{5 / 2} Algorithm for\n       Maximum Matchings in Bipartite Graphs\" In: **SIAM Journal of Computing**\n       2.4 (1973), pp. 225--231. <https://doi.org/10.1137/0202019>.\n\n    \"\"\""}, {"gtype": "[Undirected Bipartite Graph]", "func": "@nx._dispatchable\ndef to_vertex_cover(G, matching, top_nodes=None):\n\"\"\"Returns the minimum vertex cover corresponding to the given maximum\n    matching of the bipartite graph `G`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n      Undirected bipartite graph\n\n    matching : dictionary\n\n      A dictionary whose keys are vertices in `G` and whose values are the\n      distinct neighbors comprising the maximum matching for `G`, as returned\n      by, for example, :func:`maximum_matching`. The dictionary *must*\n      represent the maximum matching.\n\n    top_nodes : container\n\n      Container with all nodes in one bipartite node set. If not supplied\n      it will be computed. But if more than one solution exists an exception\n      will be raised.\n\n    Returns\n    -------\n    vertex_cover : :class:`set`\n\n      The minimum vertex cover in `G`.\n\n    Raises\n    ------\n    AmbiguousSolution\n      Raised if the input bipartite graph is disconnected and no container\n      with all nodes in one bipartite set is provided. When determining\n      the nodes in each bipartite set more than one valid solution is\n      possible if the input graph is disconnected.\n\n    Notes\n    -----\n    This function is implemented using the procedure guaranteed by `Konig's\n    theorem\n    <https://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29>`_,\n    which proves an equivalence between a maximum matching and a minimum vertex\n    cover in bipartite graphs.\n\n    Since a minimum vertex cover is the complement of a maximum independent set\n    for any graph, one can compute the maximum independent set of a bipartite\n    graph this way:\n\n    >>> G = nx.complete_bipartite_graph(2, 3)\n    >>> matching = nx.bipartite.maximum_matching(G)\n    >>> vertex_cover = nx.bipartite.to_vertex_cover(G, matching)\n    >>> independent_set = set(G) - vertex_cover\n    >>> print(list(independent_set))\n    [2, 3, 4]\n\n    See :mod:`bipartite documentation <networkx.algorithms.bipartite>`\n    for further details on how bipartite graphs are handled in NetworkX.\n\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef from_biadjacency_matrix(A, create_using=None, edge_attribute=\"weight\"):\n\"\"\"Creates a new bipartite graph from a biadjacency matrix given as a\n    SciPy sparse array.\n\n    Parameters\n    ----------\n    A: scipy sparse array\n      A biadjacency matrix representation of a graph\n\n    create_using: NetworkX graph\n       Use specified graph for result.  The default is Graph()\n\n    edge_attribute: string\n       Name of edge attribute to store matrix numeric value. The data will\n       have the same type as the matrix entry (int, float, (real,imag)).\n\n    Notes\n    -----\n    The nodes are labeled with the attribute `bipartite` set to an integer\n    0 or 1 representing membership in part 0 or part 1 of the bipartite graph.\n\n    If `create_using` is an instance of :class:`networkx.MultiGraph` or\n    :class:`networkx.MultiDiGraph` and the entries of `A` are of\n    type :class:`int`, then this function returns a multigraph (of the same\n    type as `create_using`) with parallel edges. In this case, `edge_attribute`\n    will be ignored.\n\n    See Also\n    --------\n    biadjacency_matrix\n    from_numpy_array\n\n    References\n    ----------\n    [1] https://en.wikipedia.org/wiki/Adjacency_matrix#Adjacency_matrix_of_a_bipartite_graph\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable\ndef latapy_clustering(G, nodes=None, mode=\"dot\"):\n\"\"\"Compute a bipartite clustering coefficient for nodes.\n\n    The bipartite clustering coefficient is a measure of local density\n    of connections defined as [1]_:\n\n    .. math::\n\n       c_u = \\frac{\\sum_{v \\in N(N(u))} c_{uv} }{|N(N(u))|}\n\n    where `N(N(u))` are the second order neighbors of `u` in `G` excluding `u`,\n    and `c_{uv}` is the pairwise clustering coefficient between nodes\n    `u` and `v`.\n\n    The mode selects the function for `c_{uv}` which can be:\n\n    `dot`:\n\n    .. math::\n\n       c_{uv}=\\frac{|N(u)\\cap N(v)|}{|N(u) \\cup N(v)|}\n\n    `min`:\n\n    .. math::\n\n       c_{uv}=\\frac{|N(u)\\cap N(v)|}{min(|N(u)|,|N(v)|)}\n\n    `max`:\n\n    .. math::\n\n       c_{uv}=\\frac{|N(u)\\cap N(v)|}{max(|N(u)|,|N(v)|)}\n\n\n    Parameters\n    ----------\n    G : graph\n        A bipartite graph\n\n    nodes : list or iterable (optional)\n        Compute bipartite clustering for these nodes. The default\n        is all nodes in G.\n\n    mode : string\n        The pairwise bipartite clustering method to be used in the computation.\n        It must be \"dot\", \"max\", or \"min\".\n\n    Returns\n    -------\n    clustering : dictionary\n        A dictionary keyed by node with the clustering coefficient value.\n\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> G = nx.path_graph(4)  # path graphs are bipartite\n    >>> c = bipartite.clustering(G)\n    >>> c[0]\n    0.5\n    >>> c = bipartite.clustering(G, mode=\"min\")\n    >>> c[0]\n    1.0\n\n    See Also\n    --------\n    robins_alexander_clustering\n    average_clustering\n    networkx.algorithms.cluster.square_clustering\n\n    References\n    ----------\n    .. [1] Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\n       Basic notions for the analysis of large two-mode networks.\n       Social Networks 30(1), 31--48.\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable\ndef robins_alexander_clustering(G):\n\"\"\"Compute the bipartite clustering of G.\n\n    Robins and Alexander [1]_ defined bipartite clustering coefficient as\n    four times the number of four cycles `C_4` divided by the number of\n    three paths `L_3` in a bipartite graph:\n\n    .. math::\n\n       CC_4 = \\frac{4 * C_4}{L_3}\n\n    Parameters\n    ----------\n    G : graph\n        a bipartite graph\n\n    Returns\n    -------\n    clustering : float\n       The Robins and Alexander bipartite clustering for the input graph.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> G = nx.davis_southern_women_graph()\n    >>> print(round(bipartite.robins_alexander_clustering(G), 3))\n    0.468\n\n    See Also\n    --------\n    latapy_clustering\n    networkx.algorithms.cluster.square_clustering\n\n    References\n    ----------\n    .. [1] Robins, G. and M. Alexander (2004). Small worlds among interlocking\n           directors: Network structure and distance in bipartite graphs.\n           Computational & Mathematical Organization Theory 10(1), 69\u201394.\n\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable\ndef color(G):\n\"\"\"Returns a two-coloring of the graph.\n\n    Raises an exception if the graph is not bipartite.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    Returns\n    -------\n    color : dictionary\n        A dictionary keyed by node with a 1 or 0 as data for each node color.\n\n    Raises\n    ------\n    NetworkXError\n        If the graph is not two-colorable.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> G = nx.path_graph(4)\n    >>> c = bipartite.color(G)\n    >>> print(c)\n    {0: 1, 1: 0, 2: 1, 3: 0}\n\n    You can use this to set a node attribute indicating the bipartite set:\n\n    >>> nx.set_node_attributes(G, c, \"bipartite\")\n    >>> print(G.nodes[0][\"bipartite\"])\n    1\n    >>> print(G.nodes[1][\"bipartite\"])\n    0\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_bipartite_node_set(G, nodes):\n\"\"\"Returns True if nodes and G/nodes are a bipartition of G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nodes: list or container\n      Check if nodes are a one of a bipartite set.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> G = nx.path_graph(4)\n    >>> X = set([1, 3])\n    >>> bipartite.is_bipartite_node_set(G, X)\n    True\n\n    Notes\n    -----\n    An exception is raised if the input nodes are not distinct, because in this\n    case some bipartite algorithms will yield incorrect results.\n    For connected graphs the bipartite sets are unique.  This function handles\n    disconnected graphs.\n    \"\"\""}, {"gtype": "[Bipartite Graph]", "func": "@nx._dispatchable(graphs=\"B\")\ndef density(B, nodes):\n\"\"\"Returns density of bipartite graph B.\n\n    Parameters\n    ----------\n    B : NetworkX graph\n\n    nodes: list or container\n      Nodes in one node set of the bipartite graph.\n\n    Returns\n    -------\n    d : float\n       The bipartite density\n\n    Examples\n    --------\n    >>> from networkx.algorithms import bipartite\n    >>> G = nx.complete_bipartite_graph(3, 2)\n    >>> X = set([0, 1, 2])\n    >>> bipartite.density(G, X)\n    1.0\n    >>> Y = set([3, 4])\n    >>> bipartite.density(G, Y)\n    1.0\n\n    Notes\n    -----\n    The container of nodes passed as argument must contain all nodes\n    in one of the two bipartite node sets to avoid ambiguity in the\n    case of disconnected graphs.\n    See :mod:`bipartite documentation <networkx.algorithms.bipartite>`\n    for further details on how bipartite graphs are handled in NetworkX.\n\n    See Also\n    --------\n    color\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(graphs={\"t1\": 0, \"t2\": 2}, returns_graph=True)\ndef root_trees(t1, root1, t2, root2):\n\"\"\"Create a single digraph dT of free trees t1 and t2\n    #   with roots root1 and root2 respectively\n    # rename the nodes with consecutive integers\n    # so that all nodes get a unique name between both trees\n\n    # our new \"fake\" root node is 0\n    # t1 is numbers from 1 ... n\n    # t2 is numbered from n+1 to 2n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs={\"t1\": 0, \"t2\": 2})\ndef rooted_tree_isomorphism(t1, root1, t2, root2):\n\"\"\"\n    Given two rooted trees `t1` and `t2`,\n    with roots `root1` and `root2` respectively\n    this routine will determine if they are isomorphic.\n\n    These trees may be either directed or undirected,\n    but if they are directed, all edges should flow from the root.\n\n    It returns the isomorphism, a mapping of the nodes of `t1` onto the nodes\n    of `t2`, such that two trees are then identical.\n\n    Note that two trees may have more than one isomorphism, and this\n    routine just returns one valid mapping.\n\n    Parameters\n    ----------\n    `t1` :  NetworkX graph\n        One of the trees being compared\n\n    `root1` : a node of `t1` which is the root of the tree\n\n    `t2` : undirected NetworkX graph\n        The other tree being compared\n\n    `root2` : a node of `t2` which is the root of the tree\n\n    This is a subroutine used to implement `tree_isomorphism`, but will\n    be somewhat faster if you already have rooted trees.\n\n    Returns\n    -------\n    isomorphism : list\n        A list of pairs in which the left element is a node in `t1`\n        and the right element is a node in `t2`.  The pairs are in\n        arbitrary order.  If the nodes in one tree is mapped to the names in\n        the other, then trees will be identical. Note that an isomorphism\n        will not necessarily be unique.\n\n        If `t1` and `t2` are not isomorphic, then it returns the empty list.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs={\"G1\": 0, \"G2\": 1})\ndef could_be_isomorphic(G1, G2):\n\"\"\"Returns False if graphs are definitely not isomorphic.\n    True does NOT guarantee isomorphism.\n\n    Parameters\n    ----------\n    G1, G2 : graphs\n       The two graphs G1 and G2 must be the same type.\n\n    Notes\n    -----\n    Checks for matching degree, triangle, and number of cliques sequences.\n    The triangle sequence contains the number of triangles each node is part of.\n    The clique sequence contains for each node the number of maximal cliques\n    involving that node.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs={\"G1\": 0, \"G2\": 1})\ndef faster_could_be_isomorphic(G1, G2):\n\"\"\"Returns False if graphs are definitely not isomorphic.\n\n    True does NOT guarantee isomorphism.\n\n    Parameters\n    ----------\n    G1, G2 : graphs\n       The two graphs G1 and G2 must be the same type.\n\n    Notes\n    -----\n    Checks for matching degree sequences.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs={\"G1\": 0, \"G2\": 1}, node_attrs={\"node_label\": \"default_label\"})\ndef vf2pp_isomorphism(G1, G2, node_label=None, default_label=None):\n\"\"\"Return an isomorphic mapping between `G1` and `G2` if it exists.\n\n    Parameters\n    ----------\n    G1, G2 : NetworkX Graph or MultiGraph instances.\n        The two graphs to check for isomorphism.\n\n    node_label : str, optional\n        The name of the node attribute to be used when comparing nodes.\n        The default is `None`, meaning node attributes are not considered\n        in the comparison. Any node that doesn't have the `node_label`\n        attribute uses `default_label` instead.\n\n    default_label : scalar\n        Default value to use when a node doesn't have an attribute\n        named `node_label`. Default is `None`.\n\n    Returns\n    -------\n    dict or None\n        Node mapping if the two graphs are isomorphic. None otherwise.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(graphs={\"G1\": 0, \"G2\": 1}, node_attrs={\"node_label\": \"default_label\"})\ndef vf2pp_all_isomorphisms(G1, G2, node_label=None, default_label=None):\n\"\"\"Yields all the possible mappings between G1 and G2.\n\n    Parameters\n    ----------\n    G1, G2 : NetworkX Graph or MultiGraph instances.\n        The two graphs to check for isomorphism.\n\n    node_label : str, optional\n        The name of the node attribute to be used when comparing nodes.\n        The default is `None`, meaning node attributes are not considered\n        in the comparison. Any node that doesn't have the `node_label`\n        attribute uses `default_label` instead.\n\n    default_label : scalar\n        Default value to use when a node doesn't have an attribute\n        named `node_label`. Default is `None`.\n\n    Yields\n    ------\n    dict\n        Isomorphic mapping between the nodes in `G1` and `G2`.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(preserve_edge_attrs=\"most_valuable_edge\")\ndef girvan_newman(G, most_valuable_edge=None):\n\"\"\"Finds communities in a graph using the Girvan\u2013Newman method.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    most_valuable_edge : function\n        Function that takes a graph as input and outputs an edge. The\n        edge returned by this function will be recomputed and removed at\n        each iteration of the algorithm.\n\n        If not specified, the edge with the highest\n        :func:`networkx.edge_betweenness_centrality` will be used.\n\n    Returns\n    -------\n    iterator\n        Iterator over tuples of sets of nodes in `G`. Each set of node\n        is a community, each tuple is a sequence of communities at a\n        particular level of the algorithm.\n\n    Examples\n    --------\n    To get the first pair of communities::\n\n        >>> G = nx.path_graph(10)\n        >>> comp = nx.community.girvan_newman(G)\n        >>> tuple(sorted(c) for c in next(comp))\n        ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])\n\n    To get only the first *k* tuples of communities, use\n    :func:`itertools.islice`::\n\n        >>> import itertools\n        >>> G = nx.path_graph(8)\n        >>> k = 2\n        >>> comp = nx.community.girvan_newman(G)\n        >>> for communities in itertools.islice(comp, k):\n        ...     print(tuple(sorted(c) for c in communities))\n        ...\n        ([0, 1, 2, 3], [4, 5, 6, 7])\n        ([0, 1], [2, 3], [4, 5, 6, 7])\n\n    To stop getting tuples of communities once the number of communities\n    is greater than *k*, use :func:`itertools.takewhile`::\n\n        >>> import itertools\n        >>> G = nx.path_graph(8)\n        >>> k = 4\n        >>> comp = nx.community.girvan_newman(G)\n        >>> limited = itertools.takewhile(lambda c: len(c) <= k, comp)\n        >>> for communities in limited:\n        ...     print(tuple(sorted(c) for c in communities))\n        ...\n        ([0, 1, 2, 3], [4, 5, 6, 7])\n        ([0, 1], [2, 3], [4, 5, 6, 7])\n        ([0, 1], [2, 3], [4, 5], [6, 7])\n\n    To just choose an edge to remove based on the weight::\n\n        >>> from operator import itemgetter\n        >>> G = nx.path_graph(10)\n        >>> edges = G.edges()\n        >>> nx.set_edge_attributes(G, {(u, v): v for u, v in edges}, \"weight\")\n        >>> def heaviest(G):\n        ...     u, v, w = max(G.edges(data=\"weight\"), key=itemgetter(2))\n        ...     return (u, v)\n        ...\n        >>> comp = nx.community.girvan_newman(G, most_valuable_edge=heaviest)\n        >>> tuple(sorted(c) for c in next(comp))\n        ([0, 1, 2, 3, 4, 5, 6, 7, 8], [9])\n\n    To utilize edge weights when choosing an edge with, for example, the\n    highest betweenness centrality::\n\n        >>> from networkx import edge_betweenness_centrality as betweenness\n        >>> def most_central_edge(G):\n        ...     centrality = betweenness(G, weight=\"weight\")\n        ...     return max(centrality, key=centrality.get)\n        ...\n        >>> G = nx.path_graph(10)\n        >>> comp = nx.community.girvan_newman(G, most_valuable_edge=most_central_edge)\n        >>> tuple(sorted(c) for c in next(comp))\n        ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])\n\n    To specify a different ranking algorithm for edges, use the\n    `most_valuable_edge` keyword argument::\n\n        >>> from networkx import edge_betweenness_centrality\n        >>> from random import random\n        >>> def most_central_edge(G):\n        ...     centrality = edge_betweenness_centrality(G)\n        ...     max_cent = max(centrality.values())\n        ...     # Scale the centrality values so they are between 0 and 1,\n        ...     # and add some random noise.\n        ...     centrality = {e: c / max_cent for e, c in centrality.items()}\n        ...     # Add some random noise.\n        ...     centrality = {e: c + random() for e, c in centrality.items()}\n        ...     return max(centrality, key=centrality.get)\n        ...\n        >>> G = nx.path_graph(10)\n        >>> comp = nx.community.girvan_newman(G, most_valuable_edge=most_central_edge)\n\n    Notes\n    -----\n    The Girvan\u2013Newman algorithm detects communities by progressively\n    removing edges from the original graph. The algorithm removes the\n    \"most valuable\" edge, traditionally the edge with the highest\n    betweenness centrality, at each step. As the graph breaks down into\n    pieces, the tightly knit community structure is exposed and the\n    result can be depicted as a dendrogram.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef intra_community_edges(G, partition):\n\"\"\"Returns the number of intra-community edges for a partition of `G`.\n\n    Parameters\n    ----------\n    G : NetworkX graph.\n\n    partition : iterable of sets of nodes\n        This must be a partition of the nodes of `G`.\n\n    The \"intra-community edges\" are those edges joining a pair of nodes\n    in the same block of the partition.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef inter_community_non_edges(G, partition):\n\"\"\"Returns the number of inter-community non-edges according to the\n    given partition of the nodes of `G`.\n\n    Parameters\n    ----------\n    G : NetworkX graph.\n\n    partition : iterable of sets of nodes\n        This must be a partition of the nodes of `G`.\n\n    A *non-edge* is a pair of nodes (undirected if `G` is undirected)\n    that are not adjacent in `G`. The *inter-community non-edges* are\n    those non-edges on a pair of nodes in different blocks of the\n    partition.\n\n    Implementation note: this function creates two intermediate graphs,\n    which may require up to twice the amount of memory as required to\n    store `G`.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef partition_quality(G, partition):\n\"\"\"Returns the coverage and performance of a partition of G.\n\n    The *coverage* of a partition is the ratio of the number of\n    intra-community edges to the total number of edges in the graph.\n\n    The *performance* of a partition is the number of\n    intra-community edges plus inter-community non-edges divided by the total\n    number of potential edges.\n\n    This algorithm has complexity $O(C^2 + L)$ where C is the number of communities and L is the number of links.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    partition : sequence\n        Partition of the nodes of `G`, represented as a sequence of\n        sets of nodes (blocks). Each block of the partition represents a\n        community.\n\n    Returns\n    -------\n    (float, float)\n        The (coverage, performance) tuple of the partition, as defined above.\n\n    Raises\n    ------\n    NetworkXError\n        If `partition` is not a valid partition of the nodes of `G`.\n\n    Notes\n    -----\n    If `G` is a multigraph;\n        - for coverage, the multiplicity of edges is counted\n        - for performance, the result is -1 (total number of possible edges is not defined)\n\n    References\n    ----------\n    .. [1] Santo Fortunato.\n           \"Community Detection in Graphs\".\n           *Physical Reports*, Volume 486, Issue 3--5 pp. 75--174\n           <https://arxiv.org/abs/0906.0612>\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef fast_label_propagation_communities(G, *, weight=None, seed=None):\n\"\"\"Returns communities in `G` as detected by fast label propagation.\n\n    The fast label propagation algorithm is described in [1]_. The algorithm is\n    probabilistic and the found communities may vary in different executions.\n\n    The algorithm operates as follows. First, the community label of each node is\n    set to a unique label. The algorithm then repeatedly updates the labels of\n    the nodes to the most frequent label in their neighborhood. In case of ties,\n    a random label is chosen from the most frequent labels.\n\n    The algorithm maintains a queue of nodes that still need to be processed.\n    Initially, all nodes are added to the queue in a random order. Then the nodes\n    are removed from the queue one by one and processed. If a node updates its label,\n    all its neighbors that have a different label are added to the queue (if not\n    already in the queue). The algorithm stops when the queue is empty.\n\n    Parameters\n    ----------\n    G : Graph, DiGraph, MultiGraph, or MultiDiGraph\n        Any NetworkX graph.\n\n    weight : string, or None (default)\n        The edge attribute representing a non-negative weight of an edge. If None,\n        each edge is assumed to have weight one. The weight of an edge is used in\n        determining the frequency with which a label appears among the neighbors of\n        a node (edge with weight `w` is equivalent to `w` unweighted edges).\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state. See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    communities : iterable\n        Iterable of communities given as sets of nodes.\n\n    Notes\n    -----\n    Edge directions are ignored for directed graphs.\n    Edge weights must be non-negative numbers.\n\n    References\n    ----------\n    .. [1] Vincent A. Traag & Lovro \u0160ubelj. \"Large network community detection by\n       fast label propagation.\" Scientific Reports 13 (2023): 2701.\n       https://doi.org/10.1038/s41598-023-29610-z\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef asyn_lpa_communities(G, weight=None, seed=None):\n\"\"\"Returns communities in `G` as detected by asynchronous label\n    propagation.\n\n    The asynchronous label propagation algorithm is described in\n    [1]_. The algorithm is probabilistic and the found communities may\n    vary on different executions.\n\n    The algorithm proceeds as follows. After initializing each node with\n    a unique label, the algorithm repeatedly sets the label of a node to\n    be the label that appears most frequently among that nodes\n    neighbors. The algorithm halts when each node has the label that\n    appears most frequently among its neighbors. The algorithm is\n    asynchronous because each node is updated without waiting for\n    updates on the remaining nodes.\n\n    This generalized version of the algorithm in [1]_ accepts edge\n    weights.\n\n    Parameters\n    ----------\n    G : Graph\n\n    weight : string\n        The edge attribute representing the weight of an edge.\n        If None, each edge is assumed to have weight one. In this\n        algorithm, the weight of an edge is used in determining the\n        frequency with which a label appears among the neighbors of a\n        node: a higher weight means the label appears more often.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    communities : iterable\n        Iterable of communities given as sets of nodes.\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n\n    References\n    ----------\n    .. [1] Raghavan, Usha Nandini, R\u00e9ka Albert, and Soundar Kumara. \"Near\n           linear time algorithm to detect community structures in large-scale\n           networks.\" Physical Review E 76.3 (2007): 036106.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef _one_level(G, m, partition, resolution=1, is_directed=False, seed=None):\n\"\"\"Calculate one level of the Louvain partitions tree\n\n    Parameters\n    ----------\n    G : NetworkX Graph/DiGraph\n        The graph from which to detect communities\n    m : number\n        The size of the graph `G`.\n    partition : list of sets of nodes\n        A valid partition of the graph `G`\n    resolution : positive number\n        The resolution parameter for computing the modularity of a partition\n    is_directed : bool\n        True if `G` is a directed graph.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef is_partition(G, communities):\n\"\"\"Returns *True* if `communities` is a partition of the nodes of `G`.\n\n    A partition of a universe set is a family of pairwise disjoint sets\n    whose union is the entire universe set.\n\n    Parameters\n    ----------\n    G : NetworkX graph.\n\n    communities : list or iterable of sets of nodes\n        If not a list, the iterable is converted internally to a list.\n        If it is an iterator it is exhausted.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef asyn_fluidc(G, k, max_iter=100, seed=None):\n\"\"\"Returns communities in `G` as detected by Fluid Communities algorithm.\n\n    The asynchronous fluid communities algorithm is described in\n    [1]_. The algorithm is based on the simple idea of fluids interacting\n    in an environment, expanding and pushing each other. Its initialization is\n    random, so found communities may vary on different executions.\n\n    The algorithm proceeds as follows. First each of the initial k communities\n    is initialized in a random vertex in the graph. Then the algorithm iterates\n    over all vertices in a random order, updating the community of each vertex\n    based on its own community and the communities of its neighbors. This\n    process is performed several times until convergence.\n    At all times, each community has a total density of 1, which is equally\n    distributed among the vertices it contains. If a vertex changes of\n    community, vertex densities of affected communities are adjusted\n    immediately. When a complete iteration over all vertices is done, such that\n    no vertex changes the community it belongs to, the algorithm has converged\n    and returns.\n\n    This is the original version of the algorithm described in [1]_.\n    Unfortunately, it does not support weighted graphs yet.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Graph must be simple and undirected.\n\n    k : integer\n        The number of communities to be found.\n\n    max_iter : integer\n        The number of maximum iterations allowed. By default 100.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    communities : iterable\n        Iterable of communities given as sets of nodes.\n\n    Notes\n    -----\n    k variable is not an optional argument.\n\n    References\n    ----------\n    .. [1] Par\u00e9s F., Garcia-Gasulla D. et al. \"Fluid Communities: A\n       Competitive and Highly Scalable Community Detection Algorithm\".\n       [https://arxiv.org/pdf/1703.09307.pdf].\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef kernighan_lin_bisection(G, partition=None, max_iter=10, weight=\"weight\", seed=None):\n\"\"\"Partition a graph into two blocks using the Kernighan\u2013Lin\n    algorithm.\n\n    This algorithm partitions a network into two sets by iteratively\n    swapping pairs of nodes to reduce the edge cut between the two sets.  The\n    pairs are chosen according to a modified form of Kernighan-Lin [1]_, which\n    moves node individually, alternating between sides to keep the bisection\n    balanced.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Graph must be undirected.\n\n    partition : tuple\n        Pair of iterables containing an initial partition. If not\n        specified, a random balanced partition is used.\n\n    max_iter : int\n        Maximum number of times to attempt swaps to find an\n        improvement before giving up.\n\n    weight : key\n        Edge data key to use as weight. If None, the weights are all\n        set to one.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n        Only used if partition is None\n\n    Returns\n    -------\n    partition : tuple\n        A pair of sets of nodes representing the bipartition.\n\n    Raises\n    ------\n    NetworkXError\n        If partition is not a valid partition of the nodes of the graph.\n\n    References\n    ----------\n    .. [1] Kernighan, B. W.; Lin, Shen (1970).\n       \"An efficient heuristic procedure for partitioning graphs.\"\n       *Bell Systems Technical Journal* 49: 291--307.\n       Oxford University Press 2011.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(node_attrs=\"node_weight\", edge_attrs=\"edge_weight\")\ndef lukes_partitioning(G, max_size, node_weight=None, edge_weight=None):\n\"\"\"Optimal partitioning of a weighted tree using the Lukes algorithm.\n\n    This algorithm partitions a connected, acyclic graph featuring integer\n    node weights and float edge weights. The resulting clusters are such\n    that the total weight of the nodes in each cluster does not exceed\n    max_size and that the weight of the edges that are cut by the partition\n    is minimum. The algorithm is based on [1]_.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    max_size : int\n        Maximum weight a partition can have in terms of sum of\n        node_weight for all nodes in the partition\n\n    edge_weight : key\n        Edge data key to use as weight. If None, the weights are all\n        set to one.\n\n    node_weight : key\n        Node data key to use as weight. If None, the weights are all\n        set to one. The data must be int.\n\n    Returns\n    -------\n    partition : list\n        A list of sets of nodes representing the clusters of the\n        partition.\n\n    Raises\n    ------\n    NotATree\n        If G is not a tree.\n    TypeError\n        If any of the values of node_weight is not int.\n\n    References\n    ----------\n    .. [1] Lukes, J. A. (1974).\n       \"Efficient Algorithm for the Partitioning of Trees.\"\n       IBM Journal of Research and Development, 18(3), 217\u2013224.\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef k_clique_communities(G, k, cliques=None):\n\"\"\"Find k-clique communities in graph using the percolation method.\n\n    A k-clique community is the union of all cliques of size k that\n    can be reached through adjacent (sharing k-1 nodes) k-cliques.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    k : int\n       Size of smallest clique\n\n    cliques: list or generator\n       Precomputed cliques (use networkx.find_cliques(G))\n\n    Returns\n    -------\n    Yields sets of nodes, one for each k-clique community.\n\n    Examples\n    --------\n    >>> G = nx.complete_graph(5)\n    >>> K5 = nx.convert_node_labels_to_integers(G, first_label=2)\n    >>> G.add_edges_from(K5.edges())\n    >>> c = list(nx.community.k_clique_communities(G, 4))\n    >>> sorted(list(c[0]))\n    [0, 1, 2, 3, 4, 5, 6]\n    >>> list(nx.community.k_clique_communities(G, 6))\n    []\n\n    References\n    ----------\n    .. [1] Gergely Palla, Imre Der\u00e9nyi, Ill\u00e9s Farkas1, and Tam\u00e1s Vicsek,\n       Uncovering the overlapping community structure of complex networks\n       in nature and society Nature 435, 814-818, 2005,\n       doi:10.1038/nature03607\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef naive_greedy_modularity_communities(G, resolution=1, weight=None):\n\"\"\"Find communities in G using greedy modularity maximization.\n\n    This implementation is O(n^4), much slower than alternatives, but it is\n    provided as an easy-to-understand reference implementation.\n\n    Greedy modularity maximization begins with each node in its own community\n    and joins the pair of communities that most increases modularity until no\n    such pair exists.\n\n    This function maximizes the generalized modularity, where `resolution`\n    is the resolution parameter, often expressed as $\\gamma$.\n    See :func:`~networkx.algorithms.community.quality.modularity`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Graph must be simple and undirected.\n\n    resolution : float (default=1)\n        If resolution is less than 1, modularity favors larger communities.\n        Greater than 1 favors smaller communities.\n\n    weight : string or None, optional (default=None)\n        The name of an edge attribute that holds the numerical value used\n        as a weight.  If None, then each edge has weight 1.\n        The degree is the sum of the edge weights adjacent to the node.\n\n    Returns\n    -------\n    list\n        A list of sets of nodes, one for each community.\n        Sorted by length with largest communities first.\n\n    Examples\n    --------\n    >>> G = nx.karate_club_graph()\n    >>> c = nx.community.naive_greedy_modularity_communities(G)\n    >>> sorted(c[0])\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\n\n    See Also\n    --------\n    greedy_modularity_communities\n    modularity\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef edge_betweenness_partition(G, number_of_sets, *, weight=None):\n\"\"\"Partition created by iteratively removing the highest edge betweenness edge.\n\n    This algorithm works by calculating the edge betweenness for all\n    edges and removing the edge with the highest value. It is then\n    determined whether the graph has been broken into at least\n    `number_of_sets` connected components.\n    If not the process is repeated.\n\n    Parameters\n    ----------\n    G : NetworkX Graph, DiGraph or MultiGraph\n      Graph to be partitioned\n\n    number_of_sets : int\n      Number of sets in the desired partition of the graph\n\n    weight : key, optional, default=None\n      The key to use if using weights for edge betweenness calculation\n\n    Returns\n    -------\n    C : list of sets\n      Partition of the nodes of G\n\n    Raises\n    ------\n    NetworkXError\n      If number_of_sets is <= 0 or if number_of_sets > len(G)\n\n    Examples\n    --------\n    >>> G = nx.karate_club_graph()\n    >>> part = nx.community.edge_betweenness_partition(G, 2)\n    >>> {0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21} in part\n    True\n    >>> {\n    ...     2,\n    ...     8,\n    ...     9,\n    ...     14,\n    ...     15,\n    ...     18,\n    ...     20,\n    ...     22,\n    ...     23,\n    ...     24,\n    ...     25,\n    ...     26,\n    ...     27,\n    ...     28,\n    ...     29,\n    ...     30,\n    ...     31,\n    ...     32,\n    ...     33,\n    ... } in part\n    True\n\n    See Also\n    --------\n    edge_current_flow_betweenness_partition\n\n    Notes\n    -----\n    This algorithm is fairly slow, as both the calculation of connected\n    components and edge betweenness relies on all pairs shortest\n    path algorithms. They could potentially be combined to cut down\n    on overall computation time.\n\n    References\n    ----------\n    .. [1] Santo Fortunato 'Community Detection in Graphs' Physical Reports\n       Volume 486, Issue 3-5 p. 75-174\n       http://arxiv.org/abs/0906.0612\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")"}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(preserve_edge_attrs={\"G\": {\"weight\": 1}})\ndef hits(G, max_iter=100, tol=1.0e-8, nstart=None, normalized=True):\n\"\"\"Returns HITS hubs and authorities values for nodes.\n\n    The HITS algorithm computes two numbers for a node.\n    Authorities estimates the node value based on the incoming links.\n    Hubs estimates the node value based on outgoing links.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    max_iter : integer, optional\n      Maximum number of iterations in power method.\n\n    tol : float, optional\n      Error tolerance used to check convergence in power method iteration.\n\n    nstart : dictionary, optional\n      Starting value of each node for power method iteration.\n\n    normalized : bool (default=True)\n       Normalize results by the sum of all of the values.\n\n    Returns\n    -------\n    (hubs,authorities) : two-tuple of dictionaries\n       Two dictionaries keyed by node containing the hub and authority\n       values.\n\n    Raises\n    ------\n    PowerIterationFailedConvergence\n        If the algorithm fails to converge to the specified tolerance\n        within the specified number of iterations of the power iteration\n        method.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> h, a = nx.hits(G)\n\n    Notes\n    -----\n    The eigenvector calculation is done by the power iteration method\n    and has no guarantee of convergence.  The iteration will stop\n    after max_iter iterations or an error tolerance of\n    number_of_nodes(G)*tol has been reached.\n\n    The HITS algorithm was designed for directed graphs but this\n    algorithm does not check if the input graph is directed and will\n    execute on undirected graphs.\n\n    References\n    ----------\n    .. [1] A. Langville and C. Meyer,\n       \"A survey of eigenvector methods of web information retrieval.\"\n       http://citeseer.ist.psu.edu/713792.html\n    .. [2] Jon Kleinberg,\n       Authoritative sources in a hyperlinked environment\n       Journal of the ACM 46 (5): 604-32, 1999.\n       doi:10.1145/324133.324140.\n       http://www.cs.cornell.edu/home/kleinber/auth.pdf.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "# This additionally tests the @nx._dispatchable mechanism, treating"}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef degree_assortativity_coefficient(G, x=\"out\", y=\"in\", weight=None, nodes=None):\n\"\"\"Compute degree assortativity of graph.\n\n    Assortativity measures the similarity of connections\n    in the graph with respect to the node degree.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    x: string ('in','out')\n       The degree type for source node (directed graphs only).\n\n    y: string ('in','out')\n       The degree type for target node (directed graphs only).\n\n    weight: string or None, optional (default=None)\n       The edge attribute that holds the numerical value used\n       as a weight.  If None, then each edge has weight 1.\n       The degree is the sum of the edge weights adjacent to the node.\n\n    nodes: list or iterable (optional)\n        Compute degree assortativity only for nodes in container.\n        The default is all nodes.\n\n    Returns\n    -------\n    r : float\n       Assortativity of graph by degree.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> r = nx.degree_assortativity_coefficient(G)\n    >>> print(f\"{r:3.1f}\")\n    -0.5\n\n    See Also\n    --------\n    attribute_assortativity_coefficient\n    numeric_assortativity_coefficient\n    degree_mixing_dict\n    degree_mixing_matrix\n\n    Notes\n    -----\n    This computes Eq. (21) in Ref. [1]_ , where e is the joint\n    probability distribution (mixing matrix) of the degrees.  If G is\n    directed than the matrix e is the joint probability of the\n    user-specified degree type for the source and target.\n\n    References\n    ----------\n    .. [1] M. E. J. Newman, Mixing patterns in networks,\n       Physical Review E, 67 026126, 2003\n    .. [2] Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\n       Edge direction and the structure of networks, PNAS 107, 10815-20 (2010).\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(node_attrs=\"attribute\")\ndef attribute_assortativity_coefficient(G, attribute, nodes=None):\n\"\"\"Compute assortativity for node attributes.\n\n    Assortativity measures the similarity of connections\n    in the graph with respect to the given attribute.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    attribute : string\n        Node attribute key\n\n    nodes: list or iterable (optional)\n        Compute attribute assortativity for nodes in container.\n        The default is all nodes.\n\n    Returns\n    -------\n    r: float\n       Assortativity of graph for given attribute\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> G.add_nodes_from([0, 1], color=\"red\")\n    >>> G.add_nodes_from([2, 3], color=\"blue\")\n    >>> G.add_edges_from([(0, 1), (2, 3)])\n    >>> print(nx.attribute_assortativity_coefficient(G, \"color\"))\n    1.0\n\n    Notes\n    -----\n    This computes Eq. (2) in Ref. [1]_ , (trace(M)-sum(M^2))/(1-sum(M^2)),\n    where M is the joint probability distribution (mixing matrix)\n    of the specified attribute.\n\n    References\n    ----------\n    .. [1] M. E. J. Newman, Mixing patterns in networks,\n       Physical Review E, 67 026126, 2003\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")"}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(node_attrs=\"attribute\")\ndef node_attribute_xy(G, attribute, nodes=None):\n\"\"\"Yields 2-tuples of node attribute values for all edges in `G`.\n\n    This generator yields, for each edge in `G` incident to a node in `nodes`,\n    a 2-tuple of form ``(attribute value,  attribute value)`` for the parameter\n    specified node-attribute.\n\n    Parameters\n    ----------\n    G: NetworkX graph\n\n    attribute: key\n        The node attribute key.\n\n    nodes: list or iterable (optional)\n        Use only edges that are incident to specified nodes.\n        The default is all nodes.\n\n    Yields\n    ------\n    (x, y): 2-tuple\n        Generates 2-tuple of (attribute, attribute) values.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph()\n    >>> G.add_node(1, color=\"red\")\n    >>> G.add_node(2, color=\"blue\")\n    >>> G.add_node(3, color=\"green\")\n    >>> G.add_edge(1, 2)\n    >>> list(nx.node_attribute_xy(G, \"color\"))\n    [('red', 'blue')]\n\n    Notes\n    -----\n    For undirected graphs, each edge is produced twice, once for each edge\n    representation (u, v) and (v, u), with the exception of self-loop edges\n    which only appear once.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable(node_attrs=\"attribute\")\ndef attribute_mixing_dict(G, attribute, nodes=None, normalized=False):\n\"\"\"Returns dictionary representation of mixing matrix for attribute.\n\n    Parameters\n    ----------\n    G : graph\n       NetworkX graph object.\n\n    attribute : string\n       Node attribute key.\n\n    nodes: list or iterable (optional)\n        Unse nodes in container to build the dict. The default is all nodes.\n\n    normalized : bool (default=False)\n       Return counts if False or probabilities if True.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> G.add_nodes_from([0, 1], color=\"red\")\n    >>> G.add_nodes_from([2, 3], color=\"blue\")\n    >>> G.add_edge(1, 3)\n    >>> d = nx.attribute_mixing_dict(G, \"color\")\n    >>> print(d[\"red\"][\"blue\"])\n    1\n    >>> print(d[\"blue\"][\"red\"])  # d symmetric for undirected graphs\n    1\n\n    Returns\n    -------\n    d : dictionary\n       Counts or joint probability of occurrence of attribute pairs.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef degree_mixing_dict(G, x=\"out\", y=\"in\", weight=None, nodes=None, normalized=False):\n\"\"\"Returns dictionary representation of mixing matrix for degree.\n\n    Parameters\n    ----------\n    G : graph\n        NetworkX graph object.\n\n    x: string ('in','out')\n       The degree type for source node (directed graphs only).\n\n    y: string ('in','out')\n       The degree type for target node (directed graphs only).\n\n    weight: string or None, optional (default=None)\n       The edge attribute that holds the numerical value used\n       as a weight.  If None, then each edge has weight 1.\n       The degree is the sum of the edge weights adjacent to the node.\n\n    normalized : bool (default=False)\n        Return counts if False or probabilities if True.\n\n    Returns\n    -------\n    d: dictionary\n       Counts or joint probability of occurrence of degree pairs.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef average_neighbor_degree(G, source=\"out\", target=\"out\", nodes=None, weight=None):\n\"\"\"Returns the average degree of the neighborhood of each node.\n\n    In an undirected graph, the neighborhood `N(i)` of node `i` contains the\n    nodes that are connected to `i` by an edge.\n\n    For directed graphs, `N(i)` is defined according to the parameter `source`:\n\n        - if source is 'in', then `N(i)` consists of predecessors of node `i`.\n        - if source is 'out', then `N(i)` consists of successors of node `i`.\n        - if source is 'in+out', then `N(i)` is both predecessors and successors.\n\n    The average neighborhood degree of a node `i` is\n\n    .. math::\n\n        k_{nn,i} = \\frac{1}{|N(i)|} \\sum_{j \\in N(i)} k_j\n\n    where `N(i)` are the neighbors of node `i` and `k_j` is\n    the degree of node `j` which belongs to `N(i)`. For weighted\n    graphs, an analogous measure can be defined [1]_,\n\n    .. math::\n\n        k_{nn,i}^{w} = \\frac{1}{s_i} \\sum_{j \\in N(i)} w_{ij} k_j\n\n    where `s_i` is the weighted degree of node `i`, `w_{ij}`\n    is the weight of the edge that links `i` and `j` and\n    `N(i)` are the neighbors of node `i`.\n\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : string (\"in\"|\"out\"|\"in+out\"), optional (default=\"out\")\n       Directed graphs only.\n       Use \"in\"- or \"out\"-neighbors of source node.\n\n    target : string (\"in\"|\"out\"|\"in+out\"), optional (default=\"out\")\n       Directed graphs only.\n       Use \"in\"- or \"out\"-degree for target node.\n\n    nodes : list or iterable, optional (default=G.nodes)\n        Compute neighbor degree only for specified nodes.\n\n    weight : string or None, optional (default=None)\n       The edge attribute that holds the numerical value used as a weight.\n       If None, then each edge has weight 1.\n\n    Returns\n    -------\n    d: dict\n       A dictionary keyed by node to the average degree of its neighbors.\n\n    Raises\n    ------\n    NetworkXError\n        If either `source` or `target` are not one of 'in', 'out', or 'in+out'.\n        If either `source` or `target` is passed for an undirected graph.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> G.edges[0, 1][\"weight\"] = 5\n    >>> G.edges[2, 3][\"weight\"] = 3\n\n    >>> nx.average_neighbor_degree(G)\n    {0: 2.0, 1: 1.5, 2: 1.5, 3: 2.0}\n    >>> nx.average_neighbor_degree(G, weight=\"weight\")\n    {0: 2.0, 1: 1.1666666666666667, 2: 1.25, 3: 2.0}\n\n    >>> G = nx.DiGraph()\n    >>> nx.add_path(G, [0, 1, 2, 3])\n    >>> nx.average_neighbor_degree(G, source=\"in\", target=\"in\")\n    {0: 0.0, 1: 0.0, 2: 1.0, 3: 1.0}\n\n    >>> nx.average_neighbor_degree(G, source=\"out\", target=\"out\")\n    {0: 1.0, 1: 1.0, 2: 0.0, 3: 0.0}\n\n    See Also\n    --------\n    average_degree_connectivity\n\n    References\n    ----------\n    .. [1] A. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani,\n       \"The architecture of complex weighted networks\".\n       PNAS 101 (11): 3747\u20133752 (2004).\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(edge_attrs={\"capacity\": float(\"inf\")}, returns_graph=True)\ndef build_residual_network(G, capacity):\n\"\"\"Build a residual network and initialize a zero flow.\n\n    The residual network :samp:`R` from an input graph :samp:`G` has the\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\n    in :samp:`G`.\n\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\n    :samp:`R[u][v]['capacity']` will have a high arbitrary finite value\n    that does not affect the solution of the problem. This value is stored in\n    :samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n    :samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\n    satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\n    stored in :samp:`R.graph['flow_value']`. If :samp:`cutoff` is not\n    specified, reachability to :samp:`t` using only edges :samp:`(u, v)` such\n    that :samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n    :samp:`s`-:samp:`t` cut.\n\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(graphs={\"G\": 0, \"R\": 1}, preserve_edge_attrs={\"R\": {\"flow\": None}})\ndef build_flow_dict(G, R):\n\"\"\"Build a flow dictionary from a residual network.\"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"capacity\": float(\"inf\")}, returns_graph=True)"}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"capacity\": float(\"inf\")}, returns_graph=True)\ndef boykov_kolmogorov_impl(G, s, t, capacity, residual, cutoff):\n\"\"\"Bidirectional breadth-first search for the growth stage.\n\n        Returns a connecting edge, that is and edge that connects\n        a node from the source search tree with a node from the\n        target search tree.\n        The first node in the connecting edge is always from the\n        source tree and the last node from the target tree.\n        \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"capacity\": float(\"inf\")}, returns_graph=True)"}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"capacity\": float(\"inf\")}, returns_graph=True)"}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(\ndef network_simplex(G, demand=\"demand\", capacity=\"capacity\", weight=\"weight\"):\n\"\"\"Find a minimum cost flow satisfying all demands in digraph G.\n\n    This is a primal network simplex algorithm that uses the leaving\n    arc rule to prevent cycling.\n\n    G is a digraph with edge costs and capacities and in which nodes\n    have demand, i.e., they want to send or receive some amount of\n    flow. A negative demand means that the node wants to send flow, a\n    positive demand means that the node want to receive flow. A flow on\n    the digraph G satisfies all demand if the net flow into each node\n    is equal to the demand of that node.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        DiGraph on which a minimum cost flow satisfying all demands is\n        to be found.\n\n    demand : string\n        Nodes of the graph G are expected to have an attribute demand\n        that indicates how much flow a node wants to send (negative\n        demand) or receive (positive demand). Note that the sum of the\n        demands should be 0 otherwise the problem in not feasible. If\n        this attribute is not present, a node is considered to have 0\n        demand. Default value: 'demand'.\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    weight : string\n        Edges of the graph G are expected to have an attribute weight\n        that indicates the cost incurred by sending one unit of flow on\n        that edge. If not present, the weight is considered to be 0.\n        Default value: 'weight'.\n\n    Returns\n    -------\n    flowCost : integer, float\n        Cost of a minimum cost flow satisfying all demands.\n\n    flowDict : dictionary\n        Dictionary of dictionaries keyed by nodes such that\n        flowDict[u][v] is the flow edge (u, v).\n\n    Raises\n    ------\n    NetworkXError\n        This exception is raised if the input graph is not directed or\n        not connected.\n\n    NetworkXUnfeasible\n        This exception is raised in the following situations:\n\n            * The sum of the demands is not zero. Then, there is no\n              flow satisfying all demands.\n            * There is no flow satisfying all demand.\n\n    NetworkXUnbounded\n        This exception is raised if the digraph G has a cycle of\n        negative cost and infinite capacity. Then, the cost of a flow\n        satisfying all demands is unbounded below.\n\n    Notes\n    -----\n    This algorithm is not guaranteed to work if edge weights or demands\n    are floating point numbers (overflows and roundoff errors can\n    cause problems). As a workaround you can use integer numbers by\n    multiplying the relevant edge attributes by a convenient\n    constant factor (eg 100).\n\n    See also\n    --------\n    cost_of_flow, max_flow_min_cost, min_cost_flow, min_cost_flow_cost\n\n    Examples\n    --------\n    A simple example of a min cost flow problem.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_node(\"a\", demand=-5)\n    >>> G.add_node(\"d\", demand=5)\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n    >>> flowCost, flowDict = nx.network_simplex(G)\n    >>> flowCost\n    24\n    >>> flowDict\n    {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\n\n    The mincost flow algorithm can also be used to solve shortest path\n    problems. To find the shortest path between two nodes u and v,\n    give all edges an infinite capacity, give node u a demand of -1 and\n    node v a demand a 1. Then run the network simplex. The value of a\n    min cost flow will be the distance between u and v and edges\n    carrying positive flow will indicate the path.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_weighted_edges_from(\n    ...     [\n    ...         (\"s\", \"u\", 10),\n    ...         (\"s\", \"x\", 5),\n    ...         (\"u\", \"v\", 1),\n    ...         (\"u\", \"x\", 2),\n    ...         (\"v\", \"y\", 1),\n    ...         (\"x\", \"u\", 3),\n    ...         (\"x\", \"v\", 5),\n    ...         (\"x\", \"y\", 2),\n    ...         (\"y\", \"s\", 7),\n    ...         (\"y\", \"v\", 6),\n    ...     ]\n    ... )\n    >>> G.add_node(\"s\", demand=-1)\n    >>> G.add_node(\"v\", demand=1)\n    >>> flowCost, flowDict = nx.network_simplex(G)\n    >>> flowCost == nx.shortest_path_length(G, \"s\", \"v\", weight=\"weight\")\n    True\n    >>> sorted([(u, v) for u in flowDict for v in flowDict[u] if flowDict[u][v] > 0])\n    [('s', 'x'), ('u', 'v'), ('x', 'u')]\n    >>> nx.shortest_path(G, \"s\", \"v\", weight=\"weight\")\n    ['s', 'x', 'u', 'v']\n\n    It is possible to change the name of the attributes used for the\n    algorithm.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_node(\"p\", spam=-4)\n    >>> G.add_node(\"q\", spam=2)\n    >>> G.add_node(\"a\", spam=-2)\n    >>> G.add_node(\"d\", spam=-1)\n    >>> G.add_node(\"t\", spam=2)\n    >>> G.add_node(\"w\", spam=3)\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\n    >>> flowCost, flowDict = nx.network_simplex(\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\n    ... )\n    >>> flowCost\n    37\n    >>> flowDict\n    {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}\n\n    References\n    ----------\n    .. [1] Z. Kiraly, P. Kovacs.\n           Efficient implementation of minimum-cost flow algorithms.\n           Acta Universitatis Sapientiae, Informatica 4(1):67--118. 2012.\n    .. [2] R. Barr, F. Glover, D. Klingman.\n           Enhancement of spanning tree labeling procedures for network\n           optimization.\n           INFOR 17(1):16--34. 1979.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable("}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"capacity\": float(\"inf\")}, returns_graph=True)\ndef gomory_hu_tree(G, capacity=\"capacity\", flow_func=None):\n\"\"\"Returns the Gomory-Hu tree of an undirected graph G.\n\n    A Gomory-Hu tree of an undirected graph with capacities is a\n    weighted tree that represents the minimum s-t cuts for all s-t\n    pairs in the graph.\n\n    It only requires `n-1` minimum cut computations instead of the\n    obvious `n(n-1)/2`. The tree represents all s-t cuts as the\n    minimum cut value among any pair of nodes is the minimum edge\n    weight in the shortest path between the two nodes in the\n    Gomory-Hu tree.\n\n    The Gomory-Hu tree also has the property that removing the\n    edge with the minimum weight in the shortest path between\n    any two nodes leaves two connected components that form\n    a partition of the nodes in G that defines the minimum s-t\n    cut.\n\n    See Examples section below for details.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    flow_func : function\n        Function to perform the underlying flow computations. Default value\n        :func:`edmonds_karp`. This function performs better in sparse graphs\n        with right tailed degree distributions.\n        :func:`shortest_augmenting_path` will perform better in denser\n        graphs.\n\n    Returns\n    -------\n    Tree : NetworkX graph\n        A NetworkX graph representing the Gomory-Hu tree of the input graph.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        Raised if the input graph is directed.\n\n    NetworkXError\n        Raised if the input graph is an empty Graph.\n\n    Examples\n    --------\n    >>> G = nx.karate_club_graph()\n    >>> nx.set_edge_attributes(G, 1, \"capacity\")\n    >>> T = nx.gomory_hu_tree(G)\n    >>> # The value of the minimum cut between any pair\n    ... # of nodes in G is the minimum edge weight in the\n    ... # shortest path between the two nodes in the\n    ... # Gomory-Hu tree.\n    ... def minimum_edge_weight_in_shortest_path(T, u, v):\n    ...     path = nx.shortest_path(T, u, v, weight=\"weight\")\n    ...     return min((T[u][v][\"weight\"], (u, v)) for (u, v) in zip(path, path[1:]))\n    >>> u, v = 0, 33\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n    >>> cut_value\n    10\n    >>> nx.minimum_cut_value(G, u, v)\n    10\n    >>> # The Gomory-Hu tree also has the property that removing the\n    ... # edge with the minimum weight in the shortest path between\n    ... # any two nodes leaves two connected components that form\n    ... # a partition of the nodes in G that defines the minimum s-t\n    ... # cut.\n    ... cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n    >>> T.remove_edge(*edge)\n    >>> U, V = list(nx.connected_components(T))\n    >>> # Thus U and V form a partition that defines a minimum cut\n    ... # between u and v in G. You can compute the edge cut set,\n    ... # that is, the set of edges that if removed from G will\n    ... # disconnect u from v in G, with this information:\n    ... cutset = set()\n    >>> for x, nbrs in ((n, G[n]) for n in U):\n    ...     cutset.update((x, y) for y in nbrs if y in V)\n    >>> # Because we have set the capacities of all edges to 1\n    ... # the cutset contains ten edges\n    ... len(cutset)\n    10\n    >>> # You can use any maximum flow algorithm for the underlying\n    ... # flow computations using the argument flow_func\n    ... from networkx.algorithms import flow\n    >>> T = nx.gomory_hu_tree(G, flow_func=flow.boykov_kolmogorov)\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n    >>> cut_value\n    10\n    >>> nx.minimum_cut_value(G, u, v, flow_func=flow.boykov_kolmogorov)\n    10\n\n    Notes\n    -----\n    This implementation is based on Gusfield approach [1]_ to compute\n    Gomory-Hu trees, which does not require node contractions and has\n    the same computational complexity than the original method.\n\n    See also\n    --------\n    :func:`minimum_cut`\n    :func:`maximum_flow`\n\n    References\n    ----------\n    .. [1] Gusfield D: Very simple methods for all pairs network flow analysis.\n           SIAM J Comput 19(1):143-155, 1990.\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"capacity\": float(\"inf\")}, returns_graph=True)\ndef dinitz(G, s, t, capacity=\"capacity\", residual=None, value_only=False, cutoff=None):\n\"\"\"Find a maximum single-commodity flow using Dinitz' algorithm.\n\n    This function returns the residual network resulting after computing\n    the maximum flow. See below for details about the conventions\n    NetworkX uses for defining residual networks.\n\n    This algorithm has a running time of $O(n^2 m)$ for $n$ nodes and $m$\n    edges [1]_.\n\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Edges of the graph are expected to have an attribute called\n        'capacity'. If this attribute is not present, the edge is\n        considered to have infinite capacity.\n\n    s : node\n        Source node for the flow.\n\n    t : node\n        Sink node for the flow.\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    residual : NetworkX graph\n        Residual network on which the algorithm is to be executed. If None, a\n        new residual network is created. Default value: None.\n\n    value_only : bool\n        If True compute only the value of the maximum flow. This parameter\n        will be ignored by this algorithm because it is not applicable.\n\n    cutoff : integer, float\n        If specified, the algorithm will terminate when the flow value reaches\n        or exceeds the cutoff. In this case, it may be unable to immediately\n        determine a minimum cut. Default value: None.\n\n    Returns\n    -------\n    R : NetworkX DiGraph\n        Residual network after computing the maximum flow.\n\n    Raises\n    ------\n    NetworkXError\n        The algorithm does not support MultiGraph and MultiDiGraph. If\n        the input graph is an instance of one of these two classes, a\n        NetworkXError is raised.\n\n    NetworkXUnbounded\n        If the graph has a path of infinite capacity, the value of a\n        feasible flow on the graph is unbounded above and the function\n        raises a NetworkXUnbounded.\n\n    See also\n    --------\n    :meth:`maximum_flow`\n    :meth:`minimum_cut`\n    :meth:`preflow_push`\n    :meth:`shortest_augmenting_path`\n\n    Notes\n    -----\n    The residual network :samp:`R` from an input graph :samp:`G` has the\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\n    in :samp:`G`.\n\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\n    :samp:`R[u][v]['capacity']` will have a high arbitrary finite value\n    that does not affect the solution of the problem. This value is stored in\n    :samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n    :samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\n    satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\n    stored in :samp:`R.graph['flow_value']`. If :samp:`cutoff` is not\n    specified, reachability to :samp:`t` using only edges :samp:`(u, v)` such\n    that :samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n    :samp:`s`-:samp:`t` cut.\n\n    Examples\n    --------\n    >>> from networkx.algorithms.flow import dinitz\n\n    The functions that implement flow algorithms and output a residual\n    network, such as this one, are not imported to the base NetworkX\n    namespace, so you have to explicitly import them from the flow package.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\n    >>> R = dinitz(G, \"x\", \"y\")\n    >>> flow_value = nx.maximum_flow_value(G, \"x\", \"y\")\n    >>> flow_value\n    3.0\n    >>> flow_value == R.graph[\"flow_value\"]\n    True\n\n    References\n    ----------\n    .. [1] Dinitz' Algorithm: The Original Version and Even's Version.\n           2006. Yefim Dinitz. In Theoretical Computer Science. Lecture\n           Notes in Computer Science. Volume 3895. pp 218-240.\n           https://doi.org/10.1007/11685654_10\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(\ndef min_cost_flow_cost(G, demand=\"demand\", capacity=\"capacity\", weight=\"weight\"):\n\"\"\"Find the cost of a minimum cost flow satisfying all demands in digraph G.\n\n    G is a digraph with edge costs and capacities and in which nodes\n    have demand, i.e., they want to send or receive some amount of\n    flow. A negative demand means that the node wants to send flow, a\n    positive demand means that the node want to receive flow. A flow on\n    the digraph G satisfies all demand if the net flow into each node\n    is equal to the demand of that node.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        DiGraph on which a minimum cost flow satisfying all demands is\n        to be found.\n\n    demand : string\n        Nodes of the graph G are expected to have an attribute demand\n        that indicates how much flow a node wants to send (negative\n        demand) or receive (positive demand). Note that the sum of the\n        demands should be 0 otherwise the problem in not feasible. If\n        this attribute is not present, a node is considered to have 0\n        demand. Default value: 'demand'.\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    weight : string\n        Edges of the graph G are expected to have an attribute weight\n        that indicates the cost incurred by sending one unit of flow on\n        that edge. If not present, the weight is considered to be 0.\n        Default value: 'weight'.\n\n    Returns\n    -------\n    flowCost : integer, float\n        Cost of a minimum cost flow satisfying all demands.\n\n    Raises\n    ------\n    NetworkXError\n        This exception is raised if the input graph is not directed or\n        not connected.\n\n    NetworkXUnfeasible\n        This exception is raised in the following situations:\n\n            * The sum of the demands is not zero. Then, there is no\n              flow satisfying all demands.\n            * There is no flow satisfying all demand.\n\n    NetworkXUnbounded\n        This exception is raised if the digraph G has a cycle of\n        negative cost and infinite capacity. Then, the cost of a flow\n        satisfying all demands is unbounded below.\n\n    See also\n    --------\n    cost_of_flow, max_flow_min_cost, min_cost_flow, network_simplex\n\n    Notes\n    -----\n    This algorithm is not guaranteed to work if edge weights or demands\n    are floating point numbers (overflows and roundoff errors can\n    cause problems). As a workaround you can use integer numbers by\n    multiplying the relevant edge attributes by a convenient\n    constant factor (eg 100).\n\n    Examples\n    --------\n    A simple example of a min cost flow problem.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_node(\"a\", demand=-5)\n    >>> G.add_node(\"d\", demand=5)\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n    >>> flowCost = nx.min_cost_flow_cost(G)\n    >>> flowCost\n    24\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs={\"weight\": 0})\ndef cost_of_flow(G, flowDict, weight=\"weight\"):\n\"\"\"Compute the cost of the flow given by flowDict on graph G.\n\n    Note that this function does not check for the validity of the\n    flow flowDict. This function will fail if the graph G and the\n    flow don't have the same edge set.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        DiGraph on which a minimum cost flow satisfying all demands is\n        to be found.\n\n    weight : string\n        Edges of the graph G are expected to have an attribute weight\n        that indicates the cost incurred by sending one unit of flow on\n        that edge. If not present, the weight is considered to be 0.\n        Default value: 'weight'.\n\n    flowDict : dictionary\n        Dictionary of dictionaries keyed by nodes such that\n        flowDict[u][v] is the flow edge (u, v).\n\n    Returns\n    -------\n    cost : Integer, float\n        The total cost of the flow. This is given by the sum over all\n        edges of the product of the edge's flow and the edge's weight.\n\n    See also\n    --------\n    max_flow_min_cost, min_cost_flow, min_cost_flow_cost, network_simplex\n\n    Notes\n    -----\n    This algorithm is not guaranteed to work if edge weights or demands\n    are floating point numbers (overflows and roundoff errors can\n    cause problems). As a workaround you can use integer numbers by\n    multiplying the relevant edge attributes by a convenient\n    constant factor (eg 100).\n\n    Examples\n    --------\n    >>> G = nx.DiGraph()\n    >>> G.add_node(\"a\", demand=-5)\n    >>> G.add_node(\"d\", demand=5)\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n    >>> flowDict = nx.min_cost_flow(G)\n    >>> flowDict\n    {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\n    >>> nx.cost_of_flow(G, flowDict)\n    24\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(graphs=\"flowG\", edge_attrs={\"capacity\": float(\"inf\")})\ndef maximum_flow(flowG, _s, _t, capacity=\"capacity\", flow_func=None, **kwargs):\n\"\"\"Find a maximum single-commodity flow.\n\n    Parameters\n    ----------\n    flowG : NetworkX graph\n        Edges of the graph are expected to have an attribute called\n        'capacity'. If this attribute is not present, the edge is\n        considered to have infinite capacity.\n\n    _s : node\n        Source node for the flow.\n\n    _t : node\n        Sink node for the flow.\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    flow_func : function\n        A function for computing the maximum flow among a pair of nodes\n        in a capacitated graph. The function has to accept at least three\n        parameters: a Graph or Digraph, a source node, and a target node.\n        And return a residual network that follows NetworkX conventions\n        (see Notes). If flow_func is None, the default maximum\n        flow function (:meth:`preflow_push`) is used. See below for\n        alternative algorithms. The choice of the default function may change\n        from version to version and should not be relied on. Default value:\n        None.\n\n    kwargs : Any other keyword parameter is passed to the function that\n        computes the maximum flow.\n\n    Returns\n    -------\n    flow_value : integer, float\n        Value of the maximum flow, i.e., net outflow from the source.\n\n    flow_dict : dict\n        A dictionary containing the value of the flow that went through\n        each edge.\n\n    Raises\n    ------\n    NetworkXError\n        The algorithm does not support MultiGraph and MultiDiGraph. If\n        the input graph is an instance of one of these two classes, a\n        NetworkXError is raised.\n\n    NetworkXUnbounded\n        If the graph has a path of infinite capacity, the value of a\n        feasible flow on the graph is unbounded above and the function\n        raises a NetworkXUnbounded.\n\n    See also\n    --------\n    :meth:`maximum_flow_value`\n    :meth:`minimum_cut`\n    :meth:`minimum_cut_value`\n    :meth:`edmonds_karp`\n    :meth:`preflow_push`\n    :meth:`shortest_augmenting_path`\n\n    Notes\n    -----\n    The function used in the flow_func parameter has to return a residual\n    network that follows NetworkX conventions:\n\n    The residual network :samp:`R` from an input graph :samp:`G` has the\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\n    in :samp:`G`.\n\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\n    :samp:`R[u][v]['capacity']` will have a high arbitrary finite value\n    that does not affect the solution of the problem. This value is stored in\n    :samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n    :samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\n    satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\n    stored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using\n    only edges :samp:`(u, v)` such that\n    :samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n    :samp:`s`-:samp:`t` cut.\n\n    Specific algorithms may store extra data in :samp:`R`.\n\n    The function should supports an optional boolean parameter value_only. When\n    True, it can optionally terminate the algorithm as soon as the maximum flow\n    value and the minimum cut can be determined.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph()\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\n\n    maximum_flow returns both the value of the maximum flow and a\n    dictionary with all flows.\n\n    >>> flow_value, flow_dict = nx.maximum_flow(G, \"x\", \"y\")\n    >>> flow_value\n    3.0\n    >>> print(flow_dict[\"x\"][\"b\"])\n    1.0\n\n    You can also use alternative algorithms for computing the\n    maximum flow by using the flow_func parameter.\n\n    >>> from networkx.algorithms.flow import shortest_augmenting_path\n    >>> flow_value == nx.maximum_flow(G, \"x\", \"y\", flow_func=shortest_augmenting_path)[\n    ...     0\n    ... ]\n    True\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(graphs=\"flowG\", edge_attrs={\"capacity\": float(\"inf\")})\ndef minimum_cut(flowG, _s, _t, capacity=\"capacity\", flow_func=None, **kwargs):\n\"\"\"Compute the value and the node partition of a minimum (s, t)-cut.\n\n    Use the max-flow min-cut theorem, i.e., the capacity of a minimum\n    capacity cut is equal to the flow value of a maximum flow.\n\n    Parameters\n    ----------\n    flowG : NetworkX graph\n        Edges of the graph are expected to have an attribute called\n        'capacity'. If this attribute is not present, the edge is\n        considered to have infinite capacity.\n\n    _s : node\n        Source node for the flow.\n\n    _t : node\n        Sink node for the flow.\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    flow_func : function\n        A function for computing the maximum flow among a pair of nodes\n        in a capacitated graph. The function has to accept at least three\n        parameters: a Graph or Digraph, a source node, and a target node.\n        And return a residual network that follows NetworkX conventions\n        (see Notes). If flow_func is None, the default maximum\n        flow function (:meth:`preflow_push`) is used. See below for\n        alternative algorithms. The choice of the default function may change\n        from version to version and should not be relied on. Default value:\n        None.\n\n    kwargs : Any other keyword parameter is passed to the function that\n        computes the maximum flow.\n\n    Returns\n    -------\n    cut_value : integer, float\n        Value of the minimum cut.\n\n    partition : pair of node sets\n        A partitioning of the nodes that defines a minimum cut.\n\n    Raises\n    ------\n    NetworkXUnbounded\n        If the graph has a path of infinite capacity, all cuts have\n        infinite capacity and the function raises a NetworkXError.\n\n    See also\n    --------\n    :meth:`maximum_flow`\n    :meth:`maximum_flow_value`\n    :meth:`minimum_cut_value`\n    :meth:`edmonds_karp`\n    :meth:`preflow_push`\n    :meth:`shortest_augmenting_path`\n\n    Notes\n    -----\n    The function used in the flow_func parameter has to return a residual\n    network that follows NetworkX conventions:\n\n    The residual network :samp:`R` from an input graph :samp:`G` has the\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\n    in :samp:`G`.\n\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\n    :samp:`R[u][v]['capacity']` will have a high arbitrary finite value\n    that does not affect the solution of the problem. This value is stored in\n    :samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n    :samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\n    satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\n    stored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using\n    only edges :samp:`(u, v)` such that\n    :samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n    :samp:`s`-:samp:`t` cut.\n\n    Specific algorithms may store extra data in :samp:`R`.\n\n    The function should supports an optional boolean parameter value_only. When\n    True, it can optionally terminate the algorithm as soon as the maximum flow\n    value and the minimum cut can be determined.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph()\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\n\n    minimum_cut computes both the value of the\n    minimum cut and the node partition:\n\n    >>> cut_value, partition = nx.minimum_cut(G, \"x\", \"y\")\n    >>> reachable, non_reachable = partition\n\n    'partition' here is a tuple with the two sets of nodes that define\n    the minimum cut. You can compute the cut set of edges that induce\n    the minimum cut as follows:\n\n    >>> cutset = set()\n    >>> for u, nbrs in ((n, G[n]) for n in reachable):\n    ...     cutset.update((u, v) for v in nbrs if v in non_reachable)\n    >>> print(sorted(cutset))\n    [('c', 'y'), ('x', 'b')]\n    >>> cut_value == sum(G.edges[u, v][\"capacity\"] for (u, v) in cutset)\n    True\n\n    You can also use alternative algorithms for computing the\n    minimum cut by using the flow_func parameter.\n\n    >>> from networkx.algorithms.flow import shortest_augmenting_path\n    >>> cut_value == nx.minimum_cut(G, \"x\", \"y\", flow_func=shortest_augmenting_path)[0]\n    True\n\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef has_path(G, source, target):\n\"\"\"Returns *True* if *G* has a path from *source* to *target*.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n       Starting node for path\n\n    target : node\n       Ending node for path\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef shortest_path_length(G, source=None, target=None, weight=None, method=\"dijkstra\"):\n\"\"\"Compute shortest path lengths in the graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node, optional\n        Starting node for path.\n        If not specified, compute shortest path lengths using all nodes as\n        source nodes.\n\n    target : node, optional\n        Ending node for path.\n        If not specified, compute shortest path lengths using all nodes as\n        target nodes.\n\n    weight : None, string or function, optional (default = None)\n        If None, every edge has weight/distance/cost 1.\n        If a string, use this edge attribute as the edge weight.\n        Any edge attribute not present defaults to 1.\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly\n        three positional arguments: the two endpoints of an edge and\n        the dictionary of edge attributes for that edge.\n        The function must return a number.\n\n    method : string, optional (default = 'dijkstra')\n        The algorithm to use to compute the path length.\n        Supported options: 'dijkstra', 'bellman-ford'.\n        Other inputs produce a ValueError.\n        If `weight` is None, unweighted graph methods are used, and this\n        suggestion is ignored.\n\n    Returns\n    -------\n    length: number or iterator\n        If the source and target are both specified, return the length of\n        the shortest path from the source to the target.\n\n        If only the source is specified, return a dict keyed by target\n        to the shortest path length from the source to that target.\n\n        If only the target is specified, return a dict keyed by source\n        to the shortest path length from that source to the target.\n\n        If neither the source nor target are specified, return an iterator\n        over (source, dictionary) where dictionary is keyed by target to\n        shortest path length from source to that target.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` is not in `G`.\n\n    NetworkXNoPath\n        If no path exists between source and target.\n\n    ValueError\n        If `method` is not among the supported options.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> nx.shortest_path_length(G, source=0, target=4)\n    4\n    >>> p = nx.shortest_path_length(G, source=0)  # target not specified\n    >>> p[4]\n    4\n    >>> p = nx.shortest_path_length(G, target=4)  # source not specified\n    >>> p[0]\n    4\n    >>> p = dict(nx.shortest_path_length(G))  # source,target not specified\n    >>> p[0][4]\n    4\n\n    Notes\n    -----\n    The length of the path is always 1 less than the number of nodes involved\n    in the path since the length measures the number of edges followed.\n\n    For digraphs this returns the shortest directed path length. To find path\n    lengths in the reverse direction use G.reverse(copy=False) first to flip\n    the edge orientation.\n\n    See Also\n    --------\n    all_pairs_shortest_path_length\n    all_pairs_dijkstra_path_length\n    all_pairs_bellman_ford_path_length\n    single_source_shortest_path_length\n    single_source_dijkstra_path_length\n    single_source_bellman_ford_path_length\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef all_shortest_paths(G, source, target, weight=None, method=\"dijkstra\"):\n\"\"\"Compute all shortest simple paths in the graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n       Starting node for path.\n\n    target : node\n       Ending node for path.\n\n    weight : None, string or function, optional (default = None)\n        If None, every edge has weight/distance/cost 1.\n        If a string, use this edge attribute as the edge weight.\n        Any edge attribute not present defaults to 1.\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly\n        three positional arguments: the two endpoints of an edge and\n        the dictionary of edge attributes for that edge.\n        The function must return a number.\n\n    method : string, optional (default = 'dijkstra')\n       The algorithm to use to compute the path lengths.\n       Supported options: 'dijkstra', 'bellman-ford'.\n       Other inputs produce a ValueError.\n       If `weight` is None, unweighted graph methods are used, and this\n       suggestion is ignored.\n\n    Returns\n    -------\n    paths : generator of lists\n        A generator of all paths between source and target.\n\n    Raises\n    ------\n    ValueError\n        If `method` is not among the supported options.\n\n    NetworkXNoPath\n        If `target` cannot be reached from `source`.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> nx.add_path(G, [0, 1, 2])\n    >>> nx.add_path(G, [0, 10, 2])\n    >>> print([p for p in nx.all_shortest_paths(G, source=0, target=2)])\n    [[0, 1, 2], [0, 10, 2]]\n\n    Notes\n    -----\n    There may be many shortest paths between the source and target.  If G\n    contains zero-weight cycles, this function will not produce all shortest\n    paths because doing so would produce infinitely many paths of unbounded\n    length -- instead, we only produce the shortest simple paths.\n\n    See Also\n    --------\n    shortest_path\n    single_source_shortest_path\n    all_pairs_shortest_path\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef all_pairs_all_shortest_paths(G, weight=None, method=\"dijkstra\"):\n\"\"\"Compute all shortest paths between all nodes.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : None, string or function, optional (default = None)\n        If None, every edge has weight/distance/cost 1.\n        If a string, use this edge attribute as the edge weight.\n        Any edge attribute not present defaults to 1.\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly\n        three positional arguments: the two endpoints of an edge and\n        the dictionary of edge attributes for that edge.\n        The function must return a number.\n\n    method : string, optional (default = 'dijkstra')\n       The algorithm to use to compute the path lengths.\n       Supported options: 'dijkstra', 'bellman-ford'.\n       Other inputs produce a ValueError.\n       If `weight` is None, unweighted graph methods are used, and this\n       suggestion is ignored.\n\n    Returns\n    -------\n    paths : generator of dictionary\n        Dictionary of arrays, keyed by source and target, of all shortest paths.\n\n    Raises\n    ------\n    ValueError\n        If `method` is not among the supported options.\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(4)\n    >>> dict(nx.all_pairs_all_shortest_paths(G))[0][2]\n    [[0, 1, 2], [0, 3, 2]]\n    >>> dict(nx.all_pairs_all_shortest_paths(G))[0][3]\n    [[0, 3]]\n\n    Notes\n    -----\n    There may be multiple shortest paths with equal lengths. Unlike\n    all_pairs_shortest_path, this method returns all shortest paths.\n\n    See Also\n    --------\n    all_pairs_shortest_path\n    single_source_all_shortest_paths\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\", preserve_node_attrs=\"heuristic\")\ndef astar_path(G, source, target, heuristic=None, weight=\"weight\", *, cutoff=None):\n\"\"\"Returns a list of nodes in a shortest path between source and target\n    using the A* (\"A-star\") algorithm.\n\n    There may be more than one shortest path.  This returns only one.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n       Starting node for path\n\n    target : node\n       Ending node for path\n\n    heuristic : function\n       A function to evaluate the estimate of the distance\n       from the a node to the target.  The function takes\n       two nodes arguments and must return a number.\n       If the heuristic is inadmissible (if it might\n       overestimate the cost of reaching the goal from a node),\n       the result may not be a shortest path.\n       The algorithm does not support updating heuristic\n       values for the same node due to caching the first\n       heuristic calculation per node.\n\n    weight : string or function\n       If this is a string, then edge weights will be accessed via the\n       edge attribute with this key (that is, the weight of the edge\n       joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n       such edge attribute exists, the weight of the edge is assumed to\n       be one.\n       If this is a function, the weight of an edge is the value\n       returned by the function. The function must accept exactly three\n       positional arguments: the two endpoints of an edge and the\n       dictionary of edge attributes for that edge. The function must\n       return a number or None to indicate a hidden edge.\n\n    cutoff : float, optional\n       If this is provided, the search will be bounded to this value. I.e. if\n       the evaluation function surpasses this value for a node n, the node will not\n       be expanded further and will be ignored. More formally, let h'(n) be the\n       heuristic function, and g(n) be the cost of reaching n from the source node. Then,\n       if g(n) + h'(n) > cutoff, the node will not be explored further.\n       Note that if the heuristic is inadmissible, it is possible that paths\n       are ignored even though they satisfy the cutoff.\n\n    Raises\n    ------\n    NetworkXNoPath\n        If no path exists between source and target.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> print(nx.astar_path(G, 0, 4))\n    [0, 1, 2, 3, 4]\n    >>> G = nx.grid_graph(dim=[3, 3])  # nodes are two-tuples (x,y)\n    >>> nx.set_edge_attributes(G, {e: e[1][0] * 2 for e in G.edges()}, \"cost\")\n    >>> def dist(a, b):\n    ...     (x1, y1) = a\n    ...     (x2, y2) = b\n    ...     return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n    >>> print(nx.astar_path(G, (0, 0), (2, 2), heuristic=dist, weight=\"cost\"))\n    [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    The weight function can be used to hide edges by returning None.\n    So ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\n    will find the shortest red path.\n\n    See Also\n    --------\n    shortest_path, dijkstra_path\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef dijkstra_path(G, source, target, weight=\"weight\"):\n\"\"\"Returns the shortest weighted path from source to target in G.\n\n    Uses Dijkstra's Method to compute the shortest weighted path\n    between two nodes in a graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n        Starting node\n\n    target : node\n        Ending node\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number or None to indicate a hidden edge.\n\n    Returns\n    -------\n    path : list\n        List of nodes in a shortest path.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` is not in `G`.\n\n    NetworkXNoPath\n        If no path exists between source and target.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> print(nx.dijkstra_path(G, 0, 4))\n    [0, 1, 2, 3, 4]\n\n    Find edges of shortest path in Multigraph\n\n    >>> G = nx.MultiDiGraph()\n    >>> G.add_weighted_edges_from([(1, 2, 0.75), (1, 2, 0.5), (2, 3, 0.5), (1, 3, 1.5)])\n    >>> nodes = nx.dijkstra_path(G, 1, 3)\n    >>> edges = nx.utils.pairwise(nodes)\n    >>> list(\n    ...     (u, v, min(G[u][v], key=lambda k: G[u][v][k].get(\"weight\", 1)))\n    ...     for u, v in edges\n    ... )\n    [(1, 2, 1), (2, 3, 0)]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    The weight function can be used to hide edges by returning None.\n    So ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\n    will find the shortest red path.\n\n    The weight function can be used to include node weights.\n\n    >>> def func(u, v, d):\n    ...     node_u_wt = G.nodes[u].get(\"node_weight\", 1)\n    ...     node_v_wt = G.nodes[v].get(\"node_weight\", 1)\n    ...     edge_wt = d.get(\"weight\", 1)\n    ...     return node_u_wt / 2 + node_v_wt / 2 + edge_wt\n\n    In this example we take the average of start and end node\n    weights of an edge and add it to the weight of the edge.\n\n    The function :func:`single_source_dijkstra` computes both\n    path and length-of-path if you need both, use that.\n\n    See Also\n    --------\n    bidirectional_dijkstra\n    bellman_ford_path\n    single_source_dijkstra\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef single_source_dijkstra_path(G, source, cutoff=None, weight=\"weight\"):\n\"\"\"Find shortest weighted paths in G from a source node.\n\n    Compute shortest path between source and all other reachable\n    nodes for a weighted graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n        Starting node for path.\n\n    cutoff : integer or float, optional\n        Length (sum of edge weights) at which the search is stopped.\n        If cutoff is provided, only return paths with summed weight <= cutoff.\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number or None to indicate a hidden edge.\n\n    Returns\n    -------\n    paths : dictionary\n        Dictionary of shortest path lengths keyed by target.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` is not in `G`.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> path = nx.single_source_dijkstra_path(G, 0)\n    >>> path[4]\n    [0, 1, 2, 3, 4]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    The weight function can be used to hide edges by returning None.\n    So ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\n    will find the shortest red path.\n\n    See Also\n    --------\n    single_source_dijkstra, single_source_bellman_ford\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef single_source_dijkstra(G, source, target=None, cutoff=None, weight=\"weight\"):\n\"\"\"Find shortest weighted paths and lengths from a source node.\n\n    Compute the shortest path length between source and all other\n    reachable nodes for a weighted graph.\n\n    Uses Dijkstra's algorithm to compute shortest paths and lengths\n    between a source and all other reachable nodes in a weighted graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node label\n        Starting node for path\n\n    target : node label, optional\n        Ending node for path\n\n    cutoff : integer or float, optional\n        Length (sum of edge weights) at which the search is stopped.\n        If cutoff is provided, only return paths with summed weight <= cutoff.\n\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number or None to indicate a hidden edge.\n\n    Returns\n    -------\n    distance, path : pair of dictionaries, or numeric and list.\n        If target is None, paths and lengths to all nodes are computed.\n        The return value is a tuple of two dictionaries keyed by target nodes.\n        The first dictionary stores distance to each target node.\n        The second stores the path to each target node.\n        If target is not None, returns a tuple (distance, path), where\n        distance is the distance from source to target and path is a list\n        representing the path from source to target.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` is not in `G`.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> length, path = nx.single_source_dijkstra(G, 0)\n    >>> length[4]\n    4\n    >>> for node in [0, 1, 2, 3, 4]:\n    ...     print(f\"{node}: {length[node]}\")\n    0: 0\n    1: 1\n    2: 2\n    3: 3\n    4: 4\n    >>> path[4]\n    [0, 1, 2, 3, 4]\n    >>> length, path = nx.single_source_dijkstra(G, 0, 1)\n    >>> length\n    1\n    >>> path\n    [0, 1]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    The weight function can be used to hide edges by returning None.\n    So ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\n    will find the shortest red path.\n\n    Based on the Python cookbook recipe (119466) at\n    https://code.activestate.com/recipes/119466/\n\n    This algorithm is not guaranteed to work if edge weights\n    are negative or are floating point numbers\n    (overflows and roundoff errors can cause problems).\n\n    See Also\n    --------\n    single_source_dijkstra_path\n    single_source_dijkstra_path_length\n    single_source_bellman_ford\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef multi_source_dijkstra_path_length(G, sources, cutoff=None, weight=\"weight\"):\n\"\"\"Find shortest weighted path lengths in G from a given set of\n    source nodes.\n\n    Compute the shortest path length between any of the source nodes and\n    all other reachable nodes for a weighted graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    sources : non-empty set of nodes\n        Starting nodes for paths. If this is just a set containing a\n        single node, then all paths computed by this function will start\n        from that node. If there are two or more nodes in the set, the\n        computed paths may begin from any one of the start nodes.\n\n    cutoff : integer or float, optional\n        Length (sum of edge weights) at which the search is stopped.\n        If cutoff is provided, only return paths with summed weight <= cutoff.\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number or None to indicate a hidden edge.\n\n    Returns\n    -------\n    length : dict\n        Dict keyed by node to shortest path length to nearest source.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> length = nx.multi_source_dijkstra_path_length(G, {0, 4})\n    >>> for node in [0, 1, 2, 3, 4]:\n    ...     print(f\"{node}: {length[node]}\")\n    0: 0\n    1: 1\n    2: 2\n    3: 1\n    4: 0\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    The weight function can be used to hide edges by returning None.\n    So ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\n    will find the shortest red path.\n\n    Raises\n    ------\n    ValueError\n        If `sources` is empty.\n    NodeNotFound\n        If any of `sources` is not in `G`.\n\n    See Also\n    --------\n    multi_source_dijkstra\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef dijkstra_predecessor_and_distance(G, source, cutoff=None, weight=\"weight\"):\n\"\"\"Compute weighted shortest path length and predecessors.\n\n    Uses Dijkstra's Method to obtain the shortest weighted paths\n    and return dictionaries of predecessors for each node and\n    distance for each node from the `source`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node label\n        Starting node for path\n\n    cutoff : integer or float, optional\n        Length (sum of edge weights) at which the search is stopped.\n        If cutoff is provided, only return paths with summed weight <= cutoff.\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number or None to indicate a hidden edge.\n\n    Returns\n    -------\n    pred, distance : dictionaries\n        Returns two dictionaries representing a list of predecessors\n        of a node and the distance to each node.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` is not in `G`.\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    The list of predecessors contains more than one element only when\n    there are more than one shortest paths to the key node.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5, create_using=nx.DiGraph())\n    >>> pred, dist = nx.dijkstra_predecessor_and_distance(G, 0)\n    >>> sorted(pred.items())\n    [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\n    >>> sorted(dist.items())\n    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n\n    >>> pred, dist = nx.dijkstra_predecessor_and_distance(G, 0, 1)\n    >>> sorted(pred.items())\n    [(0, []), (1, [0])]\n    >>> sorted(dist.items())\n    [(0, 0), (1, 1)]\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef all_pairs_dijkstra_path_length(G, cutoff=None, weight=\"weight\"):\n\"\"\"Compute shortest path lengths between all nodes in a weighted graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    cutoff : integer or float, optional\n        Length (sum of edge weights) at which the search is stopped.\n        If cutoff is provided, only return paths with summed weight <= cutoff.\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number or None to indicate a hidden edge.\n\n    Returns\n    -------\n    distance : iterator\n        (source, dictionary) iterator with dictionary keyed by target and\n        shortest path length as the key value.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> length = dict(nx.all_pairs_dijkstra_path_length(G))\n    >>> for node in [0, 1, 2, 3, 4]:\n    ...     print(f\"1 - {node}: {length[1][node]}\")\n    1 - 0: 1\n    1 - 1: 0\n    1 - 2: 1\n    1 - 3: 2\n    1 - 4: 3\n    >>> length[3][2]\n    1\n    >>> length[2][2]\n    0\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    The dictionary returned only has keys for reachable node pairs.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef bellman_ford_path(G, source, target, weight=\"weight\"):\n\"\"\"Returns the shortest path from source to target in a weighted graph G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n        Starting node\n\n    target : node\n        Ending node\n\n    weight : string or function (default=\"weight\")\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number.\n\n    Returns\n    -------\n    path : list\n        List of nodes in a shortest path.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` is not in `G`.\n\n    NetworkXNoPath\n        If no path exists between source and target.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> nx.bellman_ford_path(G, 0, 4)\n    [0, 1, 2, 3, 4]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    See Also\n    --------\n    dijkstra_path, bellman_ford_path_length\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef single_source_bellman_ford_path(G, source, weight=\"weight\"):\n\"\"\"Compute shortest path between source and all other reachable\n    nodes for a weighted graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n        Starting node for path.\n\n    weight : string or function (default=\"weight\")\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number.\n\n    Returns\n    -------\n    paths : dictionary\n        Dictionary of shortest path lengths keyed by target.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` is not in `G`.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> path = nx.single_source_bellman_ford_path(G, 0)\n    >>> path[4]\n    [0, 1, 2, 3, 4]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    See Also\n    --------\n    single_source_dijkstra, single_source_bellman_ford\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef single_source_bellman_ford(G, source, target=None, weight=\"weight\"):\n\"\"\"Compute shortest paths and lengths in a weighted graph G.\n\n    Uses Bellman-Ford algorithm for shortest paths.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node label\n        Starting node for path\n\n    target : node label, optional\n        Ending node for path\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number.\n\n    Returns\n    -------\n    distance, path : pair of dictionaries, or numeric and list\n        If target is None, returns a tuple of two dictionaries keyed by node.\n        The first dictionary stores distance from one of the source nodes.\n        The second stores the path from one of the sources to that node.\n        If target is not None, returns a tuple of (distance, path) where\n        distance is the distance from source to target and path is a list\n        representing the path from source to target.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` is not in `G`.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> length, path = nx.single_source_bellman_ford(G, 0)\n    >>> length[4]\n    4\n    >>> for node in [0, 1, 2, 3, 4]:\n    ...     print(f\"{node}: {length[node]}\")\n    0: 0\n    1: 1\n    2: 2\n    3: 3\n    4: 4\n    >>> path[4]\n    [0, 1, 2, 3, 4]\n    >>> length, path = nx.single_source_bellman_ford(G, 0, 1)\n    >>> length\n    1\n    >>> path\n    [0, 1]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    See Also\n    --------\n    single_source_dijkstra\n    single_source_bellman_ford_path\n    single_source_bellman_ford_path_length\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef all_pairs_bellman_ford_path(G, weight=\"weight\"):\n\"\"\"Compute shortest paths between all nodes in a weighted graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : string or function (default=\"weight\")\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number.\n\n    Returns\n    -------\n    paths : iterator\n        (source, dictionary) iterator with dictionary keyed by target and\n        shortest path as the key value.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> path = dict(nx.all_pairs_bellman_ford_path(G))\n    >>> path[0][4]\n    [0, 1, 2, 3, 4]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    See Also\n    --------\n    floyd_warshall, all_pairs_dijkstra_path\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef negative_edge_cycle(G, weight=\"weight\", heuristic=True):\n\"\"\"Returns True if there exists a negative edge cycle anywhere in G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number.\n\n    heuristic : bool\n        Determines whether to use a heuristic to early detect negative\n        cycles at a negligible cost. In case of graphs with a negative cycle,\n        the performance of detection increases by at least an order of magnitude.\n\n    Returns\n    -------\n    negative_cycle : bool\n        True if a negative edge cycle exists, otherwise False.\n\n    Examples\n    --------\n    >>> G = nx.cycle_graph(5, create_using=nx.DiGraph())\n    >>> print(nx.negative_edge_cycle(G))\n    False\n    >>> G[1][2][\"weight\"] = -7\n    >>> print(nx.negative_edge_cycle(G))\n    True\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    This algorithm uses bellman_ford_predecessor_and_distance() but finds\n    negative cycles on any component by first adding a new node connected to\n    every node, and starting bellman_ford_predecessor_and_distance on that\n    node.  It then removes that extra node.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef bidirectional_dijkstra(G, source, target, weight=\"weight\"):\n\"\"\"Dijkstra's algorithm for shortest paths using bidirectional search.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n        Starting node.\n\n    target : node\n        Ending node.\n\n    weight : string or function\n        If this is a string, then edge weights will be accessed via the\n        edge attribute with this key (that is, the weight of the edge\n        joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n        such edge attribute exists, the weight of the edge is assumed to\n        be one.\n\n        If this is a function, the weight of an edge is the value\n        returned by the function. The function must accept exactly three\n        positional arguments: the two endpoints of an edge and the\n        dictionary of edge attributes for that edge. The function must\n        return a number or None to indicate a hidden edge.\n\n    Returns\n    -------\n    length, path : number and list\n        length is the distance from source to target.\n        path is a list of nodes on a path from source to target.\n\n    Raises\n    ------\n    NodeNotFound\n        If `source` or `target` is not in `G`.\n\n    NetworkXNoPath\n        If no path exists between source and target.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> length, path = nx.bidirectional_dijkstra(G, 0, 4)\n    >>> print(length)\n    4\n    >>> print(path)\n    [0, 1, 2, 3, 4]\n\n    Notes\n    -----\n    Edge weight attributes must be numerical.\n    Distances are calculated as sums of weighted edges traversed.\n\n    The weight function can be used to hide edges by returning None.\n    So ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\n    will find the shortest red path.\n\n    In practice  bidirectional Dijkstra is much more than twice as fast as\n    ordinary Dijkstra.\n\n    Ordinary Dijkstra expands nodes in a sphere-like manner from the\n    source. The radius of this sphere will eventually be the length\n    of the shortest path. Bidirectional Dijkstra will expand nodes\n    from both the source and the target, making two spheres of half\n    this radius. Volume of the first sphere is `\\pi*r*r` while the\n    others are `2*\\pi*r/2*r/2`, making up half the volume.\n\n    This algorithm is not guaranteed to work if edge weights\n    are negative or are floating point numbers\n    (overflows and roundoff errors can cause problems).\n\n    See Also\n    --------\n    shortest_path\n    shortest_path_length\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef single_source_shortest_path_length(G, source, cutoff=None):\n\"\"\"Compute the shortest path lengths from source to all reachable nodes.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node\n       Starting node for path\n\n    cutoff : integer, optional\n        Depth to stop the search. Only paths of length <= cutoff are returned.\n\n    Returns\n    -------\n    lengths : dict\n        Dict keyed by node to shortest path length to source.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> length = nx.single_source_shortest_path_length(G, 0)\n    >>> length[4]\n    4\n    >>> for node in length:\n    ...     print(f\"{node}: {length[node]}\")\n    0: 0\n    1: 1\n    2: 2\n    3: 3\n    4: 4\n\n    See Also\n    --------\n    shortest_path_length\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef single_target_shortest_path_length(G, target, cutoff=None):\n\"\"\"Compute the shortest path lengths to target from all reachable nodes.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    target : node\n       Target node for path\n\n    cutoff : integer, optional\n        Depth to stop the search. Only paths of length <= cutoff are returned.\n\n    Returns\n    -------\n    lengths : iterator\n        (source, shortest path length) iterator\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5, create_using=nx.DiGraph())\n    >>> length = dict(nx.single_target_shortest_path_length(G, 4))\n    >>> length[0]\n    4\n    >>> for node in range(5):\n    ...     print(f\"{node}: {length[node]}\")\n    0: 4\n    1: 3\n    2: 2\n    3: 1\n    4: 0\n\n    See Also\n    --------\n    single_source_shortest_path_length, shortest_path_length\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef bidirectional_shortest_path(G, source, target):\n\"\"\"Returns a list of nodes in a shortest path between source and target.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node label\n       starting node for path\n\n    target : node label\n       ending node for path\n\n    Returns\n    -------\n    path: list\n       List of nodes in a path from source to target.\n\n    Raises\n    ------\n    NetworkXNoPath\n       If no path exists between source and target.\n\n    Examples\n    --------\n    >>> G = nx.Graph()\n    >>> nx.add_path(G, [0, 1, 2, 3, 0, 4, 5, 6, 7, 4])\n    >>> nx.bidirectional_shortest_path(G, 2, 6)\n    [2, 1, 0, 4, 5, 6]\n\n    See Also\n    --------\n    shortest_path\n\n    Notes\n    -----\n    This algorithm is used by shortest_path(G, source, target).\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef single_source_shortest_path(G, source, cutoff=None):\n\"\"\"Compute shortest path between source\n    and all other nodes reachable from source.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node label\n       Starting node for path\n\n    cutoff : integer, optional\n        Depth to stop the search. Only paths of length <= cutoff are returned.\n\n    Returns\n    -------\n    paths : dictionary\n        Dictionary, keyed by target, of shortest paths.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> path = nx.single_source_shortest_path(G, 0)\n    >>> path[4]\n    [0, 1, 2, 3, 4]\n\n    Notes\n    -----\n    The shortest path is not necessarily unique. So there can be multiple\n    paths between the source and each target node, all of which have the\n    same 'shortest' length. For each target node, this function returns\n    only one of those paths.\n\n    See Also\n    --------\n    shortest_path\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef single_target_shortest_path(G, target, cutoff=None):\n\"\"\"Compute shortest path to target from all nodes that reach target.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    target : node label\n       Target node for path\n\n    cutoff : integer, optional\n        Depth to stop the search. Only paths of length <= cutoff are returned.\n\n    Returns\n    -------\n    paths : dictionary\n        Dictionary, keyed by target, of shortest paths.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5, create_using=nx.DiGraph())\n    >>> path = nx.single_target_shortest_path(G, 4)\n    >>> path[0]\n    [0, 1, 2, 3, 4]\n\n    Notes\n    -----\n    The shortest path is not necessarily unique. So there can be multiple\n    paths between the source and each target node, all of which have the\n    same 'shortest' length. For each target node, this function returns\n    only one of those paths.\n\n    See Also\n    --------\n    shortest_path, single_source_shortest_path\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef predecessor(G, source, target=None, cutoff=None, return_seen=None):\n\"\"\"Returns dict of predecessors for the path from source to all nodes in G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    source : node label\n       Starting node for path\n\n    target : node label, optional\n       Ending node for path. If provided only predecessors between\n       source and target are returned\n\n    cutoff : integer, optional\n        Depth to stop the search. Only paths of length <= cutoff are returned.\n\n    return_seen : bool, optional (default=None)\n        Whether to return a dictionary, keyed by node, of the level (number of\n        hops) to reach the node (as seen during breadth-first-search).\n\n    Returns\n    -------\n    pred : dictionary\n        Dictionary, keyed by node, of predecessors in the shortest path.\n\n\n    (pred, seen): tuple of dictionaries\n        If `return_seen` argument is set to `True`, then a tuple of dictionaries\n        is returned. The first element is the dictionary, keyed by node, of\n        predecessors in the shortest path. The second element is the dictionary,\n        keyed by node, of the level (number of hops) to reach the node (as seen\n        during breadth-first-search).\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> list(G)\n    [0, 1, 2, 3]\n    >>> nx.predecessor(G, 0)\n    {0: [], 1: [0], 2: [1], 3: [2]}\n    >>> nx.predecessor(G, 0, return_seen=True)\n    ({0: [], 1: [0], 2: [1], 3: [2]}, {0: 0, 1: 1, 2: 2, 3: 3})\n\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef floyd_warshall_numpy(G, nodelist=None, weight=\"weight\"):\n\"\"\"Find all-pairs shortest path lengths using Floyd's algorithm.\n\n    This algorithm for finding shortest paths takes advantage of\n    matrix representations of a graph and works well for dense\n    graphs where all-pairs shortest path lengths are desired.\n    The results are returned as a NumPy array, distance[i, j],\n    where i and j are the indexes of two nodes in nodelist.\n    The entry distance[i, j] is the distance along a shortest\n    path from i to j. If no path exists the distance is Inf.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nodelist : list, optional (default=G.nodes)\n       The rows and columns are ordered by the nodes in nodelist.\n       If nodelist is None then the ordering is produced by G.nodes.\n       Nodelist should include all nodes in G.\n\n    weight: string, optional (default='weight')\n       Edge data key corresponding to the edge weight.\n\n    Returns\n    -------\n    distance : 2D numpy.ndarray\n        A numpy array of shortest path distances between nodes.\n        If there is no path between two nodes the value is Inf.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph()\n    >>> G.add_weighted_edges_from(\n    ...     [(0, 1, 5), (1, 2, 2), (2, 3, -3), (1, 3, 10), (3, 2, 8)]\n    ... )\n    >>> nx.floyd_warshall_numpy(G)\n    array([[ 0.,  5.,  7.,  4.],\n           [inf,  0.,  2., -1.],\n           [inf, inf,  0., -3.],\n           [inf, inf,  8.,  0.]])\n\n    Notes\n    -----\n    Floyd's algorithm is appropriate for finding shortest paths in\n    dense graphs or graphs with negative weights when Dijkstra's\n    algorithm fails. This algorithm can still fail if there are negative\n    cycles. It has running time $O(n^3)$ with running space of $O(n^2)$.\n\n    Raises\n    ------\n    NetworkXError\n        If nodelist is not a list of the nodes in G.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(graphs=None)\ndef reconstruct_path(source, target, predecessors):\n\"\"\"Reconstruct a path from source to target using the predecessors\n    dict as returned by floyd_warshall_predecessor_and_distance\n\n    Parameters\n    ----------\n    source : node\n       Starting node for path\n\n    target : node\n       Ending node for path\n\n    predecessors: dictionary\n       Dictionary, keyed by source and target, of predecessors in the\n       shortest path, as returned by floyd_warshall_predecessor_and_distance\n\n    Returns\n    -------\n    path : list\n       A list of nodes containing the shortest path from source to target\n\n       If source and target are the same, an empty list is returned\n\n    Notes\n    -----\n    This function is meant to give more applicability to the\n    floyd_warshall_predecessor_and_distance function\n\n    See Also\n    --------\n    floyd_warshall_predecessor_and_distance\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef group_betweenness_centrality(G, C, normalized=True, weight=None, endpoints=False):\n\"\"\"Compute the group betweenness centrality for a group of nodes.\n\n    Group betweenness centrality of a group of nodes $C$ is the sum of the\n    fraction of all-pairs shortest paths that pass through any vertex in $C$\n\n    .. math::\n\n       c_B(v) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}\n\n    where $V$ is the set of nodes, $\\sigma(s, t)$ is the number of\n    shortest $(s, t)$-paths, and $\\sigma(s, t|C)$ is the number of\n    those paths passing through some node in group $C$. Note that\n    $(s, t)$ are not members of the group ($V-C$ is the set of nodes\n    in $V$ that are not in $C$).\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph.\n\n    C : list or set or list of lists or list of sets\n      A group or a list of groups containing nodes which belong to G, for which group betweenness\n      centrality is to be calculated.\n\n    normalized : bool, optional (default=True)\n      If True, group betweenness is normalized by `1/((|V|-|C|)(|V|-|C|-1))`\n      where `|V|` is the number of nodes in G and `|C|` is the number of nodes in C.\n\n    weight : None or string, optional (default=None)\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n      The weight of an edge is treated as the length or distance between the two sides.\n\n    endpoints : bool, optional (default=False)\n      If True include the endpoints in the shortest path counts.\n\n    Raises\n    ------\n    NodeNotFound\n       If node(s) in C are not present in G.\n\n    Returns\n    -------\n    betweenness : list of floats or float\n       If C is a single group then return a float. If C is a list with\n       several groups then return a list of group betweenness centralities.\n\n    See Also\n    --------\n    betweenness_centrality\n\n    Notes\n    -----\n    Group betweenness centrality is described in [1]_ and its importance discussed in [3]_.\n    The initial implementation of the algorithm is mentioned in [2]_. This function uses\n    an improved algorithm presented in [4]_.\n\n    The number of nodes in the group must be a maximum of n - 2 where `n`\n    is the total number of nodes in the graph.\n\n    For weighted graphs the edge weights must be greater than zero.\n    Zero edge weights can produce an infinite number of equal length\n    paths between pairs of nodes.\n\n    The total number of paths between source and target is counted\n    differently for directed and undirected graphs. Directed paths\n    between \"u\" and \"v\" are counted as two possible paths (one each\n    direction) while undirected paths between \"u\" and \"v\" are counted\n    as one path. Said another way, the sum in the expression above is\n    over all ``s != t`` for directed graphs and for ``s < t`` for undirected graphs.\n\n\n    References\n    ----------\n    .. [1] M G Everett and S P Borgatti:\n       The Centrality of Groups and Classes.\n       Journal of Mathematical Sociology. 23(3): 181-201. 1999.\n       http://www.analytictech.com/borgatti/group_centrality.htm\n    .. [2] Ulrik Brandes:\n       On Variants of Shortest-Path Betweenness\n       Centrality and their Generic Computation.\n       Social Networks 30(2):136-145, 2008.\n       http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.9610&rep=rep1&type=pdf\n    .. [3] Sourav Medya et. al.:\n       Group Centrality Maximization via Network Design.\n       SIAM International Conference on Data Mining, SDM 2018, 126\u2013134.\n       https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf\n    .. [4] Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n       \"Fast algorithm for successive computation of group betweenness centrality.\"\n       https://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef _dfbnb(G, k, DF_tree, max_GBC, root, D, max_group, nodes, greedy):"}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef group_closeness_centrality(G, S, weight=None):\n\"\"\"Compute the group closeness centrality for a group of nodes.\n\n    Group closeness centrality of a group of nodes $S$ is a measure\n    of how close the group is to the other nodes in the graph.\n\n    .. math::\n\n       c_{close}(S) = \\frac{|V-S|}{\\sum_{v \\in V-S} d_{S, v}}\n\n       d_{S, v} = min_{u \\in S} (d_{u, v})\n\n    where $V$ is the set of nodes, $d_{S, v}$ is the distance of\n    the group $S$ from $v$ defined as above. ($V-S$ is the set of nodes\n    in $V$ that are not in $S$).\n\n    Parameters\n    ----------\n    G : graph\n       A NetworkX graph.\n\n    S : list or set\n       S is a group of nodes which belong to G, for which group closeness\n       centrality is to be calculated.\n\n    weight : None or string, optional (default=None)\n       If None, all edge weights are considered equal.\n       Otherwise holds the name of the edge attribute used as weight.\n       The weight of an edge is treated as the length or distance between the two sides.\n\n    Raises\n    ------\n    NodeNotFound\n       If node(s) in S are not present in G.\n\n    Returns\n    -------\n    closeness : float\n       Group closeness centrality of the group S.\n\n    See Also\n    --------\n    closeness_centrality\n\n    Notes\n    -----\n    The measure was introduced in [1]_.\n    The formula implemented here is described in [2]_.\n\n    Higher values of closeness indicate greater centrality.\n\n    It is assumed that 1 / 0 is 0 (required in the case of directed graphs,\n    or when a shortest path length is 0).\n\n    The number of nodes in the group must be a maximum of n - 1 where `n`\n    is the total number of nodes in the graph.\n\n    For directed graphs, the incoming distance is utilized here. To use the\n    outward distance, act on `G.reverse()`.\n\n    For weighted graphs the edge weights must be greater than zero.\n    Zero edge weights can produce an infinite number of equal length\n    paths between pairs of nodes.\n\n    References\n    ----------\n    .. [1] M G Everett and S P Borgatti:\n       The Centrality of Groups and Classes.\n       Journal of Mathematical Sociology. 23(3): 181-201. 1999.\n       http://www.analytictech.com/borgatti/group_centrality.htm\n    .. [2] J. Zhao et. al.:\n       Measuring and Maximizing Group Closeness Centrality over\n       Disk Resident Graphs.\n       WWWConference Proceedings, 2014. 689-694.\n       https://doi.org/10.1145/2567948.2579356\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef group_in_degree_centrality(G, S):\n\"\"\"Compute the group in-degree centrality for a group of nodes.\n\n    Group in-degree centrality of a group of nodes $S$ is the fraction\n    of non-group members connected to group members by incoming edges.\n\n    Parameters\n    ----------\n    G : graph\n       A NetworkX graph.\n\n    S : list or set\n       S is a group of nodes which belong to G, for which group in-degree\n       centrality is to be calculated.\n\n    Returns\n    -------\n    centrality : float\n       Group in-degree centrality of the group S.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n       If G is undirected.\n\n    NodeNotFound\n       If node(s) in S are not in G.\n\n    See Also\n    --------\n    degree_centrality\n    group_degree_centrality\n    group_out_degree_centrality\n\n    Notes\n    -----\n    The number of nodes in the group must be a maximum of n - 1 where `n`\n    is the total number of nodes in the graph.\n\n    `G.neighbors(i)` gives nodes with an outward edge from i, in a DiGraph,\n    so for group in-degree centrality, the reverse graph is used.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")"}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")"}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"distance\")\ndef harmonic_centrality(G, nbunch=None, distance=None, sources=None):\n\"\"\"Compute harmonic centrality for nodes.\n\n    Harmonic centrality [1]_ of a node `u` is the sum of the reciprocal\n    of the shortest path distances from all other nodes to `u`\n\n    .. math::\n\n        C(u) = \\sum_{v \\neq u} \\frac{1}{d(v, u)}\n\n    where `d(v, u)` is the shortest-path distance between `v` and `u`.\n\n    If `sources` is given as an argument, the returned harmonic centrality\n    values are calculated as the sum of the reciprocals of the shortest\n    path distances from the nodes specified in `sources` to `u` instead\n    of from all nodes to `u`.\n\n    Notice that higher values indicate higher centrality.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    nbunch : container (default: all nodes in G)\n      Container of nodes for which harmonic centrality values are calculated.\n\n    sources : container (default: all nodes in G)\n      Container of nodes `v` over which reciprocal distances are computed.\n      Nodes not in `G` are silently ignored.\n\n    distance : edge attribute key, optional (default=None)\n      Use the specified edge attribute as the edge distance in shortest\n      path calculations.  If `None`, then each edge will have distance equal to 1.\n\n    Returns\n    -------\n    nodes : dictionary\n      Dictionary of nodes with harmonic centrality as the value.\n\n    See Also\n    --------\n    betweenness_centrality, load_centrality, eigenvector_centrality,\n    degree_centrality, closeness_centrality\n\n    Notes\n    -----\n    If the 'distance' keyword is set to an edge attribute key then the\n    shortest-path length will be computed using Dijkstra's algorithm with\n    that edge attribute as the edge weight.\n\n    References\n    ----------\n    .. [1] Boldi, Paolo, and Sebastiano Vigna. \"Axioms for centrality.\"\n           Internet Mathematics 10.3-4 (2014): 222-262.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef second_order_centrality(G, weight=\"weight\"):\n\"\"\"Compute the second order centrality for nodes of G.\n\n    The second order centrality of a given node is the standard deviation of\n    the return times to that node of a perpetual random walk on G:\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX connected and undirected graph.\n\n    weight : string or None, optional (default=\"weight\")\n        The name of an edge attribute that holds the numerical value\n        used as a weight. If None then each edge has weight 1.\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary keyed by node with second order centrality as the value.\n\n    Examples\n    --------\n    >>> G = nx.star_graph(10)\n    >>> soc = nx.second_order_centrality(G)\n    >>> print(sorted(soc.items(), key=lambda x: x[1])[0][0])  # pick first id\n    0\n\n    Raises\n    ------\n    NetworkXException\n        If the graph G is empty, non connected or has negative weights.\n\n    See Also\n    --------\n    betweenness_centrality\n\n    Notes\n    -----\n    Lower values of second order centrality indicate higher centrality.\n\n    The algorithm is from Kermarrec, Le Merrer, Sericola and Tr\u00e9dan [1]_.\n\n    This code implements the analytical version of the algorithm, i.e.,\n    there is no simulation of a random walk process involved. The random walk\n    is here unbiased (corresponding to eq 6 of the paper [1]_), thus the\n    centrality values are the standard deviations for random walk return times\n    on the transformed input graph G (equal in-degree at each nodes by adding\n    self-loops).\n\n    Complexity of this implementation, made to run locally on a single machine,\n    is O(n^3), with n the size of G, which makes it viable only for small\n    graphs.\n\n    References\n    ----------\n    .. [1] Anne-Marie Kermarrec, Erwan Le Merrer, Bruno Sericola, Gilles Tr\u00e9dan\n       \"Second order centrality: Distributed assessment of nodes criticity in\n       complex networks\", Elsevier Computer Communications 34(5):619-628, 2011.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef betweenness_centrality_subset(G, sources, targets, normalized=False, weight=None):\n\"\"\"Compute betweenness centrality for a subset of nodes.\n\n    .. math::\n\n       c_B(v) =\\sum_{s\\in S, t \\in T} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}\n\n    where $S$ is the set of sources, $T$ is the set of targets,\n    $\\sigma(s, t)$ is the number of shortest $(s, t)$-paths,\n    and $\\sigma(s, t|v)$ is the number of those paths\n    passing through some  node $v$ other than $s, t$.\n    If $s = t$, $\\sigma(s, t) = 1$,\n    and if $v \\in {s, t}$, $\\sigma(s, t|v) = 0$ [2]_.\n\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph.\n\n    sources: list of nodes\n      Nodes to use as sources for shortest paths in betweenness\n\n    targets: list of nodes\n      Nodes to use as targets for shortest paths in betweenness\n\n    normalized : bool, optional\n      If True the betweenness values are normalized by $2/((n-1)(n-2))$\n      for graphs, and $1/((n-1)(n-2))$ for directed graphs where $n$\n      is the number of nodes in G.\n\n    weight : None or string, optional (default=None)\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n      Weights are used to calculate weighted shortest paths, so they are\n      interpreted as distances.\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with betweenness centrality as the value.\n\n    See Also\n    --------\n    edge_betweenness_centrality\n    load_centrality\n\n    Notes\n    -----\n    The basic algorithm is from [1]_.\n\n    For weighted graphs the edge weights must be greater than zero.\n    Zero edge weights can produce an infinite number of equal length\n    paths between pairs of nodes.\n\n    The normalization might seem a little strange but it is\n    designed to make betweenness_centrality(G) be the same as\n    betweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()).\n\n    The total number of paths between source and target is counted\n    differently for directed and undirected graphs. Directed paths\n    are easy to count. Undirected paths are tricky: should a path\n    from \"u\" to \"v\" count as 1 undirected path or as 2 directed paths?\n\n    For betweenness_centrality we report the number of undirected\n    paths when G is undirected.\n\n    For betweenness_centrality_subset the reporting is different.\n    If the source and target subsets are the same, then we want\n    to count undirected paths. But if the source and target subsets\n    differ -- for example, if sources is {0} and targets is {1},\n    then we are only counting the paths in one direction. They are\n    undirected paths but we are counting them in a directed way.\n    To count them as undirected paths, each should count as half a path.\n\n    References\n    ----------\n    .. [1] Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\n       Journal of Mathematical Sociology 25(2):163-177, 2001.\n       https://doi.org/10.1080/0022250X.2001.9990249\n    .. [2] Ulrik Brandes: On Variants of Shortest-Path Betweenness\n       Centrality and their Generic Computation.\n       Social Networks 30(2):136-145, 2008.\n       https://doi.org/10.1016/j.socnet.2007.11.001\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef katz_centrality_numpy(G, alpha=0.1, beta=1.0, normalized=True, weight=None):\n\"\"\"Compute the Katz centrality for the graph G.\n\n    Katz centrality computes the centrality for a node based on the centrality\n    of its neighbors. It is a generalization of the eigenvector centrality. The\n    Katz centrality for node $i$ is\n\n    .. math::\n\n        x_i = \\alpha \\sum_{j} A_{ij} x_j + \\beta,\n\n    where $A$ is the adjacency matrix of graph G with eigenvalues $\\lambda$.\n\n    The parameter $\\beta$ controls the initial centrality and\n\n    .. math::\n\n        \\alpha < \\frac{1}{\\lambda_{\\max}}.\n\n    Katz centrality computes the relative influence of a node within a\n    network by measuring the number of the immediate neighbors (first\n    degree nodes) and also all other nodes in the network that connect\n    to the node under consideration through these immediate neighbors.\n\n    Extra weight can be provided to immediate neighbors through the\n    parameter $\\beta$.  Connections made with distant neighbors\n    are, however, penalized by an attenuation factor $\\alpha$ which\n    should be strictly less than the inverse largest eigenvalue of the\n    adjacency matrix in order for the Katz centrality to be computed\n    correctly. More information is provided in [1]_.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    alpha : float\n      Attenuation factor\n\n    beta : scalar or dictionary, optional (default=1.0)\n      Weight attributed to the immediate neighborhood. If not a scalar the\n      dictionary must have an value for every node.\n\n    normalized : bool\n      If True normalize the resulting values.\n\n    weight : None or string, optional\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n      In this measure the weight is interpreted as the connection strength.\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with Katz centrality as the value.\n\n    Raises\n    ------\n    NetworkXError\n       If the parameter `beta` is not a scalar but lacks a value for at least\n       one node\n\n    Examples\n    --------\n    >>> import math\n    >>> G = nx.path_graph(4)\n    >>> phi = (1 + math.sqrt(5)) / 2.0  # largest eigenvalue of adj matrix\n    >>> centrality = nx.katz_centrality_numpy(G, 1 / phi)\n    >>> for n, c in sorted(centrality.items()):\n    ...     print(f\"{n} {c:.2f}\")\n    0 0.37\n    1 0.60\n    2 0.60\n    3 0.37\n\n    See Also\n    --------\n    katz_centrality\n    eigenvector_centrality_numpy\n    eigenvector_centrality\n    :func:`~networkx.algorithms.link_analysis.pagerank_alg.pagerank`\n    :func:`~networkx.algorithms.link_analysis.hits_alg.hits`\n\n    Notes\n    -----\n    Katz centrality was introduced by [2]_.\n\n    This algorithm uses a direct linear solver to solve the above equation.\n    The parameter ``alpha`` should be strictly less than the inverse of largest\n    eigenvalue of the adjacency matrix for there to be a solution.\n    You can use ``max(nx.adjacency_spectrum(G))`` to get $\\lambda_{\\max}$ the largest\n    eigenvalue of the adjacency matrix.\n\n    For strongly connected graphs, as $\\alpha \\to 1/\\lambda_{\\max}$, and $\\beta > 0$,\n    Katz centrality approaches the results for eigenvector centrality.\n\n    For directed graphs this finds \"left\" eigenvectors which corresponds\n    to the in-edges in the graph. For out-edges Katz centrality,\n    first reverse the graph with ``G.reverse()``.\n\n    References\n    ----------\n    .. [1] Mark E. J. Newman:\n       Networks: An Introduction.\n       Oxford University Press, USA, 2010, p. 173.\n    .. [2] Leo Katz:\n       A New Status Index Derived from Sociometric Index.\n       Psychometrika 18(1):39\u201343, 1953\n       https://link.springer.com/content/pdf/10.1007/BF02289026.pdf\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef flow_matrix_row(G, weight=None, dtype=float, solver=\"lu\"):"}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef degree_centrality(G):\n\"\"\"Compute the degree centrality for nodes.\n\n    The degree centrality for a node v is the fraction of nodes it\n    is connected to.\n\n    Parameters\n    ----------\n    G : graph\n      A networkx graph\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with degree centrality as the value.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> nx.degree_centrality(G)\n    {0: 1.0, 1: 1.0, 2: 0.6666666666666666, 3: 0.6666666666666666}\n\n    See Also\n    --------\n    betweenness_centrality, load_centrality, eigenvector_centrality\n\n    Notes\n    -----\n    The degree centrality values are normalized by dividing by the maximum\n    possible degree in a simple graph n-1 where n is the number of nodes in G.\n\n    For multigraphs or graphs with self loops the maximum degree might\n    be higher than n-1 and values of degree centrality greater than 1\n    are possible.\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable\ndef out_degree_centrality(G):\n\"\"\"Compute the out-degree centrality for nodes.\n\n    The out-degree centrality for a node v is the fraction of nodes its\n    outgoing edges are connected to.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX graph\n\n    Returns\n    -------\n    nodes : dictionary\n        Dictionary of nodes with out-degree centrality as values.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> nx.out_degree_centrality(G)\n    {0: 1.0, 1: 0.6666666666666666, 2: 0.0, 3: 0.0}\n\n    See Also\n    --------\n    degree_centrality, in_degree_centrality\n\n    Notes\n    -----\n    The degree centrality values are normalized by dividing by the maximum\n    possible degree in a simple graph n-1 where n is the number of nodes in G.\n\n    For multigraphs or graphs with self loops the maximum degree might\n    be higher than n-1 and values of degree centrality greater than 1\n    are possible.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef current_flow_closeness_centrality(G, weight=None, dtype=float, solver=\"lu\"):\n\"\"\"Compute current-flow closeness centrality for nodes.\n\n    Current-flow closeness centrality is variant of closeness\n    centrality based on effective resistance between nodes in\n    a network. This metric is also known as information centrality.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph.\n\n    weight : None or string, optional (default=None)\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n      The weight reflects the capacity or the strength of the\n      edge.\n\n    dtype: data type (default=float)\n      Default data type for internal matrices.\n      Set to np.float32 for lower memory consumption.\n\n    solver: string (default='lu')\n       Type of linear solver to use for computing the flow matrix.\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\n       \"cg\" (uses least memory).\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with current flow closeness centrality as the value.\n\n    See Also\n    --------\n    closeness_centrality\n\n    Notes\n    -----\n    The algorithm is from Brandes [1]_.\n\n    See also [2]_ for the original definition of information centrality.\n\n    References\n    ----------\n    .. [1] Ulrik Brandes and Daniel Fleischer,\n       Centrality Measures Based on Current Flow.\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n       https://doi.org/10.1007/978-3-540-31856-9_44\n\n    .. [2] Karen Stephenson and Marvin Zelen:\n       Rethinking centrality: Methods and examples.\n       Social Networks 11(1):1-37, 1989.\n       https://doi.org/10.1016/0378-8733(89)90016-6\n    \"\"\""}, {"gtype": "[Directed Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef trophic_levels(G, weight=\"weight\"):\n\"\"\"Compute the trophic levels of nodes.\n\n    The trophic level of a node $i$ is\n\n    .. math::\n\n        s_i = 1 + \\frac{1}{k^{in}_i} \\sum_{j} a_{ij} s_j\n\n    where $k^{in}_i$ is the in-degree of i\n\n    .. math::\n\n        k^{in}_i = \\sum_{j} a_{ij}\n\n    and nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.\n\n    These are calculated using the method outlined in Levine [1]_.\n\n    Parameters\n    ----------\n    G : DiGraph\n        A directed networkx graph\n\n    Returns\n    -------\n    nodes : dict\n        Dictionary of nodes with trophic level as the value.\n\n    References\n    ----------\n    .. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef trophic_incoherence_parameter(G, weight=\"weight\", cannibalism=False):\n\"\"\"Compute the trophic incoherence parameter of a graph.\n\n    Trophic coherence is defined as the homogeneity of the distribution of\n    trophic distances: the more similar, the more coherent. This is measured by\n    the standard deviation of the trophic differences and referred to as the\n    trophic incoherence parameter $q$ by [1].\n\n    Parameters\n    ----------\n    G : DiGraph\n        A directed networkx graph\n\n    cannibalism: Boolean\n        If set to False, self edges are not considered in the calculation\n\n    Returns\n    -------\n    trophic_incoherence_parameter : float\n        The trophic coherence of a graph\n\n    References\n    ----------\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef subgraph_centrality_exp(G):\n\"\"\"Returns the subgraph centrality for each node of G.\n\n    Subgraph centrality  of a node `n` is the sum of weighted closed\n    walks of all lengths starting and ending at node `n`. The weights\n    decrease with path length. Each closed walk is associated with a\n    connected subgraph ([1]_).\n\n    Parameters\n    ----------\n    G: graph\n\n    Returns\n    -------\n    nodes:dictionary\n        Dictionary of nodes with subgraph centrality as the value.\n\n    Raises\n    ------\n    NetworkXError\n        If the graph is not undirected and simple.\n\n    See Also\n    --------\n    subgraph_centrality:\n        Alternative algorithm of the subgraph centrality for each node of G.\n\n    Notes\n    -----\n    This version of the algorithm exponentiates the adjacency matrix.\n\n    The subgraph centrality of a node `u` in G can be found using\n    the matrix exponential of the adjacency matrix of G [1]_,\n\n    .. math::\n\n        SC(u)=(e^A)_{uu} .\n\n    References\n    ----------\n    .. [1] Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n       \"Subgraph centrality in complex networks\",\n       Physical Review E 71, 056103 (2005).\n       https://arxiv.org/abs/cond-mat/0504730\n\n    Examples\n    --------\n    (Example from [1]_)\n    >>> G = nx.Graph(\n    ...     [\n    ...         (1, 2),\n    ...         (1, 5),\n    ...         (1, 8),\n    ...         (2, 3),\n    ...         (2, 8),\n    ...         (3, 4),\n    ...         (3, 6),\n    ...         (4, 5),\n    ...         (4, 7),\n    ...         (5, 6),\n    ...         (6, 7),\n    ...         (7, 8),\n    ...     ]\n    ... )\n    >>> sc = nx.subgraph_centrality_exp(G)\n    >>> print([f\"{node} {sc[node]:0.2f}\" for node in sorted(sc)])\n    ['1 3.90', '2 3.90', '3 3.64', '4 3.71', '5 3.64', '6 3.71', '7 3.64', '8 3.90']\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef communicability_betweenness_centrality(G):\n\"\"\"Returns subgraph communicability for all pairs of nodes in G.\n\n    Communicability betweenness measure makes use of the number of walks\n    connecting every pair of nodes as the basis of a betweenness centrality\n    measure.\n\n    Parameters\n    ----------\n    G: graph\n\n    Returns\n    -------\n    nodes : dictionary\n        Dictionary of nodes with communicability betweenness as the value.\n\n    Raises\n    ------\n    NetworkXError\n        If the graph is not undirected and simple.\n\n    Notes\n    -----\n    Let `G=(V,E)` be a simple undirected graph with `n` nodes and `m` edges,\n    and `A` denote the adjacency matrix of `G`.\n\n    Let `G(r)=(V,E(r))` be the graph resulting from\n    removing all edges connected to node `r` but not the node itself.\n\n    The adjacency matrix for `G(r)` is `A+E(r)`,  where `E(r)` has nonzeros\n    only in row and column `r`.\n\n    The subraph betweenness of a node `r`  is [1]_\n\n    .. math::\n\n         \\omega_{r} = \\frac{1}{C}\\sum_{p}\\sum_{q}\\frac{G_{prq}}{G_{pq}},\n         p\\neq q, q\\neq r,\n\n    where\n    `G_{prq}=(e^{A}_{pq} - (e^{A+E(r)})_{pq}`  is the number of walks\n    involving node r,\n    `G_{pq}=(e^{A})_{pq}` is the number of closed walks starting\n    at node `p` and ending at node `q`,\n    and `C=(n-1)^{2}-(n-1)` is a normalization factor equal to the\n    number of terms in the sum.\n\n    The resulting `\\omega_{r}` takes values between zero and one.\n    The lower bound cannot be attained for a connected\n    graph, and the upper bound is attained in the star graph.\n\n    References\n    ----------\n    .. [1] Ernesto Estrada, Desmond J. Higham, Naomichi Hatano,\n       \"Communicability Betweenness in Complex Networks\"\n       Physica A 388 (2009) 764-774.\n       https://arxiv.org/abs/0905.4102\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\n    >>> cbc = nx.communicability_betweenness_centrality(G)\n    >>> print([f\"{node} {cbc[node]:0.2f}\" for node in sorted(cbc)])\n    ['0 0.03', '1 0.45', '2 0.51', '3 0.45', '4 0.40', '5 0.19', '6 0.03']\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")"}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(node_attrs=\"attribute\", edge_attrs=\"weight\")\ndef percolation_centrality(G, attribute=\"percolation\", states=None, weight=None):\n\"\"\"Compute the percolation centrality for nodes.\n\n    Percolation centrality of a node $v$, at a given time, is defined\n    as the proportion of \u2018percolated paths\u2019 that go through that node.\n\n    This measure quantifies relative impact of nodes based on their\n    topological connectivity, as well as their percolation states.\n\n    Percolation states of nodes are used to depict network percolation\n    scenarios (such as during infection transmission in a social network\n    of individuals, spreading of computer viruses on computer networks, or\n    transmission of disease over a network of towns) over time. In this\n    measure usually the percolation state is expressed as a decimal\n    between 0.0 and 1.0.\n\n    When all nodes are in the same percolated state this measure is\n    equivalent to betweenness centrality.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph.\n\n    attribute : None or string, optional (default='percolation')\n      Name of the node attribute to use for percolation state, used\n      if `states` is None. If a node does not set the attribute the\n      state of that node will be set to the default value of 1.\n      If all nodes do not have the attribute all nodes will be set to\n      1 and the centrality measure will be equivalent to betweenness centrality.\n\n    states : None or dict, optional (default=None)\n      Specify percolation states for the nodes, nodes as keys states\n      as values.\n\n    weight : None or string, optional (default=None)\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n      The weight of an edge is treated as the length or distance between the two sides.\n\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with percolation centrality as the value.\n\n    See Also\n    --------\n    betweenness_centrality\n\n    Notes\n    -----\n    The algorithm is from Mahendra Piraveenan, Mikhail Prokopenko, and\n    Liaquat Hossain [1]_\n    Pair dependencies are calculated and accumulated using [2]_\n\n    For weighted graphs the edge weights must be greater than zero.\n    Zero edge weights can produce an infinite number of equal length\n    paths between pairs of nodes.\n\n    References\n    ----------\n    .. [1] Mahendra Piraveenan, Mikhail Prokopenko, Liaquat Hossain\n       Percolation Centrality: Quantifying Graph-Theoretic Impact of Nodes\n       during Percolation in Networks\n       http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0053095\n    .. [2] Ulrik Brandes:\n       A Faster Algorithm for Betweenness Centrality.\n       Journal of Mathematical Sociology 25(2):163-177, 2001.\n       https://doi.org/10.1080/0022250X.2001.9990249\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef voterank(G, number_of_nodes=None):\n\"\"\"Select a list of influential nodes in a graph using VoteRank algorithm\n\n    VoteRank [1]_ computes a ranking of the nodes in a graph G based on a\n    voting scheme. With VoteRank, all nodes vote for each of its in-neighbors\n    and the node with the highest votes is elected iteratively. The voting\n    ability of out-neighbors of elected nodes is decreased in subsequent turns.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX graph.\n\n    number_of_nodes : integer, optional\n        Number of ranked nodes to extract (default all nodes).\n\n    Returns\n    -------\n    voterank : list\n        Ordered list of computed seeds.\n        Only nodes with positive number of votes are returned.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 4)])\n    >>> nx.voterank(G)\n    [0, 1]\n\n    The algorithm can be used both for undirected and directed graphs.\n    However, the directed version is different in two ways:\n    (i) nodes only vote for their in-neighbors and\n    (ii) only the voting ability of elected node and its out-neighbors are updated:\n\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (2, 3), (3, 4)])\n    >>> nx.voterank(G)\n    [2, 3]\n\n    Notes\n    -----\n    Each edge is treated independently in case of multigraphs.\n\n    References\n    ----------\n    .. [1] Zhang, J.-X. et al. (2016).\n        Identifying a set of influential spreaders in complex networks.\n        Sci. Rep. 6, 27823; doi: 10.1038/srep27823.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"distance\")\ndef closeness_centrality(G, u=None, distance=None, wf_improved=True):\n\"\"\"Compute closeness centrality for nodes.\n\n    Closeness centrality [1]_ of a node `u` is the reciprocal of the\n    average shortest path distance to `u` over all `n-1` reachable nodes.\n\n    .. math::\n\n        C(u) = \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},\n\n    where `d(v, u)` is the shortest-path distance between `v` and `u`,\n    and `n-1` is the number of nodes reachable from `u`. Notice that the\n    closeness distance function computes the incoming distance to `u`\n    for directed graphs. To use outward distance, act on `G.reverse()`.\n\n    Notice that higher values of closeness indicate higher centrality.\n\n    Wasserman and Faust propose an improved formula for graphs with\n    more than one connected component. The result is \"a ratio of the\n    fraction of actors in the group who are reachable, to the average\n    distance\" from the reachable actors [2]_. You might think this\n    scale factor is inverted but it is not. As is, nodes from small\n    components receive a smaller closeness value. Letting `N` denote\n    the number of nodes in the graph,\n\n    .. math::\n\n        C_{WF}(u) = \\frac{n-1}{N-1} \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    u : node, optional\n      Return only the value for node u\n\n    distance : edge attribute key, optional (default=None)\n      Use the specified edge attribute as the edge distance in shortest\n      path calculations.  If `None` (the default) all edges have a distance of 1.\n      Absent edge attributes are assigned a distance of 1. Note that no check\n      is performed to ensure that edges have the provided attribute.\n\n    wf_improved : bool, optional (default=True)\n      If True, scale by the fraction of nodes reachable. This gives the\n      Wasserman and Faust improved formula. For single component graphs\n      it is the same as the original formula.\n\n    Returns\n    -------\n    nodes : dictionary\n      Dictionary of nodes with closeness centrality as the value.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> nx.closeness_centrality(G)\n    {0: 1.0, 1: 1.0, 2: 0.75, 3: 0.75}\n\n    See Also\n    --------\n    betweenness_centrality, load_centrality, eigenvector_centrality,\n    degree_centrality, incremental_closeness_centrality\n\n    Notes\n    -----\n    The closeness centrality is normalized to `(n-1)/(|G|-1)` where\n    `n` is the number of nodes in the connected part of graph\n    containing the node.  If the graph is not completely connected,\n    this algorithm computes the closeness centrality for each\n    connected part separately scaled by that parts size.\n\n    If the 'distance' keyword is set to an edge attribute key then the\n    shortest-path length will be computed using Dijkstra's algorithm with\n    that edge attribute as the edge weight.\n\n    The closeness centrality uses *inward* distance to a node, not outward.\n    If you want to use outword distances apply the function to `G.reverse()`\n\n    In NetworkX 2.2 and earlier a bug caused Dijkstra's algorithm to use the\n    outward distance rather than the inward distance. If you use a 'distance'\n    keyword and a DiGraph, your results will change between v2.2 and v2.3.\n\n    References\n    ----------\n    .. [1] Linton C. Freeman: Centrality in networks: I.\n       Conceptual clarification. Social Networks 1:215-239, 1979.\n       https://doi.org/10.1016/0378-8733(78)90021-7\n    .. [2] pg. 201 of Wasserman, S. and Faust, K.,\n       Social Network Analysis: Methods and Applications, 1994,\n       Cambridge University Press.\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef dispersion(G, u=None, v=None, normalized=True, alpha=1.0, b=0.0, c=0.0):\n\"\"\"Calculate dispersion between `u` and `v` in `G`.\n\n    A link between two actors (`u` and `v`) has a high dispersion when their\n    mutual ties (`s` and `t`) are not well connected with each other.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX graph.\n    u : node, optional\n        The source for the dispersion score (e.g. ego node of the network).\n    v : node, optional\n        The target of the dispersion score if specified.\n    normalized : bool\n        If True (default) normalize by the embeddedness of the nodes (u and v).\n    alpha, b, c : float\n        Parameters for the normalization procedure. When `normalized` is True,\n        the dispersion value is normalized by::\n\n            result = ((dispersion + b) ** alpha) / (embeddedness + c)\n\n        as long as the denominator is nonzero.\n\n    Returns\n    -------\n    nodes : dictionary\n        If u (v) is specified, returns a dictionary of nodes with dispersion\n        score for all \"target\" (\"source\") nodes. If neither u nor v is\n        specified, returns a dictionary of dictionaries for all nodes 'u' in the\n        graph with a dispersion score for each node 'v'.\n\n    Notes\n    -----\n    This implementation follows Lars Backstrom and Jon Kleinberg [1]_. Typical\n    usage would be to run dispersion on the ego network $G_u$ if $u$ were\n    specified.  Running :func:`dispersion` with neither $u$ nor $v$ specified\n    can take some time to complete.\n\n    References\n    ----------\n    .. [1] Romantic Partnerships and the Dispersion of Social Ties:\n        A Network Analysis of Relationship Status on Facebook.\n        Lars Backstrom, Jon Kleinberg.\n        https://arxiv.org/pdf/1310.6753v1.pdf\n\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef global_reaching_centrality(G, weight=None, normalized=True):\n\"\"\"Returns the global reaching centrality of a directed graph.\n\n    The *global reaching centrality* of a weighted directed graph is the\n    average over all nodes of the difference between the local reaching\n    centrality of the node and the greatest local reaching centrality of\n    any node in the graph [1]_. For more information on the local\n    reaching centrality, see :func:`local_reaching_centrality`.\n    Informally, the local reaching centrality is the proportion of the\n    graph that is reachable from the neighbors of the node.\n\n    Parameters\n    ----------\n    G : DiGraph\n        A networkx DiGraph.\n\n    weight : None or string, optional (default=None)\n        Attribute to use for edge weights. If ``None``, each edge weight\n        is assumed to be one. A higher weight implies a stronger\n        connection between nodes and a *shorter* path length.\n\n    normalized : bool, optional (default=True)\n        Whether to normalize the edge weights by the total sum of edge\n        weights.\n\n    Returns\n    -------\n    h : float\n        The global reaching centrality of the graph.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph()\n    >>> G.add_edge(1, 2)\n    >>> G.add_edge(1, 3)\n    >>> nx.global_reaching_centrality(G)\n    1.0\n    >>> G.add_edge(3, 2)\n    >>> nx.global_reaching_centrality(G)\n    0.75\n\n    See also\n    --------\n    local_reaching_centrality\n\n    References\n    ----------\n    .. [1] Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n           \"Hierarchy Measure for Complex Networks.\"\n           *PLoS ONE* 7.3 (2012): e33799.\n           https://doi.org/10.1371/journal.pone.0033799\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef newman_betweenness_centrality(G, v=None, cutoff=None, normalized=True, weight=None):\n\"\"\"Compute load centrality for nodes.\n\n    The load centrality of a node is the fraction of all shortest\n    paths that pass through that node.\n\n    Parameters\n    ----------\n    G : graph\n      A networkx graph.\n\n    normalized : bool, optional (default=True)\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\n      n is the number of nodes in G.\n\n    weight : None or string, optional (default=None)\n      If None, edge weights are ignored.\n      Otherwise holds the name of the edge attribute used as weight.\n      The weight of an edge is treated as the length or distance between the two sides.\n\n    cutoff : bool, optional (default=None)\n      If specified, only consider paths of length <= cutoff.\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with centrality as the value.\n\n    See Also\n    --------\n    betweenness_centrality\n\n    Notes\n    -----\n    Load centrality is slightly different than betweenness. It was originally\n    introduced by [2]_. For this load algorithm see [1]_.\n\n    References\n    ----------\n    .. [1] Mark E. J. Newman:\n       Scientific collaboration networks. II.\n       Shortest paths, weighted networks, and centrality.\n       Physical Review E 64, 016132, 2001.\n       http://journals.aps.org/pre/abstract/10.1103/PhysRevE.64.016132\n    .. [2] Kwang-Il Goh, Byungnam Kahng and Doochul Kim\n       Universal behavior of Load Distribution in Scale-Free Networks.\n       Physical Review Letters 87(27):1\u20134, 2001.\n       https://doi.org/10.1103/PhysRevLett.87.278701\n    \"\"\""}, {"gtype": "[Undirected Graph]", "func": "@nx._dispatchable\ndef edge_load_centrality(G, cutoff=False):\n\"\"\"Compute edge load.\n\n    WARNING: This concept of edge load has not been analysed\n    or discussed outside of NetworkX that we know of.\n    It is based loosely on load_centrality in the sense that\n    it counts the number of shortest paths which cross each edge.\n    This function is for demonstration and testing purposes.\n\n    Parameters\n    ----------\n    G : graph\n        A networkx graph\n\n    cutoff : bool, optional (default=False)\n        If specified, only consider paths of length <= cutoff.\n\n    Returns\n    -------\n    A dict keyed by edge 2-tuple to the number of shortest paths\n    which use that edge. Where more than one path is shortest\n    the count is divided equally among paths.\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef edge_betweenness_centrality(G, k=None, normalized=True, weight=None, seed=None):\n\"\"\"Compute betweenness centrality for edges.\n\n    Betweenness centrality of an edge $e$ is the sum of the\n    fraction of all-pairs shortest paths that pass through $e$\n\n    .. math::\n\n       c_B(e) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|e)}{\\sigma(s, t)}\n\n    where $V$ is the set of nodes, $\\sigma(s, t)$ is the number of\n    shortest $(s, t)$-paths, and $\\sigma(s, t|e)$ is the number of\n    those paths passing through edge $e$ [2]_.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph.\n\n    k : int, optional (default=None)\n      If k is not None use k node samples to estimate betweenness.\n      The value of k <= n where n is the number of nodes in the graph.\n      Higher values give better approximation.\n\n    normalized : bool, optional\n      If True the betweenness values are normalized by $2/(n(n-1))$\n      for graphs, and $1/(n(n-1))$ for directed graphs where $n$\n      is the number of nodes in G.\n\n    weight : None or string, optional (default=None)\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n      Weights are used to calculate weighted shortest paths, so they are\n      interpreted as distances.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n        Note that this is only used if k is not None.\n\n    Returns\n    -------\n    edges : dictionary\n       Dictionary of edges with betweenness centrality as the value.\n\n    See Also\n    --------\n    betweenness_centrality\n    edge_load\n\n    Notes\n    -----\n    The algorithm is from Ulrik Brandes [1]_.\n\n    For weighted graphs the edge weights must be greater than zero.\n    Zero edge weights can produce an infinite number of equal length\n    paths between pairs of nodes.\n\n    References\n    ----------\n    .. [1]  A Faster Algorithm for Betweenness Centrality. Ulrik Brandes,\n       Journal of Mathematical Sociology 25(2):163-177, 2001.\n       https://doi.org/10.1080/0022250X.2001.9990249\n    .. [2] Ulrik Brandes: On Variants of Shortest-Path Betweenness\n       Centrality and their Generic Computation.\n       Social Networks 30(2):136-145, 2008.\n       https://doi.org/10.1016/j.socnet.2007.11.001\n    \"\"\""}, {"gtype": "[Weighted Graph]", "func": "@nx._dispatchable(edge_attrs=\"weight\")\ndef eigenvector_centrality(G, max_iter=100, tol=1.0e-6, nstart=None, weight=None):\n\"\"\"Compute the eigenvector centrality for the graph G.\n\n    Eigenvector centrality computes the centrality for a node by adding\n    the centrality of its predecessors. The centrality for node $i$ is the\n    $i$-th element of a left eigenvector associated with the eigenvalue $\\lambda$\n    of maximum modulus that is positive. Such an eigenvector $x$ is\n    defined up to a multiplicative constant by the equation\n\n    .. math::\n\n         \\lambda x^T = x^T A,\n\n    where $A$ is the adjacency matrix of the graph G. By definition of\n    row-column product, the equation above is equivalent to\n\n    .. math::\n\n        \\lambda x_i = \\sum_{j\\to i}x_j.\n\n    That is, adding the eigenvector centralities of the predecessors of\n    $i$ one obtains the eigenvector centrality of $i$ multiplied by\n    $\\lambda$. In the case of undirected graphs, $x$ also solves the familiar\n    right-eigenvector equation $Ax = \\lambda x$.\n\n    By virtue of the Perron\u2013Frobenius theorem [1]_, if G is strongly\n    connected there is a unique eigenvector $x$, and all its entries\n    are strictly positive.\n\n    If G is not strongly connected there might be several left\n    eigenvectors associated with $\\lambda$, and some of their elements\n    might be zero.\n\n    Parameters\n    ----------\n    G : graph\n      A networkx graph.\n\n    max_iter : integer, optional (default=100)\n      Maximum number of power iterations.\n\n    tol : float, optional (default=1.0e-6)\n      Error tolerance (in Euclidean norm) used to check convergence in\n      power iteration.\n\n    nstart : dictionary, optional (default=None)\n      Starting value of power iteration for each node. Must have a nonzero\n      projection on the desired eigenvector for the power method to converge.\n      If None, this implementation uses an all-ones vector, which is a safe\n      choice.\n\n    weight : None or string, optional (default=None)\n      If None, all edge weights are considered equal. Otherwise holds the\n      name of the edge attribute used as weight. In this measure the\n      weight is interpreted as the connection strength.\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with eigenvector centrality as the value. The\n       associated vector has unit Euclidean norm and the values are\n       nonegative.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> centrality = nx.eigenvector_centrality(G)\n    >>> sorted((v, f\"{c:0.2f}\") for v, c in centrality.items())\n    [(0, '0.37'), (1, '0.60'), (2, '0.60'), (3, '0.37')]\n\n    Raises\n    ------\n    NetworkXPointlessConcept\n        If the graph G is the null graph.\n\n    NetworkXError\n        If each value in `nstart` is zero.\n\n    PowerIterationFailedConvergence\n        If the algorithm fails to converge to the specified tolerance\n        within the specified number of iterations of the power iteration\n        method.\n\n    See Also\n    --------\n    eigenvector_centrality_numpy\n    :func:`~networkx.algorithms.link_analysis.pagerank_alg.pagerank`\n    :func:`~networkx.algorithms.link_analysis.hits_alg.hits`\n\n    Notes\n    -----\n    Eigenvector centrality was introduced by Landau [2]_ for chess\n    tournaments. It was later rediscovered by Wei [3]_ and then\n    popularized by Kendall [4]_ in the context of sport ranking. Berge\n    introduced a general definition for graphs based on social connections\n    [5]_. Bonacich [6]_ reintroduced again eigenvector centrality and made\n    it popular in link analysis.\n\n    This function computes the left dominant eigenvector, which corresponds\n    to adding the centrality of predecessors: this is the usual approach.\n    To add the centrality of successors first reverse the graph with\n    ``G.reverse()``.\n\n    The implementation uses power iteration [7]_ to compute a dominant\n    eigenvector starting from the provided vector `nstart`. Convergence is\n    guaranteed as long as `nstart` has a nonzero projection on a dominant\n    eigenvector, which certainly happens using the default value.\n\n    The method stops when the change in the computed vector between two\n    iterations is smaller than an error tolerance of ``G.number_of_nodes()\n    * tol`` or after ``max_iter`` iterations, but in the second case it\n    raises an exception.\n\n    This implementation uses $(A + I)$ rather than the adjacency matrix\n    $A$ because the change preserves eigenvectors, but it shifts the\n    spectrum, thus guaranteeing convergence even for networks with\n    negative eigenvalues of maximum modulus.\n\n    References\n    ----------\n    .. [1] Abraham Berman and Robert J. Plemmons.\n       \"Nonnegative Matrices in the Mathematical Sciences.\"\n       Classics in Applied Mathematics. SIAM, 1994.\n\n    .. [2] Edmund Landau.\n       \"Zur relativen Wertbemessung der Turnierresultate.\"\n       Deutsches Wochenschach, 11:366\u2013369, 1895.\n\n    .. [3] Teh-Hsing Wei.\n       \"The Algebraic Foundations of Ranking Theory.\"\n       PhD thesis, University of Cambridge, 1952.\n\n    .. [4] Maurice G. Kendall.\n       \"Further contributions to the theory of paired comparisons.\"\n       Biometrics, 11(1):43\u201362, 1955.\n       https://www.jstor.org/stable/3001479\n\n    .. [5] Claude Berge\n       \"Th\u00e9orie des graphes et ses applications.\"\n       Dunod, Paris, France, 1958.\n\n    .. [6] Phillip Bonacich.\n       \"Technique for analyzing overlapping memberships.\"\n       Sociological Methodology, 4:176\u2013185, 1972.\n       https://www.jstor.org/stable/270732\n\n    .. [7] Power iteration:: https://en.wikipedia.org/wiki/Power_iteration\n\n    \"\"\""}]