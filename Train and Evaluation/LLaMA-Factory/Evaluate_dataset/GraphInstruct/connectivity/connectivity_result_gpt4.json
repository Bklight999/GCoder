{"0": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [4, 5],\n    4: [8, 1],\n    5: [8, 2],\n    1: [4, 7, 6],\n    3: [10, 11],\n    10: [3, 7],\n    11: [3, 9],\n    7: [10, 1],\n    0: [9],\n    9: [0, 11],\n    6: [1, 2],\n    2: [5, 6]\n}\n\nstart_node = 0\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "1": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [4, 0],\n    0: [1, 10],\n    14: [4],\n    11: [13, 7, 5],\n    13: [9],\n    7: [6, 12],\n    5: [3, 2, 14, 11],\n    1: [12, 7, 0, 11],\n    12: [10, 2],\n    10: [9, 5, 11],\n    8: [2, 11],\n    3: [0, 11, 5]\n})\n\n# Function to check if there is a path from start to end\ndef is_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return False\n\n# Check if there is a path from node 4 to node 3\nprint(is_path(graph, 4, 3))\n```"}, "2": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [8, 5],\n    8: [1, 6, 0],\n    5: [2, 7, 8, 1, 6],\n    2: [0, 3, 11, 6, 10],\n    0: [3, 8, 11, 1, 2],\n    3: [10, 9],\n    11: [2, 4, 3],\n    6: [10, 3],\n    4: [9, 0, 11, 1, 5],\n    9: [7, 1, 6, 10, 2],\n    1: [10, 7, 0],\n    7: [0, 6, 5, 10, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 9\nprint(has_path(graph, 3, 9))\n```"}, "3": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    4: [10, 8, 0],\n    10: [0, 7, 9, 4],\n    8: [9],\n    0: [8],\n    7: [9],\n    9: [1],\n    3: [11, 5, 6],\n    11: [2, 7, 3],\n    5: [7, 10],\n    6: [8, 7]\n})\n\nprint(has_path(graph, 10, 5))\n```"}, "4": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [4, 12, 11, 3],\n    4: [0],\n    12: [0, 10],\n    11: [0, 7],\n    3: [0, 5, 6, 8],\n    5: [3],\n    6: [3],\n    8: [3],\n    10: [12, 9],\n    9: [10, 2, 1],\n    7: [11],\n    2: [9],\n    1: [9]\n}\n\nstart_node = 9\ngoal_node = 1\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "5": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [5, 7, 6],\n    5: [8, 7],\n    7: [4, 8],\n    8: [2, 0, 6],\n    2: [0],\n    0: [4, 8],\n    1: [3, 8, 7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 7 to node 3\nresult = has_path(graph, 7, 3)\nprint(result)\n```"}, "6": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [0, 6, 11, 9, 7, 1],\n    0: [4, 6, 11, 9, 12, 2],\n    6: [4, 0, 11, 9, 5, 7, 1, 12, 2],\n    11: [4, 0, 6, 10, 13, 12],\n    9: [4, 0, 6, 10, 5, 8, 1, 12, 2, 3],\n    7: [4, 6, 5, 13, 1, 3],\n    1: [4, 6, 10, 9, 5, 7, 13, 12, 2],\n    12: [0, 6, 11, 9, 1, 3],\n    2: [0, 6, 9, 5, 1, 3],\n    5: [6, 9, 7, 13, 1, 2],\n    10: [11, 9, 1, 3],\n    3: [10, 9, 7, 13, 12, 2],\n    13: [11, 5, 7, 8, 1, 3],\n    8: [9, 13]\n}\n\nstart_node = 12\ngoal_node = 6\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "7": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [9],\n    9: [12, 11],\n    5: [6],\n    6: [12, 10, 7],\n    1: [0, 7, 12, 9],\n    0: [10],\n    7: [0],\n    12: [0, 6],\n    10: [8, 7],\n    8: [7, 6],\n    4: [6, 8],\n    2: [3, 5, 8],\n    11: [2]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 8 to node 3\nprint(has_path(graph, 8, 3))\n```"}, "8": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [13, 10, 11, 9, 8, 12, 4, 3, 5, 0],\n    13: [6, 5],\n    10: [6, 12, 9, 1, 2],\n    11: [6, 2],\n    9: [6, 10],\n    8: [6, 2],\n    12: [6, 10],\n    4: [6, 2, 7],\n    3: [6, 2],\n    5: [6, 13, 1, 2],\n    0: [6, 2],\n    1: [10, 5],\n    2: [10, 5, 3, 11, 4, 0, 7, 8],\n    7: [2, 4]\n}\n\nstart_node = 4\ngoal_node = 8\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "9": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [1],\n    1: [4, 2, 6],\n    2: [1, 5],\n    6: [1, 5],\n    5: [2, 6],\n    3: [0, 7],\n    0: [3, 7],\n    7: [3, 0]\n}\n\nstart_node = 3\ngoal_node = 1\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "10": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [8, 5, 10, 4, 11, 12, 7, 3, 1],\n    8: [0],\n    5: [0],\n    10: [0, 13],\n    4: [0],\n    11: [0],\n    12: [0],\n    7: [0, 14, 2, 6, 9],\n    3: [0],\n    1: [0],\n    13: [10],\n    14: [7],\n    2: [7],\n    6: [7],\n    9: [7]\n}\n\nstart_node = 10\ngoal_node = 12\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "11": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [2, 5],\n    2: [4, 8],\n    5: [4, 6, 0],\n    8: [2, 9],\n    1: [6],\n    6: [1, 5],\n    0: [5, 9],\n    9: [0, 8],\n    7: [3, 10],\n    3: [7, 10],\n    10: [7, 3]\n}\n\nstart_node = 9\ngoal_node = 7\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "12": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph as an adjacency list\ngraph = defaultdict(list, {\n    3: [10],\n    10: [0, 6],\n    0: [10],\n    6: [10, 7, 4, 14, 3, 0],\n    7: [8, 3, 11],\n    4: [14, 6, 7],\n    14: [0, 6, 12, 10, 4],\n    11: [10, 3],\n    2: [8, 5],\n    8: [11, 10, 9, 13, 4],\n    5: [0, 2, 8],\n    9: [8],\n    13: [1]\n})\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 1\nprint(has_path(graph, 4, 1))\n```"}, "13": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [7, 1],\n    7: [5, 3],\n    1: [2, 7, 6],\n    0: [7],\n    5: [7],\n    4: [6, 7],\n    6: [4, 5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 5\nprint(has_path(graph, 2, 5))\n```"}, "14": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [7, 4],\n    7: [3, 5],\n    4: [3, 1, 2, 8],\n    5: [7, 6],\n    1: [4, 8],\n    8: [1, 4, 0],\n    2: [4],\n    6: [5],\n    0: [8]\n}\n\nstart_node = 2\ngoal_node = 0\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "15": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    5: [7],\n    2: [5],\n    4: [7, 0, 8],\n    0: [4, 3, 7, 1],\n    3: [7, 1, 0],\n    1: [6, 7],\n    6: [5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 7 to node 8\nprint(has_path(graph, 7, 8))\n```"}, "16": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [13, 5, 7, 10, 11, 3, 8, 4],\n    13: [2, 8],\n    5: [2, 12, 1, 8],\n    7: [2, 8],\n    10: [2, 12, 11],\n    11: [2, 10],\n    3: [2, 1],\n    8: [2, 13, 7, 9, 6, 5],\n    4: [2, 9, 6],\n    12: [0, 1, 10, 5],\n    0: [12, 1],\n    1: [12, 0, 3, 5, 9],\n    9: [1, 8, 4],\n    6: [8, 4]\n}\n\nstart_node = 4\nend_node = 9\n\npath_exists = dfs(graph, start_node, end_node)\nprint(path_exists)\n```"}, "17": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [3, 7],\n    3: [7, 4],\n    7: [8],\n    0: [3, 4],\n    5: [3],\n    2: [4],\n    6: [9, 1],\n    9: [0, 6],\n    8: [7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 0 to node 6\nprint(has_path(graph, 0, 6))\n```"}, "18": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    12: [13, 9, 11, 1, 2, 0, 3, 7, 8, 10, 6],\n    13: [12, 9, 4, 11, 1, 0, 3, 7, 10, 5],\n    9: [12, 13, 4, 11, 1, 2, 0, 3, 7, 8, 10, 5, 6],\n    11: [12, 13, 9, 4, 2, 0, 7, 8, 10, 5],\n    1: [12, 13, 9, 4, 2, 0, 3, 7, 8, 10, 5],\n    2: [12, 9, 4, 11, 1, 3, 7, 8, 10, 5, 6],\n    0: [12, 13, 9, 11, 1, 3, 7, 10, 5],\n    3: [12, 13, 9, 4, 1, 2, 0, 7, 8, 10, 5],\n    7: [12, 13, 9, 4, 11, 1, 2, 0, 3, 10, 5],\n    8: [12, 9, 4, 11, 1, 2, 3, 10],\n    10: [12, 13, 9, 4, 11, 1, 2, 0, 3, 7, 8, 5, 6],\n    6: [12, 9, 2, 10],\n    4: [13, 9, 11, 1, 2, 3, 7, 8, 10, 5],\n    5: [13, 9, 4, 11, 1, 2, 0, 3, 7, 10]\n}\n\nstart_node = 6\ngoal_node = 9\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "19": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    0: [5],\n    4: [3, 6, 0],\n    3: [1],\n    6: [1],\n    1: [2],\n    8: [6, 0, 4],\n    7: [1, 6, 0],\n    2: [5, 7]\n})\n\n# Function to check if there is a path from start to end\ndef is_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 3\nresult = is_path(graph, 2, 3)\nprint(result)\n```"}, "20": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [2],\n    2: [1, 3],\n    3: [2, 7, 4, 8],\n    7: [3, 10],\n    10: [7, 4],\n    4: [3, 0, 10, 6],\n    8: [3],\n    5: [0],\n    0: [5, 4, 9],\n    9: [0],\n    6: [4]\n}\n\nstart_node = 1\ngoal_node = 10\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "21": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    0: [2, 11],\n    2: [7, 1, 4],\n    11: [7, 1, 5],\n    4: [7],\n    7: [6, 12, 3],\n    5: [9],\n    9: [6, 11],\n    3: [6],\n    6: [9],\n    1: [3],\n    12: [8, 4, 6],\n    10: [8, 5, 11, 12]\n})\n\nprint(has_path(graph, 2, 0))\n```"}, "22": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [6, 2, 11, 7, 9],\n    6: [3, 1, 0],\n    2: [3, 1, 0, 5],\n    11: [3, 4, 10],\n    7: [3, 10, 9],\n    9: [3, 1, 8, 4, 10, 7],\n    1: [6, 2, 9],\n    0: [6, 8, 4, 2, 10],\n    8: [0, 10, 5, 9],\n    10: [8, 0, 11, 5, 7, 9],\n    5: [8, 2, 10],\n    4: [0, 11, 9]\n}\n\nstart_node = 9\ngoal_node = 3\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "23": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [0, 4, 3, 10],\n    0: [2, 3],\n    4: [9, 8, 0],\n    3: [10, 9, 8, 1, 0],\n    10: [5, 2],\n    1: [4, 3, 8],\n    6: [0, 9],\n    9: [8, 4, 5, 2],\n    2: [1, 6],\n    7: [2, 3, 1, 6, 4],\n    5: [2, 9, 6, 0, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 7\nprint(has_path(graph, 2, 7))\n```"}, "24": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [4, 3],\n    4: [7, 0, 2],\n    3: [7, 1, 0],\n    0: [4, 3],\n    2: [4],\n    1: [3, 5, 6],\n    5: [1],\n    6: [1]\n}\n\nstart_node = 1\nend_node = 2\n\npath_exists = dfs(graph, start_node, end_node)\nprint(path_exists)\n```"}, "25": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return False\n\ngraph = {\n    1: [12, 2, 4, 5, 10],\n    12: [9, 8, 3],\n    2: [3, 10, 12],\n    4: [7, 12, 6],\n    5: [3, 1],\n    10: [0, 3],\n    3: [9, 8],\n    6: [11, 4, 1, 12],\n    11: [8, 3],\n    0: [2, 10],\n    7: [8]\n}\n\nstart_node = 11\nend_node = 2\n\nprint(has_path(graph, start_node, end_node))\n```"}, "26": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [1, 9, 5, 8],\n    1: [3, 4, 0],\n    9: [3, 12, 2, 5],\n    5: [3, 9, 4, 0],\n    8: [3, 12, 0],\n    4: [1, 10, 0, 5],\n    0: [1, 10, 4, 5, 8, 13],\n    7: [12, 10, 13, 2],\n    12: [7, 2, 11, 8, 9],\n    10: [7, 6, 4, 0, 11],\n    13: [7, 6, 11, 0],\n    2: [7, 12, 9],\n    11: [12, 10, 6, 13],\n    6: [10, 11, 13]\n}\n\nstart_node = 0\ngoal_node = 13\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "27": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    6: [8, 1, 4],\n    8: [2, 11],\n    1: [5],\n    11: [10, 2, 9, 12, 0],\n    10: [2, 14],\n    2: [9, 14, 6, 10],\n    12: [14, 7, 0, 6, 13],\n    0: [4, 11, 8, 13],\n    14: [0, 5],\n    3: [5, 1],\n    5: [6],\n    13: [2],\n    7: [1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 3\nprint(has_path(graph, 6, 3))\n```"}, "28": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    1: [3],\n    4: [8, 0, 3, 1],\n    8: [1],\n    0: [5, 3, 1, 4, 8],\n    5: [6, 0],\n    7: [6, 3, 8],\n    6: [0, 7],\n    2: [3, 8, 5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 5\nprint(has_path(graph, 1, 5))\n```"}, "29": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [3],\n    3: [7, 2, 0],\n    5: [6, 2, 1, 0],\n    6: [5, 1],\n    2: [5, 0, 4, 3],\n    1: [5, 6, 0, 4],\n    0: [5, 2, 1, 4, 3],\n    4: [2, 1, 0]\n}\n\nstart_node = 2\ngoal_node = 3\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "30": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    11: [0, 6],\n    0: [11, 12],\n    6: [11, 1],\n    12: [0, 4],\n    8: [10, 5],\n    10: [8, 9],\n    5: [8, 3],\n    9: [10, 1],\n    1: [6, 9],\n    3: [5, 7],\n    7: [3, 13],\n    4: [2, 12],\n    2: [4, 13],\n    13: [2, 7]\n}\n\nstart_node = 4\nend_node = 8\n\npath_exists = dfs(graph, start_node, end_node)\nprint(path_exists)\n```"}, "31": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    5: [4, 8, 0, 2, 1],\n    4: [7, 1],\n    8: [0, 5, 4],\n    3: [2, 5],\n    7: [2, 4],\n    6: [3, 8]\n})\n\nprint(has_path(graph, 3, 6))\n```"}, "32": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [0, 1, 6, 4, 7, 5, 11, 8],\n    0: [3],\n    1: [3],\n    6: [3],\n    4: [3, 10, 2],\n    7: [3],\n    5: [3],\n    11: [3],\n    8: [3, 9],\n    10: [4],\n    2: [4],\n    9: [8]\n}\n\nstart_node = 5\nend_node = 7\n\nresult = dfs(graph, start_node, end_node)\nprint(result)\n```"}, "33": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [6, 4, 7],\n    6: [7],\n    4: [0, 3, 2, 6],\n    7: [5, 3, 1],\n    2: [7, 8],\n    0: [6, 4, 8],\n    5: [6]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 8 to node 6\nprint(has_path(graph, 8, 6))\n```"}, "34": {"gpt4": "```python\ndef dfs(graph, start, goal, visited):\n    if start == goal:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [10, 1, 5, 3, 12, 8],\n    10: [0, 7, 4, 1, 11, 6, 5, 3, 12, 8, 13],\n    1: [0, 7, 4, 10, 5, 12, 13],\n    5: [0, 7, 4, 2, 10, 1, 6, 3, 12, 9, 13],\n    3: [0, 7, 2, 10, 11, 5, 12, 9],\n    12: [0, 7, 4, 10, 1, 11, 6, 5, 3, 8, 13],\n    8: [0, 7, 2, 10, 12, 9, 13],\n    7: [4, 2, 10, 1, 11, 6, 5, 3, 12, 9, 8, 13],\n    4: [7, 2, 10, 1, 11, 5, 12, 9, 13],\n    2: [7, 4, 11, 6, 5, 3, 9, 8, 13],\n    11: [7, 4, 2, 10, 6, 3, 12, 9, 13],\n    6: [7, 2, 10, 11, 5, 12, 9, 13],\n    9: [7, 4, 2, 11, 6, 5, 3, 8],\n    13: [7, 4, 2, 10, 1, 11, 6, 5, 12, 8]\n}\n\nstart_node = 5\ngoal_node = 10\nvisited = set()\n\npath_exists = dfs(graph, start_node, goal_node, visited)\nprint(path_exists)\n```"}, "35": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    1: [7],\n    7: [2, 3],\n    6: [3, 5, 0, 1],\n    0: [6, 4, 5],\n    2: [5],\n    4: [0, 1, 6, 2, 3]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 0\nprint(has_path(graph, 1, 0))\n```"}, "36": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [5, 4, 0, 9, 10, 2],\n    5: [3, 6, 11, 1, 2],\n    4: [3, 6, 1, 7, 8],\n    0: [3, 6, 1, 7, 8, 9, 10, 2],\n    9: [3, 6, 0, 2],\n    10: [3, 6, 1, 7, 8, 0, 2],\n    2: [3, 6, 5, 11, 1, 7, 0, 9, 10],\n    6: [5, 1, 4, 8, 0, 9, 10, 2],\n    1: [6, 5, 11, 4, 0, 10, 2],\n    8: [6, 4, 0, 10],\n    11: [5, 1, 7, 2],\n    7: [11, 4, 0, 10, 2]\n}\n\nstart_node = 6\ngoal_node = 9\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "37": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [2],\n    2: [3, 9, 8, 4],\n    9: [2, 0],\n    6: [7],\n    7: [0],\n    1: [5],\n    5: [9],\n    8: [4, 1],\n    4: [0]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 8 to node 6\nprint(has_path(graph, 8, 6))\n```"}, "38": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [1],\n    1: [6, 3],\n    3: [1, 9],\n    9: [3, 10],\n    0: [5, 10],\n    5: [0, 2],\n    10: [0, 8, 9],\n    2: [5, 4, 7],\n    4: [2, 8],\n    7: [2],\n    8: [4, 10]\n}\n\nstart_node = 10\ngoal_node = 0\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "39": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    0: [2],\n    2: [8, 6],\n    6: [8],\n    8: [1, 0],\n    4: [2, 1],\n    1: [4, 8],\n    3: [7, 1],\n    7: [1, 6, 2, 8],\n    5: [0, 1]\n})\n\nprint(has_path(graph, 2, 5))\n```"}, "40": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [2, 9, 5, 6, 7, 3],\n    2: [1, 13, 5, 6, 12, 10, 4],\n    9: [1, 13, 11, 14, 5, 3, 4],\n    5: [1, 2, 13, 11, 9, 4],\n    6: [1, 2, 13, 11, 0, 3, 4],\n    7: [1, 8, 14, 0, 3, 4],\n    3: [1, 9, 6, 7, 12, 10],\n    8: [11, 14, 7],\n    11: [8, 9, 5, 6, 10],\n    14: [8, 9, 0, 7, 12],\n    13: [2, 9, 5, 6, 12],\n    12: [2, 13, 14, 0, 3, 10],\n    10: [2, 11, 0, 12, 3, 4],\n    4: [2, 9, 5, 6, 7, 10],\n    0: [14, 6, 7, 12, 10]\n}\n\nstart_node = 9\nend_node = 10\n\nresult = dfs(graph, start_node, end_node)\nprint(result)\n```"}, "41": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    6: [5],\n    5: [4, 7],\n    1: [2],\n    4: [2],\n    7: [2, 3],\n    3: [6],\n    0: [6, 3]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 4\nresult = has_path(graph, 2, 4)\nprint(result)\n```"}, "42": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [2, 5, 4],\n    2: [3, 5],\n    5: [3, 2, 4, 1, 0, 6, 8],\n    4: [3, 5, 1, 6],\n    1: [5, 4, 8],\n    0: [5, 7],\n    6: [5, 4, 7],\n    8: [5, 1],\n    7: [0, 6]\n}\n\nstart_node = 6\ngoal_node = 0\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "43": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [7, 10],\n    7: [1, 9],\n    10: [1, 5],\n    9: [7, 13],\n    5: [10, 0],\n    0: [5, 8],\n    4: [6, 3],\n    6: [4, 3],\n    3: [4, 6],\n    8: [0],\n    11: [2, 13],\n    2: [11, 12],\n    13: [11, 9, 12],\n    12: [2, 13]\n}\n\nstart_node = 4\nend_node = 5\n\nprint(dfs(graph, start_node, end_node))\n```"}, "44": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [6, 2, 12, 13, 11, 1, 7],\n    6: [4, 5],\n    2: [4, 10],\n    12: [4],\n    13: [4],\n    11: [4],\n    1: [4],\n    7: [4, 9, 8],\n    5: [6],\n    9: [7, 0],\n    8: [7, 3],\n    0: [9],\n    10: [2],\n    3: [8]\n}\n\nstart_node = 8\nend_node = 9\n\nprint(dfs(graph, start_node, end_node))\n```"}, "45": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    6: [2, 0, 7],\n    2: [5, 0],\n    0: [3, 4, 7, 6, 2],\n    7: [4],\n    5: [3],\n    4: [7, 1, 5, 0],\n    1: [2, 0, 7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 4\nresult = has_path(graph, 3, 4)\nprint(result)\n```"}, "46": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [1, 13],\n    1: [2, 14, 4],\n    13: [2, 7],\n    14: [1],\n    4: [1, 3],\n    10: [7, 9],\n    7: [10, 11, 13],\n    9: [10],\n    11: [7, 6],\n    6: [0, 11, 5],\n    0: [6, 8],\n    5: [6, 12],\n    8: [0],\n    12: [5, 3],\n    3: [12, 4]\n}\n\nstart_node = 2\nend_node = 1\n\nprint(dfs(graph, start_node, end_node))\n```"}, "47": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    1: [2],\n    2: [7],\n    4: [10],\n    10: [6, 0],\n    7: [2],\n    9: [7],\n    6: [7],\n    5: [4],\n    3: [8, 10],\n    8: [3],\n    0: [1, 2, 7, 5],\n    11: [9, 10]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 9 to node 4\nprint(has_path(graph, 9, 4))\n```"}, "48": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    14: [1],\n    1: [7, 9],\n    6: [1, 12, 13, 5, 14],\n    12: [5, 2, 6, 11],\n    13: [11, 8, 12],\n    5: [7, 9, 12, 3],\n    7: [3],\n    3: [2, 7, 0, 9, 12],\n    11: [13, 4],\n    4: [14, 8],\n    0: [8, 4, 3],\n    8: [9, 4, 3, 2, 14],\n    9: [5, 2, 7, 0],\n    2: [14, 6, 8],\n    10: [4]\n})\n\n# Function to check if there is a path from start to end\ndef is_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 11 to node 2\nprint(is_path(graph, 11, 2))\n```"}, "49": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [11, 9, 3],\n    11: [2, 9],\n    9: [2, 11],\n    3: [2, 7],\n    4: [6, 10, 1],\n    6: [4, 0],\n    10: [4],\n    1: [4, 0, 8],\n    0: [6, 5, 1],\n    5: [0],\n    8: [1],\n    7: [3]\n}\n\nstart_node = 2\ngoal_node = 10\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "50": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [7, 6],\n    7: [5, 4],\n    6: [5, 1, 0],\n    4: [7, 2],\n    8: [3, 9],\n    3: [8, 0],\n    9: [8],\n    0: [3, 6],\n    2: [1, 4],\n    1: [2, 6]\n}\n\nstart_node = 0\ngoal_node = 2\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "51": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [11, 3],\n    11: [1, 6],\n    3: [1, 10],\n    6: [11, 10],\n    2: [5, 9],\n    5: [2, 7],\n    9: [2],\n    7: [5, 0],\n    0: [8, 7, 4],\n    8: [0, 4],\n    4: [0, 8],\n    10: [3, 6]\n}\n\nstart_node = 10\ngoal_node = 9\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "52": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [7, 1],\n    7: [0, 2, 10],\n    1: [0, 3],\n    2: [7, 4],\n    10: [7, 12],\n    8: [6, 4, 5],\n    6: [8, 11],\n    4: [8, 2],\n    5: [8, 12],\n    11: [6],\n    12: [10, 5],\n    3: [1, 9],\n    9: [3]\n}\n\nprint(dfs(graph, 12, 6))\n```"}, "53": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    7: [0],\n    0: [6],\n    4: [1, 2],\n    1: [7],\n    2: [5],\n    3: [1, 0, 5],\n    8: [5, 2],\n    6: [2]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 6\nresult = has_path(graph, 2, 6)\nprint(result)\n```"}, "54": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    3: [2, 4, 1],\n    2: [4, 7],\n    4: [5, 7],\n    1: [6],\n    7: [3, 4],\n    5: [7, 8],\n    6: [7],\n    0: [2],\n    8: [2, 0]\n})\n\nprint(has_path(graph, 4, 5))\n```"}, "55": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    5: [3, 2, 7],\n    3: [0, 4, 5],\n    2: [4],\n    7: [3, 0, 4],\n    0: [7, 6, 1],\n    4: [6],\n    6: [4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 7\nprint(has_path(graph, 2, 7))\n```"}, "56": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    12: [2, 0, 5, 11, 4, 7],\n    2: [12, 10, 3, 8],\n    0: [12, 1, 10, 6],\n    5: [12, 1, 11, 9],\n    11: [12, 5, 6, 7],\n    4: [12, 10, 13],\n    7: [12, 6, 11, 3],\n    10: [2, 0, 14, 4, 3, 8],\n    3: [2, 14, 10, 7],\n    8: [2, 10, 13],\n    1: [5, 13, 9, 0],\n    13: [1, 4, 8],\n    9: [1, 5, 6, 14],\n    6: [0, 11, 9, 7],\n    14: [10, 9, 3]\n}\n\nstart_node = 11\nend_node = 8\npath_exists = dfs(graph, start_node, end_node)\nprint(path_exists)\n```"}, "57": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [5, 9],\n    5: [1, 8],\n    9: [0],\n    0: [7, 4, 1, 8],\n    7: [4, 11, 3, 10],\n    4: [1, 8, 0],\n    1: [8, 7, 4],\n    8: [2, 0, 10, 7, 1],\n    6: [9, 4, 2],\n    11: [3, 7, 8],\n    3: [7, 9, 1],\n    10: [9, 4, 1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 11 to node 6\nprint(has_path(graph, 11, 6))\n```"}, "58": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [4, 2],\n    4: [3, 1, 0, 7],\n    2: [3],\n    1: [4, 8],\n    0: [4],\n    7: [4, 5],\n    5: [9, 6, 7],\n    9: [5, 8],\n    6: [5],\n    8: [9, 1]\n}\n\nstart_node = 8\ngoal_node = 2\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "59": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [7, 10, 0],\n    7: [13, 2],\n    10: [13],\n    0: [9, 5],\n    2: [5, 1],\n    5: [3],\n    1: [0, 2, 5],\n    13: [5, 12, 0],\n    6: [5, 7],\n    8: [14],\n    9: [1],\n    3: [1, 4, 9, 5, 11],\n    11: [7, 9]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 12 to node 11\nprint(has_path(graph, 12, 11))\n```"}, "60": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [1],\n    1: [8, 6, 3, 5],\n    2: [5],\n    8: [0, 2],\n    4: [7, 0],\n    7: [6]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 8\nresult = has_path(graph, 3, 8)\nprint(result)\n```"}, "61": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    13: [7],\n    7: [14],\n    5: [4],\n    4: [10, 13],\n    14: [6, 8, 4, 0, 11],\n    6: [1],\n    8: [7, 3, 10, 14],\n    0: [12, 7],\n    11: [4, 9],\n    1: [10, 5, 9],\n    3: [13, 14, 7],\n    10: [2, 11]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 7\nprint(has_path(graph, 2, 7))\n```"}, "62": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    6: [7, 0, 2],\n    7: [3, 5, 2, 8, 6],\n    0: [5, 4],\n    2: [7, 3],\n    3: [6],\n    5: [8, 6, 1, 0],\n    8: [6, 7, 3, 0, 4, 2],\n    1: [2, 6, 7],\n    4: [8, 7, 1, 3, 0, 5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 8 to node 7\nprint(has_path(graph, 8, 7))\n```"}, "63": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [2, 1, 4, 3],\n    2: [0],\n    1: [0, 8],\n    4: [0, 3],\n    3: [0, 4],\n    8: [1],\n    5: [6, 7],\n    6: [5, 7],\n    7: [5, 6]\n}\n\nstart_node = 7\ngoal_node = 0\n\nresult = dfs(graph, start_node, goal_node)\nprint(result)\n```"}, "64": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [2, 7, 4, 8, 0, 1, 3, 6],\n    2: [5, 4, 8, 0, 1, 3],\n    7: [5, 4, 0, 1],\n    4: [5, 2, 7, 0, 1, 3, 6],\n    8: [5, 2, 0, 6],\n    0: [5, 2, 7, 4, 8, 3, 6],\n    1: [5, 2, 7, 4, 3, 6],\n    3: [5, 2, 4, 0, 1, 6],\n    6: [5, 4, 8, 0, 1, 3]\n}\n\nstart_node = 4\ngoal_node = 8\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "65": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [8, 1],\n    8: [1],\n    1: [3, 4, 2],\n    2: [8],\n    7: [5],\n    5: [4, 0],\n    6: [3, 0]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 5\nresult = has_path(graph, 2, 5)\nprint(result)\n```"}, "66": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [7, 6],\n    7: [5, 8],\n    6: [0, 5, 8, 4],\n    0: [2],\n    5: [8, 4, 7, 6],\n    8: [7],\n    4: [9, 6, 0],\n    3: [2],\n    1: [5, 3]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 9 to node 4\nresult = has_path(graph, 9, 4)\nprint(result)\n```"}, "67": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [6, 8, 5, 0, 7, 2, 1],\n    6: [3, 4, 5, 0, 2, 1],\n    8: [3, 4, 0, 7, 1],\n    5: [3, 6, 4, 7, 2, 1],\n    0: [3, 6, 4, 8, 2, 1],\n    7: [3, 4, 8, 5, 2],\n    2: [3, 6, 5, 0, 7, 1],\n    1: [3, 6, 4, 8, 5, 0, 2],\n    4: [6, 8, 5, 0, 7, 1]\n}\n\nstart_node = 3\ngoal_node = 8\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "68": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [6, 9, 8, 11, 7],\n    6: [3, 7, 12],\n    9: [3, 5],\n    8: [3, 4],\n    11: [3, 13, 5, 7, 2, 1],\n    7: [3, 6, 5, 0, 11],\n    12: [6, 10],\n    10: [13, 4, 5, 1, 12],\n    13: [10, 11],\n    4: [10, 5, 8, 0, 2],\n    5: [10, 9, 7, 11, 4],\n    1: [10, 11],\n    0: [4, 7],\n    2: [4, 11]\n}\n\nstart_node = 6\ngoal_node = 3\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "69": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [3],\n    3: [6],\n    0: [7],\n    7: [0, 3, 5],\n    1: [5, 4],\n    5: [4, 0, 3],\n    6: [4, 0, 7],\n    8: [7, 4],\n    2: [1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 0 to node 2\nprint(has_path(graph, 0, 2))\n```"}, "70": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [9, 7, 5, 11, 10],\n    9: [3, 0, 7, 2, 8, 11, 6, 10],\n    7: [3, 0, 9, 4, 8, 5, 6, 10],\n    5: [3, 0, 4, 7, 2, 11, 6, 1],\n    11: [3, 0, 9, 2, 5, 6, 10],\n    10: [3, 0, 9, 4, 7, 8, 11, 6, 1],\n    0: [9, 4, 7, 2, 8, 5, 11, 6, 10],\n    4: [0, 7, 2, 8, 5, 6, 1, 10],\n    2: [0, 9, 4, 5, 11, 6],\n    8: [0, 9, 4, 7, 6, 1, 10],\n    6: [0, 9, 4, 7, 2, 8, 5, 11, 1, 10],\n    1: [4, 8, 5, 6, 10]\n}\n\nstart_node = 3\ngoal_node = 11\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "71": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [6, 0],\n    0: [5, 6, 8, 7],\n    8: [4, 1],\n    4: [1, 2, 7, 5],\n    1: [7],\n    7: [3, 0, 4],\n    3: [5, 2, 6, 7],\n    5: [4, 2, 7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 1\nprint(has_path(graph, 6, 1))\n```"}, "72": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    9: [12, 13, 3, 7, 1],\n    12: [9],\n    13: [9, 2, 14],\n    3: [9, 4],\n    7: [9, 11, 6, 0],\n    1: [9, 8],\n    2: [13],\n    14: [13],\n    4: [3],\n    8: [1, 10],\n    10: [8],\n    11: [5, 7],\n    5: [11],\n    6: [7],\n    0: [7]\n}\n\nstart_node = 5\ngoal_node = 7\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "73": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [7, 8],\n    7: [8, 6],\n    3: [5, 7],\n    5: [4, 8, 2],\n    4: [8],\n    6: [0, 7, 2],\n    0: [4],\n    1: [3, 6, 7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 3\nprint(has_path(graph, 6, 3))\n```"}, "74": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [2, 3, 1, 8, 5, 7],\n    2: [6, 9],\n    3: [6, 7],\n    1: [6, 7],\n    8: [6, 7],\n    5: [6, 7, 4],\n    7: [6, 5, 9, 0, 4, 8, 3, 1],\n    9: [2, 7],\n    0: [7, 4],\n    4: [7, 5, 0]\n}\n\nstart_node = 2\ngoal_node = 0\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "75": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [1, 2],\n    1: [7, 5],\n    2: [7, 4],\n    5: [1, 3],\n    8: [0, 10],\n    0: [8, 10],\n    10: [8, 0],\n    6: [4, 3],\n    4: [6, 2],\n    3: [6, 9, 5],\n    9: [3]\n}\n\nstart_node = 3\ngoal_node = 0\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "76": {"gpt4": "```python\nfrom collections import deque\n\n# Graph representation\ngraph = {\n    11: [5, 12, 10, 3, 13, 6],\n    5: [11, 2, 0, 12, 8, 3, 9, 7, 4],\n    12: [11, 5, 14, 0, 1, 3, 13],\n    10: [11, 1, 8, 13, 4],\n    3: [11, 5, 14, 12, 9, 7],\n    13: [11, 0, 12, 10, 1, 8, 9, 6],\n    6: [11, 9, 7, 13],\n    2: [5, 14, 0, 4],\n    14: [2, 12, 3],\n    0: [2, 5, 12, 13],\n    4: [2, 5, 10, 8, 9, 7],\n    8: [5, 10, 13, 4],\n    9: [5, 3, 13, 6, 4],\n    7: [5, 1, 3, 6, 4],\n    1: [12, 10, 7, 13]\n}\n\ndef bfs(start, goal):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == goal:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n    \n    return False\n\n# Check if there is a path between node 11 and node 7\nprint(bfs(11, 7))\n```"}, "77": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [10, 6, 1, 5],\n    10: [11, 2],\n    6: [11],\n    1: [5, 10, 11, 6],\n    5: [2, 1],\n    4: [10, 0, 1, 8],\n    11: [0, 2, 6, 1, 7],\n    2: [6],\n    7: [8, 2],\n    9: [7, 4],\n    3: [6, 11]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 3\nprint(has_path(graph, 2, 3))\n```"}, "78": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [1, 6, 8],\n    1: [7, 3, 0, 12, 9],\n    6: [7, 2, 0, 4, 12, 5],\n    8: [7, 2, 3, 10, 9],\n    3: [1, 10, 11, 8],\n    0: [1, 6, 12],\n    12: [1, 6, 0, 11, 9],\n    9: [1, 2, 10, 4, 12, 8],\n    2: [6, 10, 4, 8, 9],\n    10: [2, 3, 5, 8, 9],\n    4: [2, 6, 5, 11, 9],\n    11: [3, 4, 12],\n    5: [6, 10, 4]\n}\n\nstart_node = 0\ngoal_node = 12\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "79": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    9: [7],\n    7: [1, 5, 9, 8, 4],\n    6: [2, 1, 3],\n    1: [4, 0],\n    3: [5],\n    8: [7, 1, 5, 9],\n    5: [0, 2],\n    4: [7, 2, 9],\n    0: [7, 2, 3]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 0\nprint(has_path(graph, 2, 0))\n```"}, "80": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [5, 10, 4, 8, 9],\n    5: [0, 10, 4, 3, 9],\n    10: [0, 5, 4, 3, 7, 8, 9],\n    4: [0, 5, 10, 6, 2, 7, 1, 8, 9],\n    8: [0, 10, 4, 3, 1, 9],\n    9: [0, 5, 10, 4, 7, 8],\n    3: [5, 10, 6, 2, 7, 8],\n    7: [10, 4, 3, 9],\n    6: [4, 3, 2],\n    2: [6, 4, 3],\n    1: [4, 8]\n}\n\nstart_node = 10\nend_node = 7\n\nprint(dfs(graph, start_node, end_node))\n```"}, "81": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph as an adjacency list\ngraph = defaultdict(list, {\n    1: [5, 7, 6, 2],\n    5: [6, 2],\n    7: [6, 0, 3],\n    6: [5],\n    2: [5],\n    8: [5, 3, 9, 0],\n    3: [7, 9, 5],\n    0: [5, 7],\n    4: [2]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 7\nresult = has_path(graph, 4, 7)\nprint(result)\n```"}, "82": {"gpt4": "```python\ndef dfs(graph, start, target, visited):\n    if start == target:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, target, visited):\n                return True\n    return False\n\ngraph = {\n    5: [4, 6, 10, 11, 3],\n    4: [12, 8, 2, 9],\n    6: [9],\n    10: [0, 11, 4],\n    11: [9, 5, 4, 10],\n    3: [2, 4, 12, 6, 11, 7],\n    12: [8, 3, 9],\n    8: [5, 12],\n    2: [9, 4, 12, 7],\n    9: [5, 12, 11, 7],\n    0: [11],\n    7: [1],\n    1: [8, 11]\n}\n\nstart_node = 11\ntarget_node = 0\nvisited = set()\n\nresult = dfs(graph, start_node, target_node, visited)\nprint(result)\n```"}, "83": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    12: [6],\n    6: [7, 3, 9, 8],\n    10: [5, 8],\n    5: [3, 6],\n    8: [2],\n    3: [0, 10, 7],\n    0: [11],\n    11: [4, 2],\n    9: [10, 7],\n    4: [0, 9],\n    2: [6],\n    1: [9]\n})\n\n# Function to check if there is a path from start to end\ndef is_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 7 to node 5\nprint(is_path(graph, 7, 5))\n```"}, "84": {"gpt4": "```python\ndef dfs(graph, start, target, visited):\n    if start == target:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, target, visited):\n                return True\n    return False\n\ngraph = {\n    6: [11, 10, 3, 1, 0, 4, 7, 14, 13],\n    11: [10, 5, 2, 4, 14, 9, 6],\n    10: [5, 8, 12, 2, 14, 13, 6],\n    3: [8, 1, 2, 4, 7, 9, 11, 5],\n    1: [2, 0, 4, 9],\n    0: [4, 9, 10, 3, 8, 1, 2],\n    4: [9, 6, 11, 5, 3, 1, 0],\n    7: [5, 3, 12, 4],\n    14: [9, 11, 4],\n    13: [11, 1, 0, 4],\n    5: [8, 0, 6, 11],\n    2: [0, 14, 12, 1],\n    9: [10, 5, 8, 14, 13],\n    8: [1, 4, 13, 6],\n    12: [14, 13, 9, 6, 3]\n}\n\nstart_node = 0\ntarget_node = 3\nvisited = set()\n\nresult = dfs(graph, start_node, target_node, visited)\nprint(result)\n```"}, "85": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    13: [11],\n    11: [14],\n    5: [4, 14],\n    4: [6, 7],\n    6: [11, 1, 0, 13, 2],\n    7: [0, 5],\n    9: [11],\n    8: [6, 14],\n    12: [6, 1, 0, 13, 2],\n    1: [13],\n    0: [13, 5, 12, 1],\n    3: [5],\n    10: [8, 12, 14]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 9 to node 1\nprint(has_path(graph, 9, 1))\n```"}, "86": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [6],\n    6: [7, 1],\n    1: [6, 3, 5],\n    0: [4],\n    4: [0, 2],\n    2: [4, 3, 5],\n    3: [1, 2],\n    5: [1, 2]\n}\n\nstart_node = 4\ngoal_node = 6\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "87": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    5: [10, 0, 1, 3, 8],\n    10: [7, 9, 6],\n    0: [7, 11],\n    1: [4, 7, 2],\n    3: [4, 5, 2],\n    7: [6],\n    9: [11, 5, 7],\n    11: [4],\n    2: [9, 8, 10, 0, 7],\n    4: [10, 0, 2, 3]\n})\n\nstart_node = 6\nend_node = 3\n\nprint(has_path(graph, start_node, end_node))\n```"}, "88": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [5, 3],\n    5: [1, 9],\n    3: [1, 8],\n    9: [5],\n    6: [0, 7],\n    0: [6, 2],\n    7: [6, 4, 10],\n    2: [0, 8],\n    4: [7, 8],\n    8: [4, 2, 3],\n    10: [7]\n}\n\nstart_node = 8\ngoal_node = 5\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "89": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    1: [4, 5],\n    4: [9, 7, 8],\n    5: [2],\n    9: [2, 4],\n    7: [8, 6],\n    8: [1, 4, 9],\n    6: [3],\n    2: [8, 0],\n    0: [5, 4, 8]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 8\nresult = has_path(graph, 3, 8)\nprint(result)\n```"}, "90": {"gpt4": "```python\ndef dfs(graph, start, goal, visited):\n    if start == goal:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [4, 5],\n    4: [0],\n    5: [0, 1, 6],\n    1: [5, 3],\n    6: [5, 2],\n    3: [1, 7],\n    2: [6],\n    7: [3]\n}\n\nstart_node = 1\ngoal_node = 3\nvisited = set()\n\npath_exists = dfs(graph, start_node, goal_node, visited)\nprint(path_exists)\n```"}, "91": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [8, 6, 3],\n    8: [7],\n    6: [7, 2, 5],\n    3: [7, 1],\n    9: [4, 0],\n    4: [9, 0],\n    0: [9, 4],\n    2: [5, 6],\n    5: [2, 6],\n    1: [3]\n}\n\nstart_node = 5\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "92": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    12: [7, 1],\n    7: [12, 0],\n    1: [12, 14],\n    0: [7, 9],\n    9: [0, 10],\n    6: [13],\n    13: [6, 14],\n    14: [13, 1],\n    4: [3, 10],\n    3: [4, 10],\n    10: [4, 3, 9, 8],\n    11: [2, 5],\n    2: [11, 8],\n    5: [11],\n    8: [2, 10]\n}\n\nstart_node = 2\ngoal_node = 7\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "93": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    1: [7, 6],\n    7: [6, 5, 1],\n    6: [5, 7],\n    3: [7, 2, 0],\n    0: [1, 3],\n    5: [1, 7, 2],\n    4: [1, 3]\n})\n\nstart_node = 5\nend_node = 0\n\nprint(has_path(graph, start_node, end_node))\n```"}, "94": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [8, 0, 1],\n    0: [4, 7],\n    1: [2, 10, 8],\n    5: [12, 2],\n    12: [7, 1],\n    6: [9, 3, 0, 5],\n    9: [4, 2, 5, 8],\n    3: [12],\n    10: [11, 12],\n    11: [2, 6, 7],\n    7: [9, 0, 6, 10]\n})\n\ndef bfs(start, goal):\n    queue = deque([start])\n    visited = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node == goal:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 12 to node 0\nprint(bfs(12, 0))\n```"}, "95": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    9: [8, 7],\n    8: [9, 6, 2],\n    7: [9],\n    6: [8, 2],\n    2: [8, 6],\n    5: [4, 10],\n    4: [5, 1],\n    10: [5, 0],\n    1: [4, 3],\n    0: [10, 3],\n    3: [0, 1]\n}\n\nstart_node = 6\ngoal_node = 1\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "96": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    5: [0],\n    0: [1, 6, 2, 8],\n    2: [4, 5],\n    4: [3, 0, 9, 6, 7],\n    7: [8, 1, 5],\n    8: [9, 5],\n    1: [9],\n    9: [6, 5, 4],\n    3: [1, 6, 7],\n    6: [5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 9\nresult = has_path(graph, 4, 9)\nprint(result)\n```"}, "97": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph as an adjacency list\ngraph = defaultdict(list, {\n    1: [7, 10, 9],\n    10: [8, 4],\n    9: [5, 4, 7],\n    6: [0, 8, 7],\n    0: [8],\n    8: [2, 4],\n    4: [0, 10, 2],\n    2: [1],\n    3: [7],\n    5: [4, 10]\n})\n\n# Function to check if there is a path from start to end using BFS\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 7 to node 6\nprint(has_path(graph, 7, 6))\n```"}, "98": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [12, 2, 5, 9, 10, 4, 6],\n    12: [1, 7, 2, 9, 10, 8, 4],\n    2: [1, 7, 11, 12, 5, 10, 0, 8, 3],\n    5: [1, 11, 2, 8, 4, 6, 3],\n    9: [1, 7, 11, 12, 10, 0, 6],\n    10: [1, 11, 12, 2, 9],\n    4: [1, 7, 11, 12, 5, 8],\n    6: [1, 7, 11, 5, 9, 0, 3],\n    7: [12, 2, 9, 0, 8, 4, 6],\n    0: [7, 11, 2, 9, 8, 6, 3],\n    8: [7, 12, 2, 5, 0, 4],\n    11: [2, 5, 9, 10, 0, 4, 6],\n    3: [2, 5, 0, 6]\n}\n\nstart_node = 4\ngoal_node = 11\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "99": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [1, 3],\n    1: [4, 6],\n    3: [4],\n    6: [1, 10, 9, 8],\n    13: [12, 0],\n    12: [13, 14, 2],\n    0: [13, 11],\n    14: [12],\n    2: [12, 11, 5],\n    10: [6, 8],\n    9: [6],\n    8: [6, 10],\n    11: [0, 2],\n    5: [2, 7],\n    7: [5]\n}\n\nstart_node = 9\ngoal_node = 12\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "100": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [6, 12],\n    6: [4, 12],\n    12: [4, 6, 2],\n    2: [12, 7],\n    7: [2, 8, 5],\n    9: [0, 13],\n    0: [9, 10],\n    13: [9, 3],\n    10: [0, 8],\n    11: [1],\n    1: [11, 3],\n    3: [1, 13],\n    8: [10, 7],\n    5: [7]\n}\n\nstart_node = 12\nend_node = 2\n\nprint(dfs(graph, start_node, end_node))\n```"}, "101": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [5],\n    5: [8, 3],\n    1: [8, 6, 7, 5],\n    8: [9, 5, 4],\n    6: [4],\n    7: [4, 8, 3],\n    9: [3, 5, 10, 1, 8],\n    0: [7],\n    3: [5],\n    10: [1, 0, 7, 5],\n    2: [8]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 2\nprint(has_path(graph, 3, 2))\n```"}, "102": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [8, 0],\n    8: [2, 10],\n    0: [2],\n    10: [8, 6, 3],\n    7: [4, 9],\n    4: [7, 3],\n    9: [7, 5],\n    3: [4, 10, 11],\n    6: [10, 1],\n    1: [6, 12],\n    5: [11, 9],\n    11: [5, 3],\n    12: [1]\n}\n\nstart_node = 8\ngoal_node = 4\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "103": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    0: [10, 8, 14],\n    10: [12, 13, 2, 4],\n    8: [11],\n    14: [3, 8],\n    7: [4, 5, 12],\n    5: [9, 7, 10],\n    12: [13],\n    13: [11],\n    11: [12, 13],\n    2: [10],\n    3: [8, 6],\n    6: [12, 14, 9, 1, 13, 2],\n    9: [12, 14],\n    1: [4, 3, 5, 14]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 8 to node 0\nprint(has_path(graph, 8, 0))\n```"}, "104": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [7, 4, 0, 2],\n    7: [9],\n    4: [5, 2],\n    0: [11, 7],\n    2: [3, 4, 8, 5],\n    6: [12, 1, 3],\n    12: [7],\n    1: [4, 8],\n    9: [8],\n    8: [2, 12, 9, 4, 0],\n    10: [5, 12],\n    5: [4],\n    11: [5, 9, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 9 to node 12\nprint(has_path(graph, 9, 12))\n```"}, "105": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Graph representation\ngraph = defaultdict(list, {\n    6: [5],\n    5: [3, 6],\n    4: [2, 9, 8],\n    2: [1, 8, 4],\n    9: [8, 13],\n    8: [6, 4],\n    12: [11, 10, 7],\n    11: [2, 1, 9, 0],\n    10: [8],\n    7: [0, 11],\n    13: [5],\n    1: [3, 2],\n    3: [8]\n})\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 5 to node 7\nprint(has_path(graph, 5, 7))\n```"}, "106": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    10: [0, 5],\n    0: [10, 8],\n    5: [10, 6],\n    8: [0, 12],\n    2: [4, 1, 11],\n    4: [2, 3],\n    1: [2],\n    11: [2, 12],\n    3: [4, 6, 9],\n    12: [8, 11, 7],\n    7: [12],\n    6: [3, 5],\n    9: [3]\n}\n\nstart_node = 8\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "107": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [3, 1],\n    3: [5, 10],\n    1: [5, 8],\n    10: [3, 0],\n    2: [6, 9],\n    6: [2, 9],\n    9: [2, 6, 4],\n    4: [9],\n    0: [10, 7],\n    7: [0, 8],\n    8: [1, 7]\n}\n\nstart_node = 3\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "108": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    0: [8, 7, 2],\n    8: [5],\n    7: [2, 5, 8, 3],\n    2: [5, 9, 3],\n    5: [3, 7, 0],\n    3: [8, 9],\n    6: [3, 7, 4, 0, 8],\n    4: [8, 6, 7],\n    9: [1],\n    1: [2, 6]\n})\n\nprint(has_path(graph, 9, 0))\n```"}, "109": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [4],\n    4: [6, 5, 12],\n    7: [13, 12],\n    13: [11, 1, 9, 2, 5, 0],\n    0: [5, 10],\n    5: [7, 3, 13, 4, 9, 2],\n    3: [13, 11, 2, 10],\n    11: [8, 0],\n    2: [6, 1, 8, 9],\n    1: [4, 9],\n    9: [6, 11, 4],\n    8: [2, 0, 13],\n    6: [11, 1, 9, 2],\n    14: [3, 13, 9, 6]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 14\nresult = has_path(graph, 6, 14)\nprint(result)\n```"}, "110": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [5, 8, 0, 4, 7],\n    5: [6, 10, 3, 7],\n    8: [6, 9, 0, 3],\n    0: [6, 8, 3, 2],\n    4: [6, 2, 7],\n    7: [6, 5, 10, 4, 1],\n    10: [5, 9, 7],\n    3: [5, 8, 11, 0, 1],\n    9: [8, 10, 2, 1],\n    2: [9, 11, 0, 1, 4],\n    1: [9, 3, 2, 7],\n    11: [3, 2]\n}\n\nstart_node = 1\ngoal_node = 8\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "111": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [12, 6],\n    12: [2, 3, 0],\n    6: [2],\n    3: [12, 11],\n    0: [12, 8],\n    5: [9, 14, 13],\n    9: [5],\n    14: [5, 7, 13],\n    13: [5, 14],\n    10: [8, 1],\n    8: [10, 0],\n    1: [10, 11],\n    4: [7],\n    7: [4, 14],\n    11: [3, 1]\n}\n\nstart_node = 4\nend_node = 11\n\nprint(dfs(graph, start_node, end_node))\n```"}, "112": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return False\n\ngraph = defaultdict(list, {\n    12: [8, 0],\n    8: [0],\n    0: [12],\n    4: [2],\n    2: [10],\n    1: [14, 13, 4],\n    14: [2, 5, 13, 10],\n    6: [2],\n    10: [14],\n    5: [2],\n    9: [3, 11],\n    3: [2, 11],\n    11: [3],\n    7: [14]\n})\n\nstart_node = 4\nend_node = 5\n\nprint(has_path(graph, start_node, end_node))\n```"}, "113": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    13: [3, 5],\n    3: [13, 10],\n    5: [13, 14],\n    10: [3, 0],\n    12: [9, 11],\n    9: [12, 4],\n    11: [12, 4],\n    4: [9, 11],\n    6: [8, 2],\n    8: [6, 14],\n    2: [6, 0, 7],\n    14: [8, 5],\n    0: [2, 10],\n    7: [2, 1],\n    1: [7]\n}\n\nstart_node = 3\ngoal_node = 4\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "114": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [0, 11, 10, 9],\n    0: [6, 11, 3, 9],\n    11: [6, 0, 8, 10, 1, 5],\n    10: [6, 11, 8, 2, 1, 5],\n    9: [6, 0, 12, 3, 2, 4],\n    3: [0, 2, 9, 1],\n    8: [11, 10, 1],\n    1: [11, 8, 10, 3, 2, 7, 5],\n    5: [11, 12, 10, 1],\n    12: [7, 9, 5],\n    7: [12, 1],\n    2: [10, 3, 9, 1],\n    4: [9]\n}\n\nstart_node = 7\ngoal_node = 5\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "115": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    6: [2, 1],\n    2: [7],\n    1: [7],\n    4: [5, 7],\n    5: [4],\n    7: [1],\n    0: [8, 1],\n    8: [7, 1],\n    3: [1]\n})\n\nstart_node = 5\nend_node = 0\n\nprint(has_path(graph, start_node, end_node))\n```"}, "116": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [1, 4, 6, 3, 0],\n    1: [7, 3, 2],\n    4: [7, 6],\n    6: [7, 4, 0, 5, 2],\n    3: [7, 1, 5],\n    0: [7, 6],\n    2: [1, 6],\n    5: [3, 6]\n}\n\nstart_node = 7\ngoal_node = 0\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "117": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [14, 9, 10, 6, 0],\n    14: [13, 11, 3],\n    9: [7, 12, 3],\n    10: [9, 4],\n    6: [11, 13],\n    0: [3, 2],\n    13: [3, 9],\n    11: [7],\n    12: [14, 9, 4, 10],\n    4: [2],\n    2: [5, 6, 9, 8],\n    8: [0],\n    5: [11, 12, 14, 8],\n    1: [0, 10, 11]\n})\n\n# Function to check if there's a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there's a path from node 8 to node 1\nresult = has_path(graph, 8, 1)\nprint(result)\n```"}, "118": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    11: [4, 10, 2, 5, 9, 1, 14, 7, 8],\n    4: [11, 6, 7, 2, 14, 12, 0, 10],\n    10: [11, 4, 0, 9, 12, 8, 14],\n    2: [11, 4, 9, 8, 14, 6],\n    5: [11, 3],\n    9: [11, 10, 2],\n    1: [11, 14, 13, 12],\n    14: [11, 4, 10, 0, 2, 6, 13, 3, 1],\n    7: [11, 4, 13, 8],\n    8: [11, 10, 2, 7, 3],\n    6: [4, 2, 14],\n    12: [4, 10, 1],\n    0: [4, 10, 14],\n    13: [14, 7, 1],\n    3: [14, 8, 5]\n}\n\nstart_node = 0\ngoal_node = 6\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "119": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    13: [12],\n    12: [5],\n    1: [10],\n    10: [12, 1],\n    4: [3],\n    3: [10, 2],\n    6: [10, 7, 3, 9],\n    7: [0, 9],\n    5: [7, 4],\n    0: [12, 9, 4, 6],\n    11: [9],\n    8: [1, 5, 10, 12]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 11\nprint(has_path(graph, 4, 11))\n```"}, "120": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [1, 5, 3],\n    1: [7, 0],\n    5: [7, 6, 3],\n    3: [7, 5],\n    0: [1, 4],\n    6: [5],\n    2: [4],\n    4: [2, 0]\n}\n\nstart_node = 0\ngoal_node = 2\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "121": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph as an adjacency list\ngraph = defaultdict(list, {\n    10: [3, 2, 6],\n    3: [5, 9, 6],\n    6: [0, 2, 1],\n    0: [12, 9],\n    12: [5, 9, 6],\n    9: [6, 2, 5, 8],\n    13: [12, 1, 9, 0],\n    1: [11, 10, 0],\n    5: [11],\n    7: [0],\n    4: [2, 11, 10],\n    11: [10, 12],\n    8: [11, 2, 1]\n})\n\ndef bfs(start, target, graph):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 5\nprint(bfs(2, 5, graph))\n```"}, "122": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [7],\n    7: [0, 9, 3],\n    9: [7, 10, 1],\n    3: [7],\n    8: [10],\n    10: [8, 6, 11, 9, 5],\n    6: [10],\n    11: [10, 4],\n    5: [10, 1],\n    4: [2, 11],\n    2: [4],\n    1: [5, 9]\n}\n\nstart_node = 1\ngoal_node = 10\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "123": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [6, 7],\n    6: [3, 7, 5],\n    7: [3, 6],\n    5: [6],\n    10: [2, 1, 9],\n    2: [10],\n    1: [10, 0],\n    9: [10, 4],\n    0: [1, 4, 8],\n    4: [0, 9],\n    8: [0]\n}\n\nstart_node = 3\ngoal_node = 4\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "124": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [8, 7, 1],\n    8: [5, 6, 3, 0],\n    7: [5],\n    1: [5, 4, 2],\n    6: [8],\n    3: [8, 0],\n    0: [8, 3],\n    4: [1],\n    2: [1]\n}\n\nstart_node = 4\ngoal_node = 6\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "125": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [1, 6, 3, 0],\n    1: [6, 7, 3, 2],\n    6: [5],\n    3: [8, 1],\n    8: [6],\n    7: [0],\n    5: [0, 4],\n    4: [3, 5, 1, 6]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 7 to node 4\nprint(has_path(graph, 7, 4))\n```"}, "126": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [6, 5, 7, 3, 8, 0, 9, 2],\n    6: [1, 9, 5],\n    5: [1, 6, 8, 3, 9, 4],\n    7: [1, 8, 4, 3, 2],\n    3: [1, 5, 7],\n    8: [1, 5, 7, 9, 4, 2],\n    0: [1],\n    9: [1, 6, 5, 8],\n    2: [1, 8, 7],\n    4: [5, 8, 7]\n}\n\nstart_node = 7\ngoal_node = 3\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "127": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    6: [3, 9],\n    3: [6],\n    9: [2],\n    0: [7, 10, 9],\n    7: [10, 5],\n    10: [5, 0],\n    1: [4],\n    4: [2],\n    5: [9, 2],\n    8: [1, 2, 5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 3\nresult = has_path(graph, 1, 3)\nprint(result)\n```"}, "128": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [11, 8, 7],\n    11: [4, 0, 9],\n    8: [4, 10],\n    7: [4, 6],\n    0: [11, 2],\n    9: [11, 2],\n    2: [0, 9],\n    10: [8],\n    5: [6, 1],\n    6: [5, 3, 7],\n    1: [5],\n    3: [6]\n}\n\nstart_node = 6\ngoal_node = 3\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "129": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [0, 2],\n    0: [5, 7],\n    2: [5, 4],\n    7: [0, 6],\n    1: [12, 13, 3],\n    12: [1, 10, 11],\n    13: [1, 10],\n    3: [1, 9],\n    10: [12, 13],\n    11: [12],\n    4: [2, 8],\n    6: [7, 8],\n    9: [3],\n    8: [4, 6]\n}\n\nstart_node = 0\ngoal_node = 10\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "130": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [4, 7, 2, 3],\n    4: [5, 2],\n    7: [5, 1, 6],\n    2: [5, 4, 9, 8, 3],\n    3: [5, 0, 2, 8, 6],\n    0: [9, 3, 6],\n    9: [0, 2],\n    6: [0, 7, 3],\n    1: [7, 8],\n    8: [1, 2, 3]\n}\n\nstart_node = 3\ngoal_node = 7\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "131": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    7: [4, 5],\n    4: [1],\n    5: [0, 4],\n    1: [0, 7, 4],\n    0: [7],\n    6: [8, 3, 9, 7],\n    8: [9, 4, 5],\n    3: [9, 4],\n    2: [8, 3, 4]\n})\n\nprint(has_path(graph, 1, 3))\n```"}, "132": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [0, 12, 9, 1, 11, 2, 3, 8, 6],\n    0: [4],\n    12: [4],\n    9: [4, 10, 5],\n    1: [4, 13],\n    11: [4],\n    2: [4],\n    3: [4],\n    8: [4],\n    6: [4, 7],\n    10: [9],\n    5: [9, 14],\n    13: [1],\n    14: [5],\n    7: [6]\n}\n\nstart_node = 10\ngoal_node = 8\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "133": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph as an adjacency list\ngraph = defaultdict(list, {\n    0: [4],\n    4: [0],\n    6: [2, 4, 0],\n    2: [5],\n    5: [3, 0, 6],\n    3: [0, 2],\n    7: [0, 6, 5],\n    1: [3, 0, 5],\n    8: [4, 2, 7, 3]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 8\nprint(has_path(graph, 3, 8))\n```"}, "134": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [3, 2, 10, 0, 6],\n    3: [8],\n    2: [8],\n    10: [8, 1],\n    0: [8, 4, 9],\n    6: [8],\n    4: [0, 5],\n    9: [0, 7],\n    5: [4],\n    1: [10],\n    7: [9]\n}\n\nstart_node = 6\ngoal_node = 10\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "135": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [0],\n    0: [5, 1, 8],\n    5: [1, 6, 8],\n    1: [3, 6],\n    8: [2, 3],\n    7: [3],\n    3: [1],\n    6: [8, 2, 3],\n    4: [2]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 5 to node 7\nprint(has_path(graph, 5, 7))\n```"}, "136": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [6, 9, 4, 3],\n    6: [8, 12, 0],\n    9: [8, 7, 5],\n    4: [8],\n    3: [8, 10, 2, 11],\n    12: [6],\n    0: [6],\n    7: [9],\n    5: [9, 1],\n    1: [5],\n    10: [3],\n    2: [3],\n    11: [3]\n}\n\nstart_node = 0\ngoal_node = 7\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "137": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    7: [3],\n    3: [10, 8, 13],\n    10: [2, 11],\n    8: [3, 14],\n    13: [10],\n    12: [14, 6, 0],\n    14: [1, 13, 9],\n    6: [7, 3],\n    1: [8, 13, 7, 12],\n    9: [14, 8],\n    11: [6, 12],\n    2: [10, 1],\n    5: [2, 4, 1],\n    4: [14, 6]\n})\n\nprint(has_path(graph, 11, 5))\n```"}, "138": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    9: [6, 13, 7, 12, 2],\n    6: [9, 3],\n    13: [9, 5, 1, 4, 11, 3, 10, 0, 8],\n    7: [9, 0, 11],\n    12: [9, 14, 0],\n    2: [9, 3, 0],\n    3: [6, 13, 2],\n    5: [13, 1],\n    1: [13, 5, 10],\n    4: [13, 8, 0, 10, 14],\n    11: [13, 7],\n    10: [13, 1, 4],\n    0: [13, 2, 4, 7, 12],\n    8: [13, 4],\n    14: [4, 12]\n}\n\nprint(dfs(graph, 4, 0))\n```"}, "139": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    11: [3, 12, 0],\n    3: [11, 9],\n    12: [11, 1],\n    0: [11, 9],\n    9: [3, 0],\n    10: [4],\n    4: [10, 13],\n    13: [4, 1],\n    6: [7, 2],\n    7: [6, 8],\n    2: [6, 8],\n    8: [7, 2],\n    1: [12, 5, 13],\n    5: [1]\n}\n\nstart_node = 9\ngoal_node = 8\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "140": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [5, 2, 1, 8],\n    5: [0],\n    2: [0],\n    1: [0],\n    8: [0, 7],\n    3: [7, 4, 6],\n    7: [3, 8],\n    4: [3],\n    6: [3]\n}\n\nstart_node = 7\ngoal_node = 6\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "141": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [2, 6, 3],\n    2: [10, 11],\n    6: [3, 8],\n    3: [10, 8, 6],\n    4: [5],\n    5: [3, 10],\n    10: [1, 5, 11, 6],\n    1: [7],\n    7: [0, 4],\n    0: [3, 7],\n    9: [5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 9\nprint(has_path(graph, 4, 9))\n```"}, "142": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [10, 4, 12, 9, 5, 13],\n    10: [1, 0, 3, 9],\n    4: [1, 12, 2, 5],\n    12: [1, 0, 4, 8, 13],\n    9: [1, 10, 0, 6, 3],\n    5: [1, 0, 4, 6, 7, 8],\n    13: [1, 12, 3, 7],\n    11: [3, 7],\n    3: [11, 10, 9, 7, 13],\n    7: [11, 6, 2, 3, 5, 13],\n    0: [10, 6, 12, 9, 5],\n    6: [0, 9, 5, 7],\n    2: [4, 7],\n    8: [12, 5]\n}\n\nstart_node = 12\ngoal_node = 3\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "143": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [2, 7],\n    2: [8, 7],\n    7: [8, 2],\n    1: [3, 0],\n    3: [1, 6, 4],\n    0: [1, 4],\n    6: [3],\n    4: [3, 0, 5],\n    5: [4]\n}\n\nstart_node = 4\ngoal_node = 7\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "144": {"gpt4": "```python\ndef dfs(graph, start, goal, visited):\n    if start == goal:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [1, 0, 2],\n    1: [4, 5],\n    0: [4, 10],\n    2: [4],\n    5: [1, 8, 7],\n    9: [8, 10],\n    8: [9, 5],\n    10: [9, 0],\n    7: [5, 3],\n    3: [7, 6],\n    6: [3]\n}\n\nstart_node = 0\ngoal_node = 9\nvisited = set()\n\nresult = dfs(graph, start_node, goal_node, visited)\nprint(result)\n```"}, "145": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    1: [3, 6],\n    3: [1, 8],\n    6: [8],\n    7: [5, 6, 4],\n    5: [0, 8, 4],\n    4: [5, 8],\n    0: [3, 4],\n    8: [6, 0],\n    2: [1]\n})\n\nprint(has_path(graph, 3, 2))\n```"}, "146": {"gpt4": "```python\nfrom collections import deque\n\ndef bfs(graph, start, goal):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == goal:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = {\n    6: [4, 2, 5, 0],\n    4: [7, 2, 5, 3],\n    2: [6, 4, 1],\n    5: [0, 4, 2],\n    0: [4, 2],\n    7: [1, 5, 3],\n    3: [0],\n    1: [0, 6, 4]\n}\n\nstart_node = 4\nend_node = 3\n\nprint(bfs(graph, start_node, end_node))\n```"}, "147": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    1: [3, 0],\n    3: [9, 10, 12, 11],\n    0: [9],\n    10: [12, 5, 9],\n    12: [3, 9, 10],\n    5: [10, 2, 0],\n    9: [3, 0, 7],\n    11: [0, 9, 10],\n    8: [7],\n    2: [5],\n    4: [7, 5],\n    6: [1, 0, 5, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 11 to node 1\nprint(has_path(graph, 11, 1))\n```"}, "148": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    12: [6, 13, 11],\n    6: [12, 2],\n    13: [12, 8],\n    11: [12, 4],\n    2: [6, 1],\n    5: [8],\n    8: [5, 10, 13],\n    10: [8, 14],\n    1: [2, 4],\n    4: [1, 11],\n    14: [10],\n    3: [0, 7],\n    0: [3, 9, 7],\n    7: [3, 0],\n    9: [0]\n}\n\nstart_node = 14\ngoal_node = 6\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "149": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [0],\n    7: [8],\n    8: [1, 6, 2],\n    1: [5, 6, 2, 3],\n    6: [0, 1],\n    3: [4, 7],\n    4: [0],\n    5: [2, 7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 5\nprint(has_path(graph, 2, 5))\n```"}, "150": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [5, 8, 3],\n    5: [7, 0],\n    8: [7, 1, 0, 3, 4],\n    3: [7, 0, 8, 2, 4],\n    0: [5, 1, 8, 3, 4],\n    1: [0, 8],\n    6: [2, 4],\n    2: [6, 3, 4],\n    4: [6, 0, 8, 2, 3]\n}\n\nstart_node = 7\ngoal_node = 8\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "151": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [0, 4],\n    0: [2, 6],\n    1: [7],\n    7: [8, 10, 6],\n    8: [5],\n    5: [8],\n    10: [8],\n    2: [4, 7, 10],\n    6: [9, 10, 0],\n    9: [7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 5 to node 1\nresult = has_path(graph, 5, 1)\nprint(result)\n```"}, "152": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [5],\n    5: [2, 4, 6, 1, 0, 3],\n    4: [5, 7],\n    6: [5],\n    1: [5],\n    0: [5],\n    3: [5],\n    7: [4]\n}\n\nstart_node = 0\ngoal_node = 2\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "153": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    11: [6, 9],\n    6: [11, 10, 5],\n    9: [11],\n    10: [6, 1, 5],\n    5: [6, 10, 4],\n    1: [10],\n    0: [8, 2, 12],\n    8: [0, 12],\n    2: [0, 7],\n    12: [0, 8],\n    4: [5],\n    3: [7],\n    7: [3, 2]\n}\n\nstart_node = 7\ngoal_node = 11\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "154": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [8, 9, 3, 6, 0, 13],\n    8: [9, 2, 13, 7, 1],\n    9: [0, 1, 12],\n    3: [6, 13, 4, 7, 10, 9],\n    6: [0, 4, 8, 10, 12],\n    0: [11, 9, 6],\n    13: [4, 5, 6],\n    7: [1, 8, 12, 3, 6],\n    1: [4],\n    12: [13, 4],\n    2: [6, 12, 5],\n    10: [3, 0, 13, 4, 7],\n    5: [9],\n    11: [1, 5, 2]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 13 to node 9\nprint(has_path(graph, 13, 9))\n```"}, "155": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [5],\n    5: [2, 7],\n    2: [4, 7, 5, 8, 10],\n    4: [5, 0],\n    7: [5],\n    8: [1, 9, 4, 3],\n    9: [8, 10],\n    0: [5, 1, 10, 2],\n    3: [1, 10, 2, 0, 4],\n    6: [7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 0\nprint(has_path(graph, 1, 0))\n```"}, "156": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [10, 0, 7, 8, 5, 1],\n    10: [6, 2, 8, 4],\n    0: [6, 5, 9, 2],\n    7: [6, 4, 2, 8, 3],\n    8: [6, 10, 4, 7],\n    5: [6, 1, 0],\n    1: [6, 5, 9, 3],\n    2: [10, 0, 7],\n    4: [10, 9, 8, 7],\n    9: [1, 0, 4, 3],\n    3: [1, 9, 7]\n}\n\nstart_node = 6\ngoal_node = 9\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "157": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [11, 10],\n    11: [13, 5, 10, 0, 4],\n    10: [11, 5],\n    9: [13, 10, 4],\n    13: [10, 4],\n    2: [0, 4],\n    5: [12, 7, 9],\n    3: [10, 7, 6, 2],\n    7: [2, 11, 3, 12, 10],\n    6: [13, 10],\n    1: [9, 13],\n    8: [2, 11, 13]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 0 to node 9\nprint(has_path(graph, 0, 9))\n```"}, "158": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [5, 7],\n    5: [6, 9],\n    7: [6, 10],\n    9: [5, 0, 10],\n    10: [7, 4, 9, 2],\n    1: [0, 8],\n    0: [1, 9],\n    8: [1, 3],\n    4: [10, 11],\n    2: [10],\n    11: [4],\n    3: [8]\n}\n\nstart_node = 0\ngoal_node = 8\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "159": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [6, 0, 4],\n    6: [4, 8],\n    0: [7],\n    4: [3, 7],\n    3: [6, 4],\n    5: [7],\n    7: [4, 3],\n    1: [4],\n    2: [7, 6, 0]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 8 to node 5\nprint(has_path(graph, 8, 5))\n```"}, "160": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [0, 2, 4, 6, 9, 12, 10, 8, 1, 3, 13],\n    0: [5],\n    2: [5, 7],\n    4: [5],\n    6: [5],\n    9: [5],\n    12: [5],\n    10: [5],\n    8: [5],\n    1: [5],\n    3: [5],\n    13: [5],\n    7: [2, 11],\n    11: [7]\n}\n\nstart_node = 12\nend_node = 10\n\npath_exists = dfs(graph, start_node, end_node)\nprint(path_exists)\n```"}, "161": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [0, 2, 3],\n    0: [2, 1],\n    2: [3, 7, 4, 8],\n    3: [7, 5, 6],\n    1: [9, 10, 6, 7, 4, 8],\n    10: [9],\n    6: [3, 7, 8, 9],\n    7: [5],\n    4: [9, 0],\n    5: [0, 6, 10]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 9 to node 7\nprint(has_path(graph, 9, 7))\n```"}, "162": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [2, 9],\n    2: [8, 0, 1],\n    9: [8, 4],\n    0: [2, 5],\n    1: [2],\n    3: [7, 6],\n    7: [3, 4, 5],\n    6: [3],\n    4: [7, 9],\n    5: [7, 0]\n}\n\nstart_node = 8\ngoal_node = 9\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "163": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [11, 13, 6, 4],\n    11: [14],\n    13: [14, 12, 5],\n    6: [12],\n    4: [3, 5, 14, 12],\n    3: [5, 11],\n    5: [1, 3],\n    1: [6, 12, 4],\n    7: [6, 10],\n    14: [2],\n    12: [3, 13],\n    0: [12, 6],\n    9: [2, 3, 13],\n    2: [14, 12],\n    8: [5, 7]\n})\n\n# Function to check if there is a path from start to end\ndef is_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 14 to node 8\nprint(is_path(graph, 14, 8))\n```"}, "164": {"gpt4": "```python\nfrom collections import deque\n\ndef is_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n    \n    return False\n\ngraph = {\n    1: [2, 3, 4, 5, 6],\n    2: [1, 0, 7, 3, 4],\n    3: [1, 0, 2, 8, 6],\n    4: [1, 0, 2, 8, 5, 6],\n    5: [1, 0, 8, 4, 6],\n    6: [1, 0, 8, 3, 4, 5],\n    0: [2, 8, 7, 3, 4, 5, 6],\n    8: [0, 7, 3, 4, 5, 6],\n    7: [0, 2, 8]\n}\n\nprint(is_path(graph, 3, 7))\n```"}, "165": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [5],\n    5: [1, 6, 3],\n    6: [5, 3],\n    3: [5, 8, 6],\n    8: [3],\n    0: [4, 2, 9],\n    4: [0, 7, 9],\n    2: [0],\n    9: [0, 4],\n    7: [4]\n}\n\nstart_node = 3\ngoal_node = 0\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "166": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    10: [11, 12, 8],\n    11: [8, 3],\n    8: [9, 6],\n    3: [1, 4],\n    1: [0, 4],\n    4: [14, 1, 12],\n    5: [2, 8, 9],\n    2: [13],\n    9: [7, 1, 6],\n    13: [9, 7, 4, 12],\n    0: [6],\n    7: [5, 9],\n    6: [7, 2]\n})\n\nprint(has_path(graph, 2, 7))\n```"}, "167": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    9: [1, 10, 4, 7],\n    1: [8, 2, 4, 9],\n    10: [4, 11, 8],\n    4: [2],\n    7: [8, 5],\n    2: [11],\n    11: [9, 8, 10, 5, 6, 4],\n    5: [2, 11],\n    0: [6, 3, 9],\n    6: [4, 11, 7, 9],\n    3: [7, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 8 to node 2\nprint(has_path(graph, 8, 2))\n```"}, "168": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    0: [6],\n    6: [7, 2, 4, 3],\n    2: [7, 5, 0],\n    7: [0, 2],\n    5: [6],\n    4: [3, 7, 5, 0],\n    3: [5, 4],\n    1: [2, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 5 to node 3\nprint(has_path(graph, 5, 3))\n```"}, "169": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [3],\n    3: [2, 7],\n    5: [14, 11, 6, 8, 7],\n    14: [8, 0],\n    11: [8, 13, 2],\n    6: [13],\n    8: [12],\n    10: [2, 7],\n    2: [9],\n    13: [2, 14, 10],\n    1: [9, 3],\n    9: [0, 2],\n    12: [13]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 5\nresult = has_path(graph, 3, 5)\nprint(result)\n```"}, "170": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [6, 7, 1],\n    6: [8, 7],\n    7: [8, 6],\n    1: [8, 9],\n    5: [3, 4, 2, 0],\n    3: [5],\n    4: [5, 0],\n    2: [5],\n    0: [5, 4],\n    9: [1]\n}\n\nstart_node = 6\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "171": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    12: [2, 10],\n    2: [7, 14, 10, 13, 4, 6, 12],\n    10: [2, 8],\n    0: [5, 7, 13, 9, 6],\n    5: [7, 8, 9, 4, 6, 12, 0],\n    7: [10, 4, 12, 5],\n    13: [7],\n    9: [1, 4, 12, 0, 8],\n    6: [0, 11, 2, 7, 8, 13],\n    8: [1, 12, 5],\n    4: [6, 0, 5, 3, 10, 9],\n    3: [11, 8, 12, 0],\n    11: [14, 10, 9, 1, 4, 6],\n    14: [4, 12, 0],\n    1: [6, 5, 2, 8]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 14 to node 4\nresult = has_path(graph, 14, 4)\nprint(result)\n```"}, "172": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [7, 3, 9],\n    7: [6, 4],\n    3: [6, 2],\n    9: [6, 0, 10],\n    4: [7, 5, 1],\n    2: [3],\n    8: [5],\n    5: [8, 4],\n    1: [0, 4],\n    0: [1, 9],\n    10: [9]\n}\n\nstart_node = 5\ngoal_node = 7\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "173": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [14, 1],\n    14: [9, 5],\n    13: [11, 6, 10],\n    11: [5, 4, 3],\n    6: [13, 0],\n    10: [2, 6],\n    12: [3, 11],\n    3: [6, 13],\n    2: [7],\n    7: [0, 4],\n    0: [7],\n    9: [11],\n    5: [14, 0],\n    8: [9]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 13\nprint(has_path(graph, 1, 13))\n```"}, "174": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    13: [6, 3, 4, 8],\n    6: [13, 0, 9],\n    3: [13, 7],\n    4: [13, 5, 2, 12],\n    8: [13, 7, 0, 11],\n    0: [6, 7, 8, 1, 11, 10],\n    9: [6, 5, 2, 1],\n    7: [8, 3, 14, 0, 10],\n    14: [7, 5, 10],\n    10: [7, 0, 14, 12],\n    11: [8, 0, 5],\n    1: [0, 9, 2, 12],\n    5: [9, 11, 2, 14, 12, 4],\n    2: [9, 5, 1, 4],\n    12: [5, 1, 4, 10]\n}\n\nstart_node = 7\ngoal_node = 1\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "175": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    7: [3, 8],\n    3: [8, 4, 2],\n    8: [6],\n    4: [2],\n    6: [2, 7],\n    5: [6, 1],\n    0: [7, 8]\n})\n\nstart_node = 1\nend_node = 7\n\nprint(has_path(graph, start_node, end_node))\n```"}, "176": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [7, 6, 2, 12, 1],\n    7: [5],\n    6: [5],\n    2: [5],\n    12: [5],\n    1: [5, 10, 4, 9],\n    10: [1],\n    4: [1, 8],\n    9: [1, 11, 0],\n    11: [9],\n    0: [9],\n    8: [4, 3],\n    3: [8]\n}\n\nstart_node = 1\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "177": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [8, 1],\n    8: [1],\n    1: [3, 0],\n    9: [11, 10, 5, 1],\n    10: [13],\n    5: [1, 8],\n    13: [0],\n    0: [13, 11],\n    12: [6],\n    6: [7, 12, 10, 3],\n    3: [11],\n    4: [9]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 6\nprint(has_path(graph, 3, 6))\n```"}, "178": {"gpt4": "```python\ndef is_path_between(graph, start, end):\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    \n    return False\n\ngraph = {\n    3: [0, 5, 7, 4, 6, 2, 1],\n    0: [3],\n    5: [3],\n    7: [3],\n    4: [3],\n    6: [3],\n    2: [3],\n    1: [3]\n}\n\nprint(is_path_between(graph, 3, 6))\n```"}, "179": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [5, 1, 7, 3, 0],\n    5: [7, 9],\n    1: [8],\n    7: [2],\n    3: [10, 9],\n    0: [8, 5, 1],\n    9: [4, 0],\n    8: [0],\n    10: [1],\n    6: [2, 3]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 6\nprint(has_path(graph, 4, 6))\n```"}, "180": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [2, 3, 9],\n    2: [6, 7, 5, 1],\n    3: [6, 7, 5, 4, 0, 9],\n    9: [6, 5, 4, 3],\n    8: [7],\n    7: [8, 2, 5, 3],\n    5: [7, 2, 1, 3, 9],\n    1: [2, 5, 0],\n    0: [1, 4, 3],\n    4: [3, 0, 9]\n}\n\nstart_node = 0\ngoal_node = 1\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "181": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    1: [5, 7],\n    5: [8, 0, 7],\n    3: [0, 1],\n    0: [2, 1, 5, 8],\n    8: [2, 7],\n    4: [2, 5],\n    6: [7, 4, 2]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 7\nprint(has_path(graph, 2, 7))\n```"}, "182": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [2, 8],\n    2: [5],\n    8: [5, 7],\n    7: [8, 3, 0, 4],\n    3: [1, 7],\n    1: [3, 6],\n    6: [1],\n    0: [7],\n    4: [7]\n}\n\nstart_node = 2\ngoal_node = 4\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "183": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [1, 6],\n    1: [3, 6],\n    6: [3, 1],\n    7: [4, 5],\n    4: [7, 0],\n    5: [7, 2],\n    0: [4, 8],\n    8: [0, 2],\n    2: [8, 5]\n}\n\nstart_node = 0\ngoal_node = 3\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "184": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = {\n    7: [5, 3, 12, 11, 10],\n    5: [12, 4],\n    3: [11, 10, 7, 4, 2],\n    12: [11, 4, 1, 3],\n    11: [10, 4, 8, 3, 0],\n    10: [9, 8, 12],\n    13: [4, 5, 6, 3, 12, 11],\n    4: [2],\n    6: [3, 12, 0, 10, 7, 13, 2],\n    2: [6, 10],\n    1: [2, 5, 8, 12, 0, 13],\n    8: [6, 11, 9, 7, 13, 2, 5],\n    0: [5, 3, 12],\n    9: [11]\n}\n\nstart_node = 2\nend_node = 13\n\nprint(has_path(graph, start_node, end_node))\n```"}, "185": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = {\n    4: [3, 1, 7, 8],\n    3: [6, 0],\n    1: [8, 3, 9, 5],\n    7: [9, 0],\n    8: [9, 1],\n    6: [2, 5],\n    0: [8, 3, 9, 5, 6],\n    9: [5, 0, 3],\n    5: [7, 8, 3, 9],\n    2: [5, 7]\n}\n\nprint(has_path(graph, 8, 4))\n```"}, "186": {"gpt4": "```python\ndef dfs(graph, start, goal, visited):\n    if start == goal:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [5, 8, 9, 2],\n    5: [0, 6, 11, 2],\n    8: [0, 10, 7, 1],\n    9: [0, 11, 3],\n    2: [0, 5, 6, 10, 11],\n    6: [5, 7, 1, 4, 2],\n    11: [5, 2, 3, 9],\n    7: [6, 10, 4, 8],\n    1: [6, 3, 8, 4],\n    4: [6, 7, 3, 1],\n    10: [2, 8, 7],\n    3: [11, 9, 1, 4]\n}\n\nstart_node = 7\ngoal_node = 2\nvisited = set()\n\nresult = dfs(graph, start_node, goal_node, visited)\nprint(result)\n```"}, "187": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [11, 2, 9],\n    11: [7],\n    2: [13, 6, 0],\n    9: [11],\n    3: [13, 8],\n    13: [14, 6],\n    8: [1, 3, 6, 12],\n    14: [12],\n    6: [5],\n    12: [6],\n    5: [0],\n    0: [14, 11],\n    7: [12, 11],\n    4: [1, 13, 7],\n    1: [13, 12, 2, 9]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 8\nprint(has_path(graph, 2, 8))\n```"}, "188": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [6, 7, 9, 3, 2],\n    6: [5, 7, 9, 3, 0, 8, 4],\n    7: [5, 6, 3, 0, 8, 1, 4],\n    9: [5, 6, 3, 0, 1, 4, 2],\n    3: [5, 6, 7, 9, 0, 8, 2],\n    2: [5, 9, 3, 0, 8, 1],\n    0: [6, 7, 9, 3, 1, 4, 2],\n    8: [6, 7, 3, 1, 4, 2],\n    4: [6, 7, 9, 0, 8, 1],\n    1: [7, 9, 0, 8, 4, 2]\n}\n\nstart_node = 7\nend_node = 0\n\nprint(dfs(graph, start_node, end_node))\n```"}, "189": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [2],\n    2: [12, 6, 0],\n    3: [8, 1, 0],\n    8: [5, 11, 0],\n    1: [9],\n    0: [8, 6],\n    12: [5, 2],\n    5: [6],\n    11: [0, 7, 6],\n    9: [12, 1],\n    4: [1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 2 to node 1\nprint(has_path(graph, 2, 1))\n```"}, "190": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    11: [7, 10, 8],\n    7: [11, 9, 10, 5, 2],\n    10: [11, 0, 9, 1, 7, 6],\n    8: [11, 9, 1, 5],\n    0: [1, 10, 6, 5],\n    1: [0, 3, 10, 5, 4, 8],\n    6: [0, 9, 3, 10, 5, 4, 2],\n    5: [0, 1, 7, 6, 2, 8],\n    9: [7, 3, 10, 6, 2, 8],\n    3: [9, 1, 6, 4, 2],\n    2: [9, 7, 3, 6, 5],\n    4: [1, 3, 6]\n}\n\nstart_node = 8\nend_node = 10\n\npath_exists = dfs(graph, start_node, end_node)\nprint(path_exists)\n```"}, "191": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [7, 1, 6, 3, 12, 4],\n    7: [13, 9],\n    1: [10, 5],\n    3: [4, 0, 1],\n    12: [11, 8, 5],\n    4: [10, 11, 6],\n    10: [5, 4],\n    5: [6, 4],\n    13: [3, 11],\n    9: [0],\n    11: [5, 6, 4],\n    8: [13, 2, 10, 11],\n    0: [6],\n    14: [8, 13, 6, 3, 12, 0]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 11 to node 3\nresult = has_path(graph, 11, 3)\nprint(result)\n```"}, "192": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [2, 11, 5, 3, 9],\n    2: [7, 10, 6, 12, 9, 8],\n    11: [7, 5, 9],\n    5: [7, 1, 6, 3, 11, 10, 4, 12, 8, 9],\n    3: [7, 5, 1, 9],\n    9: [7, 2, 5, 14, 3, 13, 8, 4, 11, 0],\n    10: [2, 5, 12, 0],\n    6: [2, 5, 13],\n    12: [2, 5, 10, 8, 4],\n    8: [2, 5, 9, 13, 12, 0],\n    1: [5, 3, 0],\n    4: [5, 9, 12],\n    0: [1, 9, 10, 8],\n    14: [9, 13],\n    13: [9, 14, 6, 8]\n}\n\nstart_node = 3\nend_node = 8\n\nprint(dfs(graph, start_node, end_node))\n```"}, "193": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    6: [3, 2, 5, 4, 0],\n    3: [5, 1, 7, 0],\n    2: [7],\n    5: [8],\n    4: [2, 5, 7],\n    0: [2, 4],\n    1: [7, 4, 0],\n    7: [4, 0, 8, 1],\n    8: [4, 0, 5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 5 to node 6\nprint(has_path(graph, 5, 6))\n```"}, "194": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [2, 4, 3, 0, 5, 7],\n    2: [1, 4, 3, 8, 6, 5, 7],\n    4: [1, 2, 8, 0, 6, 5, 7],\n    3: [1, 2, 8, 0, 5, 7],\n    0: [1, 4, 3, 6, 5, 7],\n    5: [1, 2, 4, 3, 8, 0, 6, 7],\n    7: [1, 2, 4, 3, 8, 0, 6, 5],\n    8: [2, 4, 3, 5, 7],\n    6: [2, 4, 0, 5, 7]\n}\n\nstart_node = 4\ngoal_node = 3\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "195": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [4, 8],\n    4: [3],\n    8: [3, 4],\n    3: [0, 5],\n    0: [1, 3],\n    5: [6],\n    7: [6, 4, 5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 5\nprint(has_path(graph, 6, 5))\n```"}, "196": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [11, 7],\n    11: [4, 10, 3, 5, 9],\n    7: [4, 3, 5, 8],\n    2: [10, 3, 5, 0, 1, 9],\n    10: [2, 3, 8, 11, 9],\n    3: [2, 6, 10, 11, 7, 1],\n    5: [2, 8, 11, 7, 1],\n    0: [2, 6, 8],\n    1: [2, 6, 3, 5, 9],\n    9: [2, 6, 10, 11, 1],\n    6: [3, 0, 1, 9],\n    8: [10, 5, 0, 7]\n}\n\nstart_node = 10\nend_node = 7\n\nprint(dfs(graph, start_node, end_node))\n```"}, "197": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [7, 11, 0, 1, 10],\n    7: [11, 2, 6, 10, 4],\n    11: [2, 10, 9, 4, 7],\n    0: [6, 10, 9, 2],\n    1: [10, 4, 5, 2],\n    10: [9],\n    5: [3, 0, 4],\n    3: [0, 4],\n    8: [11, 2, 5],\n    2: [10, 9, 4],\n    6: [10, 9, 4, 5, 7],\n    9: [7, 1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 11 to node 8\nprint(has_path(graph, 11, 8))\n```"}, "198": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [8],\n    8: [10, 9, 0, 4],\n    9: [8],\n    7: [10],\n    10: [3, 4, 8],\n    1: [5, 2],\n    5: [10],\n    3: [9],\n    0: [6, 8, 9],\n    6: [5, 10, 9, 7, 0],\n    4: [8, 9, 1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 0\nresult = has_path(graph, 3, 0)\nprint(result)\n```"}, "199": {"gpt4": "```python\nfrom collections import deque\n\n# Graph representation\ngraph = {\n    11: [0],\n    0: [11, 8],\n    8: [0, 1],\n    6: [1],\n    1: [6, 10, 7, 8],\n    10: [1, 4],\n    7: [1, 4],\n    5: [3, 2],\n    3: [5, 2],\n    2: [5, 3, 9],\n    9: [2],\n    4: [10, 7]\n}\n\ndef bfs(start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n    \n    return False\n\n# Check if there is a path between node 2 and node 6\nprint(bfs(2, 6))\n```"}, "200": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [7, 1, 0],\n    7: [8, 6],\n    1: [8, 0, 3, 5],\n    0: [8, 1],\n    6: [7],\n    3: [1, 4],\n    5: [1],\n    9: [4, 2],\n    4: [9, 3, 10],\n    2: [9],\n    10: [4]\n}\n\nstart_node = 0\ngoal_node = 9\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "201": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [5, 6],\n    5: [3, 2, 8],\n    6: [4, 5],\n    3: [7],\n    2: [4],\n    8: [6, 0],\n    7: [2, 6, 5],\n    1: [7, 0, 4, 5, 3],\n    0: [8, 4, 5, 7, 6]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 0 to node 1\nprint(has_path(graph, 0, 1))\n```"}, "202": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [3, 4, 7, 2, 0],\n    3: [5],\n    4: [5],\n    7: [5],\n    2: [5, 1],\n    0: [5],\n    1: [6, 2],\n    6: [1]\n}\n\nstart_node = 2\ngoal_node = 7\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "203": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef can_reach(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    7: [0, 6, 5, 2],\n    0: [3, 5, 2, 7],\n    6: [5, 3],\n    5: [2],\n    2: [7, 1, 6, 5],\n    3: [1, 7],\n    4: [3, 2, 0],\n    1: [5, 2]\n})\n\nstart_node = 1\nend_node = 4\n\nprint(can_reach(graph, start_node, end_node))\n```"}, "204": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [2, 9],\n    2: [5, 7],\n    9: [5, 8],\n    7: [2, 3],\n    3: [7, 4],\n    4: [3, 6],\n    0: [6, 1],\n    6: [0, 4],\n    1: [0, 10],\n    8: [9, 10],\n    10: [1, 8]\n}\n\nstart_node = 2\ngoal_node = 5\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "205": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [8, 0],\n    8: [1, 6],\n    0: [1, 3, 6],\n    6: [8, 0],\n    3: [0],\n    5: [4, 2, 7],\n    4: [5, 7],\n    2: [5],\n    7: [5, 4]\n}\n\nstart_node = 7\ngoal_node = 8\n\nresult = dfs(graph, start_node, goal_node)\nprint(result)\n```"}, "206": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [4, 8, 1],\n    4: [0, 7, 13, 11, 2, 9, 10],\n    8: [0, 7, 10, 1],\n    1: [0, 8, 2, 3, 9, 10],\n    7: [13, 4, 8, 2, 3, 6, 9, 10],\n    13: [7, 4, 11, 6, 5],\n    2: [7, 4, 11, 6, 5, 1],\n    3: [7, 12, 1],\n    6: [7, 13, 11, 2, 9, 5, 10],\n    9: [7, 12, 4, 6, 10, 1],\n    10: [7, 4, 8, 6, 9, 1],\n    11: [13, 4, 2, 6, 5],\n    5: [13, 11, 2, 6],\n    12: [3, 9]\n}\n\nstart_node = 2\ngoal_node = 7\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "207": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    9: [8, 0],\n    8: [5],\n    0: [8],\n    7: [2, 4, 5, 6, 9, 8],\n    2: [4, 1, 6, 3],\n    4: [3, 8],\n    6: [4, 1, 0]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 1\nresult = has_path(graph, 3, 1)\nprint(result)\n```"}, "208": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [5, 1],\n    5: [0, 2],\n    1: [0, 4, 3],\n    2: [5, 3, 6],\n    3: [2, 1],\n    6: [2, 7],\n    4: [1],\n    7: [6]\n}\n\nstart_node = 4\ngoal_node = 0\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "209": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    5: [10],\n    10: [11, 9, 2, 7],\n    2: [8],\n    8: [2],\n    1: [7, 8, 9],\n    7: [12],\n    12: [10, 9],\n    4: [6],\n    6: [11, 5, 2],\n    11: [0, 4],\n    0: [2],\n    3: [6]\n})\n\nprint(has_path(graph, 2, 9))\n```"}, "210": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [3, 6],\n    3: [4, 1],\n    6: [1, 0, 5],\n    7: [5, 4, 1],\n    5: [2, 1, 8, 7],\n    4: [0, 5],\n    1: [7],\n    2: [4, 6, 5],\n    0: [6]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 0\nprint(has_path(graph, 1, 0))\n```"}, "211": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    1: [5, 4, 6],\n    5: [0, 1],\n    6: [11],\n    0: [9],\n    2: [10],\n    10: [1, 9],\n    9: [10, 2],\n    11: [1],\n    7: [10],\n    8: [6, 3, 9]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 3\nprint(has_path(graph, 4, 3))\n```"}, "212": {"gpt4": "```python\nfrom collections import deque\n\n# Graph representation\ngraph = {\n    4: [8, 6, 0],\n    8: [4, 1],\n    6: [4, 2],\n    0: [4],\n    1: [8, 9],\n    9: [1, 7],\n    7: [9, 3],\n    3: [7, 5],\n    2: [6, 5],\n    5: [3, 2]\n}\n\ndef bfs(start, end, graph):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n    \n    return False\n\n# Check if there is a path between node 5 and node 0\nprint(bfs(5, 0, graph))\n```"}, "213": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [1],\n    1: [0],\n    5: [12],\n    12: [1, 8, 3, 0, 9, 2],\n    0: [6],\n    6: [10, 12, 11, 7, 1],\n    10: [2, 6],\n    9: [5],\n    8: [2],\n    11: [2],\n    7: [3, 10, 9],\n    4: [10, 12, 7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 5 to node 4\nprint(has_path(graph, 5, 4))\n```"}, "214": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [2, 8, 5, 4, 6, 1],\n    2: [0, 6, 8, 3],\n    8: [0, 2, 5, 7, 3],\n    5: [0, 8, 7],\n    4: [0],\n    6: [0, 2, 1],\n    1: [0, 6],\n    3: [2, 8],\n    7: [8, 5]\n}\n\nstart_node = 6\ngoal_node = 7\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "215": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [2, 1],\n    2: [1, 0, 7, 4, 5, 6],\n    1: [0, 7],\n    4: [8],\n    8: [1, 6],\n    5: [6, 8, 3],\n    6: [1, 5],\n    7: [4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 0 to node 7\nprint(has_path(graph, 0, 7))\n```"}, "216": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    9: [2, 6, 10, 3, 4],\n    2: [9, 3, 10],\n    6: [9, 10, 8],\n    10: [9, 2, 3, 0, 8, 6],\n    3: [9, 2, 0, 1, 5, 8, 7, 10],\n    4: [9, 0, 8],\n    0: [3, 10, 4, 8],\n    1: [3, 7],\n    5: [3, 7, 8],\n    8: [3, 0, 10, 7, 4, 6, 5],\n    7: [3, 1, 8, 5]\n}\n\nstart_node = 6\ngoal_node = 5\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "217": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [1, 7],\n    1: [0, 7, 2],\n    7: [0, 1],\n    2: [1],\n    8: [5, 4, 3],\n    5: [8, 3],\n    4: [8],\n    3: [8, 5, 6],\n    6: [3]\n}\n\nstart_node = 0\ngoal_node = 8\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "218": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [4, 1, 3, 6, 2, 7],\n    4: [8, 1],\n    1: [8, 4, 7, 2, 5],\n    3: [8, 0],\n    6: [8, 0],\n    2: [8, 1, 5],\n    7: [8, 1, 0],\n    0: [7, 6, 3],\n    5: [1, 2]\n}\n\nstart_node = 0\ngoal_node = 7\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "219": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [6, 5, 1],\n    6: [3, 10],\n    5: [3],\n    1: [3, 10],\n    10: [6, 1],\n    7: [2, 12],\n    2: [7, 11],\n    12: [7, 0],\n    11: [2, 4, 9],\n    8: [0],\n    0: [8, 12],\n    4: [9, 11],\n    9: [4, 11]\n}\n\nstart_node = 4\ngoal_node = 10\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "220": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [4, 8, 9],\n    4: [0],\n    8: [9],\n    9: [12],\n    11: [7],\n    7: [11, 2, 8],\n    0: [2, 4, 8, 10],\n    2: [4, 3, 1, 12],\n    3: [1, 5, 11, 0],\n    12: [3],\n    5: [9, 7, 1, 8],\n    6: [2, 1, 5],\n    13: [3, 9]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 12 to node 9\nresult = has_path(graph, 12, 9)\nprint(result)\n```"}, "221": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef can_reach(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    2: [5],\n    5: [2],\n    8: [4, 3],\n    4: [2, 8, 7],\n    3: [7, 5],\n    7: [6, 2],\n    0: [5, 6],\n    1: [6]\n})\n\nstart_node = 1\nend_node = 2\n\nprint(can_reach(graph, start_node, end_node))\n```"}, "222": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    7: [0, 3, 1],\n    0: [8, 4, 2, 1],\n    3: [1, 7, 0],\n    1: [7, 8, 2],\n    8: [4, 2, 3],\n    4: [6, 2, 3, 8],\n    2: [5, 8, 4],\n    6: [5, 1, 8],\n    5: [3, 8]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 8 to node 6\nresult = has_path(graph, 8, 6)\nprint(result)\n```"}, "223": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [5, 2],\n    5: [8, 0],\n    2: [9, 12, 7, 3],\n    4: [10],\n    10: [4, 2],\n    9: [1, 11, 0],\n    12: [7, 11],\n    7: [11, 8],\n    1: [10],\n    11: [9],\n    6: [1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 0 to node 3\nprint(has_path(graph, 0, 3))\n```"}, "224": {"gpt4": "```python\nfrom collections import deque\n\ndef bfs(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node] - visited)\n    return False\n\ngraph = {\n    8: {7, 3, 2, 0, 6},\n    7: {8, 0},\n    3: {8, 4, 2, 9, 0},\n    2: {8, 3},\n    0: {8, 7, 3, 9, 5},\n    6: {8},\n    4: {3, 9},\n    9: {3, 4, 5, 0, 1},\n    5: {9, 1, 0},\n    1: {9, 5}\n}\n\nstart_node = 3\nend_node = 5\n\nprint(bfs(graph, start_node, end_node))\n```"}, "225": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    7: [1, 6, 2],\n    6: [3, 0],\n    2: [7, 5],\n    0: [1, 4, 7],\n    5: [6],\n    3: [0, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 7\nresult = has_path(graph, 4, 7)\nprint(result)\n```"}, "226": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    10: [3, 6, 11, 5, 0],\n    3: [10, 1, 4, 0, 8],\n    6: [10, 4, 0, 8],\n    11: [10, 1, 4, 0, 7],\n    5: [10, 1, 2],\n    0: [10, 3, 6, 11, 12],\n    1: [3, 11, 5, 8],\n    4: [3, 6, 11, 12, 7],\n    8: [3, 1, 6, 9],\n    12: [4, 0, 2, 7],\n    7: [4, 11, 12, 13],\n    2: [12, 5],\n    13: [7],\n    9: [8]\n}\n\nstart_node = 6\ngoal_node = 7\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "227": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    8: [6, 1],\n    6: [3, 5],\n    1: [7],\n    2: [1, 7, 0, 8],\n    7: [5],\n    3: [5, 4, 6],\n    5: [1],\n    4: [0, 8, 6, 5]\n})\n\nstart_node = 6\nend_node = 2\n\nprint(has_path(graph, start_node, end_node))\n```"}, "228": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [12, 6, 7, 11, 2, 9, 8, 10, 1, 0],\n    12: [4, 5, 2, 9, 3],\n    6: [4, 7, 11, 5, 2, 8, 10, 0],\n    7: [4, 6, 11, 5, 8, 10, 13, 0],\n    11: [4, 6, 7, 5, 2, 9, 8, 1, 13],\n    2: [4, 12, 6, 11, 9, 8, 3, 10, 13, 0],\n    9: [4, 12, 11, 5, 2, 8, 10, 1, 13, 0],\n    8: [4, 6, 7, 11, 5, 2, 9, 3, 10, 1, 13, 0],\n    10: [4, 6, 7, 2, 9, 8, 13, 0],\n    1: [4, 11, 9, 8, 13],\n    0: [4, 6, 7, 5, 2, 9, 8, 3, 10, 13],\n    5: [12, 6, 7, 11, 9, 8, 3, 0],\n    3: [12, 5, 2, 8, 13, 0],\n    13: [7, 11, 2, 9, 8, 3, 10, 1, 0]\n}\n\nprint(dfs(graph, 4, 5))\n```"}, "229": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    1: [3, 2, 9],\n    3: [7, 8, 2, 10, 9],\n    2: [1, 3],\n    9: [4, 1, 0],\n    11: [12],\n    12: [2, 10, 9],\n    6: [5, 2, 11],\n    5: [1, 7, 0],\n    7: [8, 2, 10, 12, 1],\n    8: [10, 11, 3, 7, 0],\n    10: [9, 12, 11, 7, 8, 5],\n    0: [9, 3, 7],\n    4: [1, 3, 7]\n})\n\nprint(has_path(graph, 2, 6))\n```"}, "230": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [5, 10, 2, 3, 0, 4],\n    5: [6, 8, 7, 4],\n    10: [6, 1],\n    2: [6, 1],\n    3: [6, 1],\n    0: [6, 1, 9, 11],\n    4: [6, 5, 1],\n    8: [5, 1],\n    7: [5, 1],\n    1: [3, 8, 4, 7, 2, 0, 10, 9],\n    9: [1, 0, 11],\n    11: [0, 9]\n}\n\nstart_node = 2\ngoal_node = 10\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "231": {"gpt4": "```python\ndef dfs(graph, start, target, visited):\n    if start == target:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, target, visited):\n                return True\n    return False\n\ngraph = {\n    4: [1, 3, 10],\n    1: [3, 10, 9, 4, 7],\n    3: [10, 7, 1],\n    10: [6],\n    0: [7, 1, 2],\n    7: [3, 6, 2, 10, 9, 4, 0],\n    2: [0, 5],\n    6: [2, 10, 5, 3],\n    9: [0, 5, 6, 10],\n    5: [2, 7],\n    8: [1, 2, 4, 0, 7, 5]\n}\n\nstart_node = 0\ntarget_node = 8\nvisited = set()\n\nresult = dfs(graph, start_node, target_node, visited)\nprint(result)\n```"}, "232": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    9: [4],\n    4: [9, 0],\n    0: [4, 2],\n    6: [7, 8, 1],\n    7: [6, 10, 2, 5],\n    8: [6],\n    1: [6, 2],\n    10: [7],\n    2: [7, 1, 3, 0],\n    5: [7],\n    3: [2]\n}\n\nstart_node = 2\nend_node = 3\n\nprint(dfs(graph, start_node, end_node))\n```"}, "233": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    4: [0],\n    0: [1, 8],\n    1: [8, 2, 4],\n    8: [5, 4],\n    2: [3, 7, 1],\n    6: [7, 1],\n    7: [0],\n    3: [2]\n})\n\nprint(has_path(graph, 5, 8))\n```"}, "234": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [6, 4],\n    6: [8, 10],\n    4: [8, 3],\n    10: [6, 1, 5, 7],\n    11: [1],\n    1: [11, 10],\n    0: [12, 5],\n    12: [0, 2],\n    5: [0, 10],\n    2: [12, 13],\n    13: [2, 3],\n    3: [13, 4],\n    7: [10, 9],\n    9: [7]\n}\n\nstart_node = 8\ngoal_node = 11\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "235": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [2],\n    2: [0, 6],\n    7: [5, 0],\n    4: [1],\n    1: [5],\n    6: [0, 3, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 7\nresult = has_path(graph, 1, 7)\nprint(result)\n```"}, "236": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [13, 9],\n    13: [11, 7, 0, 10],\n    9: [6, 5, 8, 13],\n    11: [3, 1, 14, 5, 9],\n    7: [0, 9],\n    0: [10, 6, 1, 11],\n    10: [3, 4, 7, 0],\n    12: [10],\n    6: [4, 2, 0],\n    5: [8, 1],\n    2: [7, 10],\n    3: [5, 9, 10],\n    1: [13, 10, 3],\n    14: [2, 6],\n    4: [6, 3, 14]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 9 to node 6\nprint(has_path(graph, 9, 6))\n```"}, "237": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [8, 6, 7],\n    8: [2],\n    6: [1, 2],\n    7: [3, 8],\n    0: [2],\n    2: [6],\n    9: [7, 0, 6],\n    5: [3, 8],\n    3: [5, 1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 5 to node 9\nprint(has_path(graph, 5, 9))\n```"}, "238": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [11, 8, 1, 7, 12, 3],\n    11: [6, 1, 9],\n    8: [6, 9, 4, 0, 2],\n    1: [6, 11, 10, 12, 4, 3],\n    7: [6, 2, 4],\n    12: [6, 10, 1],\n    3: [6, 5, 1],\n    9: [11, 8, 10],\n    4: [8, 5, 1, 7],\n    0: [8, 10, 2, 5],\n    2: [8, 10, 0, 7],\n    10: [9, 2, 0, 1, 12],\n    5: [0, 4, 3]\n}\n\nstart_node = 1\nend_node = 9\n\nprint(dfs(graph, start_node, end_node))\n```"}, "239": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    0: [2],\n    2: [5, 12],\n    1: [11],\n    9: [7, 6, 1],\n    7: [0, 2, 11],\n    6: [0, 8, 7],\n    5: [7],\n    12: [2],\n    8: [1],\n    10: [3, 5],\n    3: [0],\n    4: [0, 9, 7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 6\nprint(has_path(graph, 1, 6))\n```"}, "240": {"gpt4": "```python\nfrom collections import deque\n\ndef bfs(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = {\n    5: [7, 1, 12, 4, 13, 0],\n    7: [11, 1, 9, 4, 2, 6, 13, 3],\n    1: [4, 2, 6, 0, 5, 11],\n    12: [8, 4, 2, 6, 3, 5, 10, 1, 9],\n    4: [6, 3, 5],\n    13: [0, 3, 5, 10, 7, 6],\n    0: [3, 10, 7, 11, 8, 6],\n    10: [1, 9, 8, 6, 13, 3, 5],\n    9: [5, 7],\n    8: [6, 0, 7, 11],\n    6: [3, 7],\n    3: [5, 9, 12, 6, 13],\n    11: [9, 0, 10, 7],\n    2: [6, 13, 0, 3, 5, 10, 1, 4]\n}\n\nstart_node = 13\nend_node = 5\n\nprint(bfs(graph, start_node, end_node))\n```"}, "241": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    12: [11, 2, 10, 0],\n    11: [13, 4, 7, 0, 6],\n    2: [4, 7, 10, 0, 12],\n    10: [2, 4, 7],\n    0: [6, 13, 10],\n    9: [5],\n    5: [7, 3, 11],\n    8: [5, 10, 0, 9],\n    1: [11, 3, 0, 9],\n    3: [9, 2],\n    6: [4, 0],\n    4: [12, 6, 5],\n    13: [5, 2],\n    7: [13]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 0 to node 8\nprint(has_path(graph, 0, 8))\n```"}, "242": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [3, 4, 8, 5, 7],\n    3: [6, 4, 5],\n    4: [6, 3, 0, 8, 1, 5],\n    8: [6, 0, 4, 2],\n    5: [6, 3, 0, 4, 2, 7],\n    7: [6, 5],\n    0: [4, 2, 8, 5],\n    2: [0, 8, 1, 5],\n    1: [4, 2]\n}\n\nstart_node = 5\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "243": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    10: [13, 6, 0],\n    13: [10, 4],\n    6: [10, 3, 14],\n    0: [10, 5, 12],\n    4: [13, 9],\n    1: [5, 3],\n    5: [1, 0],\n    3: [1, 6],\n    2: [7, 11],\n    7: [2, 11, 8],\n    11: [2, 7],\n    8: [7],\n    12: [0],\n    14: [6],\n    9: [4]\n}\n\nstart_node = 8\ngoal_node = 4\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "244": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    2: [4, 7, 6, 1],\n    4: [7, 5, 2],\n    7: [3, 4],\n    6: [1, 3, 5],\n    1: [4, 7, 6],\n    3: [4, 7, 5, 1, 2],\n    5: [6, 1, 3, 4, 7],\n    0: [2, 3, 4]\n})\n\nprint(has_path(graph, 0, 6))\n```"}, "245": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [12, 9, 5],\n    12: [4, 10],\n    9: [4, 10],\n    5: [4],\n    10: [12, 9, 6],\n    2: [0, 11, 3],\n    0: [2, 11],\n    11: [2, 0, 1],\n    3: [2, 8],\n    7: [1],\n    1: [7, 11],\n    8: [3],\n    6: [10]\n}\n\nstart_node = 7\ngoal_node = 4\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "246": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    4: [11, 2, 7, 0, 5, 8],\n    11: [4, 7, 10, 9, 2],\n    2: [4, 11, 3, 5, 6, 9, 10],\n    7: [4, 11, 5, 6],\n    0: [4, 1, 5, 9, 10],\n    5: [4, 3, 2, 0, 8, 7, 10],\n    8: [4, 5, 10],\n    10: [11, 5, 2, 0, 6, 8],\n    9: [11, 2, 0],\n    1: [3, 0],\n    3: [1, 2, 5],\n    6: [2, 7, 10]\n}\n\nstart_node = 1\ngoal_node = 5\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "247": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [4, 2],\n    4: [3, 0],\n    2: [5],\n    6: [8, 3],\n    0: [9, 2, 8],\n    9: [10],\n    10: [3, 6],\n    7: [3, 1, 2]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 1\nprint(has_path(graph, 3, 1))\n```"}, "248": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [1, 4, 9, 2, 5, 3, 6],\n    1: [7, 0, 8, 5],\n    4: [7, 9, 5, 3],\n    9: [7, 4, 5],\n    2: [7, 0, 5, 3],\n    5: [7, 1, 4, 9, 3, 2],\n    3: [7, 4, 8, 0, 5, 2],\n    6: [7, 8],\n    0: [1, 2, 3],\n    8: [1, 6, 3]\n}\n\nstart_node = 9\ngoal_node = 2\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "249": {"gpt4": "```python\ndef dfs(graph, start, target, visited):\n    if start == target:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, target, visited):\n                return True\n    return False\n\ngraph = {\n    5: [9, 4, 8, 3],\n    9: [3, 2],\n    4: [5],\n    3: [5, 4, 7],\n    1: [9, 4, 8],\n    2: [9, 7],\n    0: [3, 9],\n    6: [7, 8, 3, 0],\n    7: [5],\n    8: []\n}\n\nstart_node = 8\ntarget_node = 2\nvisited = set()\n\nresult = dfs(graph, start_node, target_node, visited)\nprint(result)\n```"}, "250": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [4, 5],\n    4: [1, 7, 5],\n    5: [1, 4],\n    7: [4],\n    6: [9, 3],\n    9: [6, 8],\n    3: [6, 0, 10, 2],\n    8: [9, 2],\n    2: [8, 3],\n    0: [3],\n    10: [3]\n}\n\nstart_node = 2\ngoal_node = 1\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "251": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    7: [5, 6, 4, 1, 2, 8, 0],\n    5: [7, 2, 3],\n    6: [7, 2, 8, 0, 3],\n    4: [7, 1, 2, 0],\n    1: [7, 4, 2, 0, 3],\n    2: [7, 5, 6, 4, 1, 0, 3],\n    8: [7, 6, 3],\n    0: [7, 6, 4, 1, 2],\n    3: [5, 6, 1, 2, 8]\n}\n\nstart_node = 3\ngoal_node = 2\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "252": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [6, 4, 2, 8, 0],\n    6: [5, 1],\n    4: [5],\n    2: [5],\n    8: [5, 7, 3],\n    0: [5],\n    1: [6],\n    7: [8],\n    3: [8]\n}\n\nstart_node = 6\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "253": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [3, 9],\n    3: [2, 9],\n    9: [2, 3, 0],\n    0: [9, 7],\n    1: [5],\n    5: [1, 6],\n    6: [5, 8, 4],\n    8: [6, 4],\n    4: [8, 6],\n    7: [0]\n}\n\nstart_node = 6\ngoal_node = 3\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "254": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [3, 11, 4, 6],\n    3: [12, 5],\n    11: [4, 6, 12, 8, 2],\n    4: [10, 9, 8, 2],\n    6: [9, 12, 3, 2],\n    8: [2, 11, 7, 4],\n    2: [7, 9, 5, 0],\n    7: [4, 6, 1, 3, 11],\n    1: [0, 11, 4, 8],\n    0: [11, 7, 4, 6, 8, 1],\n    5: [0, 3, 10, 6, 8, 1],\n    10: [12, 8, 1, 5, 0, 3, 2, 4],\n    9: [12, 8, 1, 5, 2, 11, 7]\n}\n\ndef bfs(start, goal):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == goal:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 4\nprint(bfs(6, 4))\n```"}, "255": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    3: [4, 12, 0, 8, 2],\n    4: [8, 2, 6],\n    12: [8, 2, 11, 6],\n    0: [11, 4],\n    8: [10, 6],\n    2: [9, 6, 12, 0],\n    5: [10, 7],\n    10: [1, 7, 3, 5, 9],\n    9: [10, 4, 8],\n    11: [6, 1],\n    6: [7, 5, 10],\n    1: [7, 3, 9, 10, 6, 12]\n})\n\n# Function to check if there is a path from start to end\ndef is_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 7 to node 10\nprint(is_path(graph, 7, 10))\n```"}, "256": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [4, 8, 2, 10],\n    4: [6, 5, 12, 3],\n    8: [6],\n    2: [6, 7],\n    10: [6, 0, 9],\n    5: [4, 1],\n    12: [4],\n    3: [4],\n    0: [10, 11],\n    9: [10],\n    11: [0],\n    1: [5],\n    7: [2]\n}\n\nstart_node = 6\ngoal_node = 2\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "257": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [3, 2, 10],\n    3: [1, 11],\n    2: [1, 12],\n    10: [1, 11],\n    11: [3, 10],\n    6: [4],\n    4: [6, 7],\n    7: [4, 5],\n    5: [7, 8],\n    8: [5, 9, 0],\n    9: [8, 0],\n    0: [8, 9],\n    12: [2]\n}\n\nstart_node = 1\ngoal_node = 4\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "258": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [5, 10, 11, 13, 12, 8, 7],\n    5: [2, 3, 0, 10, 6, 9, 12],\n    10: [2, 3, 0, 4, 5, 11, 1, 13, 8, 7],\n    11: [2, 0, 4, 10, 6, 9, 13, 7],\n    13: [2, 3, 0, 4, 10, 6, 11, 1, 12, 8, 7],\n    12: [2, 3, 4, 5, 6, 1, 9, 13, 8, 7],\n    8: [2, 3, 0, 10, 6, 9, 13, 12, 7],\n    7: [2, 3, 0, 4, 10, 6, 11, 9, 13, 12, 8],\n    3: [0, 4, 5, 10, 6, 9, 13, 12, 8, 7],\n    0: [3, 5, 10, 6, 11, 1, 9, 13, 8, 7],\n    4: [3, 10, 6, 11, 1, 9, 13, 12, 7],\n    6: [3, 0, 4, 5, 11, 1, 9, 13, 12, 8, 7],\n    9: [3, 0, 4, 5, 6, 11, 1, 12, 8, 7],\n    1: [0, 4, 10, 6, 9, 13, 12]\n}\n\nstart_node = 5\ngoal_node = 10\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "259": {"gpt4": "```python\ndef dfs(graph, start, target, visited):\n    if start == target:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, target, visited):\n                return True\n    return False\n\ngraph = {\n    0: [10, 5, 9],\n    10: [4, 6, 0, 8],\n    9: [3, 0, 1, 5],\n    8: [5, 0],\n    4: [2, 6, 3, 8, 1],\n    6: [5, 9, 0, 8, 4],\n    1: [7],\n    7: [6, 3, 0, 10],\n    2: [7, 10],\n    3: [1, 7, 6],\n    5: []\n}\n\nstart_node = 5\ntarget_node = 0\nvisited = set()\n\nresult = dfs(graph, start_node, target_node, visited)\nprint(result)\n```"}, "260": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [9, 2, 5, 13, 3, 6],\n    9: [2, 7, 0, 10, 13, 14, 1],\n    2: [7, 12, 0, 5, 6, 4],\n    5: [3, 4, 11, 12],\n    13: [9, 2],\n    3: [4, 7, 13],\n    6: [4, 12, 0, 10, 5, 3, 14],\n    7: [5],\n    0: [6, 9, 2, 7],\n    10: [3, 14, 9],\n    14: [7, 13],\n    1: [4, 11, 3, 14],\n    12: [5, 13, 1, 8, 11],\n    4: [7, 0, 6],\n    11: [10, 3]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 12 to node 2\nprint(has_path(graph, 12, 2))\n```"}, "261": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    6: [4],\n    4: [2],\n    0: [1, 3, 2],\n    3: [1],\n    2: [6, 0],\n    5: [1, 0],\n    7: [6, 5, 1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 3 to node 2\nprint(has_path(graph, 3, 2))\n```"}, "262": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    8: [7, 3, 10],\n    7: [8, 5],\n    3: [8, 0, 2, 1, 9, 5],\n    10: [8, 1],\n    5: [7, 4, 3, 1],\n    4: [0, 5, 6, 1],\n    0: [4, 3],\n    6: [4, 9],\n    1: [4, 3, 2, 10, 5],\n    2: [3, 1, 9],\n    9: [3, 2, 6]\n}\n\nstart_node = 2\nend_node = 3\n\nprint(dfs(graph, start_node, end_node))\n```"}, "263": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [1, 0],\n    0: [6, 7],\n    3: [7, 6, 4],\n    7: [1, 0, 4],\n    6: [4],\n    5: [1, 7],\n    2: [1, 6, 4, 7, 5]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 4\nprint(has_path(graph, 1, 4))\n```"}, "264": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [10, 3],\n    10: [2, 4, 5],\n    3: [2, 7],\n    4: [10, 7],\n    5: [10, 1],\n    7: [4, 6, 3],\n    6: [7, 9],\n    9: [6, 8],\n    0: [8],\n    8: [0, 9],\n    1: [5]\n}\n\nstart_node = 1\ngoal_node = 6\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "265": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [3, 0],\n    3: [1, 0, 7],\n    0: [1, 3, 11],\n    7: [3, 4],\n    8: [6, 10, 2],\n    6: [8, 10],\n    10: [8, 6],\n    2: [8, 9, 5],\n    9: [2],\n    5: [2],\n    4: [7],\n    11: [0]\n}\n\nstart_node = 0\ngoal_node = 10\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "266": {"gpt4": "```python\ndef dfs(graph, start, target, visited):\n    if start == target:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, target, visited):\n                return True\n    return False\n\ngraph = {\n    8: [5, 6, 2, 1],\n    5: [6, 2, 3, 7, 1, 8],\n    6: [2, 0, 4, 5],\n    2: [9, 0, 7, 8, 5],\n    1: [4, 5, 2, 9, 0],\n    4: [5, 0, 3, 1],\n    0: [1, 5, 6, 2],\n    3: [6, 2, 9],\n    7: [6, 3],\n    9: [1, 8]\n}\n\nstart_node = 2\ntarget_node = 5\nvisited = set()\n\nresult = dfs(graph, start_node, target_node, visited)\nprint(result)\n```"}, "267": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    2: [0, 9, 5],\n    0: [9],\n    9: [6],\n    5: [1, 0, 9],\n    4: [10, 5, 3],\n    10: [6, 1],\n    3: [4],\n    8: [10, 1],\n    1: [4, 3],\n    7: [0, 5, 3]\n})\n\nprint(has_path(graph, 0, 8))\n```"}, "268": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    2: [10, 3, 7, 0, 5],\n    10: [4, 7],\n    3: [2, 10],\n    7: [2, 3, 6, 8],\n    0: [1, 2, 9],\n    5: [10],\n    4: [0, 1, 5, 8],\n    9: [4, 10],\n    6: [4, 0, 3],\n    8: [7, 0, 9],\n    1: [10, 8, 0]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 7\nprint(has_path(graph, 6, 7))\n```"}, "269": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    10: [5, 11],\n    5: [10, 11],\n    11: [10, 5],\n    4: [0, 1, 3, 9],\n    0: [4, 12],\n    1: [4, 2],\n    3: [4, 12],\n    9: [4, 8],\n    12: [0, 3],\n    2: [1],\n    6: [7],\n    7: [6, 8],\n    8: [7, 9]\n}\n\nstart_node = 11\nend_node = 9\n\nprint(dfs(graph, start_node, end_node))\n```"}, "270": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    13: [6, 7, 10, 0, 3, 5, 2, 8, 11, 4, 14],\n    6: [13, 7, 9, 12, 0, 3, 5, 2, 1, 11, 4, 14],\n    7: [13, 6, 9, 10, 12, 0, 3, 1, 8, 11, 14],\n    10: [13, 7, 12, 0, 1, 4, 14],\n    0: [13, 6, 7, 9, 10, 12, 3, 5, 2, 1, 8, 4, 14],\n    3: [13, 6, 7, 9, 0, 5, 2, 1, 11, 4],\n    5: [13, 6, 12, 0, 3, 2, 1, 8, 11, 14],\n    2: [13, 6, 9, 12, 0, 3, 5, 1, 8, 14],\n    8: [13, 7, 9, 12, 0, 5, 2, 11, 14],\n    11: [13, 6, 7, 9, 12, 3, 5, 1, 8, 14],\n    4: [13, 6, 9, 10, 0, 3, 1],\n    14: [13, 6, 7, 10, 0, 5, 2, 1, 8, 11],\n    9: [6, 7, 0, 3, 2, 8, 11, 4],\n    12: [6, 7, 10, 0, 5, 2, 1, 8, 11],\n    1: [6, 7, 10, 12, 0, 3, 5, 2, 11, 4, 14]\n}\n\nstart_node = 10\ngoal_node = 8\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "271": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    0: [6, 5, 4],\n    6: [5, 3, 1],\n    5: [9],\n    3: [1],\n    1: [3],\n    2: [8, 0],\n    8: [4, 0, 6],\n    7: [8, 4, 2],\n    9: [8, 0, 1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 4 to node 7\nresult = has_path(graph, 4, 7)\nprint(result)\n```"}, "272": {"gpt4": "```python\ndef dfs(graph, start, goal, visited):\n    if start == goal:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    0: [1],\n    1: [0, 7],\n    7: [1, 2],\n    4: [8, 5],\n    8: [4, 3],\n    5: [4, 6, 2],\n    3: [8, 6],\n    6: [3, 5],\n    2: [5, 7]\n}\n\nstart_node = 5\ngoal_node = 3\nvisited = set()\n\nresult = dfs(graph, start_node, goal_node, visited)\nprint(result)\n```"}, "273": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [1, 6],\n    1: [5, 0],\n    6: [5, 0],\n    0: [1, 6],\n    11: [3, 10],\n    3: [11, 12],\n    10: [11, 2],\n    12: [3, 9, 4],\n    8: [9, 7],\n    9: [8, 2, 12],\n    7: [8],\n    2: [9, 10],\n    4: [12, 13],\n    13: [4]\n}\n\nstart_node = 0\ngoal_node = 12\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "274": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = {\n    7: [6, 1, 3],\n    6: [1, 7, 4],\n    1: [2, 4, 6, 5, 0],\n    3: [4, 6, 0, 2],\n    8: [6, 5, 0],\n    5: [2, 3],\n    0: [1, 2, 6],\n    4: [1, 7, 8],\n    2: [3]\n}\n\nstart_node = 8\nend_node = 6\n\nprint(has_path(graph, start_node, end_node))\n```"}, "275": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph as an adjacency list\ngraph = {\n    13: [12, 0, 9, 3, 11],\n    12: [8, 7, 6, 4, 2, 11, 10],\n    0: [6, 4, 2, 5, 10, 13],\n    9: [7, 4, 5, 13, 0],\n    3: [11, 12, 8, 0, 9],\n    8: [1, 9, 10, 13],\n    7: [6, 2, 5, 0],\n    6: [4, 10, 1, 7],\n    4: [11, 13, 12, 0],\n    2: [5, 11, 10, 1, 4],\n    10: [8, 1, 6],\n    1: [7, 4, 11, 13, 8],\n    5: [12, 1, 9, 7, 3],\n}\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 11 to node 10\nresult = has_path(graph, 11, 10)\nprint(result)\n```"}, "276": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    5: [0, 7, 9, 10, 8],\n    0: [5],\n    7: [5, 12],\n    9: [5, 1, 3, 4],\n    10: [5],\n    8: [5],\n    1: [9, 11],\n    3: [9, 2],\n    4: [9, 6],\n    11: [1],\n    2: [3],\n    12: [7],\n    6: [4]\n}\n\nstart_node = 9\ngoal_node = 12\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "277": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    7: [1],\n    1: [6, 2, 10],\n    8: [3, 0],\n    9: [12, 0],\n    12: [7, 11, 9],\n    5: [8, 9],\n    13: [6],\n    4: [12, 3],\n    2: [7, 13],\n    10: [1, 7, 5, 4, 2]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 9\nprint(has_path(graph, 6, 9))\n```"}, "278": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    9: [5, 6, 0, 10, 3, 8, 12],\n    5: [9, 6, 0, 10, 7, 11, 12, 1],\n    6: [9, 5, 0, 4, 3],\n    0: [9, 5, 6, 10, 2, 7, 3, 8, 11, 12],\n    10: [9, 5, 0, 7, 8],\n    3: [9, 6, 0, 11, 12, 1],\n    8: [9, 0, 10, 7, 11, 12],\n    12: [9, 5, 0, 7, 3, 8, 11, 1],\n    7: [5, 0, 10, 2, 8, 12],\n    11: [5, 0, 4, 3, 8, 12],\n    1: [5, 2, 3, 12],\n    4: [6, 11],\n    2: [0, 7, 1]\n}\n\nstart_node = 11\ngoal_node = 8\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "279": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    2: [6, 8],\n    6: [2, 9, 13],\n    8: [2],\n    9: [6, 4],\n    13: [6, 12, 11],\n    5: [10, 3],\n    10: [5, 7],\n    3: [5, 0],\n    7: [10, 0],\n    0: [3, 7],\n    4: [9, 12],\n    12: [13, 4],\n    11: [13, 1],\n    1: [11]\n}\n\nstart_node = 0\ngoal_node = 13\n\npath_exists = dfs(graph, start_node, goal_node)\nprint(path_exists)\n```"}, "280": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    6: [2, 10, 1, 0, 4, 3],\n    2: [6, 8, 5, 0, 4, 9],\n    10: [6, 8, 5, 7, 4, 3],\n    1: [6],\n    0: [6, 8, 5, 2, 7, 3, 9],\n    4: [6, 2, 10, 7],\n    3: [6, 10, 0],\n    8: [5, 2, 10, 7, 0],\n    5: [8, 2, 10, 7, 0, 9],\n    7: [8, 5, 10, 0, 4],\n    9: [5, 2, 0]\n}\n\nstart_node = 5\ngoal_node = 2\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "281": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    9: [5, 1, 0, 10],\n    5: [3, 4],\n    1: [3, 13, 12],\n    0: [7, 13],\n    10: [6, 12, 3, 7],\n    6: [11, 0, 3, 7, 2],\n    11: [12, 5, 7, 4],\n    3: [4, 5],\n    7: [13],\n    2: [5],\n    12: [5, 2, 4],\n    4: [7, 2],\n    13: [3, 7, 4],\n    8: [5]\n})\n\n# Function to check if there's a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there's a path from node 12 to node 11\nprint(has_path(graph, 12, 11))\n```"}, "282": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = {\n    6: [12, 9, 2, 3],\n    12: [0],\n    9: [7, 10, 6],\n    2: [8, 7, 0],\n    3: [8],\n    0: [9, 3, 10],\n    10: [1, 6, 3, 4],\n    7: [12, 0, 2],\n    11: [4, 1, 12],\n    4: [12, 2],\n    1: [7, 4],\n    5: [9, 4]\n}\n\nstart_node = 10\nend_node = 6\n\nprint(has_path(graph, start_node, end_node))\n```"}, "283": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [0, 11],\n    0: [6, 12],\n    11: [2],\n    1: [6, 3],\n    6: [8, 3, 12],\n    3: [8],\n    12: [0, 8],\n    14: [6, 5, 12, 1],\n    5: [9],\n    2: [6, 13, 9],\n    13: [0, 6, 5],\n    8: [13, 11, 0, 14, 6],\n    4: [9, 1],\n    7: [8, 5, 3]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 14 to node 4\nprint(has_path(graph, 14, 4))\n```"}, "284": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    3: [5, 7],\n    5: [3, 0, 7, 1],\n    7: [3, 5],\n    0: [5],\n    1: [5, 2],\n    6: [2, 4],\n    2: [6, 1],\n    4: [6]\n}\n\nstart_node = 1\nend_node = 4\n\npath_exists = dfs(graph, start_node, end_node)\nprint(path_exists)\n```"}, "285": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    11: [7, 4, 5],\n    7: [6, 2, 10],\n    4: [8, 1],\n    5: [3, 4],\n    8: [0, 6, 4],\n    0: [8],\n    6: [7, 1],\n    9: [4, 11],\n    10: [0, 7, 12, 9],\n    2: [6],\n    1: [4, 8, 7],\n    3: [11, 12, 9, 10, 7]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 12 to node 2\nprint(has_path(graph, 12, 2))\n```"}, "286": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    3: [12, 8],\n    12: [2],\n    8: [0, 13],\n    1: [13],\n    13: [9, 11, 2, 6],\n    9: [3, 1],\n    7: [2],\n    2: [9, 7],\n    11: [5, 13],\n    5: [13, 4],\n    4: [10],\n    0: [8, 1, 7],\n    10: [8, 1, 11],\n    6: [9]\n})\n\nprint(has_path(graph, 8, 12))\n```"}, "287": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    10: [6],\n    6: [10],\n    8: [3, 7, 0, 6],\n    3: [10, 8],\n    7: [5, 3, 4],\n    0: [1, 6, 8],\n    5: [2, 1, 8],\n    2: [6],\n    1: [7],\n    9: [4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 10 to node 9\nprint(has_path(graph, 10, 9))\n```"}, "288": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    7: [6, 5, 1, 2],\n    6: [5, 1, 2, 4],\n    1: [2],\n    2: [8, 7, 3],\n    3: [5, 0, 2, 8],\n    0: [2, 6, 5],\n    8: [7, 5, 0, 2],\n    4: [7, 6]\n})\n\nstart_node = 8\nend_node = 3\n\nprint(has_path(graph, start_node, end_node))\n```"}, "289": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph as an adjacency list\ngraph = defaultdict(list, {\n    0: [3, 2, 5, 8, 10],\n    3: [13, 12, 11, 8, 10, 9],\n    2: [6, 12, 5, 9],\n    5: [9, 4, 13, 12],\n    8: [9, 7, 13, 2, 12],\n    10: [9, 0, 4, 3, 13],\n    4: [7, 13, 2, 12, 9],\n    7: [12, 8],\n    13: [2, 11, 10, 7],\n    12: [5, 10, 9, 4, 7, 2, 6],\n    9: [4, 3, 11],\n    11: [0, 7, 13],\n    6: [12, 5, 8, 7],\n    1: [0, 4]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 13 to node 1\nresult = has_path(graph, 13, 1)\nprint(result)\n```"}, "290": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    12: [6, 9, 2, 5, 14],\n    6: [5, 12, 8],\n    9: [1, 13, 3, 6],\n    2: [5, 11, 14, 3, 0],\n    5: [14, 0],\n    14: [6, 5, 4, 11],\n    8: [3, 2, 7, 5],\n    3: [0, 2, 5, 11, 8],\n    7: [1, 10, 14, 8, 0, 2],\n    11: [14, 12, 6, 0, 1],\n    1: [4, 10, 11, 14, 9, 7],\n    13: [12, 9, 0, 2, 1, 10],\n    10: [6, 2, 4],\n    4: [14, 9, 0, 1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 1 to node 8\nresult = has_path(graph, 1, 8)\nprint(result)\n```"}, "291": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [9, 7, 0, 2, 6, 5],\n    9: [10, 2],\n    7: [8, 3, 0, 4],\n    0: [1, 10],\n    2: [10, 1],\n    6: [8, 10, 0, 2],\n    5: [0],\n    10: [2, 5, 9],\n    8: [1, 6],\n    3: [1, 9, 7],\n    1: [6, 10]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 4\nprint(has_path(graph, 6, 4))\n```"}, "292": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    1: [4, 7],\n    4: [1, 2],\n    7: [1, 3],\n    2: [4, 0, 6],\n    0: [2, 5],\n    5: [0, 6],\n    6: [2, 5],\n    3: [7]\n}\n\nstart_node = 7\ngoal_node = 3\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "293": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    4: [7, 5, 1, 0],\n    5: [1, 0],\n    1: [0, 2, 7, 5],\n    0: [1],\n    3: [6, 7],\n    2: [6]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return False\n\n# Check if there is a path from node 6 to node 4\nresult = has_path(graph, 6, 4)\nprint(result)\n```"}, "294": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    10: [6, 7],\n    6: [10, 8],\n    7: [10, 3],\n    8: [6, 11],\n    5: [13, 12, 9],\n    13: [5, 0],\n    12: [5, 4],\n    9: [5, 11],\n    0: [13, 1],\n    11: [8, 9, 1],\n    3: [7, 2],\n    2: [3],\n    1: [11, 0],\n    4: [12]\n}\n\nstart_node = 10\nend_node = 2\n\npath_exists = dfs(graph, start_node, end_node)\nprint(path_exists)\n```"}, "295": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef can_reach(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    0: [3, 2, 4],\n    3: [2, 6, 0],\n    2: [6, 3],\n    4: [1, 3],\n    1: [3, 0],\n    5: [2],\n    6: [0, 1, 3, 2],\n    7: [3]\n})\n\nprint(can_reach(graph, 0, 7))\n```"}, "296": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    8: [10, 11, 0],\n    10: [11, 7, 3, 0, 8],\n    11: [5, 6],\n    0: [12, 7, 1, 2, 3],\n    7: [6, 3, 0, 12, 8],\n    3: [2],\n    5: [7, 6, 2, 3, 12, 8],\n    6: [9, 2, 3, 0, 8, 7, 13],\n    2: [12, 8, 10, 11, 5, 7, 1, 4],\n    12: [7, 13, 1, 4, 0],\n    13: [8],\n    9: [4, 0, 8, 10, 7, 13],\n    1: [12, 10, 11],\n    4: [0, 7, 13, 6, 9]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 6 to node 3\nresult = has_path(graph, 6, 3)\nprint(result)\n```"}, "297": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\ngraph = defaultdict(list, {\n    7: [1, 5],\n    1: [5, 7],\n    5: [6, 4, 8, 3],\n    8: [5, 6, 4, 7],\n    6: [8, 3],\n    3: [5, 1],\n    2: [1],\n    0: [1, 6]\n})\n\nprint(has_path(graph, 1, 2))\n```"}, "298": {"gpt4": "```python\ndef dfs(graph, start, goal, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    if start == goal:\n        return True\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, goal, visited):\n                return True\n    return False\n\ngraph = {\n    9: [6, 12, 0, 8, 3, 5, 10, 1, 7, 2],\n    6: [9, 7, 11, 8, 4, 10, 12, 1],\n    12: [9, 6, 3],\n    0: [9, 7, 8, 11, 10, 1, 4],\n    8: [9, 6, 2, 0],\n    3: [9, 2, 1, 12, 10, 4],\n    5: [9, 10],\n    10: [9, 6, 7, 2, 0, 11, 3, 5],\n    1: [9, 6, 0, 11, 3],\n    7: [9, 6, 10, 4, 0, 2],\n    2: [9, 7, 8, 10, 3],\n    11: [6, 0, 1, 10],\n    4: [6, 7, 0, 3]\n}\n\nstart_node = 7\ngoal_node = 3\n\nprint(dfs(graph, start_node, goal_node))\n```"}, "299": {"gpt4": "```python\nfrom collections import defaultdict, deque\n\n# Define the graph\ngraph = defaultdict(list, {\n    5: [7, 1],\n    7: [4],\n    1: [11],\n    6: [0, 10, 5],\n    0: [4, 11, 10],\n    9: [2, 3],\n    2: [11],\n    3: [0, 4],\n    4: [2],\n    8: [7, 1]\n})\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Check if there is a path from node 9 to node 5\nprint(has_path(graph, 9, 5))\n```"}}