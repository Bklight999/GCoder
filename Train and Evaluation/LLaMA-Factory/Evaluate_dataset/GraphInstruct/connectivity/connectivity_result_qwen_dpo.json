[{"id": 0, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [4, 5],\n    4: [8, 1],\n    5: [8, 2],\n    1: [4, 7, 6],\n    3: [10, 11],\n    10: [3, 7],\n    11: [3, 9],\n    7: [10, 1],\n    0: [9],\n    9: [0, 11],\n    6: [1, 2],\n    2: [5, 6]\n}\n\n# Check if there is a path between node 0 and node 4\nprint(has_path(graph, 0, 4))  # Output: True\n```"}, {"id": 1, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[2] = [4, 0]\ngraph[0] = [1, 10]\ngraph[14] = [4]\ngraph[11] = [13, 7, 5]\ngraph[13] = [9]\ngraph[7] = [6, 12]\ngraph[5] = [3, 2, 14, 11]\ngraph[1] = [12, 7, 0, 11]\ngraph[12] = [10, 2]\ngraph[10] = [9, 5, 11]\ngraph[8] = [2, 11]\ngraph[3] = [0, 11, 5]\n\n# Function to perform DFS and check if there is a path from start to end\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 4 to node 3\nstart_node = 4\nend_node = 3\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 4 to node 3?\", result)\n```"}, {"id": 2, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[10] = [8, 5]\ngraph[8] = [1, 6, 0]\ngraph[5] = [2, 7, 8, 1, 6]\ngraph[2] = [0, 3, 11, 6, 10]\ngraph[0] = [3, 8, 11, 1, 2]\ngraph[3] = [10, 9]\ngraph[11] = [2, 4, 3]\ngraph[6] = [10, 3]\ngraph[4] = [9, 0, 11, 1, 5]\ngraph[9] = [7, 1, 6, 10, 2]\ngraph[1] = [10, 7, 0]\ngraph[7] = [0, 6, 5, 10, 4]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 3 to node 9\npath_exists = has_path(graph, 3, 9)\nprint(\"Is there a directed path from node 3 to node 9?\", path_exists)\n```"}, {"id": 3, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4] = [10, 8, 0]\ngraph[10] = [0, 7, 9, 4]\ngraph[8] = [9]\ngraph[0] = [8]\ngraph[7] = [9]\ngraph[9] = [1]\ngraph[3] = [11, 5, 6]\ngraph[11] = [2, 7, 3]\ngraph[5] = [7, 10]\ngraph[6] = [8, 7]\n\n# Check if there is a path from node 10 to node 5\nresult = has_path(graph, 10, 5)\nprint(result)\n```"}, {"id": 4, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [4, 12, 11, 3],\n    4: [0],\n    12: [0, 10],\n    11: [0, 7],\n    3: [0, 5, 6, 8],\n    5: [3],\n    6: [3],\n    8: [3],\n    10: [12, 9],\n    9: [10, 2, 1],\n    7: [11],\n    2: [9],\n    1: [9]\n}\n\n# Check if there is a path between node 9 and node 1\nresult = has_path(graph, 9, 1)\nprint(result)\n```"}, {"id": 5, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[3] = [5, 7, 6]\ngraph[5] = [8, 7]\ngraph[7] = [4, 8]\ngraph[8] = [2, 0, 6]\ngraph[2] = [0]\ngraph[0] = [4, 8]\ngraph[1] = [3, 8, 7]\n\n# Check if there is a path from node 7 to node 3\nresult = has_path(graph, 7, 3)\nprint(result)\n```"}, {"id": 6, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [0, 6, 11, 9, 7, 1],\n    0: [4, 6, 11, 9, 12, 2],\n    6: [4, 0, 11, 9, 5, 7, 1, 12, 2],\n    11: [4, 0, 6, 10, 13, 12],\n    9: [4, 0, 6, 10, 5, 8, 1, 12, 2, 3],\n    7: [4, 6, 5, 13, 1, 3],\n    1: [4, 6, 10, 9, 5, 7, 13, 12, 2],\n    12: [0, 6, 11, 9, 1, 3],\n    2: [0, 6, 9, 5, 1, 3],\n    5: [6, 9, 7, 13, 1, 2],\n    10: [11, 9, 1, 3],\n    3: [10, 9, 7, 13, 12, 2],\n    13: [11, 5, 7, 8, 1, 3],\n    8: [9, 13]\n}\n\n# Check if there is a path between node 12 and node 6\nresult = has_path(graph, 12, 6)\nprint(\"Is there a path between node 12 and node 6?\", result)\n```"}, {"id": 7, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[3] = [9]\ngraph[9] = [12, 11]\ngraph[5] = [6]\ngraph[6] = [12, 10, 7]\ngraph[1] = [0, 7, 12, 9]\ngraph[0] = [10]\ngraph[7] = [0]\ngraph[12] = [0, 6]\ngraph[10] = [8, 7]\ngraph[8] = [7, 6]\ngraph[4] = [6, 8]\ngraph[2] = [3, 5, 8]\ngraph[11] = [2]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 8 to node 3\npath_exists = has_path(graph, 8, 3)\nprint(\"Is there a directed path from node 8 to node 3?\", path_exists)\n```"}, {"id": 8, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [13, 10, 11, 9, 8, 12, 4, 3, 5, 0],\n    13: [6, 5],\n    10: [6, 12, 9, 1, 2],\n    11: [6, 2],\n    9: [6, 10],\n    8: [6, 2],\n    12: [6, 10],\n    4: [6, 2, 7],\n    3: [6, 2],\n    5: [6, 13, 1, 2],\n    0: [6, 2],\n    1: [10, 5],\n    2: [10, 5, 3, 11, 4, 0, 7, 8],\n    7: [2, 4]\n}\n\n# Check if there is a path between node 4 and node 8\nprint(has_path(graph, 4, 8))  # Output: True\n```"}, {"id": 9, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [1],\n    1: [4, 2, 6],\n    2: [1, 5],\n    6: [1, 5],\n    5: [2, 6],\n    3: [0, 7],\n    0: [3, 7],\n    7: [3, 0]\n}\n\n# Check if there is a path between node 3 and node 1\nprint(has_path(graph, 3, 1))  # Output: True\n```"}, {"id": 10, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [8, 5, 10, 4, 11, 12, 7, 3, 1],\n    8: [0],\n    5: [0],\n    10: [0, 13],\n    4: [0],\n    11: [0],\n    12: [0],\n    7: [0, 14, 2, 6, 9],\n    3: [0],\n    1: [0],\n    13: [10],\n    14: [7],\n    2: [7],\n    6: [7],\n    9: [7]\n}\n\n# Check if there is a path between node 10 and node 12\nresult = has_path(graph, 10, 12)\nprint(result)\n```"}, {"id": 11, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [2, 5],\n    2: [4, 8],\n    5: [4, 6, 0],\n    8: [2, 9],\n    1: [6],\n    6: [1, 5],\n    0: [5, 9],\n    9: [0, 8],\n    7: [3, 10],\n    3: [7, 10],\n    10: [7, 3]\n}\n\n# Check if there is a path between node 9 and node 7\nresult = has_path(graph, 9, 7)\nprint(result)\n```"}, {"id": 12, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[3].append(10)\ngraph[10].append(0)\ngraph[10].append(6)\ngraph[0].append(10)\ngraph[6].append(10)\ngraph[6].append(7)\ngraph[6].append(4)\ngraph[6].append(14)\ngraph[6].append(3)\ngraph[6].append(0)\ngraph[7].append(8)\ngraph[7].append(3)\ngraph[7].append(11)\ngraph[4].append(14)\ngraph[4].append(6)\ngraph[4].append(7)\ngraph[14].append(0)\ngraph[14].append(6)\ngraph[14].append(12)\ngraph[14].append(10)\ngraph[14].append(4)\ngraph[11].append(10)\ngraph[11].append(3)\ngraph[2].append(8)\ngraph[2].append(5)\ngraph[8].append(11)\ngraph[8].append(10)\ngraph[8].append(9)\ngraph[8].append(13)\ngraph[8].append(4)\ngraph[5].append(0)\ngraph[5].append(2)\ngraph[5].append(8)\ngraph[9].append(8)\ngraph[13].append(1)\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, v, visited):\n                return True\n    return False\n\n# Check if there is a path from node 4 to node 1\nresult = has_path(graph, 4, 1)\nprint(\"Is there a directed path from node 4 to node 1?\", result)\n```"}, {"id": 13, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[3] = [7, 1]\ngraph[7] = [5, 3]\ngraph[1] = [2, 7, 6]\ngraph[0] = [7]\ngraph[5] = [7]\ngraph[4] = [6, 7]\ngraph[6] = [4, 5]\n\n# Check if there is a path from node 2 to node 5\nresult = has_path(graph, 2, 5)\nprint(result)\n```"}, {"id": 14, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [7, 4],\n    7: [3, 5],\n    4: [3, 1, 2, 8],\n    5: [7, 6],\n    1: [4, 8],\n    8: [1, 4, 0],\n    2: [4],\n    6: [5],\n    0: [8]\n}\n\n# Check if there is a path between node 2 and node 0\nresult = has_path(graph, 2, 0)\nprint(result)\n```"}, {"id": 15, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[5].append(7)\ngraph[2].append(5)\ngraph[4].append(7)\ngraph[4].append(0)\ngraph[4].append(8)\ngraph[0].append(4)\ngraph[0].append(3)\ngraph[0].append(7)\ngraph[0].append(1)\ngraph[3].append(7)\ngraph[3].append(1)\ngraph[3].append(0)\ngraph[1].append(6)\ngraph[1].append(7)\ngraph[6].append(5)\n\n# Check if there is a path from node 7 to node 8\nresult = has_path(graph, 7, 8)\nprint(result)\n```"}, {"id": 16, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [13, 5, 7, 10, 11, 3, 8, 4],\n    13: [2, 8],\n    5: [2, 12, 1, 8],\n    7: [2, 8],\n    10: [2, 12, 11],\n    11: [2, 10],\n    3: [2, 1],\n    8: [2, 13, 7, 9, 6, 5],\n    4: [2, 9, 6],\n    12: [0, 1, 10, 5],\n    0: [12, 1],\n    1: [12, 0, 3, 5, 9],\n    9: [1, 8, 4],\n    6: [8, 4]\n}\n\n# Check if there is a path between node 4 and node 9\nresult = has_path(graph, 4, 9)\nprint(\"Is there a path between node 4 and node 9?\", result)\n```"}, {"id": 17, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4] = [3, 7]\ngraph[3] = [7, 4]\ngraph[7] = [8]\ngraph[0] = [3, 4]\ngraph[5] = [3]\ngraph[2] = [4]\ngraph[6] = [9, 1]\ngraph[9] = [0, 6]\ngraph[8] = [7]\n\n# Check if there is a path from node 0 to node 6\nresult = has_path(graph, 0, 6)\nprint(\"Is there a directed path from node 0 to node 6?\", result)\n```"}, {"id": 18, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [13, 9, 11, 1, 2, 0, 3, 7, 8, 10, 6],\n    13: [12, 9, 4, 11, 1, 0, 3, 7, 10, 5],\n    9: [12, 13, 4, 11, 1, 2, 0, 3, 7, 8, 10, 5, 6],\n    11: [12, 13, 9, 4, 2, 0, 7, 8, 10, 5],\n    1: [12, 13, 9, 4, 2, 0, 3, 7, 8, 10, 5],\n    2: [12, 9, 4, 11, 1, 3, 7, 8, 10, 5, 6],\n    0: [12, 13, 9, 11, 1, 3, 7, 10, 5],\n    3: [12, 13, 9, 4, 1, 2, 0, 7, 8, 10, 5],\n    7: [12, 13, 9, 4, 11, 1, 2, 0, 3, 10, 5],\n    8: [12, 9, 4, 11, 1, 2, 3, 10],\n    10: [12, 13, 9, 4, 11, 1, 2, 0, 3, 7, 8, 5, 6],\n    6: [12, 9, 2, 10],\n    4: [13, 9, 11, 1, 2, 3, 7, 8, 10, 5],\n    5: [13, 9, 4, 11, 1, 2, 0, 3, 7, 10]\n}\n\n# Check if there is a path between node 6 and node 9\nresult = has_path(graph, 6, 9)\nprint(\"Is there a path between node 6 and node 9?\", result)\n```"}, {"id": 19, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[0].append(5)\ngraph[4].append(3)\ngraph[4].append(6)\ngraph[4].append(0)\ngraph[3].append(1)\ngraph[6].append(1)\ngraph[1].append(2)\ngraph[8].append(6)\ngraph[8].append(0)\ngraph[8].append(4)\ngraph[7].append(1)\ngraph[7].append(6)\ngraph[7].append(0)\ngraph[2].append(5)\ngraph[2].append(7)\n\n# Check if there is a path from node 2 to node 3\nprint(has_path(graph, 2, 3))  # Output: True\n```"}, {"id": 20, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [2],\n    2: [1, 3],\n    3: [2, 7, 4, 8],\n    7: [3, 10],\n    10: [7, 4],\n    4: [3, 0, 10, 6],\n    8: [3],\n    5: [0],\n    0: [5, 4, 9],\n    9: [0],\n    6: [4]\n}\n\n# Check if there is a path between node 1 and node 10\nprint(has_path(graph, 1, 10))  # Output: True\n```"}, {"id": 21, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[0] = [2, 11]\ngraph[2] = [7, 1, 4]\ngraph[11] = [7, 1, 5]\ngraph[4] = [7]\ngraph[7] = [6, 12, 3]\ngraph[5] = [9]\ngraph[9] = [6, 11]\ngraph[3] = [6]\ngraph[6] = [9]\ngraph[1] = [3]\ngraph[12] = [8, 4, 6]\ngraph[10] = [8, 5, 11, 12]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 2 to node 0\nresult = has_path(graph, 2, 0)\nprint(\"Is there a directed path from node 2 to node 0?\", result)\n```"}, {"id": 22, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [6, 2, 11, 7, 9],\n    6: [3, 1, 0],\n    2: [3, 1, 0, 5],\n    11: [3, 4, 10],\n    7: [3, 10, 9],\n    9: [3, 1, 8, 4, 10, 7],\n    1: [6, 2, 9],\n    0: [6, 8, 4, 2, 10],\n    8: [0, 10, 5, 9],\n    10: [8, 0, 11, 5, 7, 9],\n    5: [8, 2, 10],\n    4: [0, 11, 9]\n}\n\n# Check if there is a path between node 9 and node 3\nresult = has_path(graph, 9, 3)\nprint(\"Is there a path between node 9 and node 3?\", result)\n```"}, {"id": 23, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [0, 4, 3, 10],\n    0: [2, 3],\n    4: [9, 8, 0],\n    3: [10, 9, 8, 1, 0],\n    10: [5, 2],\n    1: [4, 3, 8],\n    6: [0, 9],\n    9: [8, 4, 5, 2],\n    2: [1, 6],\n    7: [2, 3, 1, 6, 4],\n    5: [2, 9, 6, 0, 4]\n}\n\n# Check if there is a path from node 2 to node 7\nresult = has_path(graph, 2, 7)\nprint(result)\n```"}, {"id": 24, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [4, 3],\n    4: [7, 0, 2],\n    3: [7, 1, 0],\n    0: [4, 3],\n    2: [4],\n    1: [3, 5, 6],\n    5: [1],\n    6: [1]\n}\n\n# Check if there is a path between node 1 and node 2\nprint(has_path(graph, 1, 2))  # Output: True\n```"}, {"id": 25, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[1] = [12, 2, 4, 5, 10]\ngraph[12] = [9, 8, 3]\ngraph[2] = [3, 10, 12]\ngraph[4] = [7, 12, 6]\ngraph[5] = [3, 1]\ngraph[10] = [0, 3]\ngraph[3] = [9, 8]\ngraph[6] = [11, 4, 1, 12]\ngraph[11] = [8, 3]\ngraph[0] = [2, 10]\ngraph[7] = [8]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 11 to node 2\nresult = has_path(graph, 11, 2)\nprint(\"Is there a directed path from node 11 to node 2?\", result)\n```"}, {"id": 26, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [1, 9, 5, 8],\n    1: [3, 4, 0],\n    9: [3, 12, 2, 5],\n    5: [3, 9, 4, 0],\n    8: [3, 12, 0],\n    4: [1, 10, 0, 5],\n    0: [1, 10, 4, 5, 8, 13],\n    7: [12, 10, 13, 2],\n    12: [7, 2, 11, 8, 9],\n    10: [7, 6, 4, 0, 11],\n    13: [7, 6, 11, 0],\n    2: [7, 12, 9],\n    11: [12, 10, 6, 13],\n    6: [10, 11, 13]\n}\n\n# Check if there is a path between node 0 and node 13\nresult = has_path(graph, 0, 13)\nprint(\"Is there a path between node 0 and node 13?\", result)\n```"}, {"id": 27, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[6] = [8, 1, 4]\ngraph[8] = [2, 11]\ngraph[1] = [5]\ngraph[11] = [10, 2, 9, 12, 0]\ngraph[10] = [2, 14]\ngraph[2] = [9, 14, 6, 10]\ngraph[12] = [14, 7, 0, 6, 13]\ngraph[0] = [4, 11, 8, 13]\ngraph[14] = [0, 5]\ngraph[3] = [5, 1]\ngraph[5] = [6]\ngraph[13] = [2]\ngraph[7] = [1]\n\n# Function to perform DFS and check if there is a path from start to end\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 6 to node 3\nstart_node = 6\nend_node = 3\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 6 to node 3?\", result)\n```"}, {"id": 28, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1].append(3)\ngraph[4].append(8)\ngraph[4].append(0)\ngraph[4].append(3)\ngraph[4].append(1)\ngraph[8].append(1)\ngraph[0].append(5)\ngraph[0].append(3)\ngraph[0].append(1)\ngraph[0].append(4)\ngraph[0].append(8)\ngraph[5].append(6)\ngraph[5].append(0)\ngraph[7].append(6)\ngraph[7].append(3)\ngraph[7].append(8)\ngraph[6].append(0)\ngraph[6].append(7)\ngraph[2].append(3)\ngraph[2].append(8)\ngraph[2].append(5)\n\n# Check if there is a path from node 1 to node 5\nprint(has_path(graph, 1, 5))  # Output: True\n```"}, {"id": 29, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [3],\n    3: [7, 2, 0],\n    5: [6, 2, 1, 0],\n    6: [5, 1],\n    2: [5, 0, 4, 3],\n    1: [5, 6, 0, 4],\n    0: [5, 2, 1, 4, 3],\n    4: [2, 1, 0]\n}\n\n# Check if there is a path between node 2 and node 3\nprint(has_path(graph, 2, 3))  # Output: True\n```"}, {"id": 30, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    11: [0, 6],\n    0: [11, 12],\n    6: [11, 1],\n    12: [0, 4],\n    8: [10, 5],\n    10: [8, 9],\n    5: [8, 3],\n    9: [10, 1],\n    1: [6, 9],\n    3: [5, 7],\n    7: [3, 13],\n    4: [2, 12],\n    2: [4, 13],\n    13: [2, 7]\n}\n\n# Check if there is a path between node 4 and node 8\nprint(has_path(graph, 4, 8))  # Output: True\n```"}, {"id": 31, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[5] = [4, 8, 0, 2, 1]\ngraph[4] = [7, 1]\ngraph[8] = [0, 5, 4]\ngraph[3] = [2, 5]\ngraph[7] = [2, 4]\ngraph[6] = [3, 8]\n\n# Check if there is a path from node 3 to node 6\nresult = has_path(graph, 3, 6)\nprint(\"Is there a directed path from node 3 to node 6?\", result)\n```"}, {"id": 32, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [0, 1, 6, 4, 7, 5, 11, 8],\n    0: [3],\n    1: [3],\n    6: [3],\n    4: [3, 10, 2],\n    7: [3],\n    5: [3],\n    11: [3],\n    8: [3, 9],\n    10: [4],\n    2: [4],\n    9: [8]\n}\n\n# Check if there is a path between node 5 and node 7\nprint(has_path(graph, 5, 7))  # Output: True\n```"}, {"id": 33, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[3] = [6, 4, 7]\ngraph[6] = [7]\ngraph[4] = [0, 3, 2, 6]\ngraph[7] = [5, 3, 1]\ngraph[2] = [7, 8]\ngraph[0] = [6, 4, 8]\ngraph[5] = [6]\n\n# Check if there is a path from node 8 to node 6\nresult = has_path(graph, 8, 6)\nprint(result)\n```"}, {"id": 34, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [10, 1, 5, 3, 12, 8],\n    10: [0, 7, 4, 1, 11, 6, 5, 3, 12, 8, 13],\n    1: [0, 7, 4, 10, 5, 12, 13],\n    5: [0, 7, 4, 2, 10, 1, 6, 3, 12, 9, 13],\n    3: [0, 7, 2, 10, 11, 5, 12, 9],\n    12: [0, 7, 4, 10, 1, 11, 6, 5, 3, 8, 13],\n    8: [0, 7, 2, 10, 12, 9, 13],\n    7: [4, 2, 10, 1, 11, 6, 5, 3, 12, 9, 8, 13],\n    4: [7, 2, 10, 1, 11, 5, 12, 9, 13],\n    2: [7, 4, 11, 6, 5, 3, 9, 8, 13],\n    11: [7, 4, 2, 10, 6, 3, 12, 9, 13],\n    6: [7, 2, 10, 11, 5, 12, 9, 13],\n    9: [7, 4, 2, 11, 6, 5, 3, 8],\n    13: [7, 4, 2, 10, 1, 11, 6, 5, 12, 8]\n}\n\n# Check if there is a path between node 5 and node 10\nresult = has_path(graph, 5, 10)\nprint(\"Is there a path between node 5 and node 10?\", result)\n```"}, {"id": 35, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [7],\n    7: [2, 3],\n    6: [3, 5, 0, 1],\n    0: [6, 4, 5],\n    2: [5],\n    4: [0, 1, 6, 2, 3]\n}\n\n# Check if there is a path from node 1 to node 0\nresult = has_path(graph, 1, 0)\nprint(result)\n```"}, {"id": 36, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [5, 4, 0, 9, 10, 2],\n    5: [3, 6, 11, 1, 2],\n    4: [3, 6, 1, 7, 8],\n    0: [3, 6, 1, 7, 8, 9, 10, 2],\n    9: [3, 6, 0, 2],\n    10: [3, 6, 1, 7, 8, 0, 2],\n    2: [3, 6, 5, 11, 1, 7, 0, 9, 10],\n    6: [5, 1, 4, 8, 0, 9, 10, 2],\n    1: [6, 5, 11, 4, 0, 10, 2],\n    8: [6, 4, 0, 10],\n    11: [5, 1, 7, 2],\n    7: [11, 4, 0, 10, 2]\n}\n\n# Check if there is a path between node 6 and node 9\nresult = has_path(graph, 6, 9)\nprint(result)\n```"}, {"id": 37, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[3].append(2)\ngraph[2].append(3)\ngraph[2].append(9)\ngraph[2].append(8)\ngraph[2].append(4)\ngraph[9].append(2)\ngraph[9].append(0)\ngraph[6].append(7)\ngraph[7].append(0)\ngraph[1].append(5)\ngraph[5].append(9)\ngraph[8].append(4)\ngraph[8].append(1)\ngraph[4].append(0)\n\n# Check if there is a path from node 8 to node 6\nresult = has_path(graph, 8, 6)\nprint(\"Is there a directed path from node 8 to node 6?\", result)\n```"}, {"id": 38, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [1],\n    1: [6, 3],\n    3: [1, 9],\n    9: [3, 10],\n    0: [5, 10],\n    5: [0, 2],\n    10: [0, 8, 9],\n    2: [5, 4, 7],\n    4: [2, 8],\n    7: [2],\n    8: [4, 10]\n}\n\n# Check if there is a path between node 10 and node 0\nresult = has_path(graph, 10, 0)\nprint(result)\n```"}, {"id": 39, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[0].append(2)\ngraph[2].append(8)\ngraph[2].append(6)\ngraph[6].append(8)\ngraph[8].append(1)\ngraph[8].append(0)\ngraph[4].append(2)\ngraph[4].append(1)\ngraph[1].append(4)\ngraph[1].append(8)\ngraph[3].append(7)\ngraph[3].append(1)\ngraph[7].append(1)\ngraph[7].append(6)\ngraph[7].append(2)\ngraph[7].append(8)\ngraph[5].append(0)\ngraph[5].append(1)\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited):\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, v, visited):\n                return True\n    return False\n\n# Check if there is a path from node 2 to node 5\nvisited = set()\nresult = has_path(graph, 2, 5, visited)\nprint(\"Is there a directed path from node 2 to node 5?\", result)\n```"}, {"id": 40, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [2, 9, 5, 6, 7, 3],\n    2: [1, 13, 5, 6, 12, 10, 4],\n    9: [1, 13, 11, 14, 5, 3, 4],\n    5: [1, 2, 13, 11, 9, 4],\n    6: [1, 2, 13, 11, 0, 3, 4],\n    7: [1, 8, 14, 0, 3, 4],\n    3: [1, 9, 6, 7, 12, 10],\n    8: [11, 14, 7],\n    11: [8, 9, 5, 6, 10],\n    14: [8, 9, 0, 7, 12],\n    13: [2, 9, 5, 6, 12],\n    12: [2, 13, 14, 0, 3, 10],\n    10: [2, 11, 0, 12, 3, 4],\n    4: [2, 9, 5, 6, 7, 10],\n    0: [14, 6, 7, 12, 10]\n}\n\n# Check if there is a path between node 9 and node 10\nresult = has_path(graph, 9, 10)\nprint(\"Is there a path between node 9 and node 10?\", result)\n```"}, {"id": 41, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[6].append(5)\ngraph[5].append(4)\ngraph[5].append(7)\ngraph[1].append(2)\ngraph[4].append(2)\ngraph[7].append(2)\ngraph[7].append(3)\ngraph[3].append(6)\ngraph[0].append(6)\ngraph[0].append(3)\n\n# Check if there is a path from node 2 to node 4\nprint(has_path(graph, 2, 4))  # Output: True\n```"}, {"id": 42, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [2, 5, 4],\n    2: [3, 5],\n    5: [3, 2, 4, 1, 0, 6, 8],\n    4: [3, 5, 1, 6],\n    1: [5, 4, 8],\n    0: [5, 7],\n    6: [5, 4, 7],\n    8: [5, 1],\n    7: [0, 6]\n}\n\n# Check if there is a path between node 6 and node 0\nprint(has_path(graph, 6, 0))  # Output: True\n```"}, {"id": 43, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [7, 10],\n    7: [1, 9],\n    10: [1, 5],\n    9: [7, 13],\n    5: [10, 0],\n    0: [5, 8],\n    4: [6, 3],\n    6: [4, 3],\n    3: [4, 6],\n    8: [0],\n    11: [2, 13],\n    2: [11, 12],\n    13: [11, 9, 12],\n    12: [2, 13]\n}\n\n# Check if there is a path between node 4 and node 5\nprint(has_path(graph, 4, 5))  # Output: True\n```"}, {"id": 44, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [6, 2, 12, 13, 11, 1, 7],\n    6: [4, 5],\n    2: [4, 10],\n    12: [4],\n    13: [4],\n    11: [4],\n    1: [4],\n    7: [4, 9, 8],\n    5: [6],\n    9: [7, 0],\n    8: [7, 3],\n    0: [9],\n    10: [2],\n    3: [8]\n}\n\n# Check if there is a path between node 8 and node 9\nprint(has_path(graph, 8, 9))  # Output: True\n```"}, {"id": 45, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[6] = [2, 0, 7]\ngraph[2] = [5, 0]\ngraph[0] = [3, 4, 7, 6, 2]\ngraph[7] = [4]\ngraph[5] = [3]\ngraph[4] = [7, 1, 5, 0]\ngraph[1] = [2, 0, 7]\n\n# Check if there is a path from node 3 to node 4\nresult = has_path(graph, 3, 4)\nprint(result)\n```"}, {"id": 46, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [1, 13],\n    1: [2, 14, 4],\n    13: [2, 7],\n    14: [1],\n    4: [1, 3],\n    10: [7, 9],\n    7: [10, 11, 13],\n    9: [10],\n    11: [7, 6],\n    6: [0, 11, 5],\n    0: [6, 8],\n    5: [6, 12],\n    8: [0],\n    12: [5, 3],\n    3: [12, 4]\n}\n\n# Check if there is a path between node 2 and node 1\nprint(has_path(graph, 2, 1))  # Output: True\n```"}, {"id": 47, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1].append(2)\ngraph[2].append(7)\ngraph[4].append(10)\ngraph[10].append(6)\ngraph[10].append(0)\ngraph[7].append(2)\ngraph[9].append(7)\ngraph[6].append(7)\ngraph[5].append(4)\ngraph[3].append(8)\ngraph[3].append(10)\ngraph[8].append(3)\ngraph[0].append(1)\ngraph[0].append(2)\ngraph[0].append(7)\ngraph[0].append(5)\ngraph[11].append(9)\ngraph[11].append(10)\n\n# Check if there is a path from node 9 to node 4\nresult = has_path(graph, 9, 4)\nprint(result)\n```"}, {"id": 48, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[14] = [1]\ngraph[1] = [7, 9]\ngraph[6] = [1, 12, 13, 5, 14]\ngraph[12] = [5, 2, 6, 11]\ngraph[13] = [11, 8, 12]\ngraph[5] = [7, 9, 12, 3]\ngraph[7] = [3]\ngraph[3] = [2, 7, 0, 9, 12]\ngraph[11] = [13, 4]\ngraph[4] = [14, 8]\ngraph[0] = [8, 4, 3]\ngraph[8] = [9, 4, 3, 2, 14]\ngraph[9] = [5, 2, 7, 0]\ngraph[2] = [14, 6, 8]\ngraph[10] = [4]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 11 to node 2\nresult = has_path(graph, 11, 2)\nprint(\"Is there a directed path from node 11 to node 2?\", result)\n```"}, {"id": 49, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [11, 9, 3],\n    11: [2, 9],\n    9: [2, 11],\n    3: [2, 7],\n    4: [6, 10, 1],\n    6: [4, 0],\n    10: [4],\n    1: [4, 0, 8],\n    0: [6, 5, 1],\n    5: [0],\n    8: [1],\n    7: [3]\n}\n\n# Check if there is a path between node 2 and node 10\nprint(has_path(graph, 2, 10))  # Output: True\n```"}, {"id": 50, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [7, 6],\n    7: [5, 4],\n    6: [5, 1, 0],\n    4: [7, 2],\n    8: [3, 9],\n    3: [8, 0],\n    9: [8],\n    0: [3, 6],\n    2: [1, 4],\n    1: [2, 6]\n}\n\n# Check if there is a path between node 0 and node 2\nprint(has_path(graph, 0, 2))  # Output: True\n```"}, {"id": 51, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [11, 3],\n    11: [1, 6],\n    3: [1, 10],\n    6: [11, 10],\n    2: [5, 9],\n    5: [2, 7],\n    9: [2],\n    7: [5, 0],\n    0: [8, 7, 4],\n    8: [0, 4],\n    4: [0, 8],\n    10: [3, 6]\n}\n\n# Check if there is a path between node 10 and node 9\nresult = has_path(graph, 10, 9)\nprint(result)\n```"}, {"id": 52, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [7, 1],\n    7: [0, 2, 10],\n    1: [0, 3],\n    2: [7, 4],\n    10: [7, 12],\n    8: [6, 4, 5],\n    6: [8, 11],\n    4: [8, 2],\n    5: [8, 12],\n    11: [6],\n    12: [10, 5],\n    3: [1, 9],\n    9: [3]\n}\n\n# Check if there is a path between node 12 and node 6\nresult = has_path(graph, 12, 6)\nprint(result)\n```"}, {"id": 53, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[7].append(0)\ngraph[0].append(6)\ngraph[4].append(1)\ngraph[4].append(2)\ngraph[1].append(7)\ngraph[2].append(5)\ngraph[3].append(1)\ngraph[3].append(0)\ngraph[3].append(5)\ngraph[8].append(5)\ngraph[8].append(2)\ngraph[6].append(2)\n\n# Check if there is a path from node 2 to node 6\nresult = has_path(graph, 2, 6)\nprint(\"Is there a directed path from node 2 to node 6?\", result)\n```"}, {"id": 54, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[3] = [2, 4, 1]\ngraph[2] = [4, 7]\ngraph[4] = [5, 7]\ngraph[1] = [6]\ngraph[7] = [3, 4]\ngraph[5] = [7, 8]\ngraph[6] = [7]\ngraph[0] = [2]\ngraph[8] = [2, 0]\n\n# Function to perform DFS and check if there is a path from start to end\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 4 to node 5\nstart_node = 4\nend_node = 5\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 4 to node 5?\", result)\n```"}, {"id": 55, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[5] = [3, 2, 7]\ngraph[3] = [0, 4, 5]\ngraph[2] = [4]\ngraph[7] = [3, 0, 4]\ngraph[0] = [7, 6, 1]\ngraph[4] = [6]\ngraph[6] = [4]\n\n# Check if there is a path from node 2 to node 7\nprint(has_path(graph, 2, 7))\n```"}, {"id": 56, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [2, 0, 5, 11, 4, 7],\n    2: [12, 10, 3, 8],\n    0: [12, 1, 10, 6],\n    5: [12, 1, 11, 9],\n    11: [12, 5, 6, 7],\n    4: [12, 10, 13],\n    7: [12, 6, 11, 3],\n    10: [2, 0, 14, 4, 3, 8],\n    3: [2, 14, 10, 7],\n    8: [2, 10, 13],\n    1: [5, 13, 9, 0],\n    13: [1, 4, 8],\n    9: [1, 5, 6, 14],\n    6: [0, 11, 9, 7],\n    14: [10, 9, 3]\n}\n\n# Check if there is a path between node 11 and node 8\nresult = has_path(graph, 11, 8)\nprint(\"Is there a path between node 11 and node 8?\", result)\n```"}, {"id": 57, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[2] = [5, 9]\ngraph[5] = [1, 8]\ngraph[9] = [0]\ngraph[0] = [7, 4, 1, 8]\ngraph[7] = [4, 11, 3, 10]\ngraph[4] = [1, 8, 0]\ngraph[1] = [8, 7, 4]\ngraph[8] = [2, 0, 10, 7, 1]\ngraph[6] = [9, 4, 2]\ngraph[11] = [3, 7, 8]\ngraph[3] = [7, 9, 1]\ngraph[10] = [9, 4, 1]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 11 to node 6\nresult = has_path(graph, 11, 6)\nprint(\"Is there a directed path from node 11 to node 6?\", result)\n```"}, {"id": 58, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [4, 2],\n    4: [3, 1, 0, 7],\n    2: [3],\n    1: [4, 8],\n    0: [4],\n    7: [4, 5],\n    5: [9, 6, 7],\n    9: [5, 8],\n    6: [5],\n    8: [9, 1]\n}\n\n# Check if there is a path between node 8 and node 2\nprint(has_path(graph, 8, 2))  # Output: True\n```"}, {"id": 59, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[4] = [7, 10, 0]\ngraph[7] = [13, 2]\ngraph[10] = [13]\ngraph[0] = [9, 5]\ngraph[2] = [5, 1]\ngraph[5] = [3]\ngraph[1] = [0, 2, 5]\ngraph[13] = [5, 12, 0]\ngraph[6] = [5, 7]\ngraph[8] = [14]\ngraph[9] = [1]\ngraph[3] = [1, 4, 9, 5, 11]\ngraph[11] = [7, 9]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 12 to node 11\nresult = has_path(graph, 12, 11)\nprint(\"Is there a directed path from node 12 to node 11?\", result)\n```"}, {"id": 60, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[3].append(1)\ngraph[1].append(8)\ngraph[1].append(6)\ngraph[1].append(3)\ngraph[1].append(5)\ngraph[2].append(5)\ngraph[8].append(0)\ngraph[8].append(2)\ngraph[4].append(7)\ngraph[4].append(0)\ngraph[7].append(6)\n\n# Check if there is a path from node 3 to node 8\nprint(has_path(graph, 3, 8))  # Output: True\n```"}, {"id": 61, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[13].append(7)\ngraph[7].append(14)\ngraph[5].append(4)\ngraph[4].append(10)\ngraph[4].append(13)\ngraph[14].append(6)\ngraph[14].append(8)\ngraph[14].append(4)\ngraph[14].append(0)\ngraph[14].append(11)\ngraph[6].append(1)\ngraph[8].append(7)\ngraph[8].append(3)\ngraph[8].append(10)\ngraph[8].append(14)\ngraph[0].append(12)\ngraph[0].append(7)\ngraph[11].append(4)\ngraph[11].append(9)\ngraph[1].append(10)\ngraph[1].append(5)\ngraph[1].append(9)\ngraph[3].append(13)\ngraph[3].append(14)\ngraph[3].append(7)\ngraph[10].append(2)\ngraph[10].append(11)\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited):\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, v, visited):\n                return True\n    return False\n\n# Check if there is a path from node 2 to node 7\nvisited = set()\nresult = has_path(graph, 2, 7, visited)\nprint(\"Is there a directed path from node 2 to node 7?\", result)\n```"}, {"id": 62, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [7, 0, 2],\n    7: [3, 5, 2, 8, 6],\n    0: [5, 4],\n    2: [7, 3],\n    3: [6],\n    5: [8, 6, 1, 0],\n    8: [6, 7, 3, 0, 4, 2],\n    1: [2, 6, 7],\n    4: [8, 7, 1, 3, 0, 5]\n}\n\n# Check if there is a path from node 8 to node 7\nresult = has_path(graph, 8, 7)\nprint(result)\n```"}, {"id": 63, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [2, 1, 4, 3],\n    2: [0],\n    1: [0, 8],\n    4: [0, 3],\n    3: [0, 4],\n    8: [1],\n    5: [6, 7],\n    6: [5, 7],\n    7: [5, 6]\n}\n\n# Check if there is a path between node 7 and node 0\nresult = has_path(graph, 7, 0)\nprint(result)\n```"}, {"id": 64, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [2, 7, 4, 8, 0, 1, 3, 6],\n    2: [5, 4, 8, 0, 1, 3],\n    7: [5, 4, 0, 1],\n    4: [5, 2, 7, 0, 1, 3, 6],\n    8: [5, 2, 0, 6],\n    0: [5, 2, 7, 4, 8, 3, 6],\n    1: [5, 2, 7, 4, 3, 6],\n    3: [5, 2, 4, 0, 1, 6],\n    6: [5, 4, 8, 0, 1, 3]\n}\n\n# Check if there is a path between node 4 and node 8\nresult = has_path(graph, 4, 8)\nprint(\"Is there a path between node 4 and node 8?\", result)\n```"}, {"id": 65, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [8, 1],\n    8: [1],\n    1: [3, 4, 2],\n    2: [8],\n    7: [5],\n    5: [4, 0],\n    6: [3, 0]\n}\n\n# Check if there is a path from node 2 to node 5\nresult = has_path(graph, 2, 5)\nprint(result)\n```"}, {"id": 66, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[2] = [7, 6]\ngraph[7] = [5, 8]\ngraph[6] = [0, 5, 8, 4]\ngraph[0] = [2]\ngraph[5] = [8, 4, 7, 6]\ngraph[8] = [7]\ngraph[4] = [9, 6, 0]\ngraph[3] = [2]\ngraph[1] = [5, 3]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 9 to node 4\nresult = has_path(graph, 9, 4)\nprint(\"Is there a directed path from node 9 to node 4?\", result)\n```"}, {"id": 67, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [6, 8, 5, 0, 7, 2, 1],\n    6: [3, 4, 5, 0, 2, 1],\n    8: [3, 4, 0, 7, 1],\n    5: [3, 6, 4, 7, 2, 1],\n    0: [3, 6, 4, 8, 2, 1],\n    7: [3, 4, 8, 5, 2],\n    2: [3, 6, 5, 0, 7, 1],\n    1: [3, 6, 4, 8, 5, 0, 2],\n    4: [6, 8, 5, 0, 7, 1]\n}\n\n# Check if there is a path between node 3 and node 8\nprint(has_path(graph, 3, 8))  # Output: True\n```"}, {"id": 68, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [6, 9, 8, 11, 7],\n    6: [3, 7, 12],\n    9: [3, 5],\n    8: [3, 4],\n    11: [3, 13, 5, 7, 2, 1],\n    7: [3, 6, 5, 0, 11],\n    12: [6, 10],\n    10: [13, 4, 5, 1, 12],\n    13: [10, 11],\n    4: [10, 5, 8, 0, 2],\n    5: [10, 9, 7, 11, 4],\n    1: [10, 11],\n    0: [4, 7],\n    2: [4, 11]\n}\n\n# Check if there is a path between node 6 and node 3\nprint(has_path(graph, 6, 3))  # Output: True\n```"}, {"id": 69, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4].append(3)\ngraph[3].append(6)\ngraph[0].append(7)\ngraph[7].append(0)\ngraph[7].append(3)\ngraph[7].append(5)\ngraph[1].append(5)\ngraph[1].append(4)\ngraph[5].append(4)\ngraph[5].append(0)\ngraph[5].append(3)\ngraph[6].append(4)\ngraph[6].append(0)\ngraph[6].append(7)\ngraph[8].append(7)\ngraph[8].append(4)\ngraph[2].append(1)\n\n# Check if there is a path from node 0 to node 2\nprint(has_path(graph, 0, 2))  # Output: True\n```"}, {"id": 70, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [9, 7, 5, 11, 10],\n    9: [3, 0, 7, 2, 8, 11, 6, 10],\n    7: [3, 0, 9, 4, 8, 5, 6, 10],\n    5: [3, 0, 4, 7, 2, 11, 6, 1],\n    11: [3, 0, 9, 2, 5, 6, 10],\n    10: [3, 0, 9, 4, 7, 8, 11, 6, 1],\n    0: [9, 4, 7, 2, 8, 5, 11, 6, 10],\n    4: [0, 7, 2, 8, 5, 6, 1, 10],\n    2: [0, 9, 4, 5, 11, 6],\n    8: [0, 9, 4, 7, 6, 1, 10],\n    6: [0, 9, 4, 7, 2, 8, 5, 11, 1, 10],\n    1: [4, 8, 5, 6, 10]\n}\n\n# Check if there is a path between node 3 and node 11\nresult = has_path(graph, 3, 11)\nprint(\"Is there a path between node 3 and node 11?\", result)\n```"}, {"id": 71, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [6, 0],\n    0: [5, 6, 8, 7],\n    8: [4, 1],\n    4: [1, 2, 7, 5],\n    1: [7],\n    7: [3, 0, 4],\n    3: [5, 2, 6, 7],\n    5: [4, 2, 7]\n}\n\n# Check if there is a path from node 6 to node 1\nresult = has_path(graph, 6, 1)\nprint(result)\n```"}, {"id": 72, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    9: [12, 13, 3, 7, 1],\n    12: [9],\n    13: [9, 2, 14],\n    3: [9, 4],\n    7: [9, 11, 6, 0],\n    1: [9, 8],\n    2: [13],\n    14: [13],\n    4: [3],\n    8: [1, 10],\n    10: [8],\n    11: [5, 7],\n    5: [11],\n    6: [7],\n    0: [7]\n}\n\n# Check if there is a path between node 5 and node 7\nprint(has_path(graph, 5, 7))  # Output: True\n```"}, {"id": 73, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[2] = [7, 8]\ngraph[7] = [8, 6]\ngraph[3] = [5, 7]\ngraph[5] = [4, 8, 2]\ngraph[4] = [8]\ngraph[6] = [0, 7, 2]\ngraph[0] = [4]\ngraph[1] = [3, 6, 7]\n\n# Check if there is a path from node 6 to node 3\nresult = has_path(graph, 6, 3)\nprint(result)\n```"}, {"id": 74, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [2, 3, 1, 8, 5, 7],\n    2: [6, 9],\n    3: [6, 7],\n    1: [6, 7],\n    8: [6, 7],\n    5: [6, 7, 4],\n    7: [6, 5, 9, 0, 4, 8, 3, 1],\n    9: [2, 7],\n    0: [7, 4],\n    4: [7, 5, 0]\n}\n\n# Check if there is a path between node 2 and node 0\nprint(has_path(graph, 2, 0))  # Output: True\n```"}, {"id": 75, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [1, 2],\n    1: [7, 5],\n    2: [7, 4],\n    5: [1, 3],\n    8: [0, 10],\n    0: [8, 10],\n    10: [8, 0],\n    6: [4, 3],\n    4: [6, 2],\n    3: [6, 9, 5],\n    9: [3]\n}\n\n# Check if there is a path between node 3 and node 0\nprint(has_path(graph, 3, 0))  # Output: True\n```"}, {"id": 76, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    11: [5, 12, 10, 3, 13, 6],\n    5: [11, 2, 0, 12, 8, 3, 9, 7, 4],\n    12: [11, 5, 14, 0, 1, 3, 13],\n    10: [11, 1, 8, 13, 4],\n    3: [11, 5, 14, 12, 9, 7],\n    13: [11, 0, 12, 10, 1, 8, 9, 6],\n    6: [11, 9, 7, 13],\n    2: [5, 14, 0, 4],\n    14: [2, 12, 3],\n    0: [2, 5, 12, 13],\n    4: [2, 5, 10, 8, 9, 7],\n    8: [5, 10, 13, 4],\n    9: [5, 3, 13, 6, 4],\n    7: [5, 1, 3, 6, 4],\n    1: [12, 10, 7, 13]\n}\n\n# Check if there is a path between node 11 and node 7\nresult = has_path(graph, 11, 7)\nprint(\"Is there a path between node 11 and node 7?\", result)\n```"}, {"id": 77, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[8] = [10, 6, 1, 5]\ngraph[10] = [11, 2]\ngraph[6] = [11]\ngraph[1] = [5, 10, 11, 6]\ngraph[5] = [2, 1]\ngraph[4] = [10, 0, 1, 8]\ngraph[11] = [0, 2, 6, 1, 7]\ngraph[2] = [6]\ngraph[7] = [8, 2]\ngraph[9] = [7, 4]\ngraph[3] = [6, 11]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 2 to node 3\npath_exists = has_path(graph, 2, 3)\nprint(\"Is there a directed path from node 2 to node 3?\", path_exists)\n```"}, {"id": 78, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [1, 6, 8],\n    1: [7, 3, 0, 12, 9],\n    6: [7, 2, 0, 4, 12, 5],\n    8: [7, 2, 3, 10, 9],\n    3: [1, 10, 11, 8],\n    0: [1, 6, 12],\n    12: [1, 6, 0, 11, 9],\n    9: [1, 2, 10, 4, 12, 8],\n    2: [6, 10, 4, 8, 9],\n    10: [2, 3, 5, 8, 9],\n    4: [2, 6, 5, 11, 9],\n    11: [3, 4, 12],\n    5: [6, 10, 4]\n}\n\n# Check if there is a path between node 0 and node 12\nresult = has_path(graph, 0, 12)\nprint(\"Is there a path between node 0 and node 12?\", result)\n```"}, {"id": 79, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[9].append(7)\ngraph[7].append(1)\ngraph[7].append(5)\ngraph[7].append(9)\ngraph[7].append(8)\ngraph[7].append(4)\ngraph[6].append(2)\ngraph[6].append(1)\ngraph[6].append(3)\ngraph[1].append(4)\ngraph[1].append(0)\ngraph[3].append(5)\ngraph[8].append(7)\ngraph[8].append(1)\ngraph[8].append(5)\ngraph[8].append(9)\ngraph[5].append(0)\ngraph[5].append(2)\ngraph[4].append(7)\ngraph[4].append(2)\ngraph[4].append(9)\ngraph[0].append(7)\ngraph[0].append(2)\ngraph[0].append(3)\n\n# Check if there is a path from node 2 to node 0\nprint(has_path(graph, 2, 0))\n```"}, {"id": 80, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [5, 10, 4, 8, 9],\n    5: [0, 10, 4, 3, 9],\n    10: [0, 5, 4, 3, 7, 8, 9],\n    4: [0, 5, 10, 6, 2, 7, 1, 8, 9],\n    8: [0, 10, 4, 3, 1, 9],\n    9: [0, 5, 10, 4, 7, 8],\n    3: [5, 10, 6, 2, 7, 8],\n    7: [10, 4, 3, 9],\n    6: [4, 3, 2],\n    2: [6, 4, 3],\n    1: [4, 8]\n}\n\n# Check if there is a path between node 10 and node 7\nresult = has_path(graph, 10, 7)\nprint(\"Is there a path between node 10 and node 7?\", result)\n```"}, {"id": 81, "code": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1] = [5, 7, 6, 2]\ngraph[5] = [6, 2]\ngraph[7] = [6, 0, 3]\ngraph[6] = [5]\ngraph[2] = [5]\ngraph[8] = [5, 3, 9, 0]\ngraph[3] = [7, 9, 5]\ngraph[0] = [5, 7]\ngraph[4] = [2]\n\n# Check if there is a path from node 4 to node 7\nprint(has_path(graph, 4, 7))  # Output: True\n```"}, {"id": 82, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[5] = [4, 6, 10, 11, 3]\ngraph[4] = [12, 8, 2, 9]\ngraph[6] = [9]\ngraph[10] = [0, 11, 4]\ngraph[11] = [9, 5, 4, 10]\ngraph[3] = [2, 4, 12, 6, 11, 7]\ngraph[12] = [8, 3, 9]\ngraph[8] = [5, 12]\ngraph[2] = [9, 4, 12, 7]\ngraph[9] = [5, 12, 11, 7]\ngraph[0] = [11]\ngraph[7] = [1]\ngraph[1] = [8, 11]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 11 to node 0\nresult = has_path(graph, 11, 0)\nprint(\"Is there a directed path from node 11 to node 0?\", result)\n```"}, {"id": 83, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[12].append(6)\ngraph[6].append(7)\ngraph[6].append(3)\ngraph[6].append(9)\ngraph[6].append(8)\ngraph[10].append(5)\ngraph[10].append(8)\ngraph[5].append(3)\ngraph[5].append(6)\ngraph[8].append(2)\ngraph[3].append(0)\ngraph[3].append(10)\ngraph[3].append(7)\ngraph[0].append(11)\ngraph[11].append(4)\ngraph[11].append(2)\ngraph[9].append(10)\ngraph[9].append(7)\ngraph[4].append(0)\ngraph[4].append(9)\ngraph[2].append(6)\ngraph[1].append(9)\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 7 to node 5\npath_exists = has_path(graph, 7, 5)\nprint(\"Is there a directed path from node 7 to node 5?\", path_exists)\n```"}, {"id": 84, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [11, 10, 3, 1, 0, 4, 7, 14, 13],\n    11: [10, 5, 2, 4, 14, 9, 6],\n    10: [5, 8, 12, 2, 14, 13, 6],\n    3: [8, 1, 2, 4, 7, 9, 11, 5],\n    1: [2, 0, 4, 9],\n    0: [4, 9, 10, 3, 8, 1, 2],\n    4: [9, 6, 11, 5, 3, 1, 0],\n    7: [5, 3, 12, 4],\n    14: [9, 11, 4],\n    13: [11, 1, 0, 4],\n    5: [8, 0, 6, 11],\n    2: [0, 14, 12, 1],\n    9: [10, 5, 8, 14, 13],\n    8: [1, 4, 13, 6],\n    12: [14, 13, 9, 6, 3]\n}\n\n# Check if there is a path from node 0 to node 3\nresult = has_path(graph, 0, 3)\nprint(result)\n```"}, {"id": 85, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[13] = [11]\ngraph[11] = [14]\ngraph[5] = [4, 14]\ngraph[4] = [6, 7]\ngraph[6] = [11, 1, 0, 13, 2]\ngraph[7] = [0, 5]\ngraph[9] = [11]\ngraph[8] = [6, 14]\ngraph[12] = [6, 1, 0, 13, 2]\ngraph[1] = [13]\ngraph[0] = [13, 5, 12, 1]\ngraph[3] = [5]\ngraph[10] = [8, 12, 14]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 9 to node 1\npath_exists = has_path(graph, 9, 1)\nprint(\"Is there a directed path from node 9 to node 1?\", path_exists)\n```"}, {"id": 86, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [6],\n    6: [7, 1],\n    1: [6, 3, 5],\n    0: [4],\n    4: [0, 2],\n    2: [4, 3, 5],\n    3: [1, 2],\n    5: [1, 2]\n}\n\n# Check if there is a path between node 4 and node 6\nprint(has_path(graph, 4, 6))  # Output: True\n```"}, {"id": 87, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[5] = [10, 0, 1, 3, 8]\ngraph[10] = [7, 9, 6]\ngraph[0] = [7, 11]\ngraph[1] = [4, 7, 2]\ngraph[3] = [4, 5, 2]\ngraph[7] = [6]\ngraph[9] = [11, 5, 7]\ngraph[11] = [4]\ngraph[2] = [9, 8, 10, 0, 7]\ngraph[4] = [10, 0, 2, 3]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 6 to node 3\npath_exists = has_path(graph, 6, 3)\nprint(\"Is there a directed path from node 6 to node 3?\", path_exists)\n```"}, {"id": 88, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [5, 3],\n    5: [1, 9],\n    3: [1, 8],\n    9: [5],\n    6: [0, 7],\n    0: [6, 2],\n    7: [6, 4, 10],\n    2: [0, 8],\n    4: [7, 8],\n    8: [4, 2, 3],\n    10: [7]\n}\n\n# Check if there is a path between node 8 and node 5\nprint(has_path(graph, 8, 5))  # Output: True\n```"}, {"id": 89, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1] = [4, 5]\ngraph[4] = [9, 7, 8]\ngraph[5] = [2]\ngraph[9] = [2, 4]\ngraph[7] = [8, 6]\ngraph[8] = [1, 4, 9]\ngraph[6] = [3]\ngraph[2] = [8, 0]\ngraph[0] = [5, 4, 8]\n\n# Check if there is a path from node 3 to node 8\nprint(has_path(graph, 3, 8))  # Output: True\n```"}, {"id": 90, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [4, 5],\n    4: [0],\n    5: [0, 1, 6],\n    1: [5, 3],\n    6: [5, 2],\n    3: [1, 7],\n    2: [6],\n    7: [3]\n}\n\n# Check if there is a path between node 1 and node 3\nprint(has_path(graph, 1, 3))  # Output: True\n```"}, {"id": 91, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [8, 6, 3],\n    8: [7],\n    6: [7, 2, 5],\n    3: [7, 1],\n    9: [4, 0],\n    4: [9, 0],\n    0: [9, 4],\n    2: [5, 6],\n    5: [2, 6],\n    1: [3]\n}\n\n# Check if there is a path between node 5 and node 4\nprint(has_path(graph, 5, 4))  # Output: True\n```"}, {"id": 92, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [7, 1],\n    7: [12, 0],\n    1: [12, 14],\n    0: [7, 9],\n    9: [0, 10],\n    6: [13],\n    13: [6, 14],\n    14: [13, 1],\n    4: [3, 10],\n    3: [4, 10],\n    10: [4, 3, 9, 8],\n    11: [2, 5],\n    2: [11, 8],\n    5: [11],\n    8: [2, 10]\n}\n\n# Check if there is a path between node 2 and node 7\nprint(has_path(graph, 2, 7))  # Output: True\n```"}, {"id": 93, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1] = [7, 6]\ngraph[7] = [6, 5, 1]\ngraph[6] = [5, 7]\ngraph[3] = [7, 2, 0]\ngraph[0] = [1, 3]\ngraph[5] = [1, 7, 2]\ngraph[4] = [1, 3]\n\n# Check if there is a path from node 5 to node 0\nresult = has_path(graph, 5, 0)\nprint(result)\n```"}, {"id": 94, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[4] = [8, 0, 1]\ngraph[0] = [4, 7]\ngraph[1] = [2, 10, 8]\ngraph[5] = [12, 2]\ngraph[12] = [7, 1]\ngraph[6] = [9, 3, 0, 5]\ngraph[9] = [4, 2, 5, 8]\ngraph[3] = [12]\ngraph[10] = [11, 12]\ngraph[11] = [2, 6, 7]\ngraph[7] = [9, 0, 6, 10]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 12 to node 0\nresult = has_path(graph, 12, 0)\nprint(\"Is there a directed path from node 12 to node 0?\", result)\n```"}, {"id": 95, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    9: [8, 7],\n    8: [9, 6, 2],\n    7: [9],\n    6: [8, 2],\n    2: [8, 6],\n    5: [4, 10],\n    4: [5, 1],\n    10: [5, 0],\n    1: [4, 3],\n    0: [10, 3],\n    3: [0, 1]\n}\n\n# Check if there is a path between node 6 and node 1\nprint(has_path(graph, 6, 1))  # Output: True\n```"}, {"id": 96, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[5].append(0)\ngraph[0].append(1)\ngraph[0].append(6)\ngraph[0].append(2)\ngraph[0].append(8)\ngraph[2].append(4)\ngraph[2].append(5)\ngraph[4].append(3)\ngraph[4].append(0)\ngraph[4].append(9)\ngraph[4].append(6)\ngraph[4].append(7)\ngraph[7].append(8)\ngraph[7].append(1)\ngraph[7].append(5)\ngraph[8].append(9)\ngraph[8].append(5)\ngraph[1].append(9)\ngraph[9].append(6)\ngraph[9].append(5)\ngraph[9].append(4)\ngraph[3].append(1)\ngraph[3].append(6)\ngraph[3].append(7)\ngraph[6].append(5)\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited):\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, v, visited):\n                return True\n    return False\n\n# Check if there is a path from node 4 to node 9\nvisited = set()\nresult = has_path(graph, 4, 9, visited)\nprint(\"Is there a directed path from node 4 to node 9?\", result)\n```"}, {"id": 97, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1] = [7, 10, 9]\ngraph[10] = [8, 4]\ngraph[9] = [5, 4, 7]\ngraph[6] = [0, 8, 7]\ngraph[0] = [8]\ngraph[8] = [2, 4]\ngraph[4] = [0, 10, 2]\ngraph[2] = [1]\ngraph[3] = [7]\ngraph[5] = [4, 10]\n\n# Check if there is a path from node 7 to node 6\nresult = has_path(graph, 7, 6)\nprint(result)\n```"}, {"id": 98, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [12, 2, 5, 9, 10, 4, 6],\n    12: [1, 7, 2, 9, 10, 8, 4],\n    2: [1, 7, 11, 12, 5, 10, 0, 8, 3],\n    5: [1, 11, 2, 8, 4, 6, 3],\n    9: [1, 7, 11, 12, 10, 0, 6],\n    10: [1, 11, 12, 2, 9],\n    4: [1, 7, 11, 12, 5, 8],\n    6: [1, 7, 11, 5, 9, 0, 3],\n    7: [12, 2, 9, 0, 8, 4, 6],\n    0: [7, 11, 2, 9, 8, 6, 3],\n    8: [7, 12, 2, 5, 0, 4],\n    11: [2, 5, 9, 10, 0, 4, 6],\n    3: [2, 5, 0, 6]\n}\n\n# Check if there is a path between node 4 and node 11\nresult = has_path(graph, 4, 11)\nprint(\"Is there a path between node 4 and node 11?\", result)\n```"}, {"id": 99, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [1, 3],\n    1: [4, 6],\n    3: [4],\n    6: [1, 10, 9, 8],\n    13: [12, 0],\n    12: [13, 14, 2],\n    0: [13, 11],\n    14: [12],\n    2: [12, 11, 5],\n    10: [6, 8],\n    9: [6],\n    8: [6, 10],\n    11: [0, 2],\n    5: [2, 7],\n    7: [5]\n}\n\n# Check if there is a path between node 9 and node 12\nresult = has_path(graph, 9, 12)\nprint(result)\n```"}, {"id": 100, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [6, 12],\n    6: [4, 12],\n    12: [4, 6, 2],\n    2: [12, 7],\n    7: [2, 8, 5],\n    9: [0, 13],\n    0: [9, 10],\n    13: [9, 3],\n    10: [0, 8],\n    11: [1],\n    1: [11, 3],\n    3: [1, 13],\n    8: [10, 7],\n    5: [7]\n}\n\n# Check if there is a path between node 12 and node 2\nprint(has_path(graph, 12, 2))  # Output: True\n```"}, {"id": 101, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[4] = [5]\ngraph[5] = [8, 3]\ngraph[1] = [8, 6, 7, 5]\ngraph[8] = [9, 5, 4]\ngraph[6] = [4]\ngraph[7] = [4, 8, 3]\ngraph[9] = [3, 5, 10, 1, 8]\ngraph[0] = [7]\ngraph[3] = [5]\ngraph[10] = [1, 0, 7, 5]\ngraph[2] = [8]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 3 to node 2\nresult = has_path(graph, 3, 2)\nprint(\"Is there a directed path from node 3 to node 2?\", result)\n```"}, {"id": 102, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [8, 0],\n    8: [2, 10],\n    0: [2],\n    10: [8, 6, 3],\n    7: [4, 9],\n    4: [7, 3],\n    9: [7, 5],\n    3: [4, 10, 11],\n    6: [10, 1],\n    1: [6, 12],\n    5: [11, 9],\n    11: [5, 3],\n    12: [1]\n}\n\n# Check if there is a path between node 8 and node 4\nprint(has_path(graph, 8, 4))  # Output: True\n```"}, {"id": 103, "code": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[0] = [10, 8, 14]\ngraph[10] = [12, 13, 2, 4]\ngraph[8] = [11]\ngraph[14] = [3, 8]\ngraph[7] = [4, 5, 12]\ngraph[5] = [9, 7, 10]\ngraph[12] = [13]\ngraph[13] = [11]\ngraph[11] = [12, 13]\ngraph[2] = [10]\ngraph[3] = [8, 6]\ngraph[6] = [12, 14, 9, 1, 13, 2]\ngraph[9] = [12, 14]\ngraph[1] = [4, 3, 5, 14]\n\n# Check if there is a path from node 8 to node 0\nresult = has_path(graph, 8, 0)\nprint(result)\n```"}, {"id": 104, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [7, 4, 0, 2],\n    7: [9],\n    4: [5, 2],\n    0: [11, 7],\n    2: [3, 4, 8, 5],\n    6: [12, 1, 3],\n    12: [7],\n    1: [4, 8],\n    9: [8],\n    8: [2, 12, 9, 4, 0],\n    10: [5, 12],\n    5: [4],\n    11: [5, 9, 4]\n}\n\n# Check if there is a path from node 9 to node 12\nresult = has_path(graph, 9, 12)\nprint(result)\n```"}, {"id": 105, "code": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[6].append(5)\ngraph[5].append(3)\ngraph[5].append(6)\ngraph[4].append(2)\ngraph[4].append(9)\ngraph[4].append(8)\ngraph[2].append(1)\ngraph[2].append(8)\ngraph[2].append(4)\ngraph[9].append(8)\ngraph[9].append(13)\ngraph[8].append(6)\ngraph[8].append(4)\ngraph[12].append(11)\ngraph[12].append(10)\ngraph[12].append(7)\ngraph[11].append(2)\ngraph[11].append(1)\ngraph[11].append(9)\ngraph[11].append(0)\ngraph[10].append(8)\ngraph[7].append(0)\ngraph[7].append(11)\ngraph[13].append(5)\ngraph[1].append(3)\ngraph[1].append(2)\ngraph[3].append(8)\n\n# Check if there is a path from node 5 to node 7\nprint(has_path(graph, 5, 7))  # Output: True\n```"}, {"id": 106, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    10: [0, 5],\n    0: [10, 8],\n    5: [10, 6],\n    8: [0, 12],\n    2: [4, 1, 11],\n    4: [2, 3],\n    1: [2],\n    11: [2, 12],\n    3: [4, 6, 9],\n    12: [8, 11, 7],\n    7: [12],\n    6: [3, 5],\n    9: [3]\n}\n\n# Check if there is a path between node 8 and node 4\nresult = has_path(graph, 8, 4)\nprint(result)\n```"}, {"id": 107, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [3, 1],\n    3: [5, 10],\n    1: [5, 8],\n    10: [3, 0],\n    2: [6, 9],\n    6: [2, 9],\n    9: [2, 6, 4],\n    4: [9],\n    0: [10, 7],\n    7: [0, 8],\n    8: [1, 7]\n}\n\n# Check if there is a path between node 3 and node 4\nprint(has_path(graph, 3, 4))  # Output: True\n```"}, {"id": 108, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[0] = [8, 7, 2]\ngraph[8] = [5]\ngraph[7] = [2, 5, 8, 3]\ngraph[2] = [5, 9, 3]\ngraph[5] = [3, 7, 0]\ngraph[3] = [8, 9]\ngraph[6] = [3, 7, 4, 0, 8]\ngraph[4] = [8, 6, 7]\ngraph[9] = [1]\ngraph[1] = [2, 6]\n\n# Function to perform DFS and check if there is a path from src to dest\ndef dfs(src, dest, visited):\n    if src == dest:\n        return True\n    visited.add(src)\n    for neighbor in graph[src]:\n        if neighbor not in visited:\n            if dfs(neighbor, dest, visited):\n                return True\n    return False\n\n# Check if there is a path from node 9 to node 0\nvisited = set()\nresult = dfs(9, 0, visited)\nprint(\"Is there a directed path from node 9 to node 0?\", result)\n```"}, {"id": 109, "code": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[10].append(4)\ngraph[4].append(6)\ngraph[4].append(5)\ngraph[4].append(12)\ngraph[7].append(13)\ngraph[7].append(12)\ngraph[13].append(11)\ngraph[13].append(1)\ngraph[13].append(9)\ngraph[13].append(2)\ngraph[13].append(5)\ngraph[13].append(0)\ngraph[0].append(5)\ngraph[0].append(10)\ngraph[5].append(7)\ngraph[5].append(3)\ngraph[5].append(13)\ngraph[5].append(4)\ngraph[5].append(9)\ngraph[5].append(2)\ngraph[3].append(13)\ngraph[3].append(11)\ngraph[3].append(2)\ngraph[3].append(10)\ngraph[11].append(8)\ngraph[11].append(0)\ngraph[2].append(6)\ngraph[2].append(1)\ngraph[2].append(8)\ngraph[2].append(9)\ngraph[1].append(4)\ngraph[1].append(9)\ngraph[9].append(6)\ngraph[9].append(11)\ngraph[9].append(4)\ngraph[8].append(2)\ngraph[8].append(0)\ngraph[8].append(13)\ngraph[6].append(11)\ngraph[6].append(1)\ngraph[6].append(9)\ngraph[6].append(2)\ngraph[14].append(3)\ngraph[14].append(13)\ngraph[14].append(9)\ngraph[14].append(6)\n\n# Check if there is a path from node 6 to node 14\nprint(has_path(graph, 6, 14))\n```"}, {"id": 110, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [5, 8, 0, 4, 7],\n    5: [6, 10, 3, 7],\n    8: [6, 9, 0, 3],\n    0: [6, 8, 3, 2],\n    4: [6, 2, 7],\n    7: [6, 5, 10, 4, 1],\n    10: [5, 9, 7],\n    3: [5, 8, 11, 0, 1],\n    9: [8, 10, 2, 1],\n    2: [9, 11, 0, 1, 4],\n    1: [9, 3, 2, 7],\n    11: [3, 2]\n}\n\n# Check if there is a path between node 1 and node 8\nprint(has_path(graph, 1, 8))  # Output: True\n```"}, {"id": 111, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [12, 6],\n    12: [2, 3, 0],\n    6: [2],\n    3: [12, 11],\n    0: [12, 8],\n    5: [9, 14, 13],\n    9: [5],\n    14: [5, 7, 13],\n    13: [5, 14],\n    10: [8, 1],\n    8: [10, 0],\n    1: [10, 11],\n    4: [7],\n    7: [4, 14],\n    11: [3, 1]\n}\n\n# Check if there is a path between node 4 and node 11\nresult = has_path(graph, 4, 11)\nprint(result)\n```"}, {"id": 112, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[12] = [8, 0]\ngraph[8] = [0]\ngraph[0] = [12]\ngraph[4] = [2]\ngraph[2] = [10]\ngraph[1] = [14, 13, 4]\ngraph[14] = [2, 5, 13, 10]\ngraph[6] = [2]\ngraph[10] = [14]\ngraph[5] = [2]\ngraph[9] = [3, 11]\ngraph[3] = [2, 11]\ngraph[11] = [3]\ngraph[7] = [14]\n\n# Function to perform DFS and check if there is a path from start to end\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 4 to node 5\nstart_node = 4\nend_node = 5\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 4 to node 5?\", result)\n```"}, {"id": 113, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    13: [3, 5],\n    3: [13, 10],\n    5: [13, 14],\n    10: [3, 0],\n    12: [9, 11],\n    9: [12, 4],\n    11: [12, 4],\n    4: [9, 11],\n    6: [8, 2],\n    8: [6, 14],\n    2: [6, 0, 7],\n    14: [8, 5],\n    0: [2, 10],\n    7: [2, 1],\n    1: [7]\n}\n\n# Check if there is a path between node 3 and node 4\nprint(has_path(graph, 3, 4))  # Output: True\n```"}, {"id": 114, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [0, 11, 10, 9],\n    0: [6, 11, 3, 9],\n    11: [6, 0, 8, 10, 1, 5],\n    10: [6, 11, 8, 2, 1, 5],\n    9: [6, 0, 12, 3, 2, 4],\n    3: [0, 2, 9, 1],\n    8: [11, 10, 1],\n    1: [11, 8, 10, 3, 2, 7, 5],\n    5: [11, 12, 10, 1],\n    12: [7, 9, 5],\n    7: [12, 1],\n    2: [10, 3, 9, 1],\n    4: [9]\n}\n\n# Check if there is a path between node 7 and node 5\nresult = has_path(graph, 7, 5)\nprint(\"Is there a path between node 7 and node 5?\", result)\n```"}, {"id": 115, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[6] = [2, 1]\ngraph[2] = [7]\ngraph[1] = [7]\ngraph[4] = [5, 7]\ngraph[5] = [4]\ngraph[7] = [1]\ngraph[0] = [8, 1]\ngraph[8] = [7, 1]\ngraph[3] = [1]\n\n# Check if there is a path from node 5 to node 0\nresult = has_path(graph, 5, 0)\nprint(result)\n```"}, {"id": 116, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [1, 4, 6, 3, 0],\n    1: [7, 3, 2],\n    4: [7, 6],\n    6: [7, 4, 0, 5, 2],\n    3: [7, 1, 5],\n    0: [7, 6],\n    2: [1, 6],\n    5: [3, 6]\n}\n\n# Check if there is a path between node 7 and node 0\nprint(has_path(graph, 7, 0))  # Output: True\n```"}, {"id": 117, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[3] = [14, 9, 10, 6, 0]\ngraph[14] = [13, 11, 3]\ngraph[9] = [7, 12, 3]\ngraph[10] = [9, 4]\ngraph[6] = [11, 13]\ngraph[0] = [3, 2]\ngraph[13] = [3, 9]\ngraph[11] = [7]\ngraph[12] = [14, 9, 4, 10]\ngraph[4] = [2]\ngraph[2] = [5, 6, 9, 8]\ngraph[8] = [0]\ngraph[5] = [11, 12, 14, 8]\ngraph[1] = [0, 10, 11]\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Check if there is a path from node 8 to node 1\nresult = has_path(graph, 8, 1)\nprint(\"Is there a directed path from node 8 to node 1?\", result)\n```"}, {"id": 118, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    11: [4, 10, 2, 5, 9, 1, 14, 7, 8],\n    4: [11, 6, 7, 2, 14, 12, 0, 10],\n    10: [11, 4, 0, 9, 12, 8, 14],\n    2: [11, 4, 9, 8, 14, 6],\n    5: [11, 3],\n    9: [11, 10, 2],\n    1: [11, 14, 13, 12],\n    14: [11, 4, 10, 0, 2, 6, 13, 3, 1],\n    7: [11, 4, 13, 8],\n    8: [11, 10, 2, 7, 3],\n    6: [4, 2, 14],\n    12: [4, 10, 1],\n    0: [4, 10, 14],\n    13: [14, 7, 1],\n    3: [14, 8, 5]\n}\n\n# Check if there is a path between node 0 and node 6\nresult = has_path(graph, 0, 6)\nprint(result)\n```"}, {"id": 119, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[13].append(12)\ngraph[12].append(5)\ngraph[1].append(10)\ngraph[10].append(12)\ngraph[10].append(1)\ngraph[4].append(3)\ngraph[3].append(10)\ngraph[3].append(2)\ngraph[6].append(10)\ngraph[6].append(7)\ngraph[6].append(3)\ngraph[6].append(9)\ngraph[7].append(0)\ngraph[7].append(9)\ngraph[5].append(7)\ngraph[5].append(4)\ngraph[0].append(12)\ngraph[0].append(9)\ngraph[0].append(4)\ngraph[0].append(6)\ngraph[11].append(9)\ngraph[8].append(1)\ngraph[8].append(5)\ngraph[8].append(10)\ngraph[8].append(12)\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 4 to node 11\nresult = has_path(graph, 4, 11)\nprint(\"Is there a directed path from node 4 to node 11?\", result)\n```"}, {"id": 120, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [1, 5, 3],\n    1: [7, 0],\n    5: [7, 6, 3],\n    3: [7, 5],\n    0: [1, 4],\n    6: [5],\n    2: [4],\n    4: [2, 0]\n}\n\n# Check if there is a path between node 0 and node 2\nprint(has_path(graph, 0, 2))  # Output: True\n```"}, {"id": 121, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[10] = [3, 2, 6]\ngraph[3] = [5, 9, 6]\ngraph[6] = [0, 2, 1]\ngraph[0] = [12, 9]\ngraph[12] = [5, 9, 6]\ngraph[9] = [6, 2, 5, 8]\ngraph[13] = [12, 1, 9, 0]\ngraph[1] = [11, 10, 0]\ngraph[5] = [11]\ngraph[7] = [0]\ngraph[4] = [2, 11, 10]\ngraph[11] = [10, 12]\ngraph[8] = [11, 2, 1]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 2 to node 5\npath_exists = has_path(graph, 2, 5)\nprint(\"Is there a directed path from node 2 to node 5?\", path_exists)\n```"}, {"id": 122, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [7],\n    7: [0, 9, 3],\n    9: [7, 10, 1],\n    3: [7],\n    8: [10],\n    10: [8, 6, 11, 9, 5],\n    6: [10],\n    11: [10, 4],\n    5: [10, 1],\n    4: [2, 11],\n    2: [4],\n    1: [5, 9]\n}\n\n# Check if there is a path between node 1 and node 10\nprint(has_path(graph, 1, 10))  # Output: True\n```"}, {"id": 123, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [6, 7],\n    6: [3, 7, 5],\n    7: [3, 6],\n    5: [6],\n    10: [2, 1, 9],\n    2: [10],\n    1: [10, 0],\n    9: [10, 4],\n    0: [1, 4, 8],\n    4: [0, 9],\n    8: [0]\n}\n\n# Check if there is a path between node 3 and node 4\nprint(has_path(graph, 3, 4))  # Output: True\n```"}, {"id": 124, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [8, 7, 1],\n    8: [5, 6, 3, 0],\n    7: [5],\n    1: [5, 4, 2],\n    6: [8],\n    3: [8, 0],\n    0: [8, 3],\n    4: [1],\n    2: [1]\n}\n\n# Check if there is a path between node 4 and node 6\nprint(has_path(graph, 4, 6))  # Output: True\n```"}, {"id": 125, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[2] = [1, 6, 3, 0]\ngraph[1] = [6, 7, 3, 2]\ngraph[6] = [5]\ngraph[3] = [8, 1]\ngraph[8] = [6]\ngraph[7] = [0]\ngraph[5] = [0, 4]\ngraph[4] = [3, 5, 1, 6]\n\n# Check if there is a path from node 7 to node 4\nresult = has_path(graph, 7, 4)\nprint(result)\n```"}, {"id": 126, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [6, 5, 7, 3, 8, 0, 9, 2],\n    6: [1, 9, 5],\n    5: [1, 6, 8, 3, 9, 4],\n    7: [1, 8, 4, 3, 2],\n    3: [1, 5, 7],\n    8: [1, 5, 7, 9, 4, 2],\n    0: [1],\n    9: [1, 6, 5, 8],\n    2: [1, 8, 7],\n    4: [5, 8, 7]\n}\n\n# Check if there is a path between node 7 and node 3\nprint(has_path(graph, 7, 3))  # Output: True\n```"}, {"id": 127, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[6] = [3, 9]\ngraph[3] = [6]\ngraph[9] = [2]\ngraph[0] = [7, 10, 9]\ngraph[7] = [10, 5]\ngraph[10] = [5, 0]\ngraph[1] = [4]\ngraph[4] = [2]\ngraph[5] = [9, 2]\ngraph[8] = [1, 2, 5]\n\n# Check if there is a path from node 1 to node 3\nresult = has_path(graph, 1, 3)\nprint(result)\n```"}, {"id": 128, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [11, 8, 7],\n    11: [4, 0, 9],\n    8: [4, 10],\n    7: [4, 6],\n    0: [11, 2],\n    9: [11, 2],\n    2: [0, 9],\n    10: [8],\n    5: [6, 1],\n    6: [5, 3, 7],\n    1: [5],\n    3: [6]\n}\n\n# Check if there is a path between node 6 and node 3\nprint(has_path(graph, 6, 3))  # Output: True\n```"}, {"id": 129, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [0, 2],\n    0: [5, 7],\n    2: [5, 4],\n    7: [0, 6],\n    1: [12, 13, 3],\n    12: [1, 10, 11],\n    13: [1, 10],\n    3: [1, 9],\n    10: [12, 13],\n    11: [12],\n    4: [2, 8],\n    6: [7, 8],\n    9: [3],\n    8: [4, 6]\n}\n\n# Check if there is a path between node 0 and node 10\nprint(has_path(graph, 0, 10))  # Output: True\n```"}, {"id": 130, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [4, 7, 2, 3],\n    4: [5, 2],\n    7: [5, 1, 6],\n    2: [5, 4, 9, 8, 3],\n    3: [5, 0, 2, 8, 6],\n    0: [9, 3, 6],\n    9: [0, 2],\n    6: [0, 7, 3],\n    1: [7, 8],\n    8: [1, 2, 3]\n}\n\n# Check if there is a path between node 3 and node 7\nprint(has_path(graph, 3, 7))  # Output: True\n```"}, {"id": 131, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[7] = [4, 5]\ngraph[4] = [1]\ngraph[5] = [0, 4]\ngraph[1] = [0, 7, 4]\ngraph[0] = [7]\ngraph[6] = [8, 3, 9, 7]\ngraph[8] = [9, 4, 5]\ngraph[3] = [9, 4]\ngraph[2] = [8, 3, 4]\n\n# Check if there is a path from node 1 to node 3\nresult = has_path(graph, 1, 3)\nprint(result)\n```"}, {"id": 132, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [0, 12, 9, 1, 11, 2, 3, 8, 6],\n    0: [4],\n    12: [4],\n    9: [4, 10, 5],\n    1: [4, 13],\n    11: [4],\n    2: [4],\n    3: [4],\n    8: [4],\n    6: [4, 7],\n    10: [9],\n    5: [9, 14],\n    13: [1],\n    14: [5],\n    7: [6]\n}\n\n# Check if there is a path between node 10 and node 8\nresult = has_path(graph, 10, 8)\nprint(result)\n```"}, {"id": 133, "code": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[0].append(4)\ngraph[4].append(0)\ngraph[6].append(2)\ngraph[6].append(4)\ngraph[6].append(0)\ngraph[2].append(5)\ngraph[5].append(3)\ngraph[5].append(0)\ngraph[5].append(6)\ngraph[3].append(0)\ngraph[3].append(2)\ngraph[7].append(0)\ngraph[7].append(6)\ngraph[7].append(5)\ngraph[1].append(3)\ngraph[1].append(0)\ngraph[1].append(5)\ngraph[8].append(4)\ngraph[8].append(2)\ngraph[8].append(7)\ngraph[8].append(3)\n\n# Check if there is a path from node 3 to node 8\nprint(has_path(graph, 3, 8))  # Output: True\n```"}, {"id": 134, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [3, 2, 10, 0, 6],\n    3: [8],\n    2: [8],\n    10: [8, 1],\n    0: [8, 4, 9],\n    6: [8],\n    4: [0, 5],\n    9: [0, 7],\n    5: [4],\n    1: [10],\n    7: [9]\n}\n\n# Check if there is a path between node 6 and node 10\nresult = has_path(graph, 6, 10)\nprint(result)\n```"}, {"id": 135, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[2].append(0)\ngraph[0].append(5)\ngraph[0].append(1)\ngraph[0].append(8)\ngraph[5].append(1)\ngraph[5].append(6)\ngraph[5].append(8)\ngraph[1].append(3)\ngraph[1].append(6)\ngraph[8].append(2)\ngraph[8].append(3)\ngraph[7].append(3)\ngraph[3].append(1)\ngraph[6].append(8)\ngraph[6].append(2)\ngraph[6].append(3)\ngraph[4].append(2)\n\n# Check if there is a path from node 5 to node 7\nresult = has_path(graph, 5, 7)\nprint(\"Is there a directed path from node 5 to node 7?\", result)\n```"}, {"id": 136, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [6, 9, 4, 3],\n    6: [8, 12, 0],\n    9: [8, 7, 5],\n    4: [8],\n    3: [8, 10, 2, 11],\n    12: [6],\n    0: [6],\n    7: [9],\n    5: [9, 1],\n    1: [5],\n    10: [3],\n    2: [3],\n    11: [3]\n}\n\n# Check if there is a path between node 0 and node 7\nprint(has_path(graph, 0, 7))  # Output: True\n```"}, {"id": 137, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[7] = [3]\ngraph[3] = [10, 8, 13]\ngraph[10] = [2, 11]\ngraph[8] = [3, 14]\ngraph[13] = [10]\ngraph[12] = [14, 6, 0]\ngraph[14] = [1, 13, 9]\ngraph[6] = [7, 3]\ngraph[1] = [8, 13, 7, 12]\ngraph[9] = [14, 8]\ngraph[11] = [6, 12]\ngraph[2] = [10, 1]\ngraph[5] = [2, 4, 1]\ngraph[4] = [14, 6]\n\n# Function to perform DFS and check if there is a path from start to end\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 11 to node 5\nstart_node = 11\nend_node = 5\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 11 to node 5?\", result)\n```"}, {"id": 138, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    9: [6, 13, 7, 12, 2],\n    6: [9, 3],\n    13: [9, 5, 1, 4, 11, 3, 10, 0, 8],\n    7: [9, 0, 11],\n    12: [9, 14, 0],\n    2: [9, 3, 0],\n    3: [6, 13, 2],\n    5: [13, 1],\n    1: [13, 5, 10],\n    4: [13, 8, 0, 10, 14],\n    11: [13, 7],\n    10: [13, 1, 4],\n    0: [13, 2, 4, 7, 12],\n    8: [13, 4],\n    14: [4, 12]\n}\n\n# Check if there is a path between node 4 and node 0\nresult = has_path(graph, 4, 0)\nprint(result)\n```"}, {"id": 139, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    11: [3, 12, 0],\n    3: [11, 9],\n    12: [11, 1],\n    0: [11, 9],\n    9: [3, 0],\n    10: [4],\n    4: [10, 13],\n    13: [4, 1],\n    6: [7, 2],\n    7: [6, 8],\n    2: [6, 8],\n    8: [7, 2],\n    1: [12, 5, 13],\n    5: [1]\n}\n\n# Check if there is a path between node 9 and node 8\nresult = has_path(graph, 9, 8)\nprint(result)\n```"}, {"id": 140, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [5, 2, 1, 8],\n    5: [0],\n    2: [0],\n    1: [0],\n    8: [0, 7],\n    3: [7, 4, 6],\n    7: [3, 8],\n    4: [3],\n    6: [3]\n}\n\n# Check if there is a path between node 7 and node 6\nprint(has_path(graph, 7, 6))  # Output: True\n```"}, {"id": 141, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[8] = [2, 6, 3]\ngraph[2] = [10, 11]\ngraph[6] = [3, 8]\ngraph[3] = [10, 8, 6]\ngraph[4] = [5]\ngraph[5] = [3, 10]\ngraph[10] = [1, 5, 11, 6]\ngraph[1] = [7]\ngraph[7] = [0, 4]\ngraph[0] = [3, 7]\ngraph[9] = [5]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 4 to node 9\nresult = has_path(graph, 4, 9)\nprint(\"Is there a directed path from node 4 to node 9?\", result)\n```"}, {"id": 142, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [10, 4, 12, 9, 5, 13],\n    10: [1, 0, 3, 9],\n    4: [1, 12, 2, 5],\n    12: [1, 0, 4, 8, 13],\n    9: [1, 10, 0, 6, 3],\n    5: [1, 0, 4, 6, 7, 8],\n    13: [1, 12, 3, 7],\n    11: [3, 7],\n    3: [11, 10, 9, 7, 13],\n    7: [11, 6, 2, 3, 5, 13],\n    0: [10, 6, 12, 9, 5],\n    6: [0, 9, 5, 7],\n    2: [4, 7],\n    8: [12, 5]\n}\n\n# Check if there is a path between node 12 and node 3\nresult = has_path(graph, 12, 3)\nprint(\"Is there a path between node 12 and node 3?\", result)\n```"}, {"id": 143, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [2, 7],\n    2: [8, 7],\n    7: [8, 2],\n    1: [3, 0],\n    3: [1, 6, 4],\n    0: [1, 4],\n    6: [3],\n    4: [3, 0, 5],\n    5: [4]\n}\n\n# Check if there is a path between node 4 and node 7\nprint(has_path(graph, 4, 7))  # Output: True\n```"}, {"id": 144, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [1, 0, 2],\n    1: [4, 5],\n    0: [4, 10],\n    2: [4],\n    5: [1, 8, 7],\n    9: [8, 10],\n    8: [9, 5],\n    10: [9, 0],\n    7: [5, 3],\n    3: [7, 6],\n    6: [3]\n}\n\n# Check if there is a path between node 0 and node 9\nprint(has_path(graph, 0, 9))  # Output: True\n```"}, {"id": 145, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1] = [3, 6]\ngraph[3] = [1, 8]\ngraph[6] = [8]\ngraph[7] = [5, 6, 4]\ngraph[5] = [0, 8, 4]\ngraph[4] = [5, 8]\ngraph[0] = [3, 4]\ngraph[8] = [6, 0]\ngraph[2] = [1]\n\n# Check if there is a path from node 3 to node 2\nresult = has_path(graph, 3, 2)\nprint(result)\n```"}, {"id": 146, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[6] = [4, 2, 5, 0]\ngraph[4] = [7, 2, 5, 3]\ngraph[2] = [6, 4, 1]\ngraph[5] = [0, 4, 2]\ngraph[0] = [4, 2]\ngraph[7] = [1, 5, 3]\ngraph[3] = [0]\ngraph[1] = [0, 6, 4]\n\n# Check if there is a path from node 4 to node 3\nprint(has_path(graph, 4, 3))\n```"}, {"id": 147, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [3, 0],\n    3: [9, 10, 12, 11],\n    0: [9],\n    10: [12, 5, 9],\n    12: [3, 9, 10],\n    5: [10, 2, 0],\n    9: [3, 0, 7],\n    11: [0, 9, 10],\n    8: [7],\n    2: [5],\n    4: [7, 5],\n    6: [1, 0, 5, 4]\n}\n\n# Check if there is a path from node 11 to node 1\nresult = has_path(graph, 11, 1)\nprint(result)\n```"}, {"id": 148, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [6, 13, 11],\n    6: [12, 2],\n    13: [12, 8],\n    11: [12, 4],\n    2: [6, 1],\n    5: [8],\n    8: [5, 10, 13],\n    10: [8, 14],\n    1: [2, 4],\n    4: [1, 11],\n    14: [10],\n    3: [0, 7],\n    0: [3, 9, 7],\n    7: [3, 0],\n    9: [0]\n}\n\n# Check if there is a path between node 14 and node 6\nresult = has_path(graph, 14, 6)\nprint(result)\n```"}, {"id": 149, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[2].append(0)\ngraph[7].append(8)\ngraph[8].append(1)\ngraph[8].append(6)\ngraph[8].append(2)\ngraph[1].append(5)\ngraph[1].append(6)\ngraph[1].append(2)\ngraph[1].append(3)\ngraph[6].append(0)\ngraph[6].append(1)\ngraph[3].append(4)\ngraph[3].append(7)\ngraph[4].append(0)\ngraph[5].append(2)\ngraph[5].append(7)\n\n# Check if there is a path from node 2 to node 5\nprint(has_path(graph, 2, 5))  # Output: True\n```"}, {"id": 150, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [5, 8, 3],\n    5: [7, 0],\n    8: [7, 1, 0, 3, 4],\n    3: [7, 0, 8, 2, 4],\n    0: [5, 1, 8, 3, 4],\n    1: [0, 8],\n    6: [2, 4],\n    2: [6, 3, 4],\n    4: [6, 0, 8, 2, 3]\n}\n\n# Check if there is a path between node 7 and node 8\nprint(has_path(graph, 7, 8))  # Output: True\n```"}, {"id": 151, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[3] = [0, 4]\ngraph[0] = [2, 6]\ngraph[1] = [7]\ngraph[7] = [8, 10, 6]\ngraph[8] = [5]\ngraph[5] = [8]\ngraph[10] = [8]\ngraph[2] = [4, 7, 10]\ngraph[6] = [9, 10, 0]\ngraph[9] = [7]\n\n# Check if there is a path from node 5 to node 1\nresult = has_path(graph, 5, 1)\nprint(result)\n```"}, {"id": 152, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [5],\n    5: [2, 4, 6, 1, 0, 3],\n    4: [5, 7],\n    6: [5],\n    1: [5],\n    0: [5],\n    3: [5],\n    7: [4]\n}\n\n# Check if there is a path between node 0 and node 2\nprint(has_path(graph, 0, 2))  # Output: True\n```"}, {"id": 153, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    11: [6, 9],\n    6: [11, 10, 5],\n    9: [11],\n    10: [6, 1, 5],\n    5: [6, 10, 4],\n    1: [10],\n    0: [8, 2, 12],\n    8: [0, 12],\n    2: [0, 7],\n    12: [0, 8],\n    4: [5],\n    3: [7],\n    7: [3, 2]\n}\n\n# Check if there is a path between node 7 and node 11\nresult = has_path(graph, 7, 11)\nprint(result)\n```"}, {"id": 154, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[4] = [8, 9, 3, 6, 0, 13]\ngraph[8] = [9, 2, 13, 7, 1]\ngraph[9] = [0, 1, 12]\ngraph[3] = [6, 13, 4, 7, 10, 9]\ngraph[6] = [0, 4, 8, 10, 12]\ngraph[0] = [11, 9, 6]\ngraph[13] = [4, 5, 6]\ngraph[7] = [1, 8, 12, 3, 6]\ngraph[1] = [4]\ngraph[12] = [13, 4]\ngraph[2] = [6, 12, 5]\ngraph[10] = [3, 0, 13, 4, 7]\ngraph[5] = [9]\ngraph[11] = [1, 5, 2]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 13 to node 9\npath_exists = has_path(graph, 13, 9)\nprint(\"Is there a directed path from node 13 to node 9?\", path_exists)\n```"}, {"id": 155, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[10] = [5]\ngraph[5] = [2, 7]\ngraph[2] = [4, 7, 5, 8, 10]\ngraph[4] = [5, 0]\ngraph[7] = [5]\ngraph[8] = [1, 9, 4, 3]\ngraph[9] = [8, 10]\ngraph[0] = [5, 1, 10, 2]\ngraph[3] = [1, 10, 2, 0, 4]\ngraph[6] = [7]\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Check if there is a path from node 1 to node 0\nresult = has_path(graph, 1, 0)\nprint(\"Is there a directed path from node 1 to node 0?\", result)\n```"}, {"id": 156, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [10, 0, 7, 8, 5, 1],\n    10: [6, 2, 8, 4],\n    0: [6, 5, 9, 2],\n    7: [6, 4, 2, 8, 3],\n    8: [6, 10, 4, 7],\n    5: [6, 1, 0],\n    1: [6, 5, 9, 3],\n    2: [10, 0, 7],\n    4: [10, 9, 8, 7],\n    9: [1, 0, 4, 3],\n    3: [1, 9, 7]\n}\n\n# Check if there is a path between node 6 and node 9\nprint(has_path(graph, 6, 9))  # Output: True\n```"}, {"id": 157, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [11, 10],\n    11: [13, 5, 10, 0, 4],\n    10: [11, 5],\n    9: [13, 10, 4],\n    13: [10, 4],\n    2: [0, 4],\n    5: [12, 7, 9],\n    3: [10, 7, 6, 2],\n    7: [2, 11, 3, 12, 10],\n    6: [13, 10],\n    1: [9, 13],\n    8: [2, 11, 13]\n}\n\n# Check if there is a path from node 0 to node 9\nresult = has_path(graph, 0, 9)\nprint(result)\n```"}, {"id": 158, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [5, 7],\n    5: [6, 9],\n    7: [6, 10],\n    9: [5, 0, 10],\n    10: [7, 4, 9, 2],\n    1: [0, 8],\n    0: [1, 9],\n    8: [1, 3],\n    4: [10, 11],\n    2: [10],\n    11: [4],\n    3: [8]\n}\n\n# Check if there is a path between node 0 and node 8\nprint(has_path(graph, 0, 8))  # Output: True\n```"}, {"id": 159, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[8] = [6, 0, 4]\ngraph[6] = [4, 8]\ngraph[0] = [7]\ngraph[4] = [3, 7]\ngraph[3] = [6, 4]\ngraph[5] = [7]\ngraph[7] = [4, 3]\ngraph[1] = [4]\ngraph[2] = [7, 6, 0]\n\n# Check if there is a path from node 8 to node 5\nresult = has_path(graph, 8, 5)\nprint(result)\n```"}, {"id": 160, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [0, 2, 4, 6, 9, 12, 10, 8, 1, 3, 13],\n    0: [5],\n    2: [5, 7],\n    4: [5],\n    6: [5],\n    9: [5],\n    12: [5],\n    10: [5],\n    8: [5],\n    1: [5],\n    3: [5],\n    13: [5],\n    7: [2, 11],\n    11: [7]\n}\n\n# Check if there is a path between node 12 and node 10\nresult = has_path(graph, 12, 10)\nprint(result)\n```"}, {"id": 161, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [0, 2, 3],\n    0: [2, 1],\n    2: [3, 7, 4, 8],\n    3: [7, 5, 6],\n    1: [9, 10, 6, 7, 4, 8],\n    10: [9],\n    6: [3, 7, 8, 9],\n    7: [5],\n    4: [9, 0],\n    5: [0, 6, 10]\n}\n\n# Check if there is a path from node 9 to node 7\nresult = has_path(graph, 9, 7)\nprint(result)\n```"}, {"id": 162, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [2, 9],\n    2: [8, 0, 1],\n    9: [8, 4],\n    0: [2, 5],\n    1: [2],\n    3: [7, 6],\n    7: [3, 4, 5],\n    6: [3],\n    4: [7, 9],\n    5: [7, 0]\n}\n\n# Check if there is a path between node 8 and node 9\nprint(has_path(graph, 8, 9))  # Output: True\n```"}, {"id": 163, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[10] = [11, 13, 6, 4]\ngraph[11] = [14]\ngraph[13] = [14, 12, 5]\ngraph[6] = [12]\ngraph[4] = [3, 5, 14, 12]\ngraph[3] = [5, 11]\ngraph[5] = [1, 3]\ngraph[1] = [6, 12, 4]\ngraph[7] = [6, 10]\ngraph[14] = [2]\ngraph[12] = [3, 13]\ngraph[0] = [12, 6]\ngraph[9] = [2, 3, 13]\ngraph[2] = [14, 12]\ngraph[8] = [5, 7]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 14 to node 8\nresult = has_path(graph, 14, 8)\nprint(\"Is there a directed path from node 14 to node 8?\", result)\n```"}, {"id": 164, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [2, 3, 4, 5, 6],\n    2: [1, 0, 7, 3, 4],\n    3: [1, 0, 2, 8, 6],\n    4: [1, 0, 2, 8, 5, 6],\n    5: [1, 0, 8, 4, 6],\n    6: [1, 0, 8, 3, 4, 5],\n    0: [2, 8, 7, 3, 4, 5, 6],\n    8: [0, 7, 3, 4, 5, 6],\n    7: [0, 2, 8]\n}\n\n# Check if there is a path between node 3 and node 7\nresult = has_path(graph, 3, 7)\nprint(\"Is there a path between node 3 and node 7?\", result)\n```"}, {"id": 165, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [5],\n    5: [1, 6, 3],\n    6: [5, 3],\n    3: [5, 8, 6],\n    8: [3],\n    0: [4, 2, 9],\n    4: [0, 7, 9],\n    2: [0],\n    9: [0, 4],\n    7: [4]\n}\n\n# Check if there is a path between node 3 and node 0\nprint(has_path(graph, 3, 0))  # Output: True\n```"}, {"id": 166, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    10: [11, 12, 8],\n    11: [8, 3],\n    8: [9, 6],\n    3: [1, 4],\n    1: [0, 4],\n    4: [14, 1, 12],\n    5: [2, 8, 9],\n    2: [13],\n    9: [7, 1, 6],\n    13: [9, 7, 4, 12],\n    0: [6],\n    7: [5, 9],\n    6: [7, 2]\n}\n\n# Check if there is a path from node 2 to node 7\nresult = has_path(graph, 2, 7)\nprint(result)\n```"}, {"id": 167, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[9] = [1, 10, 4, 7]\ngraph[1] = [8, 2, 4, 9]\ngraph[10] = [4, 11, 8]\ngraph[4] = [2]\ngraph[7] = [8, 5]\ngraph[2] = [11]\ngraph[11] = [9, 8, 10, 5, 6, 4]\ngraph[5] = [2, 11]\ngraph[0] = [6, 3, 9]\ngraph[6] = [4, 11, 7, 9]\ngraph[3] = [7, 4]\n\n# Function to perform DFS and check if there is a path from start to end\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 8 to node 2\nstart_node = 8\nend_node = 2\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 8 to node 2?\", result)\n```"}, {"id": 168, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[0].append(6)\ngraph[6].append(7)\ngraph[6].append(2)\ngraph[6].append(4)\ngraph[6].append(3)\ngraph[2].append(7)\ngraph[2].append(5)\ngraph[2].append(0)\ngraph[7].append(0)\ngraph[7].append(2)\ngraph[5].append(6)\ngraph[4].append(3)\ngraph[4].append(7)\ngraph[4].append(5)\ngraph[4].append(0)\ngraph[3].append(5)\ngraph[3].append(4)\ngraph[1].append(2)\ngraph[1].append(4)\n\n# Check if there is a path from node 5 to node 3\nresult = has_path(graph, 5, 3)\nprint(\"Is there a directed path from node 5 to node 3?\", result)\n```"}, {"id": 169, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4].append(3)\ngraph[3].append(2)\ngraph[3].append(7)\ngraph[5].append(14)\ngraph[5].append(11)\ngraph[5].append(6)\ngraph[5].append(8)\ngraph[5].append(7)\ngraph[14].append(8)\ngraph[14].append(0)\ngraph[11].append(8)\ngraph[11].append(13)\ngraph[11].append(2)\ngraph[6].append(13)\ngraph[8].append(12)\ngraph[10].append(2)\ngraph[10].append(7)\ngraph[2].append(9)\ngraph[13].append(2)\ngraph[13].append(14)\ngraph[13].append(10)\ngraph[1].append(9)\ngraph[1].append(3)\ngraph[9].append(0)\ngraph[9].append(2)\ngraph[12].append(13)\n\n# Check if there is a path from node 3 to node 5\nprint(has_path(graph, 3, 5))  # Output: True\n```"}, {"id": 170, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [6, 7, 1],\n    6: [8, 7],\n    7: [8, 6],\n    1: [8, 9],\n    5: [3, 4, 2, 0],\n    3: [5],\n    4: [5, 0],\n    2: [5],\n    0: [5, 4],\n    9: [1]\n}\n\n# Check if there is a path between node 6 and node 4\nprint(has_path(graph, 6, 4))  # Output: True\n```"}, {"id": 171, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        \n        if current == end:\n            return True\n        \n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [2, 10],\n    2: [7, 14, 10, 13, 4, 6, 12],\n    10: [2, 8],\n    0: [5, 7, 13, 9, 6],\n    5: [7, 8, 9, 4, 6, 12, 0],\n    7: [10, 4, 12, 5],\n    13: [7],\n    9: [1, 4, 12, 0, 8],\n    6: [0, 11, 2, 7, 8, 13],\n    8: [1, 12, 5],\n    4: [6, 0, 5, 3, 10, 9],\n    3: [11, 8, 12, 0],\n    11: [14, 10, 9, 1, 4, 6],\n    14: [4, 12, 0],\n    1: [6, 5, 2, 8]\n}\n\n# Check if there is a path from node 14 to node 4\nresult = has_path(graph, 14, 4)\nprint(result)\n```"}, {"id": 172, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [7, 3, 9],\n    7: [6, 4],\n    3: [6, 2],\n    9: [6, 0, 10],\n    4: [7, 5, 1],\n    2: [3],\n    8: [5],\n    5: [8, 4],\n    1: [0, 4],\n    0: [1, 9],\n    10: [9]\n}\n\n# Check if there is a path between node 5 and node 7\nprint(has_path(graph, 5, 7))  # Output: True\n```"}, {"id": 173, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[4] = [14, 1]\ngraph[14] = [9, 5]\ngraph[13] = [11, 6, 10]\ngraph[11] = [5, 4, 3]\ngraph[6] = [13, 0]\ngraph[10] = [2, 6]\ngraph[12] = [3, 11]\ngraph[3] = [6, 13]\ngraph[2] = [7]\ngraph[7] = [0, 4]\ngraph[0] = [7]\ngraph[9] = [11]\ngraph[5] = [14, 0]\ngraph[8] = [9]\n\n# Function to perform DFS and check for path\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 1 to node 13\nstart_node = 1\nend_node = 13\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 1 to node 13?\", result)\n```"}, {"id": 174, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    13: [6, 3, 4, 8],\n    6: [13, 0, 9],\n    3: [13, 7],\n    4: [13, 5, 2, 12],\n    8: [13, 7, 0, 11],\n    0: [6, 7, 8, 1, 11, 10],\n    9: [6, 5, 2, 1],\n    7: [8, 3, 14, 0, 10],\n    14: [7, 5, 10],\n    10: [7, 0, 14, 12],\n    11: [8, 0, 5],\n    1: [0, 9, 2, 12],\n    5: [9, 11, 2, 14, 12, 4],\n    2: [9, 5, 1, 4],\n    12: [5, 1, 4, 10]\n}\n\n# Check if there is a path between node 7 and node 1\nresult = has_path(graph, 7, 1)\nprint(result)\n```"}, {"id": 175, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[7] = [3, 8]\ngraph[3] = [8, 4, 2]\ngraph[8] = [6]\ngraph[4] = [2]\ngraph[6] = [2, 7]\ngraph[5] = [6, 1]\ngraph[0] = [7, 8]\n\n# Check if there is a path from node 1 to node 7\nresult = has_path(graph, 1, 7)\nprint(result)\n```"}, {"id": 176, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [7, 6, 2, 12, 1],\n    7: [5],\n    6: [5],\n    2: [5],\n    12: [5],\n    1: [5, 10, 4, 9],\n    10: [1],\n    4: [1, 8],\n    9: [1, 11, 0],\n    11: [9],\n    0: [9],\n    8: [4, 3],\n    3: [8]\n}\n\n# Check if there is a path between node 1 and node 4\nprint(has_path(graph, 1, 4))  # Output: True\n```"}, {"id": 177, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[2] = [8, 1]\ngraph[8] = [1]\ngraph[1] = [3, 0]\ngraph[9] = [11, 10, 5, 1]\ngraph[10] = [13]\ngraph[5] = [1, 8]\ngraph[13] = [0]\ngraph[0] = [13, 11]\ngraph[12] = [6]\ngraph[6] = [7, 12, 10, 3]\ngraph[3] = [11]\ngraph[4] = [9]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 3 to node 6\npath_exists = has_path(graph, 3, 6)\nprint(\"Is there a directed path from node 3 to node 6?\", path_exists)\n```"}, {"id": 178, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [0, 5, 7, 4, 6, 2, 1],\n    0: [3],\n    5: [3],\n    7: [3],\n    4: [3],\n    6: [3],\n    2: [3],\n    1: [3]\n}\n\n# Check if there is a path between node 3 and node 6\nprint(has_path(graph, 3, 6))  # Output: True\n```"}, {"id": 179, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4] = [5, 1, 7, 3, 0]\ngraph[5] = [7, 9]\ngraph[1] = [8]\ngraph[7] = [2]\ngraph[3] = [10, 9]\ngraph[0] = [8, 5, 1]\ngraph[9] = [4, 0]\ngraph[8] = [0]\ngraph[10] = [1]\ngraph[6] = [2, 3]\n\n# Check if there is a path from node 4 to node 6\nresult = has_path(graph, 4, 6)\nprint(\"Is there a directed path from node 4 to node 6?\", result)\n```"}, {"id": 180, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [2, 3, 9],\n    2: [6, 7, 5, 1],\n    3: [6, 7, 5, 4, 0, 9],\n    9: [6, 5, 4, 3],\n    8: [7],\n    7: [8, 2, 5, 3],\n    5: [7, 2, 1, 3, 9],\n    1: [2, 5, 0],\n    0: [1, 4, 3],\n    4: [3, 0, 9]\n}\n\n# Check if there is a path between node 0 and node 1\nprint(has_path(graph, 0, 1))  # Output: True\n```"}, {"id": 181, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1] = [5, 7]\ngraph[5] = [8, 0, 7]\ngraph[3] = [0, 1]\ngraph[0] = [2, 1, 5, 8]\ngraph[8] = [2, 7]\ngraph[4] = [2, 5]\ngraph[6] = [7, 4, 2]\n\n# Check if there is a path from node 2 to node 7\nresult = has_path(graph, 2, 7)\nprint(\"Is there a directed path from node 2 to node 7?\", result)\n```"}, {"id": 182, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [2, 8],\n    2: [5],\n    8: [5, 7],\n    7: [8, 3, 0, 4],\n    3: [1, 7],\n    1: [3, 6],\n    6: [1],\n    0: [7],\n    4: [7]\n}\n\n# Check if there is a path between node 2 and node 4\nprint(has_path(graph, 2, 4))  # Output: True\n```"}, {"id": 183, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [1, 6],\n    1: [3, 6],\n    6: [3, 1],\n    7: [4, 5],\n    4: [7, 0],\n    5: [7, 2],\n    0: [4, 8],\n    8: [0, 2],\n    2: [8, 5]\n}\n\n# Check if there is a path between node 0 and node 3\nprint(has_path(graph, 0, 3))  # Output: True\n```"}, {"id": 184, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [5, 3, 12, 11, 10],\n    5: [12, 4],\n    3: [11, 10, 7, 4, 2],\n    12: [11, 4, 1, 3],\n    11: [10, 4, 8, 3, 0],\n    10: [9, 8, 12],\n    13: [4, 5, 6, 3, 12, 11],\n    4: [2],\n    6: [3, 12, 0, 10, 7, 13, 2],\n    2: [6, 10],\n    1: [2, 5, 8, 12, 0, 13],\n    8: [6, 11, 9, 7, 13, 2, 5],\n    0: [5, 3, 12],\n    9: [11]\n}\n\n# Check if there is a path from node 2 to node 13\nresult = has_path(graph, 2, 13)\nprint(result)\n```"}, {"id": 185, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[4] = [3, 1, 7, 8]\ngraph[3] = [6, 0]\ngraph[1] = [8, 3, 9, 5]\ngraph[7] = [9, 0]\ngraph[8] = [9, 1]\ngraph[6] = [2, 5]\ngraph[0] = [8, 3, 9, 5, 6]\ngraph[9] = [5, 0, 3]\ngraph[5] = [7, 8, 3, 9]\ngraph[2] = [5, 7]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 8 to node 4\npath_exists = has_path(graph, 8, 4)\nprint(\"Is there a directed path from node 8 to node 4?\", path_exists)\n```"}, {"id": 186, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [5, 8, 9, 2],\n    5: [0, 6, 11, 2],\n    8: [0, 10, 7, 1],\n    9: [0, 11, 3],\n    2: [0, 5, 6, 10, 11],\n    6: [5, 7, 1, 4, 2],\n    11: [5, 2, 3, 9],\n    7: [6, 10, 4, 8],\n    1: [6, 3, 8, 4],\n    4: [6, 7, 3, 1],\n    10: [2, 8, 7],\n    3: [11, 9, 1, 4]\n}\n\n# Check if there is a path between node 7 and node 2\nresult = has_path(graph, 7, 2)\nprint(\"Is there a path between node 7 and node 2?\", result)\n```"}, {"id": 187, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[10] = [11, 2, 9]\ngraph[11] = [7]\ngraph[2] = [13, 6, 0]\ngraph[9] = [11]\ngraph[3] = [13, 8]\ngraph[13] = [14, 6]\ngraph[8] = [1, 3, 6, 12]\ngraph[14] = [12]\ngraph[6] = [5]\ngraph[12] = [6]\ngraph[5] = [0]\ngraph[0] = [14, 11]\ngraph[7] = [12, 11]\ngraph[4] = [1, 13, 7]\ngraph[1] = [13, 12, 2, 9]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 2 to node 8\npath_exists = has_path(graph, 2, 8)\nprint(\"Is there a directed path from node 2 to node 8?\", path_exists)\n```"}, {"id": 188, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [6, 7, 9, 3, 2],\n    6: [5, 7, 9, 3, 0, 8, 4],\n    7: [5, 6, 3, 0, 8, 1, 4],\n    9: [5, 6, 3, 0, 1, 4, 2],\n    3: [5, 6, 7, 9, 0, 8, 2],\n    2: [5, 9, 3, 0, 8, 1],\n    0: [6, 7, 9, 3, 1, 4, 2],\n    8: [6, 7, 3, 1, 4, 2],\n    4: [6, 7, 9, 0, 8, 1],\n    1: [7, 9, 0, 8, 4, 2]\n}\n\n# Check if there is a path between node 7 and node 0\nprint(has_path(graph, 7, 0))  # Output: True\n```"}, {"id": 189, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[10].append(2)\ngraph[2].append(12)\ngraph[2].append(6)\ngraph[2].append(0)\ngraph[3].append(8)\ngraph[3].append(1)\ngraph[3].append(0)\ngraph[8].append(5)\ngraph[8].append(11)\ngraph[8].append(0)\ngraph[1].append(9)\ngraph[0].append(8)\ngraph[0].append(6)\ngraph[12].append(5)\ngraph[12].append(2)\ngraph[5].append(6)\ngraph[11].append(0)\ngraph[11].append(7)\ngraph[11].append(6)\ngraph[9].append(12)\ngraph[9].append(1)\ngraph[4].append(1)\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 2 to node 1\npath_exists = has_path(graph, 2, 1)\nprint(\"Path exists:\", path_exists)\n```"}, {"id": 190, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    11: [7, 10, 8],\n    7: [11, 9, 10, 5, 2],\n    10: [11, 0, 9, 1, 7, 6],\n    8: [11, 9, 1, 5],\n    0: [1, 10, 6, 5],\n    1: [0, 3, 10, 5, 4, 8],\n    6: [0, 9, 3, 10, 5, 4, 2],\n    5: [0, 1, 7, 6, 2, 8],\n    9: [7, 3, 10, 6, 2, 8],\n    3: [9, 1, 6, 4, 2],\n    2: [9, 7, 3, 6, 5],\n    4: [1, 3, 6]\n}\n\n# Check if there is a path between node 8 and node 10\nresult = has_path(graph, 8, 10)\nprint(\"Is there a path between node 8 and node 10?\", result)\n```"}, {"id": 191, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [7, 1, 6, 3, 12, 4],\n    7: [13, 9],\n    1: [10, 5],\n    3: [4, 0, 1],\n    12: [11, 8, 5],\n    4: [10, 11, 6],\n    10: [5, 4],\n    5: [6, 4],\n    13: [3, 11],\n    9: [0],\n    11: [5, 6, 4],\n    8: [13, 2, 10, 11],\n    0: [6],\n    14: [8, 13, 6, 3, 12, 0]\n}\n\n# Check if there is a path from node 11 to node 3\nresult = has_path(graph, 11, 3)\nprint(result)\n```"}, {"id": 192, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [2, 11, 5, 3, 9],\n    2: [7, 10, 6, 12, 9, 8],\n    11: [7, 5, 9],\n    5: [7, 1, 6, 3, 11, 10, 4, 12, 8, 9],\n    3: [7, 5, 1, 9],\n    9: [7, 2, 5, 14, 3, 13, 8, 4, 11, 0],\n    10: [2, 5, 12, 0],\n    6: [2, 5, 13],\n    12: [2, 5, 10, 8, 4],\n    8: [2, 5, 9, 13, 12, 0],\n    1: [5, 3, 0],\n    4: [5, 9, 12],\n    0: [1, 9, 10, 8],\n    14: [9, 13],\n    13: [9, 14, 6, 8]\n}\n\n# Check if there is a path between node 3 and node 8\nresult = has_path(graph, 3, 8)\nprint(\"Is there a path between node 3 and node 8?\", result)\n```"}, {"id": 193, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[6] = [3, 2, 5, 4, 0]\ngraph[3] = [5, 1, 7, 0]\ngraph[2] = [7]\ngraph[5] = [8]\ngraph[4] = [2, 5, 7]\ngraph[0] = [2, 4]\ngraph[1] = [7, 4, 0]\ngraph[7] = [4, 0, 8, 1]\ngraph[8] = [4, 0, 5]\n\n# Check if there is a path from node 5 to node 6\nresult = has_path(graph, 5, 6)\nprint(result)\n```"}, {"id": 194, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [2, 4, 3, 0, 5, 7],\n    2: [1, 4, 3, 8, 6, 5, 7],\n    4: [1, 2, 8, 0, 6, 5, 7],\n    3: [1, 2, 8, 0, 5, 7],\n    0: [1, 4, 3, 6, 5, 7],\n    5: [1, 2, 4, 3, 8, 0, 6, 7],\n    7: [1, 2, 4, 3, 8, 0, 6, 5],\n    8: [2, 4, 3, 5, 7],\n    6: [2, 4, 0, 5, 7]\n}\n\n# Check if there is a path between node 4 and node 3\nresult = has_path(graph, 4, 3)\nprint(\"Is there a path between node 4 and node 3?\", result)\n```"}, {"id": 195, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[2] = [4, 8]\ngraph[4] = [3]\ngraph[8] = [3, 4]\ngraph[3] = [0, 5]\ngraph[0] = [1, 3]\ngraph[5] = [6]\ngraph[7] = [6, 4, 5]\n\n# Check if there is a path from node 6 to node 5\nresult = has_path(graph, 6, 5)\nprint(result)\n```"}, {"id": 196, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [11, 7],\n    11: [4, 10, 3, 5, 9],\n    7: [4, 3, 5, 8],\n    2: [10, 3, 5, 0, 1, 9],\n    10: [2, 3, 8, 11, 9],\n    3: [2, 6, 10, 11, 7, 1],\n    5: [2, 8, 11, 7, 1],\n    0: [2, 6, 8],\n    1: [2, 6, 3, 5, 9],\n    9: [2, 6, 10, 11, 1],\n    6: [3, 0, 1, 9],\n    8: [10, 5, 0, 7]\n}\n\n# Check if there is a path between node 10 and node 7\nresult = has_path(graph, 10, 7)\nprint(\"Is there a path between node 10 and node 7?\", result)\n```"}, {"id": 197, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4] = [7, 11, 0, 1, 10]\ngraph[7] = [11, 2, 6, 10, 4]\ngraph[11] = [2, 10, 9, 4, 7]\ngraph[0] = [6, 10, 9, 2]\ngraph[1] = [10, 4, 5, 2]\ngraph[10] = [9]\ngraph[5] = [3, 0, 4]\ngraph[3] = [0, 4]\ngraph[8] = [11, 2, 5]\ngraph[2] = [10, 9, 4]\ngraph[6] = [10, 9, 4, 5, 7]\ngraph[9] = [7, 1]\n\n# Check if there is a path from node 11 to node 8\nresult = has_path(graph, 11, 8)\nprint(result)\n```"}, {"id": 198, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[2] = [8]\ngraph[8] = [10, 9, 0, 4]\ngraph[9] = [8]\ngraph[7] = [10]\ngraph[10] = [3, 4, 8]\ngraph[1] = [5, 2]\ngraph[5] = [10]\ngraph[3] = [9]\ngraph[0] = [6, 8, 9]\ngraph[6] = [5, 10, 9, 7, 0]\ngraph[4] = [8, 9, 1]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 3 to node 0\npath_exists = has_path(graph, 3, 0)\nprint(\"Is there a directed path from node 3 to node 0?\", path_exists)\n```"}, {"id": 199, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    11: [0],\n    0: [11, 8],\n    8: [0, 1],\n    6: [1],\n    1: [6, 10, 7, 8],\n    10: [1, 4],\n    7: [1, 4],\n    5: [3, 2],\n    3: [5, 2],\n    2: [5, 3, 9],\n    9: [2],\n    4: [10, 7]\n}\n\n# Check if there is a path between node 2 and node 6\nprint(has_path(graph, 2, 6))  # Output: True\n```"}, {"id": 200, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [7, 1, 0],\n    7: [8, 6],\n    1: [8, 0, 3, 5],\n    0: [8, 1],\n    6: [7],\n    3: [1, 4],\n    5: [1],\n    9: [4, 2],\n    4: [9, 3, 10],\n    2: [9],\n    10: [4]\n}\n\n# Check if there is a path between node 0 and node 9\nprint(has_path(graph, 0, 9))  # Output: True\n```"}, {"id": 201, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4] = [5, 6]\ngraph[5] = [3, 2, 8]\ngraph[6] = [4, 5]\ngraph[3] = [7]\ngraph[2] = [4]\ngraph[8] = [6, 0]\ngraph[7] = [2, 6, 5]\ngraph[1] = [7, 0, 4, 5, 3]\ngraph[0] = [8, 4, 5, 7, 6]\n\n# Check if there is a path from node 0 to node 1\nprint(has_path(graph, 0, 1))  # Output: True\n```"}, {"id": 202, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [3, 4, 7, 2, 0],\n    3: [5],\n    4: [5],\n    7: [5],\n    2: [5, 1],\n    0: [5],\n    1: [6, 2],\n    6: [1]\n}\n\n# Check if there is a path between node 2 and node 7\nprint(has_path(graph, 2, 7))  # Output: True\n```"}, {"id": 203, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[7] = [0, 6, 5, 2]\ngraph[0] = [3, 5, 2, 7]\ngraph[6] = [5, 3]\ngraph[5] = [2]\ngraph[2] = [7, 1, 6, 5]\ngraph[3] = [1, 7]\ngraph[4] = [3, 2, 0]\ngraph[1] = [5, 2]\n\n# Check if there is a path from node 1 to node 4\nresult = has_path(graph, 1, 4)\nprint(result)\n```"}, {"id": 204, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [2, 9],\n    2: [5, 7],\n    9: [5, 8],\n    7: [2, 3],\n    3: [7, 4],\n    4: [3, 6],\n    0: [6, 1],\n    6: [0, 4],\n    1: [0, 10],\n    8: [9, 10],\n    10: [1, 8]\n}\n\n# Check if there is a path between node 2 and node 5\nprint(has_path(graph, 2, 5))  # Output: True\n```"}, {"id": 205, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [8, 0],\n    8: [1, 6],\n    0: [1, 3, 6],\n    6: [8, 0],\n    3: [0],\n    5: [4, 2, 7],\n    4: [5, 7],\n    2: [5],\n    7: [5, 4]\n}\n\n# Check if there is a path between node 7 and node 8\nresult = has_path(graph, 7, 8)\nprint(result)\n```"}, {"id": 206, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [4, 8, 1],\n    4: [0, 7, 13, 11, 2, 9, 10],\n    8: [0, 7, 10, 1],\n    1: [0, 8, 2, 3, 9, 10],\n    7: [13, 4, 8, 2, 3, 6, 9, 10],\n    13: [7, 4, 11, 6, 5],\n    2: [7, 4, 11, 6, 5, 1],\n    3: [7, 12, 1],\n    6: [7, 13, 11, 2, 9, 5, 10],\n    9: [7, 12, 4, 6, 10, 1],\n    10: [7, 4, 8, 6, 9, 1],\n    11: [13, 4, 2, 6, 5],\n    5: [13, 11, 2, 6],\n    12: [3, 9]\n}\n\n# Check if there is a path between node 2 and node 7\nprint(has_path(graph, 2, 7))  # Output: True\n```"}, {"id": 207, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[9] = [8, 0]\ngraph[8] = [5]\ngraph[0] = [8]\ngraph[7] = [2, 4, 5, 6, 9, 8]\ngraph[2] = [4, 1, 6, 3]\ngraph[4] = [3, 8]\ngraph[6] = [4, 1, 0]\n\n# Check if there is a path from node 3 to node 1\nresult = has_path(graph, 3, 1)\nprint(result)\n```"}, {"id": 208, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [5, 1],\n    5: [0, 2],\n    1: [0, 4, 3],\n    2: [5, 3, 6],\n    3: [2, 1],\n    6: [2, 7],\n    4: [1],\n    7: [6]\n}\n\n# Check if there is a path between node 4 and node 0\nprint(has_path(graph, 4, 0))  # Output: True\n```"}, {"id": 209, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[5].append(10)\ngraph[10].append(11)\ngraph[10].append(9)\ngraph[10].append(2)\ngraph[10].append(7)\ngraph[2].append(8)\ngraph[8].append(2)\ngraph[1].append(7)\ngraph[1].append(8)\ngraph[1].append(9)\ngraph[7].append(12)\ngraph[12].append(10)\ngraph[12].append(9)\ngraph[4].append(6)\ngraph[6].append(11)\ngraph[6].append(5)\ngraph[6].append(2)\ngraph[11].append(0)\ngraph[11].append(4)\ngraph[0].append(2)\ngraph[3].append(6)\n\n# Function to perform DFS and check for path\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 2 to node 9\nstart_node = 2\nend_node = 9\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 2 to node 9?\", result)\n```"}, {"id": 210, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[8] = [3, 6]\ngraph[3] = [4, 1]\ngraph[6] = [1, 0, 5]\ngraph[7] = [5, 4, 1]\ngraph[5] = [2, 1, 8, 7]\ngraph[4] = [0, 5]\ngraph[1] = [7]\ngraph[2] = [4, 6, 5]\ngraph[0] = [6]\n\n# Check if there is a path from node 1 to node 0\nresult = has_path(graph, 1, 0)\nprint(\"Is there a directed path from node 1 to node 0?\", result)\n```"}, {"id": 211, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[1] = [5, 4, 6]\ngraph[5] = [0, 1]\ngraph[6] = [11]\ngraph[0] = [9]\ngraph[2] = [10]\ngraph[10] = [1, 9]\ngraph[9] = [10, 2]\ngraph[11] = [1]\ngraph[7] = [10]\ngraph[8] = [6, 3, 9]\n\n# Check if there is a path from node 4 to node 3\nresult = has_path(graph, 4, 3)\nprint(result)\n```"}, {"id": 212, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [8, 6, 0],\n    8: [4, 1],\n    6: [4, 2],\n    0: [4],\n    1: [8, 9],\n    9: [1, 7],\n    7: [9, 3],\n    3: [7, 5],\n    2: [6, 5],\n    5: [3, 2]\n}\n\n# Check if there is a path between node 5 and node 0\nprint(has_path(graph, 5, 0))  # Output: True\n```"}, {"id": 213, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[3].append(1)\ngraph[1].append(0)\ngraph[5].append(12)\ngraph[12].append(1)\ngraph[12].append(8)\ngraph[12].append(3)\ngraph[12].append(0)\ngraph[12].append(9)\ngraph[12].append(2)\ngraph[0].append(6)\ngraph[6].append(10)\ngraph[6].append(12)\ngraph[6].append(11)\ngraph[6].append(7)\ngraph[6].append(1)\ngraph[10].append(2)\ngraph[10].append(6)\ngraph[9].append(5)\ngraph[8].append(2)\ngraph[11].append(2)\ngraph[7].append(3)\ngraph[7].append(10)\ngraph[7].append(9)\ngraph[4].append(10)\ngraph[4].append(12)\ngraph[4].append(7)\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, v, visited):\n                return True\n    return False\n\n# Check if there is a path from node 5 to node 4\nresult = has_path(graph, 5, 4)\nprint(\"Is there a directed path from node 5 to node 4?\", result)\n```"}, {"id": 214, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [2, 8, 5, 4, 6, 1],\n    2: [0, 6, 8, 3],\n    8: [0, 2, 5, 7, 3],\n    5: [0, 8, 7],\n    4: [0],\n    6: [0, 2, 1],\n    1: [0, 6],\n    3: [2, 8],\n    7: [8, 5]\n}\n\n# Check if there is a path between node 6 and node 7\nprint(has_path(graph, 6, 7))  # Output: True\n```"}, {"id": 215, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [2, 1],\n    2: [1, 0, 7, 4, 5, 6],\n    1: [0, 7],\n    4: [8],\n    8: [1, 6],\n    5: [6, 8, 3],\n    6: [1, 5],\n    7: [4]\n}\n\n# Check if there is a path from node 0 to node 7\nresult = has_path(graph, 0, 7)\nprint(result)\n```"}, {"id": 216, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    9: [2, 6, 10, 3, 4],\n    2: [9, 3, 10],\n    6: [9, 10, 8],\n    10: [9, 2, 3, 0, 8, 6],\n    3: [9, 2, 0, 1, 5, 8, 7, 10],\n    4: [9, 0, 8],\n    0: [3, 10, 4, 8],\n    1: [3, 7],\n    5: [3, 7, 8],\n    8: [3, 0, 10, 7, 4, 6, 5],\n    7: [3, 1, 8, 5]\n}\n\n# Check if there is a path between node 6 and node 5\nprint(has_path(graph, 6, 5))  # Output: True\n```"}, {"id": 217, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [1, 7],\n    1: [0, 7, 2],\n    7: [0, 1],\n    2: [1],\n    8: [5, 4, 3],\n    5: [8, 3],\n    4: [8],\n    3: [8, 5, 6],\n    6: [3]\n}\n\n# Check if there is a path between node 0 and node 8\nprint(has_path(graph, 0, 8))  # Output: True\n```"}, {"id": 218, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [4, 1, 3, 6, 2, 7],\n    4: [8, 1],\n    1: [8, 4, 7, 2, 5],\n    3: [8, 0],\n    6: [8, 0],\n    2: [8, 1, 5],\n    7: [8, 1, 0],\n    0: [7, 6, 3],\n    5: [1, 2]\n}\n\n# Check if there is a path between node 0 and node 7\nprint(has_path(graph, 0, 7))  # Output: True\n```"}, {"id": 219, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [6, 5, 1],\n    6: [3, 10],\n    5: [3],\n    1: [3, 10],\n    10: [6, 1],\n    7: [2, 12],\n    2: [7, 11],\n    12: [7, 0],\n    11: [2, 4, 9],\n    8: [0],\n    0: [8, 12],\n    4: [9, 11],\n    9: [4, 11]\n}\n\n# Check if there is a path between node 4 and node 10\nresult = has_path(graph, 4, 10)\nprint(result)\n```"}, {"id": 220, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[10] = [4, 8, 9]\ngraph[4] = [0]\ngraph[8] = [9]\ngraph[9] = [12]\ngraph[11] = [7]\ngraph[7] = [11, 2, 8]\ngraph[0] = [2, 4, 8, 10]\ngraph[2] = [4, 3, 1, 12]\ngraph[3] = [1, 5, 11, 0]\ngraph[12] = [3]\ngraph[5] = [9, 7, 1, 8]\ngraph[6] = [2, 1, 5]\ngraph[13] = [3, 9]\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Check if there is a path from node 12 to node 9\nresult = has_path(graph, 12, 9)\nprint(\"Is there a directed path from node 12 to node 9?\", result)\n```"}, {"id": 221, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[2].append(5)\ngraph[5].append(2)\ngraph[8].append(4)\ngraph[8].append(3)\ngraph[4].append(2)\ngraph[4].append(8)\ngraph[4].append(7)\ngraph[3].append(7)\ngraph[3].append(5)\ngraph[7].append(6)\ngraph[7].append(2)\ngraph[0].append(5)\ngraph[0].append(6)\ngraph[1].append(6)\n\n# Check if there is a path from node 1 to node 2\nprint(has_path(graph, 1, 2))  # Output: True\n```"}, {"id": 222, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[7] = [0, 3, 1]\ngraph[0] = [8, 4, 2, 1]\ngraph[3] = [1, 7, 0]\ngraph[1] = [7, 8, 2]\ngraph[8] = [4, 2, 3]\ngraph[4] = [6, 2, 3, 8]\ngraph[2] = [5, 8, 4]\ngraph[6] = [5, 1, 8]\ngraph[5] = [3, 8]\n\n# Check if there is a path from node 8 to node 6\nresult = has_path(graph, 8, 6)\nprint(result)\n```"}, {"id": 223, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[3] = [5, 2]\ngraph[5] = [8, 0]\ngraph[2] = [9, 12, 7, 3]\ngraph[4] = [10]\ngraph[10] = [4, 2]\ngraph[9] = [1, 11, 0]\ngraph[12] = [7, 11]\ngraph[7] = [11, 8]\ngraph[1] = [10]\ngraph[11] = [9]\ngraph[6] = [1]\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Check if there is a path from node 0 to node 3\nresult = has_path(graph, 0, 3)\nprint(\"Is there a directed path from node 0 to node 3?\", result)\n```"}, {"id": 224, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [7, 3, 2, 0, 6],\n    7: [8, 0],\n    3: [8, 4, 2, 9, 0],\n    2: [8, 3],\n    0: [8, 7, 3, 9, 5],\n    6: [8],\n    4: [3, 9],\n    9: [3, 4, 5, 0, 1],\n    5: [9, 1, 0],\n    1: [9, 5]\n}\n\n# Check if there is a path between node 3 and node 5\nprint(has_path(graph, 3, 5))  # Output: True\n```"}, {"id": 225, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[7] = [1, 6, 2]\ngraph[6] = [3, 0]\ngraph[2] = [7, 5]\ngraph[0] = [1, 4, 7]\ngraph[5] = [6]\ngraph[3] = [0, 4]\n\n# Check if there is a path from node 4 to node 7\nprint(has_path(graph, 4, 7))\n```"}, {"id": 226, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    10: [3, 6, 11, 5, 0],\n    3: [10, 1, 4, 0, 8],\n    6: [10, 4, 0, 8],\n    11: [10, 1, 4, 0, 7],\n    5: [10, 1, 2],\n    0: [10, 3, 6, 11, 12],\n    1: [3, 11, 5, 8],\n    4: [3, 6, 11, 12, 7],\n    8: [3, 1, 6, 9],\n    12: [4, 0, 2, 7],\n    7: [4, 11, 12, 13],\n    2: [12, 5],\n    13: [7],\n    9: [8]\n}\n\n# Check if there is a path between node 6 and node 7\nprint(has_path(graph, 6, 7))  # Output: True\n```"}, {"id": 227, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[8] = [6, 1]\ngraph[6] = [3, 5]\ngraph[1] = [7]\ngraph[2] = [1, 7, 0, 8]\ngraph[7] = [5]\ngraph[3] = [5, 4, 6]\ngraph[5] = [1]\ngraph[4] = [0, 8, 6, 5]\n\n# Check if there is a path from node 6 to node 2\nresult = has_path(graph, 6, 2)\nprint(result)\n```"}, {"id": 228, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [12, 6, 7, 11, 2, 9, 8, 10, 1, 0],\n    12: [4, 5, 2, 9, 3],\n    6: [4, 7, 11, 5, 2, 8, 10, 0],\n    7: [4, 6, 11, 5, 8, 10, 13, 0],\n    11: [4, 6, 7, 5, 2, 9, 8, 1, 13],\n    2: [4, 12, 6, 11, 9, 8, 3, 10, 13, 0],\n    9: [4, 12, 11, 5, 2, 8, 10, 1, 13, 0],\n    8: [4, 6, 7, 11, 5, 2, 9, 3, 10, 1, 13, 0],\n    10: [4, 6, 7, 2, 9, 8, 13, 0],\n    1: [4, 11, 9, 8, 13],\n    0: [4, 6, 7, 5, 2, 9, 8, 3, 10, 13],\n    5: [12, 6, 7, 11, 9, 8, 3, 0],\n    3: [12, 5, 2, 8, 13, 0],\n    13: [7, 11, 2, 9, 8, 3, 10, 1, 0]\n}\n\n# Check if there is a path between node 4 and node 5\nresult = has_path(graph, 4, 5)\nprint(\"Is there a path between node 4 and node 5?\", result)\n```"}, {"id": 229, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[1] = [3, 2, 9]\ngraph[3] = [7, 8, 2, 10, 9]\ngraph[2] = [1, 3]\ngraph[9] = [4, 1, 0]\ngraph[11] = [12]\ngraph[12] = [2, 10, 9]\ngraph[6] = [5, 2, 11]\ngraph[5] = [1, 7, 0]\ngraph[7] = [8, 2, 10, 12, 1]\ngraph[8] = [10, 11, 3, 7, 0]\ngraph[10] = [9, 12, 11, 7, 8, 5]\ngraph[0] = [9, 3, 7]\ngraph[4] = [1, 3, 7]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 2 to node 6\npath_exists = has_path(graph, 2, 6)\nprint(\"Is there a directed path from node 2 to node 6?\", path_exists)\n```"}, {"id": 230, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [5, 10, 2, 3, 0, 4],\n    5: [6, 8, 7, 4],\n    10: [6, 1],\n    2: [6, 1],\n    3: [6, 1],\n    0: [6, 1, 9, 11],\n    4: [6, 5, 1],\n    8: [5, 1],\n    7: [5, 1],\n    1: [3, 8, 4, 7, 2, 0, 10, 9],\n    9: [1, 0, 11],\n    11: [0, 9]\n}\n\n# Check if there is a path between node 2 and node 10\nresult = has_path(graph, 2, 10)\nprint(result)\n```"}, {"id": 231, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [1, 3, 10],\n    1: [3, 10, 9, 4, 7],\n    3: [10, 7, 1],\n    10: [6],\n    0: [7, 1, 2],\n    7: [3, 6, 2, 10, 9, 4, 0],\n    2: [0, 5],\n    6: [2, 10, 5, 3],\n    9: [0, 5, 6, 10],\n    5: [2, 7],\n    8: [1, 2, 4, 0, 7, 5]\n}\n\n# Check if there is a path from node 0 to node 8\nresult = has_path(graph, 0, 8)\nprint(result)\n```"}, {"id": 232, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    9: [4],\n    4: [9, 0],\n    0: [4, 2],\n    6: [7, 8, 1],\n    7: [6, 10, 2, 5],\n    8: [6],\n    1: [6, 2],\n    10: [7],\n    2: [7, 1, 3, 0],\n    5: [7],\n    3: [2]\n}\n\n# Check if there is a path between node 2 and node 3\nprint(has_path(graph, 2, 3))  # Output: True\n```"}, {"id": 233, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4].append(0)\ngraph[0].append(1)\ngraph[0].append(8)\ngraph[1].append(8)\ngraph[1].append(2)\ngraph[1].append(4)\ngraph[8].append(5)\ngraph[8].append(4)\ngraph[2].append(3)\ngraph[2].append(7)\ngraph[2].append(1)\ngraph[6].append(7)\ngraph[6].append(1)\ngraph[7].append(0)\ngraph[3].append(2)\n\n# Check if there is a path from node 5 to node 8\nresult = has_path(graph, 5, 8)\nprint(result)\n```"}, {"id": 234, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [6, 4],\n    6: [8, 10],\n    4: [8, 3],\n    10: [6, 1, 5, 7],\n    11: [1],\n    1: [11, 10],\n    0: [12, 5],\n    12: [0, 2],\n    5: [0, 10],\n    2: [12, 13],\n    13: [2, 3],\n    3: [13, 4],\n    7: [10, 9],\n    9: [7]\n}\n\n# Check if there is a path between node 8 and node 11\nprint(has_path(graph, 8, 11))  # Output: True\n```"}, {"id": 235, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[3].append(2)\ngraph[2].append(0)\ngraph[2].append(6)\ngraph[7].append(5)\ngraph[7].append(0)\ngraph[4].append(1)\ngraph[1].append(5)\ngraph[6].append(0)\ngraph[6].append(3)\ngraph[6].append(4)\n\n# Check if there is a path from node 1 to node 7\nprint(has_path(graph, 1, 7))\n```"}, {"id": 236, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [13, 9],\n    13: [11, 7, 0, 10],\n    9: [6, 5, 8, 13],\n    11: [3, 1, 14, 5, 9],\n    7: [0, 9],\n    0: [10, 6, 1, 11],\n    10: [3, 4, 7, 0],\n    12: [10],\n    6: [4, 2, 0],\n    5: [8, 1],\n    2: [7, 10],\n    3: [5, 9, 10],\n    1: [13, 10, 3],\n    14: [2, 6],\n    4: [6, 3, 14]\n}\n\n# Check if there is a path from node 9 to node 6\nresult = has_path(graph, 9, 6)\nprint(result)\n```"}, {"id": 237, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4] = [8, 6, 7]\ngraph[8] = [2]\ngraph[6] = [1, 2]\ngraph[7] = [3, 8]\ngraph[0] = [2]\ngraph[2] = [6]\ngraph[9] = [7, 0, 6]\ngraph[5] = [3, 8]\ngraph[3] = [5, 1]\n\n# Check if there is a path from node 5 to node 9\nresult = has_path(graph, 5, 9)\nprint(result)\n```"}, {"id": 238, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [11, 8, 1, 7, 12, 3],\n    11: [6, 1, 9],\n    8: [6, 9, 4, 0, 2],\n    1: [6, 11, 10, 12, 4, 3],\n    7: [6, 2, 4],\n    12: [6, 10, 1],\n    3: [6, 5, 1],\n    9: [11, 8, 10],\n    4: [8, 5, 1, 7],\n    0: [8, 10, 2, 5],\n    2: [8, 10, 0, 7],\n    10: [9, 2, 0, 1, 12],\n    5: [0, 4, 3]\n}\n\n# Check if there is a path between node 1 and node 9\nprint(has_path(graph, 1, 9))  # Output: True\n```"}, {"id": 239, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[0] = [2]\ngraph[2] = [5, 12]\ngraph[1] = [11]\ngraph[9] = [7, 6, 1]\ngraph[7] = [0, 2, 11]\ngraph[6] = [0, 8, 7]\ngraph[5] = [7]\ngraph[12] = [2]\ngraph[8] = [1]\ngraph[10] = [3, 5]\ngraph[3] = [0]\ngraph[4] = [0, 9, 7]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 1 to node 6\nresult = has_path(graph, 1, 6)\nprint(\"Is there a directed path from node 1 to node 6?\", result)\n```"}, {"id": 240, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [7, 1, 12, 4, 13, 0],\n    7: [11, 1, 9, 4, 2, 6, 13, 3],\n    1: [4, 2, 6, 0, 5, 11],\n    12: [8, 4, 2, 6, 3, 5, 10, 1, 9],\n    4: [6, 3, 5],\n    13: [0, 3, 5, 10, 7, 6],\n    0: [3, 10, 7, 11, 8, 6],\n    10: [1, 9, 8, 6, 13, 3, 5],\n    9: [5, 7],\n    8: [6, 0, 7, 11],\n    6: [3, 7],\n    3: [5, 9, 12, 6, 13],\n    11: [9, 0, 10, 7],\n    2: [6, 13, 0, 3, 5, 10, 1, 4]\n}\n\n# Check if there is a path from node 13 to node 5\nresult = has_path(graph, 13, 5)\nprint(result)\n```"}, {"id": 241, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [11, 2, 10, 0],\n    11: [13, 4, 7, 0, 6],\n    2: [4, 7, 10, 0, 12],\n    10: [2, 4, 7],\n    0: [6, 13, 10],\n    9: [5],\n    5: [7, 3, 11],\n    8: [5, 10, 0, 9],\n    1: [11, 3, 0, 9],\n    3: [9, 2],\n    6: [4, 0],\n    4: [12, 6, 5],\n    13: [5, 2],\n    7: [13]\n}\n\n# Check if there is a path from node 0 to node 8\nresult = has_path(graph, 0, 8)\nprint(result)\n```"}, {"id": 242, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [3, 4, 8, 5, 7],\n    3: [6, 4, 5],\n    4: [6, 3, 0, 8, 1, 5],\n    8: [6, 0, 4, 2],\n    5: [6, 3, 0, 4, 2, 7],\n    7: [6, 5],\n    0: [4, 2, 8, 5],\n    2: [0, 8, 1, 5],\n    1: [4, 2]\n}\n\n# Check if there is a path between node 5 and node 4\nprint(has_path(graph, 5, 4))  # Output: True\n```"}, {"id": 243, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    10: [13, 6, 0],\n    13: [10, 4],\n    6: [10, 3, 14],\n    0: [10, 5, 12],\n    4: [13, 9],\n    1: [5, 3],\n    5: [1, 0],\n    3: [1, 6],\n    2: [7, 11],\n    7: [2, 11, 8],\n    11: [2, 7],\n    8: [7],\n    12: [0],\n    14: [6],\n    9: [4]\n}\n\n# Check if there is a path between node 8 and node 4\nprint(has_path(graph, 8, 4))  # Output: True\n```"}, {"id": 244, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [2, 3, 4],\n    2: [4, 7, 6, 1],\n    4: [7, 5, 2],\n    7: [3, 4],\n    6: [1, 3, 5],\n    1: [4, 7, 6],\n    3: [4, 7, 5, 1, 2],\n    5: [6, 1, 3, 4, 7]\n}\n\n# Check if there is a path from node 0 to node 6\nresult = has_path(graph, 0, 6)\nprint(result)\n```"}, {"id": 245, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [12, 9, 5],\n    12: [4, 10],\n    9: [4, 10],\n    5: [4],\n    10: [12, 9, 6],\n    2: [0, 11, 3],\n    0: [2, 11],\n    11: [2, 0, 1],\n    3: [2, 8],\n    7: [1],\n    1: [7, 11],\n    8: [3],\n    6: [10]\n}\n\n# Check if there is a path between node 7 and node 4\nresult = has_path(graph, 7, 4)\nprint(result)\n```"}, {"id": 246, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [11, 2, 7, 0, 5, 8],\n    11: [4, 7, 10, 9, 2],\n    2: [4, 11, 3, 5, 6, 9, 10],\n    7: [4, 11, 5, 6],\n    0: [4, 1, 5, 9, 10],\n    5: [4, 3, 2, 0, 8, 7, 10],\n    8: [4, 5, 10],\n    10: [11, 5, 2, 0, 6, 8],\n    9: [11, 2, 0],\n    1: [3, 0],\n    3: [1, 2, 5],\n    6: [2, 7, 10]\n}\n\n# Check if there is a path between node 1 and node 5\nprint(has_path(graph, 1, 5))  # Output: True\n```"}, {"id": 247, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [4, 2],\n    4: [3, 0],\n    2: [5],\n    6: [8, 3],\n    0: [9, 2, 8],\n    9: [10],\n    10: [3, 6],\n    7: [3, 1, 2]\n}\n\n# Check if there is a path from node 3 to node 1\nresult = has_path(graph, 3, 1)\nprint(result)\n```"}, {"id": 248, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [1, 4, 9, 2, 5, 3, 6],\n    1: [7, 0, 8, 5],\n    4: [7, 9, 5, 3],\n    9: [7, 4, 5],\n    2: [7, 0, 5, 3],\n    5: [7, 1, 4, 9, 3, 2],\n    3: [7, 4, 8, 0, 5, 2],\n    6: [7, 8],\n    0: [1, 2, 3],\n    8: [1, 6, 3]\n}\n\n# Check if there is a path between node 9 and node 2\nprint(has_path(graph, 9, 2))  # Output: True\n```"}, {"id": 249, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[5] = [9, 4, 8, 3]\ngraph[9] = [3, 2]\ngraph[4] = [5]\ngraph[3] = [5, 4, 7]\ngraph[1] = [9, 4, 8]\ngraph[2] = [9, 7]\ngraph[0] = [3, 9]\ngraph[6] = [7, 8, 3, 0]\ngraph[7] = [5]\n\n# Function to perform DFS and check if there is a path from start to end\ndef dfs(graph, start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 8 to node 2\nstart_node = 8\nend_node = 2\nvisited = set()\nresult = dfs(graph, start_node, end_node, visited)\nprint(\"Is there a directed path from node 8 to node 2?\", result)\n```"}, {"id": 250, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [4, 5],\n    4: [1, 7, 5],\n    5: [1, 4],\n    7: [4],\n    6: [9, 3],\n    9: [6, 8],\n    3: [6, 0, 10, 2],\n    8: [9, 2],\n    2: [8, 3],\n    0: [3],\n    10: [3]\n}\n\n# Check if there is a path between node 2 and node 1\nprint(has_path(graph, 2, 1))  # Output: False\n```"}, {"id": 251, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [5, 6, 4, 1, 2, 8, 0],\n    5: [7, 2, 3],\n    6: [7, 2, 8, 0, 3],\n    4: [7, 1, 2, 0],\n    1: [7, 4, 2, 0, 3],\n    2: [7, 5, 6, 4, 1, 0, 3],\n    8: [7, 6, 3],\n    0: [7, 6, 4, 1, 2],\n    3: [5, 6, 1, 2, 8]\n}\n\n# Check if there is a path between node 3 and node 2\nprint(has_path(graph, 3, 2))  # Output: True\n```"}, {"id": 252, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [6, 4, 2, 8, 0],\n    6: [5, 1],\n    4: [5],\n    2: [5],\n    8: [5, 7, 3],\n    0: [5],\n    1: [6],\n    7: [8],\n    3: [8]\n}\n\n# Check if there is a path between node 6 and node 4\nprint(has_path(graph, 6, 4))  # Output: True\n```"}, {"id": 253, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [3, 9],\n    3: [2, 9],\n    9: [2, 3, 0],\n    0: [9, 7],\n    1: [5],\n    5: [1, 6],\n    6: [5, 8, 4],\n    8: [6, 4],\n    4: [8, 6],\n    7: [0]\n}\n\n# Check if there is a path between node 6 and node 3\nprint(has_path(graph, 6, 3))  # Output: True\n```"}, {"id": 254, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [3, 11, 4, 6],\n    3: [12, 5],\n    11: [4, 6, 12, 8, 2],\n    4: [10, 9, 8, 2],\n    6: [9, 12, 3, 2],\n    8: [2, 11, 7, 4],\n    2: [7, 9, 5, 0],\n    7: [4, 6, 1, 3, 11],\n    1: [0, 11, 4, 8],\n    0: [11, 7, 4, 6, 8, 1],\n    5: [0, 3, 10, 6, 8, 1],\n    10: [12, 8, 1, 5, 0, 3, 2, 4],\n    9: [12, 8, 1, 5, 2, 11, 7]\n}\n\n# Check if there is a path from node 6 to node 4\nresult = has_path(graph, 6, 4)\nprint(result)\n```"}, {"id": 255, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [4, 12, 0, 8, 2],\n    4: [8, 2, 6],\n    12: [8, 2, 11, 6],\n    0: [11, 4],\n    8: [10, 6],\n    2: [9, 6, 12, 0],\n    5: [10, 7],\n    10: [1, 7, 3, 5, 9],\n    9: [10, 4, 8],\n    11: [6, 1],\n    6: [7, 5, 10],\n    1: [7, 3, 9, 10, 6, 12]\n}\n\n# Check if there is a path from node 7 to node 10\nresult = has_path(graph, 7, 10)\nprint(result)\n```"}, {"id": 256, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [4, 8, 2, 10],\n    4: [6, 5, 12, 3],\n    8: [6],\n    2: [6, 7],\n    10: [6, 0, 9],\n    5: [4, 1],\n    12: [4],\n    3: [4],\n    0: [10, 11],\n    9: [10],\n    11: [0],\n    1: [5],\n    7: [2]\n}\n\n# Check if there is a path between node 6 and node 2\nprint(has_path(graph, 6, 2))  # Output: True\n```"}, {"id": 257, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [3, 2, 10],\n    3: [1, 11],\n    2: [1, 12],\n    10: [1, 11],\n    11: [3, 10],\n    6: [4],\n    4: [6, 7],\n    7: [4, 5],\n    5: [7, 8],\n    8: [5, 9, 0],\n    9: [8, 0],\n    0: [8, 9],\n    12: [2]\n}\n\n# Check if there is a path between node 1 and node 4\nprint(has_path(graph, 1, 4))  # Output: True\n```"}, {"id": 258, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [5, 10, 11, 13, 12, 8, 7],\n    5: [2, 3, 0, 10, 6, 9, 12],\n    10: [2, 3, 0, 4, 5, 11, 1, 13, 8, 7],\n    11: [2, 0, 4, 10, 6, 9, 13, 7],\n    13: [2, 3, 0, 4, 10, 6, 11, 1, 12, 8, 7],\n    12: [2, 3, 4, 5, 6, 1, 9, 13, 8, 7],\n    8: [2, 3, 0, 10, 6, 9, 13, 12, 7],\n    7: [2, 3, 0, 4, 10, 6, 11, 9, 13, 12, 8],\n    3: [0, 4, 5, 10, 6, 9, 13, 12, 8, 7],\n    0: [3, 5, 10, 6, 11, 1, 9, 13, 8, 7],\n    4: [3, 10, 6, 11, 1, 9, 13, 12, 7],\n    6: [3, 0, 4, 5, 11, 1, 9, 13, 12, 8, 7],\n    9: [3, 0, 4, 5, 6, 11, 1, 12, 8, 7],\n    1: [0, 4, 10, 6, 9, 13, 12]\n}\n\n# Check if there is a path between node 5 and node 10\nresult = has_path(graph, 5, 10)\nprint(\"Is there a path between node 5 and node 10?\", result)\n```"}, {"id": 259, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [10, 5, 9],\n    10: [4, 6, 0, 8],\n    9: [3, 0, 1, 5],\n    8: [5, 0],\n    4: [2, 6, 3, 8, 1],\n    6: [5, 9, 0, 8, 4],\n    1: [7],\n    7: [6, 3, 0, 10],\n    2: [7, 10],\n    3: [1, 7, 6]\n}\n\n# Check if there is a path from node 5 to node 0\nresult = has_path(graph, 5, 0)\nprint(result)\n```"}, {"id": 260, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [9, 2, 5, 13, 3, 6],\n    9: [2, 7, 0, 10, 13, 14, 1],\n    2: [7, 12, 0, 5, 6, 4],\n    5: [3, 4, 11, 12],\n    13: [9, 2],\n    3: [4, 7, 13],\n    6: [4, 12, 0, 10, 5, 3, 14],\n    7: [5],\n    0: [6, 9, 2, 7],\n    10: [3, 14, 9],\n    14: [7, 13],\n    1: [4, 11, 3, 14],\n    12: [5, 13, 1, 8, 11],\n    4: [7, 0, 6],\n    11: [10, 3]\n}\n\n# Check if there is a path from node 12 to node 2\nresult = has_path(graph, 12, 2)\nprint(result)\n```"}, {"id": 261, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[6].append(4)\ngraph[4].append(2)\ngraph[0].append(1)\ngraph[0].append(3)\ngraph[0].append(2)\ngraph[3].append(1)\ngraph[2].append(6)\ngraph[2].append(0)\ngraph[5].append(1)\ngraph[5].append(0)\ngraph[7].append(6)\ngraph[7].append(5)\ngraph[7].append(1)\n\n# Check if there is a path from node 3 to node 2\nprint(has_path(graph, 3, 2))  # Output: True\n```"}, {"id": 262, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [7, 3, 10],\n    7: [8, 5],\n    3: [8, 0, 2, 1, 9, 5],\n    10: [8, 1],\n    5: [7, 4, 3, 1],\n    4: [0, 5, 6, 1],\n    0: [4, 3],\n    6: [4, 9],\n    1: [4, 3, 2, 10, 5],\n    2: [3, 1, 9],\n    9: [3, 2, 6]\n}\n\n# Check if there is a path between node 2 and node 3\nprint(has_path(graph, 2, 3))  # Output: True\n```"}, {"id": 263, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[4] = [1, 0]\ngraph[0] = [6, 7]\ngraph[3] = [7, 6, 4]\ngraph[7] = [1, 0, 4]\ngraph[6] = [4]\ngraph[5] = [1, 7]\ngraph[2] = [1, 6, 4, 7, 5]\n\n# Check if there is a path from node 1 to node 4\nresult = has_path(graph, 1, 4)\nprint(result)\n```"}, {"id": 264, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [10, 3],\n    10: [2, 4, 5],\n    3: [2, 7],\n    4: [10, 7],\n    5: [10, 1],\n    7: [4, 6, 3],\n    6: [7, 9],\n    9: [6, 8],\n    0: [8],\n    8: [0, 9],\n    1: [5]\n}\n\n# Check if there is a path between node 1 and node 6\nprint(has_path(graph, 1, 6))  # Output: True\n```"}, {"id": 265, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [3, 0],\n    3: [1, 0, 7],\n    0: [1, 3, 11],\n    7: [3, 4],\n    8: [6, 10, 2],\n    6: [8, 10],\n    10: [8, 6],\n    2: [8, 9, 5],\n    9: [2],\n    5: [2],\n    4: [7],\n    11: [0]\n}\n\n# Check if there is a path between node 0 and node 10\nprint(has_path(graph, 0, 10))  # Output: True\n```"}, {"id": 266, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[8] = [5, 6, 2, 1]\ngraph[5] = [6, 2, 3, 7, 1, 8]\ngraph[6] = [2, 0, 4, 5]\ngraph[2] = [9, 0, 7, 8, 5]\ngraph[1] = [4, 5, 2, 9, 0]\ngraph[4] = [5, 0, 3, 1]\ngraph[0] = [1, 5, 6, 2]\ngraph[3] = [6, 2, 9]\ngraph[7] = [6, 3]\ngraph[9] = [1, 8]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 2 to node 5\npath_exists = has_path(graph, 2, 5)\nprint(\"Is there a directed path from node 2 to node 5?\", path_exists)\n```"}, {"id": 267, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [0, 9, 5],\n    0: [9],\n    9: [6],\n    5: [1, 0, 9],\n    4: [10, 5, 3],\n    10: [6, 1],\n    3: [4],\n    8: [10, 1],\n    1: [4, 3],\n    7: [0, 5, 3]\n}\n\n# Check if there is a path from node 0 to node 8\nresult = has_path(graph, 0, 8)\nprint(result)\n```"}, {"id": 268, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[2] = [10, 3, 7, 0, 5]\ngraph[10] = [4, 7]\ngraph[3] = [2, 10]\ngraph[7] = [2, 3, 6, 8]\ngraph[0] = [1, 2, 9]\ngraph[5] = [10]\ngraph[4] = [0, 1, 5, 8]\ngraph[9] = [4, 10]\ngraph[6] = [4, 0, 3]\ngraph[8] = [7, 0, 9]\ngraph[1] = [10, 8, 0]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 6 to node 7\npath_exists = has_path(graph, 6, 7)\nprint(\"Is there a directed path from node 6 to node 7?\", path_exists)\n```"}, {"id": 269, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    10: [5, 11],\n    5: [10, 11],\n    11: [10, 5],\n    4: [0, 1, 3, 9],\n    0: [4, 12],\n    1: [4, 2],\n    3: [4, 12],\n    9: [4, 8],\n    12: [0, 3],\n    2: [1],\n    6: [7],\n    7: [6, 8],\n    8: [7, 9]\n}\n\n# Check if there is a path between node 11 and node 9\nresult = has_path(graph, 11, 9)\nprint(result)\n```"}, {"id": 270, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    13: [6, 7, 10, 0, 3, 5, 2, 8, 11, 4, 14],\n    6: [13, 7, 9, 12, 0, 3, 5, 2, 1, 11, 4, 14],\n    7: [13, 6, 9, 10, 12, 0, 3, 1, 8, 11, 14],\n    10: [13, 7, 12, 0, 1, 4, 14],\n    0: [13, 6, 7, 9, 10, 12, 3, 5, 2, 1, 8, 4, 14],\n    3: [13, 6, 7, 9, 0, 5, 2, 1, 11, 4],\n    5: [13, 6, 12, 0, 3, 2, 1, 8, 11, 14],\n    2: [13, 6, 9, 12, 0, 3, 5, 1, 8, 14],\n    8: [13, 7, 9, 12, 0, 5, 2, 11, 14],\n    11: [13, 6, 7, 9, 12, 3, 5, 1, 8, 14],\n    4: [13, 6, 9, 10, 0, 3, 1],\n    14: [13, 6, 7, 10, 0, 5, 2, 1, 8, 11],\n    9: [6, 7, 0, 3, 2, 8, 11, 4],\n    12: [6, 7, 10, 0, 5, 2, 1, 8, 11],\n    1: [6, 7, 10, 12, 0, 3, 5, 2, 11, 4, 14]\n}\n\n# Check if there is a path between node 10 and node 8\nresult = has_path(graph, 10, 8)\nprint(\"Is there a path between node 10 and node 8?\", result)\n```"}, {"id": 271, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [6, 5, 4],\n    6: [5, 3, 1],\n    5: [9],\n    3: [1],\n    1: [3],\n    2: [8, 0],\n    8: [4, 0, 6],\n    7: [8, 4, 2],\n    9: [8, 0, 1]\n}\n\n# Check if there is a path from node 4 to node 7\nresult = has_path(graph, 4, 7)\nprint(result)\n```"}, {"id": 272, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [1],\n    1: [0, 7],\n    7: [1, 2],\n    4: [8, 5],\n    8: [4, 3],\n    5: [4, 6, 2],\n    3: [8, 6],\n    6: [3, 5],\n    2: [5, 7]\n}\n\n# Check if there is a path between node 5 and node 3\nprint(has_path(graph, 5, 3))  # Output: True\n```"}, {"id": 273, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [1, 6],\n    1: [5, 0],\n    6: [5, 0],\n    0: [1, 6],\n    11: [3, 10],\n    3: [11, 12],\n    10: [11, 2],\n    12: [3, 9, 4],\n    8: [9, 7],\n    9: [8, 2, 12],\n    7: [8],\n    2: [9, 10],\n    4: [12, 13],\n    13: [4]\n}\n\n# Check if there is a path between node 0 and node 12\nprint(has_path(graph, 0, 12))  # Output: True\n```"}, {"id": 274, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[7] = [6, 1, 3]\ngraph[6] = [1, 7, 4]\ngraph[1] = [2, 4, 6, 5, 0]\ngraph[3] = [4, 6, 0, 2]\ngraph[8] = [6, 5, 0]\ngraph[5] = [2, 3]\ngraph[0] = [1, 2, 6]\ngraph[4] = [1, 7, 8]\ngraph[2] = [3]\n\n# Check if there is a path from node 8 to node 6\nresult = has_path(graph, 8, 6)\nprint(result)\n```"}, {"id": 275, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    13: [12, 0, 9, 3, 11],\n    12: [8, 7, 6, 4, 2, 11, 10],\n    0: [6, 4, 2, 5, 10, 13],\n    9: [7, 4, 5, 13, 0],\n    3: [11, 12, 8, 0, 9],\n    8: [1, 9, 10, 13],\n    7: [6, 2, 5, 0],\n    6: [4, 10, 1, 7],\n    4: [11, 13, 12, 0],\n    2: [5, 11, 10, 1, 4],\n    10: [8, 1, 6],\n    1: [7, 4, 11, 13, 8],\n    5: [12, 1, 9, 7, 3]\n}\n\n# Check if there is a path from node 11 to node 10\nresult = has_path(graph, 11, 10)\nprint(result)\n```"}, {"id": 276, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [0, 7, 9, 10, 8],\n    0: [5],\n    7: [5, 12],\n    9: [5, 1, 3, 4],\n    10: [5],\n    8: [5],\n    1: [9, 11],\n    3: [9, 2],\n    4: [9, 6],\n    11: [1],\n    2: [3],\n    12: [7],\n    6: [4]\n}\n\n# Check if there is a path between node 9 and node 12\nresult = has_path(graph, 9, 12)\nprint(result)\n```"}, {"id": 277, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[7] = [1]\ngraph[1] = [6, 2, 10]\ngraph[8] = [3, 0]\ngraph[9] = [12, 0]\ngraph[12] = [7, 11, 9]\ngraph[5] = [8, 9]\ngraph[13] = [6]\ngraph[4] = [12, 3]\ngraph[2] = [7, 13]\ngraph[10] = [1, 7, 5, 4, 2]\n\n# Check if there is a path from node 6 to node 9\nprint(has_path(graph, 6, 9))\n```"}, {"id": 278, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    9: [5, 6, 0, 10, 3, 8, 12],\n    5: [9, 6, 0, 10, 7, 11, 12, 1],\n    6: [9, 5, 0, 4, 3],\n    0: [9, 5, 6, 10, 2, 7, 3, 8, 11, 12],\n    10: [9, 5, 0, 7, 8],\n    3: [9, 6, 0, 11, 12, 1],\n    8: [9, 0, 10, 7, 11, 12],\n    12: [9, 5, 0, 7, 3, 8, 11, 1],\n    7: [5, 0, 10, 2, 8, 12],\n    11: [5, 0, 4, 3, 8, 12],\n    1: [5, 2, 3, 12],\n    4: [6, 11],\n    2: [0, 7, 1]\n}\n\n# Check if there is a path between node 11 and node 8\nresult = has_path(graph, 11, 8)\nprint(result)\n```"}, {"id": 279, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    2: [6, 8],\n    6: [2, 9, 13],\n    8: [2],\n    9: [6, 4],\n    13: [6, 12, 11],\n    5: [10, 3],\n    10: [5, 7],\n    3: [5, 0],\n    7: [10, 0],\n    0: [3, 7],\n    4: [9, 12],\n    12: [13, 4],\n    11: [13, 1],\n    1: [11]\n}\n\n# Check if there is a path between node 0 and node 13\nprint(has_path(graph, 0, 13))  # Output: True\n```"}, {"id": 280, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    6: [2, 10, 1, 0, 4, 3],\n    2: [6, 8, 5, 0, 4, 9],\n    10: [6, 8, 5, 7, 4, 3],\n    1: [6],\n    0: [6, 8, 5, 2, 7, 3, 9],\n    4: [6, 2, 10, 7],\n    3: [6, 10, 0],\n    8: [5, 2, 10, 7, 0],\n    5: [8, 2, 10, 7, 0, 9],\n    7: [8, 5, 10, 0, 4],\n    9: [5, 2, 0]\n}\n\n# Check if there is a path between node 5 and node 2\nprint(has_path(graph, 5, 2))  # Output: True\n```"}, {"id": 281, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[9] = [5, 1, 0, 10]\ngraph[5] = [3, 4]\ngraph[1] = [3, 13, 12]\ngraph[0] = [7, 13]\ngraph[10] = [6, 12, 3, 7]\ngraph[6] = [11, 0, 3, 7, 2]\ngraph[11] = [12, 5, 7, 4]\ngraph[3] = [4, 5]\ngraph[7] = [13]\ngraph[2] = [5]\ngraph[12] = [5, 2, 4]\ngraph[4] = [7, 2]\ngraph[13] = [3, 7, 4]\ngraph[8] = [5]\n\n# Function to perform DFS and check if there is a path from start to end\ndef dfs(start, end, visited):\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if dfs(neighbor, end, visited):\n                return True\n    visited.remove(start)\n    return False\n\n# Check if there is a path from node 12 to node 11\nstart_node = 12\nend_node = 11\nvisited = set()\nresult = dfs(start_node, end_node, visited)\nprint(\"Is there a directed path from node 12 to node 11?\", result)\n```"}, {"id": 282, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[6] = [12, 9, 2, 3]\ngraph[12] = [0]\ngraph[9] = [7, 10, 6]\ngraph[2] = [8, 7, 0]\ngraph[3] = [8]\ngraph[0] = [9, 3, 10]\ngraph[10] = [1, 6, 3, 4]\ngraph[7] = [12, 0, 2]\ngraph[11] = [4, 1, 12]\ngraph[4] = [12, 2]\ngraph[1] = [7, 4]\ngraph[5] = [9, 4]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 10 to node 6\npath_exists = has_path(graph, 10, 6)\nprint(\"Is there a directed path from node 10 to node 6?\", path_exists)\n```"}, {"id": 283, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    10: [0, 11],\n    0: [6, 12],\n    11: [2],\n    1: [6, 3],\n    6: [8, 3, 12],\n    3: [8],\n    12: [0, 8],\n    14: [6, 5, 12, 1],\n    5: [9],\n    2: [6, 13, 9],\n    13: [0, 6, 5],\n    8: [13, 11, 0, 14, 6],\n    4: [9, 1],\n    7: [8, 5, 3]\n}\n\n# Check if there is a path from node 14 to node 4\nresult = has_path(graph, 14, 4)\nprint(result)\n```"}, {"id": 284, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [5, 7],\n    5: [3, 0, 7, 1],\n    7: [3, 5],\n    0: [5],\n    1: [5, 2],\n    6: [2, 4],\n    2: [6, 1],\n    4: [6]\n}\n\n# Check if there is a path between node 1 and node 4\nprint(has_path(graph, 1, 4))  # Output: True\n```"}, {"id": 285, "code": "```python\nfrom collections import defaultdict\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[11] = [7, 4, 5]\ngraph[7] = [6, 2, 10]\ngraph[4] = [8, 1]\ngraph[5] = [3, 4]\ngraph[8] = [0, 6, 4]\ngraph[0] = [8]\ngraph[6] = [7, 1]\ngraph[9] = [4, 11]\ngraph[10] = [0, 7, 12, 9]\ngraph[2] = [6]\ngraph[1] = [4, 8, 7]\ngraph[3] = [11, 12, 9, 10, 7]\n\n# Check if there is a path from node 12 to node 2\nresult = has_path(graph, 12, 2)\nprint(result)\n```"}, {"id": 286, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[3] = [12, 8]\ngraph[12] = [2]\ngraph[8] = [0, 13]\ngraph[1] = [13]\ngraph[13] = [9, 11, 2, 6]\ngraph[9] = [3, 1]\ngraph[7] = [2]\ngraph[2] = [9, 7]\ngraph[11] = [5, 13]\ngraph[5] = [13, 4]\ngraph[4] = [10]\ngraph[0] = [8, 1, 7]\ngraph[10] = [8, 1, 11]\ngraph[6] = [9]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 8 to node 12\npath_exists = has_path(graph, 8, 12)\nprint(\"Is there a directed path from node 8 to node 12?\", path_exists)\n```"}, {"id": 287, "code": "```python\nfrom collections import defaultdict, deque\n\ndef has_path(graph, start, end):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    \n    return False\n\n# Define the graph\ngraph = defaultdict(list)\ngraph[10].append(6)\ngraph[6].append(10)\ngraph[8].append(3)\ngraph[8].append(7)\ngraph[8].append(0)\ngraph[8].append(6)\ngraph[3].append(10)\ngraph[3].append(8)\ngraph[7].append(5)\ngraph[7].append(3)\ngraph[7].append(4)\ngraph[0].append(1)\ngraph[0].append(6)\ngraph[0].append(8)\ngraph[5].append(2)\ngraph[5].append(1)\ngraph[5].append(8)\ngraph[2].append(6)\ngraph[1].append(7)\ngraph[9].append(4)\n\n# Check if there is a path from node 10 to node 9\nresult = has_path(graph, 10, 9)\nprint(result)\n```"}, {"id": 288, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    7: [6, 5, 1, 2],\n    6: [5, 1, 2, 4],\n    1: [2],\n    2: [8, 7, 3],\n    3: [5, 0, 2, 8],\n    0: [2, 6, 5],\n    8: [7, 5, 0, 2],\n    4: [7, 6]\n}\n\n# Check if there is a path from node 8 to node 3\nresult = has_path(graph, 8, 3)\nprint(result)  # Output: True\n```"}, {"id": 289, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [3, 2, 5, 8, 10],\n    3: [13, 12, 11, 8, 10, 9],\n    2: [6, 12, 5, 9],\n    5: [9, 4, 13, 12],\n    8: [9, 7, 13, 2, 12],\n    10: [9, 0, 4, 3, 13],\n    4: [7, 13, 2, 12, 9],\n    7: [12, 8],\n    13: [2, 11, 10, 7],\n    12: [5, 10, 9, 4, 7, 2, 6],\n    9: [4, 3, 11],\n    11: [0, 7, 13],\n    6: [12, 5, 8, 7],\n    1: [0, 4]\n}\n\n# Check if there is a path from node 13 to node 1\nresult = has_path(graph, 13, 1)\nprint(result)\n```"}, {"id": 290, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    12: [6, 9, 2, 5, 14],\n    6: [5, 12, 8],\n    9: [1, 13, 3, 6],\n    2: [5, 11, 14, 3, 0],\n    5: [14, 0],\n    14: [6, 5, 4, 11],\n    8: [3, 2, 7, 5],\n    3: [0, 2, 5, 11, 8],\n    7: [1, 10, 14, 8, 0, 2],\n    11: [14, 12, 6, 0, 1],\n    1: [4, 10, 11, 14, 9, 7],\n    13: [12, 9, 0, 2, 1, 10],\n    10: [6, 2, 4],\n    4: [14, 9, 0, 1]\n}\n\n# Check if there is a path from node 1 to node 8\nresult = has_path(graph, 1, 8)\nprint(result)\n```"}, {"id": 291, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[4] = [9, 7, 0, 2, 6, 5]\ngraph[9] = [10, 2]\ngraph[7] = [8, 3, 0, 4]\ngraph[0] = [1, 10]\ngraph[2] = [10, 1]\ngraph[6] = [8, 10, 0, 2]\ngraph[5] = [0]\ngraph[10] = [2, 5, 9]\ngraph[8] = [1, 6]\ngraph[3] = [1, 9, 7]\ngraph[1] = [6, 10]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 6 to node 4\npath_exists = has_path(graph, 6, 4)\nprint(\"Is there a directed path from node 6 to node 4?\", path_exists)\n```"}, {"id": 292, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    1: [4, 7],\n    4: [1, 2],\n    7: [1, 3],\n    2: [4, 0, 6],\n    0: [2, 5],\n    5: [0, 6],\n    6: [2, 5],\n    3: [7]\n}\n\n# Check if there is a path between node 7 and node 3\nresult = has_path(graph, 7, 3)\nprint(result)  # Output: True\n```"}, {"id": 293, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [7, 5, 1, 0],\n    5: [1, 0],\n    1: [0, 2, 7, 5],\n    0: [1],\n    3: [6, 7],\n    2: [6]\n}\n\n# Check if there is a path from node 6 to node 4\nresult = has_path(graph, 6, 4)\nprint(result)\n```"}, {"id": 294, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    10: [6, 7],\n    6: [10, 8],\n    7: [10, 3],\n    8: [6, 11],\n    5: [13, 12, 9],\n    13: [5, 0],\n    12: [5, 4],\n    9: [5, 11],\n    0: [13, 1],\n    11: [8, 9, 1],\n    3: [7, 2],\n    2: [3],\n    1: [11, 0],\n    4: [12]\n}\n\n# Check if there is a path between node 10 and node 2\nprint(has_path(graph, 10, 2))  # Output: True\n```"}, {"id": 295, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [3, 2, 4],\n    3: [2, 6, 0],\n    2: [6, 3],\n    4: [1, 3],\n    1: [3, 0],\n    5: [2],\n    6: [0, 1, 3, 2],\n    7: [3]\n}\n\n# Check if there is a path from node 0 to node 7\nresult = has_path(graph, 0, 7)\nprint(result)\n```"}, {"id": 296, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    8: [10, 11, 0],\n    10: [11, 7, 3, 0, 8],\n    11: [5, 6],\n    0: [12, 7, 1, 2, 3],\n    7: [6, 3, 0, 12, 8],\n    3: [2],\n    5: [7, 6, 2, 3, 12, 8],\n    6: [9, 2, 3, 0, 8, 7, 13],\n    2: [12, 8, 10, 11, 5, 7, 1, 4],\n    12: [7, 13, 1, 4, 0],\n    13: [8],\n    9: [4, 0, 8, 10, 7, 13],\n    1: [12, 10, 11],\n    4: [0, 7, 13, 6, 9]\n}\n\n# Check if there is a path from node 6 to node 3\nresult = has_path(graph, 6, 3)\nprint(result)\n```"}, {"id": 297, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[7] = [1, 5]\ngraph[1] = [5, 7]\ngraph[5] = [6, 4, 8, 3]\ngraph[8] = [5, 6, 4, 7]\ngraph[6] = [8, 3]\ngraph[3] = [5, 1]\ngraph[2] = [1]\ngraph[0] = [1, 6]\n\n# Function to check if there is a path from node u to node v\ndef has_path(graph, u, v, visited=None):\n    if visited is None:\n        visited = set()\n    if u == v:\n        return True\n    visited.add(u)\n    for neighbor in graph[u]:\n        if neighbor not in visited and has_path(graph, neighbor, v, visited):\n            return True\n    return False\n\n# Check if there is a path from node 1 to node 2\npath_exists = has_path(graph, 1, 2)\nprint(\"Is there a directed path from node 1 to node 2?\", path_exists)\n```"}, {"id": 298, "code": "```python\nfrom collections import deque\n\ndef has_path(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\n# Define the graph as an adjacency list\ngraph = {\n    9: [6, 12, 0, 8, 3, 5, 10, 1, 7, 2],\n    6: [9, 7, 11, 8, 4, 10, 12, 1],\n    12: [9, 6, 3],\n    0: [9, 7, 8, 11, 10, 1, 4],\n    8: [9, 6, 2, 0],\n    3: [9, 2, 1, 12, 10, 4],\n    5: [9, 10],\n    10: [9, 6, 7, 2, 0, 11, 3, 5],\n    1: [9, 6, 0, 11, 3],\n    7: [9, 6, 10, 4, 0, 2],\n    2: [9, 7, 8, 10, 3],\n    11: [6, 0, 1, 10],\n    4: [6, 7, 0, 3]\n}\n\n# Check if there is a path between node 7 and node 3\nprint(has_path(graph, 7, 3))  # Output: True\n```"}, {"id": 299, "code": "```python\nfrom collections import defaultdict\n\n# Define the graph using adjacency list\ngraph = defaultdict(list)\ngraph[5] = [7, 1]\ngraph[7] = [4]\ngraph[1] = [11]\ngraph[6] = [0, 10, 5]\ngraph[0] = [4, 11, 10]\ngraph[9] = [2, 3]\ngraph[2] = [11]\ngraph[3] = [0, 4]\ngraph[4] = [2]\ngraph[8] = [7, 1]\n\n# Function to check if there is a path from start to end\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            if has_path(graph, neighbor, end, visited):\n                return True\n    return False\n\n# Check if there is a path from node 9 to node 5\nresult = has_path(graph, 9, 5)\nprint(\"Is there a directed path from node 9 to node 5?\", result)\n```"}]