[{"id": 0, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 8, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 4, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 3],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 10\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 1, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 7, 0, 0, 9, 0, 0, 5, 0, 0, 0, 0, 2, 0],\n    [0, 0, 6, 0, 0, 0, 9, 8, 0, 0, 0, 0, 2, 0],\n    [0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 2, 0, 0, 9, 0, 0, 4, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0],\n    [0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 7, 5, 1],\n    [0, 5, 0, 0, 7, 9, 1, 0, 0, 0, 6, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 1, 10, 0],\n    [0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 7, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 13\nsink = 12\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 2, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9],\n    [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5],\n    [0, 10, 9, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 0, 7, 0, 6, 0, 9, 0]\n]\n\ng = Graph(graph)\nsource = 3\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 3, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 3, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 10, 9, 0, 5, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 10],\n         [0, 7, 0, 0, 6, 0, 0, 0, 0, 0],\n         [0, 0, 10, 0, 0, 0, 4, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 3, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 4, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 8, 2, 0, 0, 6, 0],\n         [6, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 7, 9, 0],\n         [0, 0, 10, 0, 0, 4, 0],\n         [0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 5, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 8, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 9, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 2, 10, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 3, 0],\n         [0, 0, 0, 0, 7, 0, 0, 2, 0, 0, 9, 0],\n         [0, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 6, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 9, 0, 0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 7, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 5, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 7, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 8, 10, 0, 7, 0, 0, 0, 0, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n    [2, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n    [0, 1, 0, 0, 0, 9, 0, 2, 0, 0, 0, 0, 0, 0],\n    [7, 0, 0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 8, 0],\n    [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 5, 0, 1, 1, 0, 0, 0, 1],\n    [0, 6, 0, 0, 0, 5, 0, 0, 0, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 6, 5, 0, 9, 0, 0, 0],\n    [0, 0, 0, 9, 0, 0, 9, 0, 0, 0, 0, 0, 5, 0],\n    [0, 10, 0, 0, 0, 0, 0, 0, 0, 7, 10, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 8, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 2, 9],\n         [0, 0, 8, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 7, 0, 6, 6, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 6, 9, 0, 0],\n         [0, 0, 5, 0, 6, 0, 0, 2, 0, 3, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 1, 0, 6, 6, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 9, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 7, 0, 0, 5, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n    [3, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n    [0, 8, 5, 0, 2, 0, 6, 0, 0, 0, 0, 7, 0, 0, 0],\n    [0, 0, 0, 0, 2, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 5, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 14\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 10, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9],\n         [0, 8, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 11, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 1, 8, 2, 0, 0],\n    [10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 9, 6],\n    [0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 7, 1, 0],\n    [0, 0, 8, 0, 0, 0, 0, 0, 0, 9, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 11\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 12, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 10, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n    [0, 2, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n    [9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 5, 10, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n    [0, 6, 0, 0, 0, 0, 0, 8, 5, 0, 0, 0, 0],\n    [0, 9, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 5, 4, 0, 0, 5, 1, 0, 0]\n]\n\ng = Graph(graph)\nsource = 10\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 13, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 2, 0, 10, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 2, 0, 0, 0, 0, 3, 10, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 10, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n    [0, 8, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 12\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 14, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 15, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 2, 0, 0, 7, 0],\n         [0, 0, 1, 0, 0, 7, 0, 0],\n         [0, 3, 0, 7, 0, 1, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 7, 0],\n         [0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 16, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 1, 2, 2, 0, 0, 0, 5, 0, 0],\n    [8, 0, 0, 0, 6, 10, 6, 0, 1, 0],\n    [0, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 5, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 5, 6, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 9, 0, 0, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 17, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\ngraph = [[0, 3, 0, 0, 0, 8, 0],\n         [0, 0, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0],\n         [9, 0, 0, 3, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 18, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 7, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 5],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 9, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 19, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 4, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 1, 0, 0],\n         [4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 8, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0, 2, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 20, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0],\n         [0, 9, 0, 0, 0, 5, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 21, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 1, 0, 0, 0, 2, 8, 0, 0, 0, 0, 10, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 9, 0, 2, 0],\n    [0, 5, 0, 0, 0, 0, 4, 10, 0, 8, 2, 0, 7, 0],\n    [0, 3, 0, 0, 0, 0, 0, 0, 0, 6, 5, 9, 1, 0],\n    [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 9, 0, 2, 0],\n    [0, 0, 0, 0, 7, 1, 0, 0, 0, 7, 6, 0, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 22, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 9, 2],\n         [0, 0, 0, 0, 7, 9, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 3, 0, 2, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 23, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4],\n         [0, 0, 6, 0, 0, 10, 0, 0, 0, 0, 0, 10],\n         [0, 0, 0, 7, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 8, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 24, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\ngraph = [[0, 6, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [6, 0, 1, 8, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0],\n         [5, 5, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 0, 2, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 5, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0, 0, 4, 0, 10, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 2, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 25, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 8, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 7, 8, 0, 0],\n         [0, 0, 0, 0, 5, 1, 0, 2, 0],\n         [0, 10, 0, 0, 0, 9, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [9, 0, 0, 0, 3, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 26, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 7, 0, 1],\n         [0, 0, 0, 0, 5, 0, 8],\n         [0, 0, 0, 9, 0, 9, 0],\n         [0, 0, 2, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 5, 6],\n         [0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 27, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 3, 0, 0, 0, 2, 3, 0, 0],\n    [9, 0, 8, 0, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 10, 5, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 3, 0, 0, 0, 0, 9],\n    [0, 0, 0, 5, 0, 0, 8, 8, 0],\n    [0, 0, 3, 0, 8, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 3],\n    [0, 1, 0, 0, 0, 0, 0, 6, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 28, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 10, 0, 7, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 29, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 9, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 4, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 7, 0, 10, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 4, 0, 9, 0, 10, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 6, 0, 9, 0, 8, 0],\n    [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n    [0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 4, 1, 0, 0, 0, 10, 0],\n    [0, 0, 0, 0, 4, 0, 0, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 5, 7, 1, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 7\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 30, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 7, 0, 0, 0, 0, 0, 0, 3],\n    [0, 0, 9, 3, 0, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 10, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 6, 0],\n    [0, 0, 0, 0, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 2],\n    [0, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 2, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 31, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 8, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 7, 8, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 5, 5, 0, 0],\n    [0, 0, 0, 0, 9, 4, 0, 5, 6, 0],\n    [0, 0, 9, 0, 0, 0, 5, 0, 8, 0],\n    [0, 0, 0, 4, 0, 0, 7, 7, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 5, 0],\n    [0, 0, 5, 0, 0, 0, 7, 0, 0, 0],\n    [0, 0, 0, 6, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 4, 0, 0, 2, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 32, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 4],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 12\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 33, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 7, 1, 3, 0, 0],\n         [0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n         [0, 3, 0, 8, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 0, 10, 0],\n         [0, 0, 0, 5, 0, 0, 0, 0, 4, 0],\n         [0, 9, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 34, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n    [0, 0, 4, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 9, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 5, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n    [0, 0, 0, 0, 6, 0, 2, 0, 0, 0, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 35, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 7, 0, 0, 9, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 6, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 8, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0],\n         [0, 6, 0, 0, 0, 0, 0, 0, 0],\n         [5, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 36, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 10, 3, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n    [0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 7\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 37, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10, 0, 3, 4],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 10, 0, 9, 6, 0],\n         [0, 4, 0, 0, 6, 2, 0, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [1, 0, 0, 9, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 38, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 9, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 3, 0, 0, 7],\n         [1, 0, 7, 0, 0, 6, 0, 0],\n         [0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 4, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 7, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 39, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 5, 0, 6, 8, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 7, 0, 4, 0, 9, 7, 0, 10, 0, 0],\n         [0, 0, 0, 1, 5, 3, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 9],\n         [0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 0, 0],\n         [0, 0, 0, 7, 1, 0, 0, 0, 0, 8, 3, 0],\n         [0, 0, 0, 0, 0, 1, 9, 0, 0, 0, 0, 9],\n         [0, 0, 0, 0, 0, 0, 2, 0, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 40, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 10, 1, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0],\n    [0, 0, 0, 0, 8, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 8, 0, 2, 0, 7, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 9, 4, 0, 0, 4, 9, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 3, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 10, 9, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 7, 6, 2, 0],\n    [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 5, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 12\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 41, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n         [0, 0, 0, 0, 9, 0, 0, 0, 0, 6, 0, 0],\n         [0, 5, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 6\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 42, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 43, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 10, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n    [0, 0, 0, 1, 5, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 9, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 8\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 44, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 6, 3, 0, 0, 1, 1],\n         [0, 0, 7, 8, 0, 10, 4],\n         [0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 3, 0],\n         [0, 0, 0, 8, 0, 0, 9],\n         [5, 0, 0, 9, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 45, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 4],\n         [0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4],\n         [0, 0, 4, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 46, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 3, 0, 0, 6],\n         [0, 0, 0, 9, 0, 9, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 7, 0, 9, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 10, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 0, 0]]\n\n        g = Graph(graph)\n        print(\"The maximum possible flow is %d \" % g.ford_fulkerson(10, 9))\n```"}, {"id": 47, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 10, 0, 0, 1, 0]]\n\ng = Graph(graph)\nsource = 11\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 48, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 10, 7, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n    [0, 0, 0, 0, 4, 0, 0, 0, 3, 0, 0, 0],\n    [0, 0, 0, 6, 9, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 10, 0, 0, 8],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n    [0, 0, 0, 0, 0, 0, 5, 0, 0, 4, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 9, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 49, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 7, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 10, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 3, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 50, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 1, 6, 0, 6, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 0, 0, 0],\n    [0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 5, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0],\n    [0, 0, 1, 4, 9, 3, 3, 0, 0, 0, 0, 1, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0],\n    [0, 2, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 51, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 0, 0, 0],\n         [4, 0, 3, 2, 6, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [8, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 10, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 52, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 0, 0, 0, 0, 0, 4],\n         [0, 0, 5, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 10, 0, 2, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 7, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 53, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 6, 1, 9, 0, 0, 0, 0, 0, 0],\n         [9, 0, 0, 0, 6, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 2, 0, 3, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 3, 0, 0, 0, 0],\n         [2, 0, 9, 0, 0, 0, 8, 8, 0, 0, 0, 7],\n         [6, 0, 0, 0, 0, 0, 0, 7, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 6, 1, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 54, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 8\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 55, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 6, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n         [9, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0],\n         [0, 0, 8, 9, 0, 6, 0, 0, 5, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 0],\n         [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 56, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 2, 7, 0, 0, 0],\n         [0, 3, 0, 0, 0, 0, 0, 0, 0, 2],\n         [0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 6, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0, 0, 0],\n         [0, 8, 0, 0, 0, 0, 9, 6, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 57, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0,0, 7, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 58, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 4, 0, 0],\n         [0, 0, 9, 1, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [10, 0, 0, 0, 5, 0, 0, 0],\n         [0, 3, 0, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0, 8],\n         [0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 59, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 0, 0, 0, 10, 0, 5],\n         [0, 0, 1, 5, 5, 0, 0, 0],\n         [0, 0, 0, 0, 7, 3, 0, 3],\n         [0, 0, 0, 0, 1, 0, 2, 0],\n         [0, 0, 0, 5, 0, 0, 1, 2],\n         [0, 0, 7, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 60, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 1, 0],\n         [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0, 2, 1, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 61, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n    [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 62, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 9, 0, 0, 0, 0, 0],\n         [0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 63, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 10, 9, 2, 4, 3, 0, 0, 0, 0, 0, 0],\n    [0, 0, 3, 7, 9, 0, 1, 0, 0, 0, 0, 0],\n    [0, 2, 0, 10, 1, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 9, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 64, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 0, 0],\n         [0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 65, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 0, 7, 9],\n         [0, 0, 0, 0, 0, 0, 0, 4, 2, 0],\n         [0, 0, 0, 0, 7, 8, 0, 5, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 0, 5, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 66, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 8, 2, 6, 0],\n         [0, 0, 7, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 6, 3],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 3, 8, 3],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 7, 6, 0, 5, 2],\n         [0, 0, 0, 0, 0, 5, 3, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 67, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n    [2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6, 0],\n    [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 5, 0, 7, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 5, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 1, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 8, 1, 0, 4, 0, 0, 7, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0],\n    [0, 8, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 1\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 68, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 10, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 10, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0,0, 1, 0, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 3, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8]]\n\ng = Graph(graph)\nsource = 6\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 69, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 7, 5, 4, 10, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 8, 8, 8, 3, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 5, 3, 0, 0],\n         [0, 0, 0, 0, 0, 1, 6, 0, 0, 0, 8, 0, 0, 10, 0],\n         [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 4, 7, 0, 0, 0, 0],\n         [0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 9, 0, 0, 0, 0],\n         [0, 4, 0, 0, 0, 6, 5, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 8, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 14\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 70, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 9, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 6, 3, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 71, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n                    if ind == t:\n                        return True\n        return False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 7, 2, 0],\n    [0, 5, 0, 0, 5, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 6, 0, 0, 9, 0, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 8, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [10, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 72, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 0, 0, 2, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0],\n    [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 2, 8, 0, 2, 0, 0],\n    [0, 0, 0, 0, 5, 0, 0, 0, 4, 0, 0],\n    [0, 0, 0, 8, 0, 10, 0, 0, 9, 6, 0],\n    [0, 4, 2, 0, 0, 10, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 9, 9, 0, 0, 0, 2, 2],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 3\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 73, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 4, 0, 0, 1, 0, 9, 0],\n         [0, 0, 6, 8, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 6, 0, 10, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 8, 0, 0]]\n\ng = Graph(graph)\nsource = 6\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 74, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 4, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 5, 0, 0, 0, 0, 0, 0],\n         [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 75, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [[0, 3, 0, 0, 0, 0, 6],\n         [7, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 7, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0],\n         [0, 9, 4, 0, 0, 5, 0],\n         [0, 0, 0, 1, 0, 0, 4],\n         [0, 5, 0, 0, 5, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 76, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 0, 9, 6, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n    [0, 0, 2, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 4, 9, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 7, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 5, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 7],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 3\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 77, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 10, 0, 0, 10, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 9, 0, 0, 0, 0, 0, 4, 3, 0],\n    [0, 3, 0, 0, 8, 0, 0, 0, 0, 10, 0, 0],\n    [0, 0, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 4, 1],\n    [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 10\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 78, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [8, 1, 0, 0, 0, 8, 7, 0, 0, 0, 0, 0, 0],\n    [0, 0, 7, 0, 0, 0, 0, 0, 0, 9, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n    [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 79, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n         [5, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 80, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 0, 0, 8, 3, 0],\n         [0, 0, 0, 0, 0, 7, 0],\n         [0, 0, 0, 9, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10],\n         [0, 1, 6, 0, 0, 0, 1],\n         [0, 0, 0, 0, 10, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 81, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 5, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 2, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 10, 0, 0, 8, 0, 9, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 82, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 9, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 5, 0, 0, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 5, 0],\n    [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 3\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 83, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [10, 0, 0, 0, 0, 0, 10, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 11\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 84, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 3, 3, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 9, 1, 0, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 8, 0, 0, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 9, 0],\n    [0, 1, 0, 0, 0, 0, 0, 2, 0, 10],\n    [0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 5, 0, 0, 5],\n    [0, 0, 0, 0, 0, 0, 0, 6, 0, 0]\n]\n\ng = Graph(graph)\nsource = 6\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 85, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 0, 0, 0, 8, 0, 5, 0, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 3, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 6, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 86, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 2, 0, 3, 4, 0, 0, 0],\n         [0, 0, 0, 2, 2, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0, 0],\n         [0, 9, 0, 0, 0, 0, 0, 2, 1],\n         [0, 0, 0, 1, 7, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 87, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 3, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 5, 0, 0, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 6, 0, 0, 5, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 9, 3],\n         [0, 0, 0, 0, 0, 0, 0, 5, 10, 0],\n         [0, 0, 2, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 7],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 88, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 1, 6],\n         [0, 0, 10, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9],\n         [0, 0, 10, 0, 4, 0, 0, 0],\n         [0, 6, 5, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 7, 1, 0, 4, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 89, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 0, 3],\n         [0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0],\n         [6, 0, 0, 0, 1, 0, 0],\n         [0, 0, 9, 0, 0, 1, 10],\n         [0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 4, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 90, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n# Define the graph\ng = Graph(graph)\n\n# Define the source and sink\nsource = 7\nsink = 11\n\n# Calculate the maximum flow\nmax_flow = g.ford_fulkerson(source, sink)\n\nprint(\"The maximum possible flow is %d \" % max_flow)\n```"}, {"id": 91, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 4, 0, 1, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 10, 0, 0, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 7, 4],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n         [0, 0, 10, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 92, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 93, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 9, 0, 1, 0, 0, 4],\n         [0, 0, 8, 1, 0, 1, 0, 0],\n         [0, 10, 0, 0, 0, 9, 0, 0],\n         [0, 0, 10, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 6, 0],\n         [0, 0, 0, 0, 10, 0, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 94, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0],\n    [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 2, 0, 0, 0, 6, 0, 0],\n    [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0],\n    [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0]\n]\n\ng = Graph(graph)\nsource = 6\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 95, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 2, 9, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 8, 0, 0, 9, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 1, 0, 0, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 4, 0, 0, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 96, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n    [0, 0, 0, 0, 0, 7, 0, 0, 0, 9, 8],\n    [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 0, 1, 7, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n    [0, 0, 0, 0, 0, 0, 7, 6, 0, 0, 5],\n    [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 4, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 10, 9, 0, 1],\n    [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 97, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 0, 0, 0, 8, 0, 0, 0],\n         [0, 0, 2, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 2, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 98, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 6, 1, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0],\n         [0, 0, 0, 7, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 5, 0, 0, 0, 7, 0, 0],\n         [0, 0, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 5, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0]]\n\n        g = Graph(graph)\n        print(\"The maximum possible flow is %d \" % g.ford_fulkerson(12, 7))\n```"}, {"id": 99, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 6, 5, 10, 0, 0, 0, 2, 0, 0],\n    [0, 0, 9, 0, 0, 10, 0, 0, 0, 0],\n    [0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 3, 0, 0, 10, 4, 0],\n    [0, 0, 0, 0, 0, 1, 5, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 5, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 2],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 7\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 100, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 6, 5, 9, 0, 0, 0, 0, 0],\n         [0, 0, 8, 0, 0, 10, 0, 7, 10, 0],\n         [0, 0, 0, 0, 0, 2, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 5, 3, 2, 0],\n         [0, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 2, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 101, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 10, 0],\n         [0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 7, 0, 2, 0, 0, 0],\n         [0, 4, 0, 2, 0, 5, 0, 1],\n         [0, 0, 10, 0, 0, 0, 0, 0],\n         [0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 102, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 7, 0, 0, 0, 0, 10, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n    [0, 0, 10, 9, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0],\n    [0, 7, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 9, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 7, 6, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 10, 5, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 5, 3, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 10, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 5, 10, 0]\n]\n\ng = Graph(graph)\nsource = 8\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 103, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 8, 8, 0, 0, 0, 1, 0, 0, 1, 7, 0, 0, 0],\n         [4, 0, 10, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 10, 9, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 6, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 4, 3, 0, 0, 0, 0, 10, 3, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 2, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 104, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 5, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 1, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 6, 8, 3, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 3, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10, 10, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 105, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 3, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0, 6]]\n\ng = Graph(graph)\nsource = 0\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 106, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n    [0, 10, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 10, 0, 0, 0],\n    [0, 7, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0]\n]\n\ng = Graph(graph)\nsource = 3\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 107, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 10, 0, 0, 0, 0, 10, 0, 0, 0, 2],\n         [0, 0, 7, 0, 9, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0],\n         [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 3, 0, 0, 0, 10, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 108, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 0, 0, 0],\n         [0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 9, 9],\n         [0, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 8, 0, 7, 0],\n         [0, 5, 5, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 109, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 8, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 10, 0, 0, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 9, 5, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 4, 6, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 2, 5, 0, 7, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 110, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 6, 0, 5, 0, 0],\n    [0, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 0, 0, 4, 4, 10, 0, 0, 0],\n    [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 0, 1, 0, 7, 0, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n    [0, 0, 5, 0, 0, 6, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 4, 10, 0, 0, 0, 10, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 111, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 7, 3, 0, 10, 9, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 112, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 6, 0, 0, 0, 0, 0, 0, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 5, 0, 0, 1, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 8, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 113, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 6, 0, 0, 6, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 5, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 10, 6, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 114, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 4, 0, 0, 0, 0, 6, 0, 0],\n    [7, 0, 9, 0, 8, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 3, 0, 0, 1, 0],\n    [9, 0, 0, 3, 0, 8, 0, 2, 0],\n    [0, 0, 0, 0, 0, 0, 10, 0, 0],\n    [0, 0, 0, 0, 0, 10, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 6\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 115, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 10, 0, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n    [3, 4, 0, 0, 0, 0, 0, 2, 0, 0, 9, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 10, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n    [0, 0, 0, 5, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 7, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 1\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 116, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 3, 0, 0, 0, 0, 7, 0, 0, 0, 0, 5],\n    [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 0, 10],\n    [0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n    [0, 5, 0, 0, 10, 0, 0, 7, 0, 0, 9, 0]\n]\n\ng = Graph(graph)\nsource = 4\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 117, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 2, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n         [2, 5, 0, 8, 0, 0, 5, 0, 4, 0],\n         [0, 0, 7, 0, 0, 0, 0, 2, 10, 0],\n         [1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 4, 0, 0, 0, 0, 0, 0, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 118, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n                    if ind == t:\n                        return True\n        return False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 6, 0, 0, 5, 1, 0, 0, 0, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 2, 9, 0, 0, 1, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 1\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 119, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 8, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 10, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 3, 0, 0, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 6, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 120, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 9, 0, 9, 0, 0, 0, 0],\n         [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 3],\n         [0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 121, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 8, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 122, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 4, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 9, 0, 0, 10, 0, 0, 4],\n    [0, 0, 0, 8, 0, 10, 0, 0, 0],\n    [0, 10, 0, 0, 6, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 7, 0, 1],\n    [0, 0, 0, 0, 0, 0, 10, 4, 0],\n    [0, 0, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 0]\n]\n\ng = Graph(graph)\nsource = 6\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 123, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 3, 0, 0, 0, 3],\n         [0, 5, 0, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 1, 5],\n         [0, 0, 0, 8, 0, 0, 6],\n         [0, 0, 5, 10, 0, 0, 0],\n         [0, 0, 0, 1, 0, 3, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 124, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 2, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 125, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 3, 0, 1, 6, 1],\n         [0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 5, 0, 0, 0, 0, 4, 0],\n         [0, 0, 1, 0, 0, 0, 0, 4],\n         [0, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 126, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 8, 0, 7],\n         [0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 8, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 2, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 127, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0],\n    [0, 5, 0, 9, 0, 0, 0, 6, 0, 0, 5, 0, 0, 0],\n    [0, 0, 6, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0],\n    [0, 0, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 0, 7, 0, 0, 10, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 12\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 128, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 3, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 4, 0, 0, 0, 0, 5, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 3, 8, 0, 8, 0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 2],\n         [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 129, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n# Define the edges and their capacities\nedges = {\n    0: {1: 2, 3: 3, 4: 4, 12: 5},\n    1: {4: 1, 7: 9, 5: 5},\n    2: {7: 2, 3: 8, 4: 7, 12: 4, 7: 0},\n    3: {6: 1, 9: 2, 1: 5, 0: 2, 12: 8},\n    4: {0: 4, 7: 9, 11: 1, 6: 1, 1: 4, 5: 10},\n    5: {0: 7, 10: 5, 12: 1, 6: 5, 1: 4},\n    6: {4: 8, 0: 4, 12: 7},\n    7: {2: 2, 3: 6, 4: 0},\n    8: {12: 8},\n    9: {10: 3, 12: 1, 8: 3, 11: 9, 6: 10},\n    10: {7: 3, 11: 9, 3: 3, 6: 3, 1: 4, 5: 3, 4: 5},\n    11: {},\n    12: {},\n}\n\n# Update the graph with the given edges and capacities\nfor i in range(13):\n    for j, val in edges[i].items():\n        graph[i][j] = val\n\ng = Graph(graph)\nsource = 6\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 130, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 9, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 7, 0],\n         [1, 0, 9, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 9, 3, 0, 7, 0, 0, 0, 0, 8, 0, 5],\n         [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 9, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 131, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 9, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0]]\n\ng = Graph(graph)\nsource = 6\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 132, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10, 0, 0, 10, 0, 0],\n         [1, 9, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0],\n         [0, 0, 0, 0, 7, 0, 0, 6, 0, 0, 0, 0],\n         [0, 0, 4, 0, 0, 0, 0, 0, 6, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 133, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 8, 0, 0, 6, 0, 4, 0],\n         [0, 0, 10, 0, 0, 0, 0, 0],\n         [0, 5, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 2, 0, 4],\n         [0, 1, 0, 7, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 134, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 4, 0, 0, 0, 8, 0, 0],\n    [0, 0, 2, 0, 5, 0, 0, 9],\n    [0, 0, 0, 0, 0, 10, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 7, 0, 0, 4],\n    [0, 0, 0, 9, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 135, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 2, 1, 0, 0, 0, 1],\n         [0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0],\n         [0, 8, 0, 0, 0, 0, 9, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n         [7, 0, 8, 10, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 6, 4, 0, 7, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 136, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 8, 0, 4, 0],\n         [8, 0, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 6, 0, 0],\n         [0, 1, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 10, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 4, 5],\n         [0, 0, 0, 0, 8, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 9, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 137, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 1, 0, 0, 0],\n         [0, 0, 0, 2, 2, 0],\n         [9, 0, 0, 0, 0, 0],\n         [0, 0, 10, 0, 0, 0],\n         [0, 0, 4, 0, 0, 2],\n         [0, 0, 10, 0, 1, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 138, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 8, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 4],\n         [0, 0, 0, 1, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 5, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 139, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 8, 0, 0, 7, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 140, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n    [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 12\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 141, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 7, 0, 0, 0, 0, 0, 0],\n    [0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 4],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 142, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 6, 0, 0, 0, 0, 4],\n         [0, 0, 6, 2, 0, 0, 0, 10],\n         [0, 3, 0, 10, 4, 5, 0, 0],\n         [0, 0, 0, 0, 2, 0, 10, 0],\n         [0, 0, 0, 5, 0, 0, 0, 2],\n         [0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 143, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 2, 0, 0, 0, 7, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 4, 4, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n    [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 6, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n    [0, 0, 0, 0, 3, 0, 10, 4, 0, 0, 3, 0, 0],\n    [0, 0, 7, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 8],\n    [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 3, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 6, 3, 0, 0, 0, 6, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7],\n    [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 7, 0]\n]\n\ng = Graph(graph)\nsource = 12\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 144, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 7, 5, 0, 0, 7, 0, 0],\n         [0, 0, 4, 0, 0, 6, 1, 0, 0],\n         [0, 10, 0, 0, 1, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 3, 0, 2, 0],\n         [0, 1, 0, 0, 0, 0, 1, 6, 0],\n         [0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 5, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 145, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 7, 3, 0, 0, 0, 0, 0],\n         [0, 0, 4, 10, 10, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5],\n         [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n         [0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 2, 2, 0, 0, 3, 0, 0]]\n\ng = Graph(graph)\nsource = 6\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 146, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 8, 4, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 3, 0, 5, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0],\n    [0, 6, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 1\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 147, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 10, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 5, 0, 0, 0, 7, 0, 0, 6, 0, 10, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n    [0, 0, 0, 2, 0, 9, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 148, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\ngraph = [[0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 2, 8, 0, 2],\n         [0, 0, 0, 0, 9, 0, 6, 0],\n         [0, 0, 0, 0, 0, 1, 0, 9],\n         [1, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 4, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 3],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 149, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 4, 9, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 2, 0, 3, 8, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 0, 0, 0, 10, 10, 6, 1],\n         [0, 0, 0, 0, 0, 0, 0, 6, 1],\n         [0, 3, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 2, 0, 0, 0, 9, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 150, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 9, 1, 8, 0, 0, 0, 10, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 3, 0, 10, 0, 5],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [10, 0, 0, 0, 0, 0, 0, 0, 2, 7, 9, 0, 7, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 151, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 10, 0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 3, 0, 0, 7, 6, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 8, 0, 0, 0, 0, 1, 0, 0, 6, 0],\n         [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 152, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 9, 5, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 9, 0, 0, 0, 0, 0, 0, 0, 8],\n         [4, 0, 0, 0, 10, 0, 10, 1, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 153, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 13\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 154, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 8, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 8, 0, 0, 0],\n         [0, 0, 9, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 0, 5, 6],\n         [0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 155, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 0, 10, 0],\n         [0, 0, 2, 0, 0, 0, 0, 0, 0, 1],\n         [0, 2, 0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 4, 0, 8, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 3, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 156, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\ngraph = [[0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 8, 8, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 10, 8, 0, 0, 0, 0, 0, 0, 0],\n         [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 8, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 14\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 157, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 4, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n         [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10],\n         [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 4, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 14\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 158, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 3, 1, 0, 0, 0, 0, 0, 0, 9, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 2, 0, 3, 9, 2],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n    [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 9],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 10\nsink = 13\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 159, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 9, 0, 0, 0, 0, 0, 0, 6, 6],\n         [0, 0, 0, 9, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 1, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 10, 0],\n         [0, 0, 0, 0, 1, 0, 0, 4, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 4, 0, 3, 0, 5, 0, 0, 0],\n         [7, 0, 0, 0, 0, 5, 0, 6, 0, 0],\n         [0, 1, 0, 0, 0, 2, 10, 0, 1, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 160, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 4, 0, 0, 10, 0, 0, 0, 0],\n         [0, 0, 4, 0, 7, 0, 5, 0, 4, 0],\n         [0, 0, 0, 10, 0, 6, 2, 0, 0, 0],\n         [5, 4, 8, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 5, 0, 0, 10, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 161, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 2, 0, 0],\n         [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 162, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 8, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 4, 5, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 4, 0, 0, 0, 10, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n    [0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 9, 2, 0, 0, 0],\n    [0, 7, 0, 0, 0, 0, 0, 0, 2, 9, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 163, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 3, 2, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 5, 0, 10, 6, 0],\n         [0, 1, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0],\n         [0, 0, 9, 0, 0, 5, 0, 0, 2, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 4, 6, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 164, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 0, 0, 1],\n         [0, 0, 5, 8, 0, 0, 0, 0],\n         [0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 10, 4, 10, 0],\n         [0, 9, 5, 0, 0, 6, 8, 0],\n         [0, 0, 0, 2, 4, 0, 0, 0],\n         [0, 6, 0, 0, 4, 0, 0, 0],\n         [0, 0, 5, 6, 0, 4, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 165, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 9, 0, 0, 4, 0, 6, 0],\n    [0, 0, 0, 0, 0, 2, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 9, 0, 0, 4, 2],\n    [0, 0, 0, 0, 0, 0, 3, 0],\n    [0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 166, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n                    if ind == t:\n                        return True\n        return False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 6, 0, 7],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 2, 0, 0, 0, 0],\n    [0, 1, 9, 0, 0, 0, 0, 2, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 167, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n                    if ind == t:\n                        return True\n        return False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 4, 0, 1, 0, 1, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 168, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 7\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 169, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 7, 0],\n         [0, 0, 0, 10, 0, 4, 1, 6, 0],\n         [0, 0, 0, 4, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 8, 6, 0, 0, 0],\n         [0, 4, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 5],\n         [0, 2, 7, 4, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 170, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 1, 0, 0, 2, 2, 4, 0, 0, 0],\n    [0, 0, 8, 0, 0, 0, 0, 3, 2, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 10, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 9],\n    [0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 2, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 171, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 0, 0, 0, 0, 1, 0, 6, 0, 0],\n    [0, 0, 4, 0, 0, 6, 0, 0, 0, 0, 0],\n    [0, 0, 0, 5, 0, 0, 0, 0, 0, 2, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n    [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 8\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 172, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 7, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 4\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 173, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 10, 0, 4, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 2, 10, 0, 7, 2, 0, 0, 0],\n    [0, 0, 0, 5, 0, 10, 0, 0, 10, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 10, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 3, 0, 8],\n    [0, 0, 0, 0, 10, 0, 0, 3, 0, 0, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 4],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 13\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 174, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0],\n         [9, 0, 6, 0, 0, 0, 0],\n         [9, 0, 0, 0, 0, 0, 0],\n         [8, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 10, 0, 7, 1, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 175, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 3\nsink = 12\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 176, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 7, 7, 0, 0, 0, 0, 0, 8, 0, 0, 4, 0, 0, 0, 0],\n    [0, 0, 9, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 4, 6, 0, 0, 0, 9, 2, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 4, 6, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 11\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 177, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 0, 0, 8, 5, 9, 0, 0],\n         [0, 0, 10, 0, 6, 0, 3, 0],\n         [0, 4, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 5, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 178, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\ngraph = [[0, 0, 0, 0, 8, 3, 1, 0, 0, 0],\n         [0, 0, 0, 0, 4, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 9, 0, 0, 0, 5, 0, 0, 0],\n         [8, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 9, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 6\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 179, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 7, 0, 8, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 1\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 180, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 0, 0, 0, 0, 1, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 9, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n         [0, 0, 10, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 5, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 181, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9],\n         [0, 9, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 182, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 5, 7, 0, 0, 0, 0, 0, 10],\n         [0, 0, 0, 5, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 9, 6, 8, 0, 0],\n         [0, 0, 0, 0, 0, 2, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 183, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 7, 0, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 8, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 2, 0, 6, 0, 10, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 2, 8, 0, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 12\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 184, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 9, 0, 0, 2, 0, 0, 0, 0, 10, 0, 0],\n    [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 10],\n    [0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 8\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 185, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n# Define the graph\ng = Graph(graph)\n\n# Define the source and sink nodes\nsource = 3\nsink = 9\n\n# Calculate the maximum flow\nmax_flow = g.ford_fulkerson(source, sink)\n\nprint(\"The maximum possible flow is %d \" % max_flow)\n```"}, {"id": 186, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 8, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 10, 0, 0, 10, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 6, 9, 6, 1, 0, 0],\n         [0, 0, 0, 5, 0, 1, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 187, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0],\n         [0, 2, 7, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 8, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 188, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [\n    [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 7, 0, 0],\n    [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 8\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 189, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 9],\n         [0, 5, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 6, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 190, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 0, 0, 10, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 2, 0, 4, 0],\n         [0, 0, 0, 0, 0, 4, 3, 0, 0, 0],\n         [0, 0, 0, 0, 9, 0, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 3, 0, 0, 0, 0, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 191, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 2, 0, 0],\n         [0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 9, 0],\n         [0, 5, 0, 0, 0, 0, 0],\n         [0, 0, 9, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 192, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 8, 0, 0, 10, 0, 0, 0, 1, 0, 0, 5, 4, 0],\n         [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 5, 9, 10, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n         [0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 3, 0],\n         [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 12\nsink = 13\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 193, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 1, 0, 0, 0, 0, 8],\n         [0, 0, 7, 0, 0, 7, 0, 0, 0, 7, 0],\n         [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0, 6, 3, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 0, 10, 0, 8, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 1, 3, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 194, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 8, 0, 0, 0, 0, 0, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 9, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 1, 0, 0, 1],\n         [0, 0, 0, 5, 0, 0, 0, 0, 0],\n         [0, 0, 10, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 5],\n         [0, 0, 0, 0, 1, 0, 5, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 195, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [[0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 4, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 2, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n         [7, 6, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 10, 0, 0, 0, 0, 8, 0, 3, 2, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 196, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 7, 0, 0, 10, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 4, 0, 0, 0, 0, 0, 10, 0, 0, 2, 0, 0],\n    [4, 0, 0, 0, 0, 8, 0, 2, 6, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n    [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 197, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 3, 0, 2, 0, 0, 0, 9, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 1, 1, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 198, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 10, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 6],\n         [0, 0, 5, 0, 0, 0, 0, 0, 0],\n         [0, 3, 0, 0, 0, 0, 9, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 199, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 10, 8, 9, 0, 0, 0, 0, 0, 0, 0],\n         [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 10, 0, 0, 0],\n         [0, 0, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 11\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 200, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 5, 0, 0, 0, 7, 2, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 8, 0, 0, 1, 0, 1, 3, 0, 0, 0],\n    [0, 10, 0, 0, 0, 0, 9, 4, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 9, 9, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 3, 0, 0, 9, 4, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 10],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 4\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 201, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 7, 8, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 6, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 1],\n         [0, 6, 0, 0, 0, 0, 0, 0, 0, 7],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 8, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 202, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 7, 2, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [9, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 203, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 5, 0, 0, 0, 5, 0, 0, 0, 10, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 4],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]]\n\ng = Graph(graph)\nsource = 11\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 204, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 9, 0, 5, 7, 6, 0, 0, 0, 0],\n    [0, 0, 3, 0, 0, 0, 10, 0, 0, 0],\n    [0, 10, 0, 9, 0, 0, 0, 0, 0, 0],\n    [7, 8, 0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 8, 0],\n    [0, 1, 0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 205, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n    [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [2, 0, 6, 0, 0, 10, 8, 0, 0, 0, 3, 0, 0],\n    [7, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0],\n    [0, 0, 0, 0, 5, 0, 3, 0, 0, 1, 0, 6, 0],\n    [0, 0, 0, 0, 6, 0, 2, 0, 0, 0, 0, 1, 0],\n    0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 0, 3, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 2, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 7\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 206, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 10, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n    [10, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n    [0, 0, 8, 0, 0, 9, 7, 0, 0, 5, 0, 0, 0],\n    [0, 1, 0, 0, 4, 0, 0, 6, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 5, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],\n    [0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 10\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 207, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [[0, 7, 0, 0, 0, 0, 9, 0, 0, 0],\n         [3, 0, 6, 0, 0, 2, 0, 0, 0, 0],\n         [0, 4, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4],\n         [1, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 208, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 9, 6, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 5, 8, 2, 8, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0, 8, 0, 0, 0, 0, 0],\n         [0, 0, 0, 8, 0, 0, 0, 10, 0, 0, 6, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n         [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 209, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [[0, 3, 3, 0, 0, 0, 9, 5],\n         [8, 0, 0, 4, 0, 0, 0, 0],\n         [0, 7, 0, 3, 4, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 3, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 1, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 210, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 0, 0, 7, 0],\n         [0, 0, 2, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 9, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4],\n         [0, 10, 0, 0, 0, 0, 0, 0],\n         [0, 0, 4, 3, 0, 0, 10, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 211, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 9, 0, 0, 0, 9, 0, 0, 0],\n         [6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 4, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 8, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 1],\n         [0, 6, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3]]\n\ng = Graph(graph)\nsource = 11\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 212, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 7, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 5, 0, 0, 0, 0],\n         [0, 0, 8, 0, 0, 0, 1, 0, 9, 0, 0, 1, 5, 0, 0],\n         [0, 0, 0, 6, 0, 0, 0, 7, 0, 0, 0, 7, 0, 10, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 9, 0, 6],\n         [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 213, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 9, 0, 0, 0, 0, 9, 0, 0, 0],\n    [0, 0, 0, 3, 5, 8, 0, 6, 0, 0, 0],\n    [0, 8, 0, 0, 9, 0, 6, 0, 6, 0, 0],\n    [0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 6, 0, 0, 0, 0, 0, 0, 0, 4, 2],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0],\n    [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 214, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 2, 0, 0],\n         [0, 0, 7, 0, 0, 0, 10],\n         [0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 9, 0],\n         [3, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 215, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 16, 13, 0, 0, 0, 0, 0, 0],\n    [0, 0, 10, 12, 0, 0, 0, 0, 0],\n    [0, 4, 0, 0, 20, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 216, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 4, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 7, 5, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 4, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 1, 0, 0, 5],\n         [0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [7, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 217, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 9, 0, 0],\n         [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 14\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 218, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 10, 0, 0, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n    [0, 8, 0, 0, 0, 8, 0, 1, 1, 9, 0, 0, 0],\n    [0, 0, 0, 0, 8, 0, 10, 0, 0, 4, 7, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 5, 7, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 8, 3, 0, 0, 4, 0, 4, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 8, 0, 0, 6, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]\n]\n\ng = Graph(graph)\nsource = 7\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 219, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 7, 0, 0, 0, 0, 0, 9, 0, 9, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n    [0, 3, 0, 0, 0, 4, 6, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [2, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 11\nsink = 13\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 220, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 7, 6, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 2, 0, 0, 0, 9, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 8, 0, 0, 0],\n    [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 5, 10, 0, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 5, 4, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0]\n]\n\ng = Graph(graph)\nsource = 8\nsink = 12\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 221, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 16, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 10, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0],\n    [0, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 1\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 222, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 7, 0, 0, 6],\n         [0, 0, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 10, 1, 0, 0, 5, 3, 0],\n         [0, 0, 0, 6, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 7, 0, 0, 9, 0, 2, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 223, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 6, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 8, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n    [0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 10\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 224, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 6, 9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 2, 0],\n    [0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [2, 9, 0, 5, 1, 0, 8, 0, 0, 0, 0, 4, 6, 0],\n    [6, 5, 3, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n    [0, 0, 0, 10, 0, 2, 0, 0, 0, 0, 0, 0, 3, 7],\n    [0, 0, 0, 0, 0, 0, 9, 0, 9, 0, 0, 0, 0, 0],\n    [9, 0, 0, 0, 0, 0, 0, 2, 0, 5, 7, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 7],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 10\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 225, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0],\n         [3, 0, 7, 9, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],\n         [0, 7, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [3, 0, 6, 0, 0, 0, 3, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 6, 0, 0, 0, 0, 0, 0, 0, 10, 0, 10, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 9, 9, 0, 0, 0, 10, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 10],\n         [0, 0, 0, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 10, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 226, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n# Define the connections\nconnections = {\n    8: {4: 9, 7: 10, 6: 4, 2: 1},\n    4: {7: 7, 13: 3, 6: 5, 3: 4, 11: 2, 12: 4},\n    7: {10: 3, 1: 5, 6: 10, 2: 5, 12: 1, 9: 9},\n    6: {3: 2, 11: 7, 2: 10, 7: 10, 10: 2, 13: 5},\n    2: {12: 5, 4: 8, 1: 1, 6: 8, 3: 6, 5: 3, 11: 0},\n    13: {6: 10, 5: 5, 8: 9, 9: 2, 7: 4, 10: 10, 12: 0},\n    3: {11: 8, 12: 8, 9: 2, 4: 5},\n    11: {2: 2, 12: 1},\n    12: {9: 5, 4: 8, 7: 10, 13: 8, 1: 10, 8: 3, 11: 0, 2: 0},\n    10: {1: 4, 0: 6, 11: 6, 2: 7, 9: 10, 4: 7},\n    1: {3: 7, 7: 9, 13: 7},\n    9: {10: 10, 5: 10, 12: 9},\n    5: {8: 7, 9: 6, 7: 7, 6: 9},\n    0: {8: 1, 7: 3, 10: 5, 1: 9, 3: 7, 5: 4}\n}\n\n# Populate the graph matrix\nfor node, connections in connections.items():\n    for neighbor, weight in connections.items():\n        graph[node][neighbor] = weight\n\ng = Graph(graph)\nsource = 11\nsink = 13\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 227, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 8, 0, 0, 0, 0, 0, 9, 10, 0],\n         [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 10\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 228, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 0, 2],\n         [0, 0, 4, 0, 0, 0, 6],\n         [0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0],\n         [0, 3, 0, 0, 0, 0, 8],\n         [0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 229, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 10, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 5, 3, 8, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 1, 0],\n         [0, 1, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 230, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n         [4, 0, 2, 8, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 9, 5, 0, 0],\n         [0, 2, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n         [0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [1, 0, 9, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 0, 5, 0, 1],\n         [0, 0, 0, 0, 3, 0, 0, 4, 0, 0]]\n\ng = Graph(graph)\nsource = 6\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 231, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 10, 0, 0, 7, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 232, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 8, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 2, 5, 0, 0, 5, 0, 0, 3, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 6, 0, 2, 0, 4, 0, 3],\n         [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 10, 0],\n         [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 10\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 233, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [10, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 6, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 6, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0]]\n\ng = Graph(graph)\nsource = 10\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 234, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 5, 0, 0, 0, 0, 1, 0, 0],\n    [9, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n    [0, 9, 0, 1, 4, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 9, 0, 0, 10, 0],\n    [7, 2, 0, 0, 0, 9, 0, 0, 6, 10],\n    [8, 0, 7, 5, 0, 0, 8, 0, 0, 0],\n    [0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 4, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 10, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 235, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n         [3, 0, 9, 2, 2, 0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 3, 0, 0, 6, 10, 10, 0, 0],\n         [0, 0, 0, 0, 9, 0, 0, 3, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 0, 1, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 10, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n         [0, 6, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 236, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 5, 0, 0, 9, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 237, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 10, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 10],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 9, 0, 5],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 10\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 238, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 2, 7],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 6, 5, 0, 0, 0, 7, 3, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0],\n    [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 7, 0, 2, 10, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 0, 8, 0, 0]\n]\n\ng = Graph(graph)\nsource = 11\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 239, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 6, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 240, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 10, 3, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 7, 4, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 5, 0, 0, 0, 1, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 241, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 7, 0],\n    [0, 1, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0]\n]\n\ng = Graph(graph)\nsource = 4\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 242, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 0, 8, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 3, 0, 8, 0],\n         [0, 0, 0, 9, 1, 4, 0, 0, 2, 0, 0],\n         [0, 0, 0, 1, 10, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 243, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 8, 0, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 2, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 3, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 7, 0, 0, 5, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 244, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 2, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 6, 7, 0, 7],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 245, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 8, 10],\n    [0, 0, 4, 0, 0, 0, 0, 0, 0, 10, 0, 4, 0, 0, 0],\n    [0, 4, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 6, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 6, 0, 0, 6, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n    [0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 5, 9, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 9, 1],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 9, 9, 7],\n    [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 0, 0, 9],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 13\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 246, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 9, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 0, 10, 0, 5, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 10, 7, 0, 0, 0, 0, 0, 6, 0, 9, 0, 1],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 12\nsink = 11\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 247, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 1, 0, 1, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 4\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 248, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 4, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 6, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 6, 0, 5, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 3, 0, 0, 0, 0, 0, 0, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 2, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 249, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 0, 0, 5, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 3, 0],\n         [0, 6, 0, 0, 0, 0, 0, 0, 0, 7],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 8, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 2, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 250, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 0],\n         [0, 0, 4, 0, 0, 8, 0, 0],\n         [0, 0, 0, 3, 0, 3, 2, 0],\n         [0, 3, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 4, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 7, 0, 4, 0, 0]]\n\ng = Graph(graph)\nsource = 6\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 251, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 8, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 6],\n         [0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 6],\n         [7, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 3\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 252, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 5, 0, 0, 0, 0, 10, 0, 0, 0],\n    [1, 1, 0, 0, 4, 0, 0, 9, 0, 0],\n    [0, 0, 6, 0, 0, 0, 0, 0, 0, 0],\n    [0, 4, 0, 5, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 8, 0, 0, 10, 0, 0, 0],\n    [0, 0, 10, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 4\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 253, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 0, 3, 0, 0, 0, 0, 0, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 7, 0],\n         [0, 0, 0, 5, 0, 0, 0, 10, 0, 0, 0, 0, 0],\n         [3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 8, 2, 0, 7, 0, 3, 10, 0],\n         [0, 0, 0, 0, 9, 0, 6, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 254, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 5, 0, 0, 0, 10, 0, 0],\n         [0, 0, 1, 0, 6, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 6, 0],\n         [0, 0, 0, 0, 0, 9, 5, 0],\n         [0, 0, 0, 1, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 4, 0, 9],\n         [0, 0, 0, 0, 0, 1, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 4\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 255, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 8, 0],\n         [4, 0, 0, 0, 9, 0],\n         [0, 0, 0, 1, 3, 0],\n         [0, 0, 2, 0, 0, 0],\n         [0, 2, 0, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 9, 8, 2]]\n\ng = Graph(graph)\nsource = 3\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 256, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 3, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 6, 0, 0, 0],\n         [0, 4, 0, 0, 10, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 7, 10, 0, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 6],\n         [0, 9, 0, 2, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 3\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 257, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 7, 0, 0, 0, 0, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 258, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0],\n         [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 3, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n         [0, 2, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 7, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 259, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 1, 2, 8, 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 10, 6, 0, 0, 7, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 8, 5, 2, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 260, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 5, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n    [2, 0, 0, 0, 9, 0, 1, 0, 0, 0, 7, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 3, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 4, 7],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 4\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 261, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n# Define the connections and weights\nconnections = {\n    9: {7: 1, 11: 10, 5: 4, 3: 4, 12: 9, 2: 4, 6: 8},\n    7: {5: 2, 12: 1, 4: 8, 13: 3, 6: 5},\n    11: {12: 1, 2: 3, 4: 3, 13: 7, 6: 8},\n    5: {3: 9, 13: 9, 6: 3, 7: 0, 2: 0},\n    3: {8: 9, 2: 4, 4: 7, 0: 5, 10: 3, 5: 0},\n    12: {6: 8, 9: 6, 7: 1, 11: 0},\n    2: {6: 7, 5: 7, 8: 4, 11: 0},\n    6: {0: 6, 10: 5, 2: 10, 13: 10, 11: 0, 12: 0, 4: 0},\n    4: {6: 8, 7: 7, 8: 3, 11: 0},\n    13: {11: 2, 10: 8, 6: 0},\n    8: {1: 2, 2: 8, 0: 4},\n    0: {10: 6, 8: 9, 1: 10, 6: 0},\n    10: {8: 2, 1: 3, 9: 7, 13: 0, 6: 0, 0: 0, 3: 0},\n    1: {4: 10, 13: 1, 11: 4, 12: 3}\n}\n\n# Populate the graph matrix\nfor node, connections in connections.items():\n    for neighbor, weight in connections.items():\n        graph[node][neighbor] = weight\n\ng = Graph(graph)\nsource = 11\nsink = 10\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 262, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\ngraph = [[0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [0, 0, 3, 0, 3, 9, 0, 4, 3, 0, 0],\n         [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n         [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 0],\n         [0, 0, 8, 0, 0, 0, 9, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 6, 0, 0, 2, 0]]\n\ng = Graph(graph)\nsource = 1\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 263, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n                    if ind == t:\n                        return True\n        return False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 6, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [9, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 1, 0, 0, 0, 0],\n    [0, 7, 6, 0, 0, 0, 10, 2, 2, 8, 0, 0, 1, 0, 0],\n    [0, 7, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 9],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n    [4, 9, 1, 0, 0, 0, 0, 1, 0, 8, 0, 10, 0, 0, 0],\n    [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 10, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 7, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 14\nsink = 12\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 264, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [5, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0],\n    [0, 5, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n    [0, 0, 0, 6, 0, 0, 10, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 265, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 7, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 4, 0, 0, 0, 0, 0, 0],\n         [0, 0, 2, 0, 0, 0, 0, 6, 3],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 10, 0, 1, 0, 6, 0, 0, 4],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 266, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n# Define the edges and their capacities\nedges = {\n    8: {4: 4, 14: 5, 5: 6, 9: 10, 11: 7, 12: 9, 2: 1, 7: 0},\n    4: {14: 7, 9: 10, 1: 7, 7: 0, 3: 0},\n    14: {1: 4, 11: 4, 6: 6, 7: 7, 12: 5, 13: 4, 2: 0, 8: 0, 4: 0},\n    5: {9: 2, 0: 10, 1: 2, 6: 1, 2: 3, 3: 4, 4: 5, 14: 9},\n    9: {0: 1, 1: 8, 11: 4, 7: 4, 12: 7, 2: 6, 8: 1, 4: 10, 13: 10, 5: 7},\n    11: {4: 3, 14: 5},\n    12: {3: 8, 1: 1},\n    2: {3: 10, 13: 7, 14: 1, 1: 5, 10: 7, 12: 1, 7: 0},\n    1: {12: 2, 3: 2, 4: 10, 13: 3},\n    6: {12: 1, 2: 7, 8: 6, 14: 7, 0: 7, 1: 8, 11: 1},\n    7: {12: 6, 2: 2, 8: 1, 3: 2, 4: 1, 9: 6, 1: 8, 13: 0},\n    13: {7: 4},\n    0: {11: 4, 8: 9, 4: 7, 13: 5},\n    3: {4: 5, 1: 9, 10: 2, 7: 8, 12: 6},\n    10: {12: 4, 2: 7, 3: 7, 4: 9, 13: 2, 0: 7, 1: 10}\n}\n\n# Update the graph with the given edges and capacities\nfor node in edges:\n    for neighbor, capacity in edges[node].items():\n        graph[node][neighbor] = capacity\n\ng = Graph(graph)\nsource = 13\nsink = 14\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 267, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 10, 5, 0, 0, 0, 0, 0, 0, 1],\n    [9, 0, 0, 6, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 8, 0, 8, 0, 0],\n    [0, 0, 0, 3, 0, 0, 0, 0, 10, 7],\n    [0, 0, 0, 0, 2, 0, 0, 0, 0, 5],\n    [0, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 10, 0],\n    [0, 0, 0, 0, 4, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 268, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 5, 0, 0, 9, 0, 7, 3],\n         [8, 0, 8, 0, 0, 8, 0, 0],\n         [0, 0, 0, 6, 4, 0, 9, 0],\n         [0, 1, 3, 0, 9, 9, 0, 10],\n         [0, 10, 8, 0, 0, 0, 4, 0],\n         [0, 0, 0, 2, 10, 0, 5, 0],\n         [0, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 4, 1, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 269, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 6, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 3, 1, 0, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 12\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 270, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 5, 5, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 0, 0, 0],\n         [0, 8, 0, 0, 2, 0, 0, 0],\n         [0, 0, 0, 0, 1, 7, 3, 0],\n         [0, 0, 0, 5, 0, 1, 0, 1],\n         [0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8],\n         [0, 4, 0, 0, 0, 0, 8, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 271, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 7, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [1, 0, 7, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 9, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0]]\n\ng = Graph(graph)\nsource = 6\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 272, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [[0, 0, 0, 0, 10, 0, 10, 0, 0, 9, 1],\n         [0, 0, 0, 7, 0, 0, 0, 0, 3, 0, 1],\n         [0, 0, 0, 0, 9, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 8, 0, 10, 5, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0],\n         [0, 0, 10, 0, 0, 0, 7, 3, 0, 6, 0],\n         [0, 7, 0, 0, 0, 0, 0, 5, 4, 10, 1],\n         [0, 0, 0, 0, 2, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 8],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 273, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\ngraph = [[0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 0, 8, 0, 0, 4, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n         [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 10\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 274, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 9, 0, 0, 0, 0, 3, 4],\n         [0, 0, 3, 0, 0, 3, 0, 0],\n         [0, 0, 0, 0, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 10, 0, 0],\n         [0, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 0, 0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 7, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 275, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n         [0, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 9, 0, 2, 0, 0, 1, 6, 0, 0, 0, 0, 0],\n         [0, 9, 7, 0, 7, 0, 7, 6, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 6, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 10\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 276, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 1, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 5, 2, 0, 0, 0, 0, 9, 5, 0],\n    [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n    [0, 0, 6, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 0, 10, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 8\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 277, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Define the graph as an adjacency matrix\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [9, 10, 0, 3, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 7, 0, 4, 0, 0, 0, 6, 0, 0, 10, 0, 0, 0],\n    [0, 8, 0, 0, 0, 8, 0, 5, 0, 0, 6, 0, 7, 0, 0],\n    [0, 0, 0, 0, 8, 0, 0, 0, 9, 0, 7, 0, 4, 0, 0],\n    [1, 0, 1, 0, 0, 0, 0, 1, 2, 2, 5, 6, 0, 0, 0],\n    [0, 0, 0, 0, 5, 0, 0, 0, 7, 0, 10, 0, 6, 0, 0],\n    [0, 0, 7, 0, 0, 9, 0, 0, 0, 8, 0, 0, 5, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0],\n    [0, 0, 0, 0, 4, 7, 5, 0, 0, 8, 0, 9, 8, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 0],\n    [0, 0, 0, 3, 0, 0, 0, 10, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 7\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 278, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 9, 3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 5\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 279, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 1, 0, 0, 0, 0, 0, 0, 10],\n    [0, 0, 10, 6, 9, 0, 0, 0, 0],\n    [3, 0, 0, 0, 5, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 7, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 4, 0, 0, 0],\n    [0, 0, 0, 0, 7, 0, 0, 8, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 2\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 280, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 2, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 10, 0, 0, 0, 7, 0, 7, 0],\n         [0, 0, 0, 0, 0, 3, 0, 3, 0, 4],\n         [0, 0, 0, 0, 5, 0, 0, 9, 0, 0],\n         [0, 0, 0, 7, 0, 0, 0, 1, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 7, 10, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 5, 0, 0, 0, 0, 0, 9, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 281, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 10, 7, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 5, 3, 6, 0],\n    [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 8, 0, 4, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 2, 7, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 282, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 6, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 7, 9, 0, 0, 0, 6, 0, 0],\n         [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 5, 0, 0, 0, 0, 5, 0, 1, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 283, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 10, 0, 0],\n         [0, 0, 0, 1, 0, 0, 0, 0],\n         [5, 0, 4, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 3],\n         [0, 0, 0, 0, 0, 0, 3, 0]]\n\ng = Graph(graph)\nsource = 7\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 284, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 6, 9, 6, 10, 0, 0, 0, 0, 0, 0, 0],\n         [4, 0, 0, 10, 0, 1, 0, 0, 0, 0, 0, 0],\n         [0, 8, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n         [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 5\nsink = 7\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 285, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 4, 0, 10, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 6, 4, 0, 9, 0, 0, 0, 8, 4, 0, 0],\n    [0, 0, 0, 0, 6, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 9, 3, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 5, 0, 5, 0, 0],\n    [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],\n    [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0]\n]\n\ng = Graph(graph)\nsource = 11\nsink = 13\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 286, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 5, 0, 0, 0, 0, 0, 0, 0],\n    [0, 3, 0, 5, 4, 0, 0, 0, 0, 0],\n    [0, 0, 2, 0, 2, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 6, 2, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 1, 6, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 10, 0, 6],\n    [0, 0, 0, 7, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 3\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 287, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 5, 0, 0, 0, 6, 0, 0, 9, 0],\n    [0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n    [0, 10, 0, 0, 0, 0, 0, 0, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 9, 0, 4, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 6],\n    [0, 0, 0, 0, 0, 7, 0, 0, 0, 10],\n    [0, 0, 0, 0, 9, 0, 9, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n    [0, 0, 0, 0, 0, 0, 0, 0, 6, 0]\n]\n\ng = Graph(graph)\nsource = 3\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 288, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 10, 3, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 10, 7, 0, 0, 0, 0, 0],\n    [10, 0, 0, 3, 1, 3, 0, 0, 0, 0, 0, 5, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 9, 7, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 7, 8, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 289, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 5, 0, 0, 0, 9, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 8, 0, 9, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 2, 3, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 5, 0, 3, 0, 0, 0, 0],\n    [0, 8, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0],\n    [0, 0, 0, 0, 1, 0, 0, 2, 2, 0, 0, 0, 0, 7],\n    [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 9, 0, 0, 0],\n    [0, 4, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 9, 0, 0],\n    [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 10, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 7],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 0\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 290, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 7, 0, 7, 0, 0, 0, 0, 2, 0, 0, 0],\n         [0, 0, 10, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 4, 0, 0, 5, 0, 8, 7, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 3, 0, 0, 10, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0],\n         [0, 0, 0, 0, 5, 0, 0, 3, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 4, 0, 3, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 291, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 8, 10, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 10, 10, 0, 0],\n         [0, 0, 0, 10, 6, 0, 8, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 3, 0, 0, 0, 5, 0, 0],\n         [0, 0, 0, 0, 10, 0, 2, 0, 0],\n         [0, 0, 4, 0, 0, 0, 0, 7, 0],\n         [9, 0, 10, 0, 4, 0, 0, 0, 0],\n         [0, 0, 0, 7, 8, 0, 0, 6, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 0\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 292, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 10, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0],\n         [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 6, 0, 0, 0, 8, 4, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 2, 2, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 2\nsink = 5\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 293, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 4, 0, 0, 8, 0, 0, 0, 0, 0, 3, 0, 0],\n         [0, 0, 2, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 10],\n         [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0]]\n\n        g = Graph(graph)\n        source = 9\n        sink = 4\n        print(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 294, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 0, 0],\n    [0, 5, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4],\n    [0, 0, 0, 0, 0, 7, 5, 1, 3, 0, 1, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 7, 10, 0, 1],\n    [0, 0, 0, 2, 8, 0, 0, 0, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 2, 9, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n    [3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\ng = Graph(graph)\nsource = 2\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 295, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph as an adjacency matrix\ngraph = [\n    [0, 9, 0, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 7, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0,"}, {"id": 296, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * (self.ROW)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * (self.ROW)\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while(s != source):\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while(v != source):\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 3, 6, 0, 0, 6, 0, 0, 0, 0, 4, 0],\n         [0, 0, 0, 0, 0, 0, 10, 0, 0, 4, 0, 0],\n         [0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 10, 5, 0, 0],\n         [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 9],\n         [0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 8, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 9\nsink = 6\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 297, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [[0, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n         [9, 0, 10, 0, 0, 0, 0, 0, 2, 0],\n         [0, 0, 0, 0, 3, 0, 0, 0, 0, 0],\n         [0, 9, 0, 0, 0, 0, 0, 7, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 5, 1],\n         [0, 0, 0, 0, 0, 0, 10, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 8\nsink = 9\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 298, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 10, 0, 0, 0, 0, 0],\n    [0, 0, 10, 9, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 10],\n    [0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 6, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 2, 6, 5, 4, 0]\n]\n\ng = Graph(graph)\nsource = 9\nsink = 8\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}, {"id": 299, "code": "```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n\n# Given graph\ngraph = [\n    [0, 7, 2, 0, 0, 0, 0, 2, 0, 0],\n    [0, 0, 9, 2, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 8, 0],\n    [0, 0, 0, 0, 2, 0, 6, 5, 0, 8],\n    [0, 9, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 5, 4, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 8, 0, 5, 0, 10, 0]\n]\n\ng = Graph(graph)\nsource = 10\nsink = 1\nprint(\"The maximum possible flow is %d \" % g.ford_fulkerson(source, sink))\n```"}]