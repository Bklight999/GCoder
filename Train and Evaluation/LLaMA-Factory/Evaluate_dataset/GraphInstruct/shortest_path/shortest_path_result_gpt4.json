{"0": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(4, 6), (2, 2), (1, 8)],\n    4: [(8, 6), (2, 6), (3, 4)],\n    2: [(8, 2), (4, 6), (5, 4), (0, 1), (6, 8), (1, 2)],\n    1: [(8, 8), (2, 2), (5, 5), (0, 6), (6, 10), (7, 7), (3, 7)],\n    3: [(4, 4), (1, 7)],\n    5: [(2, 4), (1, 5)],\n    0: [(2, 1), (1, 6)],\n    6: [(2, 8), (1, 10)],\n    7: [(1, 7)]\n}\n\nstart_node = 5\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "1": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    8: [(3, 1), (9, 3), (2, 10), (4, 10), (6, 1), (0, 1), (5, 7), (1, 9)],\n    3: [(8, 1)],\n    9: [(8, 3)],\n    2: [(8, 10)],\n    4: [(8, 10)],\n    6: [(8, 1), (7, 9)],\n    0: [(8, 1)],\n    5: [(8, 7)],\n    1: [(8, 9)],\n    7: [(6, 9)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue for the minimum distance\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 9 to node 3\nshortest_path_length = dijkstra(graph, 9, 3)\nprint(shortest_path_length)\n```"}, "2": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(4, 3), (3, 8), (5, 3), (6, 6), (10, 8), (0, 10), (8, 5), (7, 10)],\n    4: [(2, 3), (3, 10), (5, 4), (6, 1), (9, 3), (1, 4), (10, 1), (0, 8), (8, 10), (7, 3)],\n    3: [(2, 8), (4, 10), (5, 2), (6, 9), (9, 1), (0, 10), (8, 5), (7, 8)],\n    5: [(2, 3), (4, 4), (3, 2), (6, 8), (9, 10), (10, 9), (7, 1)],\n    6: [(2, 6), (4, 1), (3, 9), (5, 8), (9, 3), (1, 1), (10, 2), (0, 4), (8, 9), (7, 5)],\n    10: [(2, 8), (4, 1), (5, 9), (6, 2), (9, 2), (1, 7), (8, 10), (7, 1)],\n    0: [(2, 10), (4, 8), (3, 10), (6, 4), (1, 3), (8, 4)],\n    8: [(2, 5), (4, 10), (3, 5), (6, 9), (10, 10), (0, 4), (9, 7), (1, 9), (7, 1)],\n    7: [(2, 10), (4, 3), (3, 8), (5, 1), (6, 5), (10, 1), (8, 1), (9, 3), (1, 7)],\n    9: [(4, 3), (3, 1), (5, 10), (6, 3), (10, 2), (8, 7), (7, 3), (1, 6)],\n    1: [(4, 4), (6, 1), (10, 7), (0, 3), (8, 9), (7, 7), (9, 6)]\n}\n\nprint(dijkstra(graph, 6, 0))\n```"}, "3": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    10: [(5, 6), (6, 2)],\n    5: [(10, 6), (7, 1)],\n    6: [(10, 2), (3, 1)],\n    7: [(5, 1), (9, 3), (1, 5)],\n    3: [(6, 1), (0, 5)],\n    9: [(7, 3), (8, 2)],\n    1: [(7, 5), (13, 4)],\n    8: [(9, 2), (4, 10)],\n    4: [(8, 10), (0, 9), (2, 6)],\n    0: [(4, 9), (3, 5)],\n    2: [(4, 6), (14, 1)],\n    14: [(2, 1), (11, 5)],\n    13: [(1, 4)],\n    12: [(11, 8)],\n    11: [(12, 8), (14, 5)]\n}\n\nprint(dijkstra(graph, 10, 8))\n```"}, "4": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(3, 10), (5, 9), (10, 4), (11, 5), (2, 9)],\n    3: [(9, 10), (6, 2), (4, 9)],\n    5: [(9, 9), (7, 5), (8, 2), (4, 7)],\n    10: [(9, 4), (11, 4), (12, 8), (1, 1)],\n    11: [(9, 5), (10, 4), (4, 3), (2, 5)],\n    2: [(9, 9), (11, 5), (12, 10), (1, 4)],\n    6: [(3, 2), (0, 2)],\n    4: [(3, 9), (5, 7), (11, 3), (7, 5), (8, 1), (0, 5)],\n    7: [(5, 5), (4, 5), (1, 1), (0, 7), (8, 2)],\n    8: [(5, 2), (4, 1), (7, 2)],\n    12: [(10, 8), (2, 10), (1, 2)],\n    1: [(10, 1), (2, 4), (7, 1), (12, 2), (0, 6)],\n    0: [(6, 2), (4, 5), (7, 7), (1, 6)]\n}\n\nstart_node = 7\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "5": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor has been found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\ngraph = {\n    4: [(8, 10), (3, 5), (1, 6)],\n    8: [(6, 7), (0, 2), (4, 5)],\n    3: [(5, 4), (4, 3), (8, 8), (7, 1)],\n    1: [(8, 4), (7, 1), (0, 3)],\n    6: [(7, 7), (3, 3), (8, 1)],\n    0: [(8, 1), (6, 10), (7, 4)],\n    5: [(6, 6)],\n    7: [(3, 9), (2, 8), (8, 5), (6, 2)],\n    2: [(8, 10), (0, 10), (5, 2)]\n}\n\nstart_node = 2\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "6": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(1, 1), (8, 4), (0, 4), (4, 7)],\n    1: [(2, 1), (7, 8), (0, 2), (4, 3)],\n    8: [(2, 4), (7, 5), (6, 1), (0, 6), (5, 9), (4, 5)],\n    0: [(2, 4), (1, 2), (8, 6), (7, 2), (6, 8), (3, 5), (5, 6)],\n    4: [(2, 7), (1, 3), (8, 5), (7, 10), (6, 2), (3, 6), (5, 9)],\n    7: [(1, 8), (8, 5), (0, 2), (4, 10), (5, 9)],\n    6: [(8, 1), (0, 8), (4, 2), (5, 6), (3, 2)],\n    5: [(8, 9), (0, 6), (4, 9), (7, 9), (6, 6), (3, 8)],\n    3: [(0, 5), (4, 6), (5, 8), (6, 2)]\n}\n\nstart_node = 4\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "7": {"gpt4": "```python\nimport heapq\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [(2, 8), (5, 9), (7, 7)],\n    1: [(5, 4)],\n    2: [],\n    3: [(2, 6), (5, 8)],\n    4: [(7, 9), (6, 2), (2, 9), (1, 6), (5, 5)],\n    5: [],\n    6: [(1, 10)],\n    7: [(6, 4), (0, 1)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')  # If the end node is not reachable\n\n# Calculate the shortest path from node 0 to node 6\nshortest_path_length = dijkstra(graph, 0, 6)\nprint(shortest_path_length)\n```"}, "8": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(4, 6), (1, 6), (3, 1), (0, 1), (6, 6), (7, 6), (5, 4)],\n    4: [(2, 6), (6, 9), (3, 4), (8, 1), (5, 10)],\n    1: [(2, 6), (7, 9), (0, 2)],\n    3: [(2, 1), (4, 4)],\n    0: [(2, 1), (1, 2), (8, 1)],\n    6: [(2, 6), (4, 9)],\n    7: [(2, 6), (1, 9)],\n    5: [(2, 4), (4, 10)],\n    8: [(4, 1), (0, 1)]\n}\n\nprint(dijkstra(graph, 2, 5))\n```"}, "9": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(13, 6), (10, 4), (9, 10), (1, 1), (8, 10)],\n    13: [(4, 6), (6, 8), (14, 5)],\n    10: [(4, 4), (6, 10), (0, 1), (8, 3), (1, 1)],\n    9: [(4, 10), (11, 4), (6, 3), (14, 4), (5, 4)],\n    1: [(4, 1), (10, 1), (3, 9), (7, 9), (2, 3)],\n    8: [(4, 10), (10, 3)],\n    6: [(13, 8), (10, 10), (9, 3)],\n    14: [(13, 5), (9, 4), (3, 3), (12, 9), (0, 10)],\n    0: [(10, 1), (14, 10), (12, 4), (5, 1), (7, 8)],\n    11: [(9, 4), (3, 9), (12, 9)],\n    5: [(9, 4), (3, 6), (2, 3), (0, 1)],\n    3: [(1, 9), (14, 3), (11, 9), (2, 7), (5, 6)],\n    7: [(1, 9), (2, 4), (0, 8)],\n    2: [(1, 3), (3, 7), (5, 3), (7, 4)],\n    12: [(14, 9), (11, 9), (0, 4)]\n}\n\nprint(dijkstra(graph, 4, 6))\n```"}, "10": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(0, 10), (1, 6), (6, 7), (2, 5), (12, 10)],\n    0: [(10, 10), (4, 5)],\n    1: [(10, 6), (12, 9)],\n    6: [(10, 7), (2, 8)],\n    2: [(10, 5), (6, 8), (12, 10), (7, 9), (13, 8), (8, 2), (4, 7)],\n    12: [(10, 10), (1, 9), (2, 10), (11, 3), (14, 6), (8, 5), (5, 7), (3, 7), (9, 3)],\n    4: [(0, 5), (2, 7), (13, 10), (3, 6)],\n    7: [(2, 9), (8, 1)],\n    13: [(2, 8), (4, 10)],\n    8: [(2, 2), (12, 5), (11, 3), (14, 7), (7, 1), (5, 3)],\n    11: [(12, 3), (8, 3)],\n    14: [(12, 6), (8, 7), (9, 4)],\n    5: [(12, 7), (8, 3)],\n    3: [(12, 7), (4, 6)],\n    9: [(12, 3), (14, 4)]\n}\n\nstart_node = 7\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "11": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(5, 7), (4, 1), (8, 2), (1, 9), (6, 2), (0, 3), (11, 8), (9, 1), (7, 2)],\n    5: [(3, 7), (11, 7), (0, 5)],\n    4: [(3, 1), (6, 2), (8, 2), (11, 4), (2, 5), (0, 8)],\n    8: [(3, 2), (4, 2), (10, 3)],\n    1: [(3, 9), (6, 5), (10, 10), (0, 1)],\n    6: [(3, 2), (4, 2), (1, 5), (10, 4), (9, 2), (0, 7)],\n    0: [(3, 3), (5, 5), (4, 8), (1, 1), (6, 7), (10, 4)],\n    11: [(3, 8), (5, 7), (4, 4)],\n    9: [(3, 1), (6, 2), (7, 5)],\n    7: [(3, 2), (9, 5), (2, 3)],\n    2: [(4, 5), (7, 3), (10, 4)],\n    10: [(8, 3), (1, 10), (6, 4), (0, 4), (2, 4)]\n}\n\nstart_node = 8\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "12": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    10: [(0, 10)],\n    0: [(10, 8), (7, 7)],\n    7: [(6, 5)],\n    3: [(8, 9)],\n    8: [(1, 2), (5, 7), (0, 4)],\n    5: [(0, 5), (2, 9), (4, 6), (10, 8)],\n    6: [(1, 5), (3, 5)],\n    2: [(6, 7), (8, 8), (5, 5), (0, 6)],\n    9: [(8, 6), (1, 7), (5, 2), (6, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue for the minimum distance\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to the current node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n\n            # If a shorter path to the neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 9 to node 2\nshortest_path_length = dijkstra(graph, 9, 2)\nprint(shortest_path_length)\n```"}, "13": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(2, 4), (7, 2), (3, 10)],\n    2: [(10, 4), (9, 1), (5, 5), (0, 1), (1, 5), (6, 9), (4, 10), (7, 10), (3, 7)],\n    7: [(10, 2), (2, 10), (9, 4), (5, 8), (1, 2), (6, 9), (4, 3)],\n    3: [(10, 10), (2, 7), (9, 4), (5, 2), (1, 10), (6, 5), (4, 6), (8, 1)],\n    9: [(2, 1), (7, 4), (3, 4), (5, 5), (0, 4), (1, 9), (6, 8), (4, 1), (8, 2)],\n    5: [(2, 5), (7, 8), (3, 2), (9, 5), (0, 1), (1, 9), (4, 5), (8, 7)],\n    0: [(2, 1), (9, 4), (5, 1), (1, 6), (6, 10), (4, 4), (8, 9)],\n    1: [(2, 5), (7, 2), (3, 10), (9, 9), (5, 9), (0, 6), (6, 1), (4, 3), (8, 7)],\n    6: [(2, 9), (7, 9), (3, 5), (9, 8), (0, 10), (1, 1), (4, 5)],\n    4: [(2, 10), (7, 3), (3, 6), (9, 1), (5, 5), (0, 4), (1, 3), (6, 5), (8, 5)],\n    8: [(3, 1), (9, 2), (5, 7), (0, 9), (1, 7), (4, 5)]\n}\n\nprint(dijkstra(graph, 9, 0))\n```"}, "14": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(10, 4)],\n    10: [(3, 7), (0, 7)],\n    3: [(8, 10), (2, 9)],\n    0: [(9, 4), (12, 6)],\n    4: [(0, 6), (9, 10), (10, 9), (3, 2), (5, 1), (8, 6)],\n    5: [(12, 3), (11, 10), (2, 7)],\n    8: [(6, 9), (0, 1), (3, 6)],\n    12: [(11, 8), (0, 5)],\n    2: [(3, 7), (5, 9), (1, 8)],\n    11: [(6, 7), (9, 10), (3, 6)],\n    6: [(10, 2), (5, 6)],\n    1: [(11, 2), (6, 8), (0, 5), (5, 3)]\n}\n\nstart_node = 10\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "15": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(1, 5), (2, 2)],\n    1: [(6, 10)],\n    2: [(1, 9)],\n    6: [(8, 1), (0, 5), (5, 8)],\n    8: [(10, 4), (1, 4), (2, 3), (3, 4)],\n    0: [(9, 4), (8, 7)],\n    5: [(4, 4), (9, 1), (7, 3), (10, 8)],\n    9: [(3, 4), (10, 8), (5, 3), (1, 9)],\n    3: [(7, 2), (5, 7), (4, 8), (9, 3), (6, 1)],\n    10: [(0, 2), (5, 2), (4, 10), (8, 3)],\n    7: [(10, 9), (5, 4), (1, 8)]\n}\n\nstart_node = 9\nend_node = 0\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "16": {"gpt4": "```python\nimport heapq\n\n# Graph represented as an adjacency list\ngraph = {\n    6: [(0, 3), (4, 8), (1, 8), (2, 4), (5, 4), (7, 7)],\n    0: [(6, 3), (4, 4), (2, 8), (5, 4), (7, 10)],\n    4: [(6, 8), (0, 4), (1, 8), (5, 4), (3, 10), (7, 5)],\n    1: [(6, 8), (4, 8), (2, 6), (5, 9), (7, 3)],\n    2: [(6, 4), (0, 8), (1, 6), (5, 3), (3, 5), (7, 1)],\n    5: [(6, 4), (0, 4), (4, 4), (1, 9), (2, 3), (7, 5)],\n    7: [(6, 7), (0, 10), (4, 5), (1, 3), (2, 1), (5, 5), (3, 10)],\n    3: [(4, 10), (2, 5), (7, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 6 to node 0\nshortest_path_length = dijkstra(graph, 6, 0)\nprint(shortest_path_length)\n```"}, "17": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    5: [(0, 1), (6, 4)],\n    0: [(3, 8), (8, 4), (4, 7), (2, 9), (1, 8)],\n    6: [(2, 10)],\n    3: [(7, 2), (6, 1), (2, 2), (5, 7)],\n    8: [(0, 1), (3, 3), (7, 10), (6, 9)],\n    4: [(6, 8)],\n    2: [(1, 2), (0, 7), (7, 1)],\n    1: [(6, 8), (5, 3)],\n    7: [(6, 6), (8, 3), (4, 9), (1, 5), (3, 10), (9, 6)],\n    9: [(8, 1), (2, 10)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 3)\nprint(shortest_path_length)\n```"}, "18": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    11: {3: 3, 5: 2, 2: 7, 4: 7},\n    3: {11: 3, 0: 1, 9: 2, 5: 1},\n    5: {11: 2, 3: 1, 10: 8, 8: 3, 1: 6},\n    2: {11: 7, 10: 8, 12: 4},\n    4: {11: 7, 12: 4, 1: 2},\n    0: {3: 1, 7: 8, 9: 1, 12: 3, 6: 3},\n    9: {3: 2, 0: 1, 7: 8},\n    10: {5: 8, 2: 8, 7: 3, 12: 3, 6: 9, 1: 1},\n    8: {5: 3, 12: 2, 6: 9},\n    1: {5: 6, 4: 2, 10: 1},\n    12: {2: 4, 4: 4, 0: 3, 10: 3, 6: 7, 8: 2},\n    7: {0: 8, 9: 8, 10: 3},\n    6: {0: 3, 10: 9, 12: 7, 8: 9}\n}\n\nprint(dijkstra(graph, 11, 5))\n```"}, "19": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 9), (1, 2), (12, 2), (6, 8), (7, 3), (9, 3)],\n    1: [(2, 3), (4, 6), (12, 1), (0, 2)],\n    2: [(1, 3), (3, 1), (8, 7), (12, 8), (4, 8), (6, 7), (7, 7), (0, 9)],\n    3: [(2, 1), (10, 10), (7, 7), (8, 6), (12, 1), (6, 2)],\n    4: [(2, 8), (1, 6), (8, 4), (12, 9), (7, 6), (6, 9), (9, 9), (10, 4), (11, 4)],\n    5: [(12, 5)],\n    6: [(2, 7), (3, 2), (12, 6), (4, 9), (9, 2), (0, 8)],\n    7: [(2, 7), (3, 7), (8, 9), (12, 3), (4, 6), (0, 3)],\n    8: [(2, 7), (3, 6), (4, 4), (7, 9)],\n    9: [(4, 9), (6, 2), (0, 3), (11, 8)],\n    10: [(3, 10), (12, 4), (4, 4), (11, 5)],\n    11: [(12, 3), (4, 4), (10, 5), (9, 8)],\n    12: [(2, 8), (1, 1), (3, 1), (4, 9), (11, 3), (0, 2), (7, 3), (6, 6), (5, 5), (10, 4)]\n}\n\nstart_node = 4\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "20": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(1, 9), (7, 2), (5, 2)],\n    1: [(5, 9)],\n    7: [(9, 1), (5, 6), (2, 1), (0, 8)],\n    5: [(6, 2)],\n    9: [(2, 1), (0, 8), (3, 2), (1, 3)],\n    2: [(8, 7), (7, 4), (5, 1)],\n    0: [(4, 7), (1, 9), (7, 5), (8, 2)],\n    6: [(4, 10), (1, 5), (2, 1), (8, 2), (0, 8)],\n    8: [(0, 4), (6, 9), (1, 8), (7, 5), (2, 5)],\n    4: [(7, 3), (2, 2), (8, 1)]\n}\n\nstart_node = 5\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "21": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_node == end:\n            return current_distance\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return float('inf')\n\ngraph = {\n    6: [(4, 1), (1, 7)],\n    4: [(6, 1), (3, 9)],\n    1: [(6, 7), (3, 9)],\n    3: [(4, 9), (1, 9), (11, 9), (7, 3)],\n    11: [(3, 9), (5, 4)],\n    7: [(3, 3), (9, 3)],\n    5: [(11, 4)],\n    9: [(7, 3), (10, 3)],\n    2: [(0, 1)],\n    0: [(2, 1), (8, 8)],\n    8: [(0, 8), (10, 6)],\n    10: [(8, 6), (9, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 3)\nprint(shortest_path_length)\n```"}, "22": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    2: [(6, 5), (8, 9), (9, 5), (0, 8), (7, 1), (5, 9), (4, 10), (1, 2), (3, 6), (10, 9)],\n    6: [(2, 5), (8, 10), (9, 9), (0, 4), (7, 3), (5, 7), (4, 6), (3, 5)],\n    8: [(2, 9), (6, 10), (9, 3), (0, 9), (7, 2), (5, 8), (4, 4), (3, 1), (10, 4)],\n    9: [(2, 5), (6, 9), (8, 3), (5, 5), (4, 6), (1, 9), (3, 6), (10, 4)],\n    0: [(2, 8), (6, 4), (8, 9), (7, 8), (5, 8), (3, 4), (10, 10)],\n    7: [(2, 1), (6, 3), (8, 2), (0, 8), (4, 10), (1, 3), (3, 8)],\n    5: [(2, 9), (6, 7), (8, 8), (9, 5), (0, 8), (3, 2), (10, 9)],\n    4: [(2, 10), (6, 6), (8, 4), (9, 6), (7, 10), (1, 3), (10, 7)],\n    1: [(2, 2), (9, 9), (7, 3), (4, 3), (3, 4), (10, 7)],\n    3: [(2, 6), (6, 5), (8, 1), (9, 6), (0, 4), (7, 8), (5, 2), (1, 4)],\n    10: [(2, 9), (8, 4), (9, 4), (0, 10), (5, 9), (4, 7), (1, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate shortest path from node 10 to node 6\nresult = dijkstra(graph, 10, 6)\nprint(result)\n```"}, "23": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    6: [(4, 8), (3, 6), (7, 2)],\n    4: [(6, 8), (5, 3)],\n    3: [(6, 6), (2, 10)],\n    7: [(6, 2)],\n    5: [(4, 3), (1, 6)],\n    2: [(3, 10), (0, 7)],\n    1: [(5, 6), (8, 5)],\n    0: [(2, 7), (8, 6)],\n    8: [(0, 6), (1, 5)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 7 to node 8\nshortest_path_length = dijkstra(graph, 7, 8)\nprint(shortest_path_length)\n```"}, "24": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(7, 1), (10, 3), (9, 8), (8, 7), (12, 10), (6, 9)],\n    7: [(5, 1), (10, 6), (3, 10)],\n    10: [(5, 3), (7, 6), (12, 2)],\n    9: [(5, 8), (12, 2)],\n    8: [(5, 7), (2, 8), (6, 3)],\n    12: [(5, 10), (10, 2), (9, 2), (1, 9), (6, 5), (4, 4), (0, 9)],\n    6: [(5, 9), (8, 3), (12, 5), (1, 2), (0, 4)],\n    3: [(7, 10), (2, 7)],\n    2: [(8, 8), (3, 7), (1, 3), (11, 8)],\n    1: [(12, 9), (6, 2), (2, 3)],\n    4: [(12, 4), (11, 1)],\n    0: [(12, 9), (6, 4)],\n    11: [(2, 8), (4, 1)]\n}\n\nresult = dijkstra(graph, 1, 11)\nprint(result)\n```"}, "25": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(2, 1), (1, 9)],\n    2: [(3, 1), (4, 7)],\n    1: [(3, 9)],\n    4: [(2, 7), (10, 3), (6, 9)],\n    10: [(4, 3)],\n    6: [(4, 9), (0, 9), (12, 7)],\n    5: [(0, 10), (7, 2)],\n    0: [(5, 10), (6, 9)],\n    7: [(5, 2), (12, 2)],\n    12: [(7, 2), (6, 7), (11, 5)],\n    11: [(12, 5), (9, 3), (8, 4)],\n    9: [(11, 3)],\n    8: [(11, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 11, 12)\nprint(shortest_path_length)\n```"}, "26": {"gpt4": "```python\nimport heapq\n\n# Define the graph as an adjacency list\ngraph = {\n    0: [(5, 10)],\n    5: [(1, 5), (2, 8)],\n    1: [(3, 10)],\n    2: [(5, 6)],\n    7: [(4, 4), (1, 5)],\n    4: [(3, 2)],\n    3: [(7, 4)],\n    6: [(2, 5), (5, 5)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 6 to node 5\nshortest_path_length = dijkstra(graph, 6, 5)\nprint(shortest_path_length)\n```"}, "27": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    9: [(8, 4), (6, 8), (3, 8)],\n    8: [(9, 4), (7, 9), (4, 1)],\n    6: [(9, 8), (1, 6)],\n    3: [(9, 8)],\n    7: [(8, 9), (5, 6), (1, 1), (2, 8)],\n    4: [(8, 1)],\n    1: [(6, 6), (7, 1)],\n    5: [(7, 6), (0, 8)],\n    2: [(7, 8)],\n    0: [(5, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue\n    queue = [(0, start)]\n    # Distances dictionary\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reached the end node\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate shortest path from node 8 to node 0\nshortest_path_length = dijkstra(graph, 8, 0)\nprint(shortest_path_length)\n```"}, "28": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    0: [(3, 10), (1, 10), (5, 1)],\n    3: [(0, 10)],\n    1: [(0, 10), (5, 5)],\n    5: [(0, 1), (1, 5), (6, 7)],\n    6: [(5, 7), (7, 7)],\n    7: [(6, 7), (8, 7)],\n    8: [(7, 7), (2, 10)],\n    2: [(8, 10), (4, 7)],\n    4: [(2, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 2 to node 5\nshortest_path_length = dijkstra(graph, 2, 5)\nprint(shortest_path_length)\n```"}, "29": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    4: [(2, 6), (0, 5), (7, 3), (3, 2), (1, 5), (6, 6)],\n    2: [(4, 6)],\n    0: [(4, 5)],\n    7: [(4, 3), (5, 4)],\n    3: [(4, 2)],\n    1: [(4, 5)],\n    6: [(4, 6)],\n    5: [(7, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 4 to node 0\nshortest_path_length = dijkstra(graph, 4, 0)\nprint(shortest_path_length)\n```"}, "30": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(4, 9), (1, 4)],\n    4: [(8, 9), (0, 7)],\n    1: [(8, 4), (5, 5)],\n    0: [(4, 7), (3, 8), (2, 2)],\n    5: [(1, 5), (7, 7)],\n    3: [(0, 8), (2, 1), (6, 6)],\n    2: [(0, 2), (3, 1)],\n    7: [(5, 7)],\n    6: [(3, 6)]\n}\n\nstart_node = 3\nend_node = 0\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "31": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(1, 5), (9, 6), (4, 8), (10, 1)],\n    1: [(3, 5), (0, 9), (4, 8), (5, 4)],\n    9: [(3, 6), (8, 10), (6, 5), (7, 7)],\n    4: [(3, 8), (1, 8), (10, 1), (5, 2), (6, 1)],\n    10: [(3, 1), (4, 1), (6, 2), (0, 10), (2, 8)],\n    0: [(1, 9), (10, 10), (5, 5), (2, 6)],\n    5: [(1, 4), (4, 2), (0, 5), (2, 1), (7, 3)],\n    8: [(9, 10), (6, 10)],\n    6: [(9, 5), (4, 1), (10, 2), (8, 10), (2, 8)],\n    7: [(9, 7), (5, 3)],\n    2: [(10, 8), (0, 6), (5, 1), (6, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 0)\nprint(shortest_path_length)\n```"}, "32": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(8, 5), (10, 6), (9, 8)],\n    8: [(4, 9), (2, 9)],\n    10: [(0, 7), (6, 2)],\n    9: [(8, 7), (7, 9), (0, 1), (12, 1)],\n    4: [(7, 10), (11, 10), (12, 8), (5, 1)],\n    2: [(9, 3), (4, 2), (7, 7)],\n    0: [(6, 2), (1, 6), (4, 1)],\n    6: [(0, 5)],\n    7: [(11, 5), (3, 4), (5, 5), (1, 4), (8, 2), (4, 10), (10, 3)],\n    5: [(1, 8)]\n}\n\nstart_node = 6\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "33": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(8, 8), (7, 5), (12, 9)],\n    8: [(0, 7)],\n    7: [(13, 9), (2, 6), (4, 3), (5, 9)],\n    0: [(6, 9), (12, 2), (10, 2), (5, 2), (7, 1)],\n    13: [(1, 10)],\n    2: [(10, 4)],\n    4: [(0, 10), (3, 4)],\n    5: [(9, 2), (7, 3), (10, 10), (4, 7)],\n    3: [(9, 1)],\n    9: [(12, 4), (3, 1)],\n    1: [(3, 8), (5, 9)],\n    11: [(2, 1), (5, 8), (6, 2)]\n}\n\nstart_node = 8\nend_node = 0\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "34": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(6, 5), (5, 3), (4, 8), (7, 4), (9, 6), (8, 10), (3, 4)],\n    6: [(1, 5), (3, 7), (7, 2), (8, 4), (10, 7)],\n    5: [(1, 3), (7, 7), (10, 9)],\n    4: [(1, 8), (7, 2), (0, 6)],\n    7: [(1, 4), (6, 2), (5, 7), (4, 2), (3, 9), (8, 8), (2, 2), (9, 9), (0, 4)],\n    9: [(1, 6), (7, 9), (3, 7)],\n    8: [(1, 10), (6, 4), (7, 8), (10, 8)],\n    3: [(1, 4), (6, 7), (7, 9), (9, 7), (0, 2)],\n    10: [(6, 7), (5, 9), (8, 8), (0, 8)],\n    0: [(4, 6), (7, 4), (3, 2), (10, 8)],\n    2: [(7, 2)]\n}\n\nprint(dijkstra(graph, 2, 0))\n```"}, "35": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(6, 6), (4, 7)],\n    6: [(2, 6), (8, 7), (3, 2), (7, 9)],\n    4: [(2, 7), (5, 3), (0, 8), (1, 8), (3, 4)],\n    8: [(6, 7), (0, 7), (1, 5), (3, 1), (7, 7)],\n    3: [(6, 2), (4, 4), (8, 1), (1, 5)],\n    7: [(6, 9), (8, 7), (0, 4), (1, 7)],\n    5: [(4, 3)],\n    0: [(4, 8), (8, 7), (1, 1), (7, 4)],\n    1: [(4, 8), (8, 5), (0, 1), (3, 5), (7, 7)]\n}\n\nprint(dijkstra(graph, 4, 1))\n```"}, "36": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(10, 8), (7, 7)],\n    10: [(9, 8)],\n    7: [(9, 7), (2, 4), (6, 8), (8, 9)],\n    2: [(7, 4), (4, 5)],\n    6: [(7, 8), (5, 5), (0, 1)],\n    8: [(7, 9), (0, 9)],\n    3: [(5, 4), (1, 2)],\n    5: [(3, 4), (6, 5)],\n    1: [(3, 2)],\n    0: [(6, 1), (8, 9)],\n    4: [(2, 5)]\n}\n\nprint(dijkstra(graph, 9, 10))\n```"}, "37": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    6: [(2, 3), (5, 5), (1, 9), (10, 2), (0, 8), (9, 10)],\n    2: [(6, 3), (4, 10)],\n    5: [(6, 5)],\n    1: [(6, 9)],\n    10: [(6, 2), (8, 2), (3, 6)],\n    0: [(6, 8)],\n    9: [(6, 10), (7, 4)],\n    4: [(2, 10)],\n    8: [(10, 2)],\n    3: [(10, 6)],\n    7: [(9, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 10 to node 8\nshortest_path_length = dijkstra(graph, 10, 8)\nprint(shortest_path_length)\n```"}, "38": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    12: [(13, 7), (2, 8), (10, 1), (4, 3), (7, 4), (0, 4), (8, 8)],\n    13: [(12, 7), (9, 3), (5, 8), (3, 8), (0, 9), (11, 10)],\n    2: [(12, 8), (6, 6), (10, 4), (5, 3), (1, 7), (7, 6), (11, 8)],\n    10: [(12, 1), (2, 4), (6, 10), (5, 2), (3, 10), (11, 4)],\n    4: [(12, 3), (7, 1)],\n    7: [(12, 4), (2, 6), (4, 1), (9, 8), (5, 5), (1, 6), (3, 6)],\n    0: [(12, 4), (13, 9), (6, 9), (9, 2), (1, 3), (3, 3), (8, 1)],\n    8: [(12, 8), (0, 1), (6, 10), (9, 4), (5, 9), (11, 9)],\n    9: [(13, 3), (7, 8), (0, 2), (8, 4), (6, 6), (3, 4), (11, 6)],\n    5: [(13, 8), (2, 3), (10, 2), (7, 5), (8, 9), (1, 7), (11, 6)],\n    3: [(13, 8), (10, 10), (7, 6), (0, 3), (9, 4), (11, 9)],\n    11: [(13, 10), (2, 8), (10, 4), (8, 9), (9, 6), (5, 6), (3, 9)],\n    6: [(2, 6), (10, 10), (0, 9), (8, 10), (9, 6)],\n    1: [(2, 7), (7, 6), (0, 3), (5, 7)]\n}\n\nstart_node = 10\nend_node = 5\nprint(dijkstra(graph, start_node, end_node))\n```"}, "39": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    12: [(5, 7), (4, 3), (9, 5), (2, 10)],\n    5: [(12, 7), (10, 8), (13, 5), (8, 6)],\n    4: [(12, 3), (3, 5), (8, 3), (2, 7)],\n    9: [(12, 5), (1, 2), (0, 10), (7, 8)],\n    2: [(12, 10), (4, 7), (7, 6)],\n    10: [(5, 8), (6, 5), (7, 3), (0, 6)],\n    13: [(5, 5), (1, 1), (6, 3), (7, 8), (0, 10)],\n    8: [(5, 6), (4, 3), (1, 8), (11, 2)],\n    3: [(4, 5), (6, 7), (0, 1), (11, 10)],\n    1: [(9, 2), (13, 1), (8, 8), (0, 7), (11, 3)],\n    0: [(9, 10), (10, 6), (13, 10), (3, 1), (1, 7)],\n    7: [(9, 8), (2, 6), (10, 3), (13, 8)],\n    6: [(10, 5), (13, 3), (3, 7)],\n    11: [(8, 2), (3, 10), (1, 3)]\n}\n\nstart_node = 5\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "40": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(3, 2), (7, 4), (9, 6)],\n    3: [(4, 2), (2, 9), (9, 7), (0, 3), (6, 9), (11, 8), (10, 6), (13, 2)],\n    7: [(4, 4), (2, 10), (5, 8), (6, 1), (8, 9), (10, 8), (12, 8), (13, 6)],\n    9: [(4, 6), (3, 7), (5, 2), (0, 1), (11, 2), (8, 2), (12, 1)],\n    2: [(3, 9), (7, 10), (5, 2), (1, 1), (11, 10), (8, 6), (10, 7), (12, 6), (13, 5)],\n    0: [(3, 3), (9, 1), (1, 1), (8, 6)],\n    6: [(3, 9), (7, 1), (5, 7), (1, 3), (10, 7), (13, 4)],\n    11: [(3, 8), (9, 2), (2, 10), (5, 2), (12, 8), (13, 1)],\n    10: [(3, 6), (7, 8), (2, 7), (6, 7)],\n    13: [(3, 2), (7, 6), (2, 5), (5, 8), (1, 3), (11, 1), (12, 7), (6, 4)],\n    5: [(7, 8), (9, 2), (2, 2), (1, 6), (6, 7), (11, 2), (13, 8)],\n    8: [(7, 9), (9, 2), (2, 6), (0, 6), (12, 3)],\n    12: [(7, 8), (9, 1), (2, 6), (11, 8), (8, 3), (13, 7)],\n    1: [(2, 1), (5, 6), (0, 1), (6, 3), (13, 3)]\n}\n\nprint(dijkstra(graph, 11, 13))\n```"}, "41": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    0: [(3, 5), (1, 6)],\n    1: [(0, 6)],\n    2: [(11, 7)],\n    3: [(6, 7), (0, 5)],\n    4: [(6, 5)],\n    5: [(6, 2)],\n    6: [(10, 10), (3, 7), (5, 2), (8, 9), (4, 5), (9, 1), (7, 3), (11, 4)],\n    7: [(6, 3)],\n    8: [(6, 9)],\n    9: [(6, 1)],\n    10: [(6, 10)],\n    11: [(6, 4), (2, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue for the minimum distance\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor has been found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 0 to node 9\nshortest_path_length = dijkstra(graph, 0, 9)\nprint(shortest_path_length)\n```"}, "42": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(11, 10), (3, 4), (4, 7), (2, 8), (6, 5), (7, 3)],\n    11: [(10, 10), (4, 6), (9, 3)],\n    3: [(10, 4), (4, 8), (5, 7)],\n    4: [(10, 7), (11, 6), (3, 8), (1, 1), (5, 5)],\n    2: [(10, 8), (8, 10), (9, 4)],\n    6: [(10, 5), (8, 4), (1, 10), (7, 7), (0, 10)],\n    7: [(10, 3), (6, 7), (1, 5), (0, 7)],\n    9: [(11, 3), (2, 4), (8, 6), (0, 6)],\n    5: [(3, 7), (4, 5), (0, 4)],\n    1: [(4, 1), (6, 10), (7, 5), (8, 10)],\n    8: [(2, 10), (6, 4), (9, 6), (1, 10)],\n    0: [(6, 10), (7, 7), (9, 6), (5, 4)]\n}\n\nprint(dijkstra(graph, 8, 9))\n```"}, "43": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    2: [(8, 3), (1, 6), (7, 6), (9, 1), (4, 3), (0, 4), (3, 2)],\n    8: [(2, 3), (0, 9), (3, 5)],\n    1: [(2, 6), (7, 4), (0, 5)],\n    7: [(2, 6), (1, 4), (0, 6), (5, 4), (9, 3)],\n    9: [(2, 1), (7, 3), (4, 3)],\n    4: [(2, 3), (9, 3), (0, 5), (3, 10), (6, 8)],\n    0: [(2, 4), (8, 9), (1, 5), (7, 6), (4, 5), (3, 9), (5, 4)],\n    3: [(2, 2), (8, 5), (4, 10), (0, 9), (5, 5)],\n    5: [(7, 4), (0, 4), (3, 5)],\n    6: [(4, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 3 to node 0\nshortest_path_length = dijkstra(graph, 3, 0)\nprint(shortest_path_length)\n```"}, "44": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: {3: 7, 2: 6, 8: 7, 5: 6, 7: 5, 6: 7, 1: 8},\n    3: {0: 7, 4: 8, 2: 9, 8: 8, 6: 9},\n    2: {0: 6, 3: 9, 4: 5, 7: 6, 6: 8, 1: 5},\n    8: {0: 7, 3: 8, 7: 4, 6: 9},\n    5: {0: 6, 4: 4, 7: 9, 1: 4},\n    7: {0: 5, 2: 6, 8: 4, 5: 9, 4: 7, 1: 10},\n    6: {0: 7, 3: 9, 2: 8, 8: 9, 4: 8, 1: 6},\n    1: {0: 8, 2: 5, 5: 4, 7: 10, 6: 6, 4: 2},\n    4: {3: 8, 2: 5, 5: 4, 7: 7, 6: 8, 1: 2}\n}\n\nprint(dijkstra(graph, 7, 0))\n```"}, "45": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(6, 5), (2, 10), (3, 9), (8, 9), (4, 8), (0, 4)],\n    6: [(5, 5), (1, 1), (2, 2), (3, 5)],\n    2: [(5, 10), (6, 2), (8, 7), (7, 9), (1, 2), (9, 6)],\n    3: [(5, 9), (6, 5), (8, 2), (9, 6), (0, 1)],\n    8: [(5, 9), (2, 7), (3, 2), (1, 3), (7, 10), (0, 7), (9, 7)],\n    4: [(5, 8), (7, 1)],\n    0: [(5, 4), (3, 1), (8, 7)],\n    1: [(6, 1), (2, 2), (8, 3)],\n    7: [(2, 9), (8, 10), (4, 1)],\n    9: [(2, 6), (3, 6), (8, 7)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 5)\nprint(shortest_path_length)\n```"}, "46": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    0: [(3, 10), (2, 7), (6, 9), (10, 6), (4, 8)],\n    3: [(0, 10)],\n    2: [(0, 7)],\n    6: [(0, 9), (5, 2), (1, 1), (7, 2)],\n    10: [(0, 6)],\n    4: [(0, 8), (9, 5), (8, 8)],\n    5: [(6, 2)],\n    1: [(6, 1)],\n    7: [(6, 2)],\n    9: [(4, 5)],\n    8: [(4, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor has been found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 4 to node 8\nshortest_path_length = dijkstra(graph, 4, 8)\nprint(shortest_path_length)\n```"}, "47": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(8, 1), (3, 6)],\n    8: [(1, 4), (6, 8)],\n    3: [(1, 2), (6, 1)],\n    1: [(2, 4), (3, 2), (7, 8)],\n    2: [(0, 1), (8, 10)],\n    0: [(7, 6), (5, 10), (1, 9), (2, 3)],\n    7: [(1, 6), (4, 9), (6, 9)],\n    5: [(4, 9), (6, 6), (0, 10), (7, 3)],\n    4: [(0, 6), (8, 5), (3, 8), (7, 7), (1, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 6, 3)\nprint(shortest_path_length)\n```"}, "48": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(2, 1), (1, 3), (3, 9), (0, 1), (8, 6)],\n    2: [(5, 1)],\n    1: [(5, 3), (7, 9), (4, 8)],\n    3: [(5, 9)],\n    0: [(5, 1), (9, 10)],\n    8: [(5, 6)],\n    7: [(1, 9)],\n    4: [(1, 8), (6, 3)],\n    9: [(0, 10)],\n    6: [(4, 3)]\n}\n\nprint(dijkstra(graph, 0, 8))\n```"}, "49": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    12: [(8, 1), (4, 7), (6, 9), (1, 8)],\n    8: [(12, 1), (2, 2), (10, 7), (13, 5), (5, 10), (6, 5), (11, 6)],\n    4: [(12, 7), (10, 2), (0, 10), (7, 1), (6, 3), (11, 9), (9, 4), (1, 8), (3, 5)],\n    6: [(12, 9), (8, 5), (4, 3), (2, 8), (13, 8), (7, 7), (5, 4), (9, 8)],\n    1: [(12, 8), (4, 8), (13, 3), (0, 7), (7, 8)],\n    2: [(8, 2), (6, 8), (13, 6), (0, 5), (7, 7), (5, 7), (11, 5), (9, 5)],\n    10: [(8, 7), (4, 2), (0, 5), (5, 5), (11, 5), (3, 7)],\n    13: [(8, 5), (6, 8), (1, 3), (2, 6), (7, 4), (5, 3), (11, 2), (3, 7)],\n    5: [(8, 10), (6, 4), (2, 7), (13, 3), (10, 5), (9, 6)],\n    11: [(8, 6), (4, 9), (2, 5), (13, 2), (7, 8), (10, 5), (9, 9)],\n    0: [(4, 10), (1, 7), (2, 5), (10, 5), (7, 3), (9, 10), (3, 5)],\n    7: [(4, 1), (6, 7), (1, 8), (2, 7), (13, 4), (0, 3), (11, 8), (9, 8), (3, 10)],\n    9: [(4, 4), (6, 8), (2, 5), (0, 10), (7, 8), (5, 6), (11, 9)],\n    3: [(4, 5), (13, 7), (0, 5), (7, 10), (10, 7)]\n}\n\nprint(dijkstra(graph, 10, 11))\n```"}, "50": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(5, 1), (7, 6), (1, 6)],\n    5: [(10, 1), (3, 6), (2, 8), (6, 2), (0, 8)],\n    7: [(10, 6), (3, 5), (8, 1), (4, 5)],\n    1: [(10, 6), (9, 6), (0, 8)],\n    3: [(5, 6), (7, 5), (2, 8)],\n    2: [(5, 8), (3, 8), (8, 6), (4, 7)],\n    6: [(5, 2), (11, 4), (9, 6)],\n    0: [(5, 8), (1, 8), (8, 10), (4, 4)],\n    8: [(7, 1), (2, 6), (11, 2), (0, 10)],\n    4: [(7, 5), (2, 7), (11, 1), (9, 4), (0, 4)],\n    9: [(1, 6), (4, 4), (6, 6)],\n    11: [(8, 2), (4, 1), (6, 4)]\n}\n\nprint(dijkstra(graph, 9, 6))\n```"}, "51": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    11: [(0, 3), (5, 7), (6, 8), (14, 6), (10, 1), (8, 9), (7, 8)],\n    0: [(11, 3), (2, 7), (14, 7), (7, 2)],\n    5: [(11, 7), (1, 9), (4, 8), (6, 5), (2, 8), (14, 10)],\n    6: [(11, 8), (5, 5), (1, 8), (2, 10), (12, 1), (9, 1), (8, 1)],\n    14: [(11, 6), (0, 7), (5, 10), (1, 1), (4, 1), (2, 2), (9, 7), (8, 9), (7, 8)],\n    10: [(11, 1), (2, 9), (12, 4), (8, 8)],\n    8: [(11, 9), (6, 1), (14, 9), (10, 8), (1, 8), (3, 1)],\n    7: [(11, 8), (0, 2), (14, 8), (2, 8), (12, 6), (9, 5)],\n    2: [(0, 7), (5, 8), (6, 10), (14, 2), (10, 9), (7, 8), (3, 9), (12, 5), (9, 7)],\n    1: [(5, 9), (6, 8), (14, 1), (8, 8)],\n    4: [(5, 8), (14, 1), (3, 4)],\n    12: [(6, 1), (10, 4), (7, 6), (2, 5), (9, 1)],\n    9: [(6, 1), (14, 7), (7, 5), (2, 7), (12, 1), (13, 5)],\n    3: [(8, 1), (2, 9), (4, 4), (13, 3)],\n    13: [(3, 3), (9, 5)]\n}\n\nstart_node = 3\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "52": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(5, 9), (2, 4), (1, 10)],\n    5: [(0, 1)],\n    2: [(1, 8), (4, 2), (0, 7), (7, 9)],\n    1: [(5, 4), (3, 7), (6, 2)],\n    4: [(5, 1), (3, 2), (2, 10)],\n    7: [(1, 2), (5, 9), (3, 2)],\n    3: [(6, 4)],\n    6: [(3, 10)]\n}\n\n# Calculate shortest path from node 1 to node 0\nshortest_path_length = dijkstra(graph, 1, 0)\nprint(shortest_path_length)\n```"}, "53": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    7: [(6, 7), (4, 1)],\n    6: [(7, 7), (5, 8), (3, 4)],\n    4: [(7, 1), (0, 5)],\n    5: [(6, 8), (1, 7)],\n    3: [(6, 4), (1, 1)],\n    0: [(4, 5), (2, 9)],\n    1: [(5, 7), (3, 1)],\n    2: [(0, 9)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 6)\nprint(shortest_path_length)\n```"}, "54": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(0, 10), (11, 8), (4, 2), (8, 3), (10, 5), (7, 9), (12, 7), (6, 5), (5, 2), (1, 3), (9, 7)],\n    0: [(2, 10), (3, 9), (4, 9), (8, 1), (10, 1), (7, 7), (12, 9), (1, 8), (9, 2)],\n    11: [(2, 8), (3, 2), (4, 3), (7, 2), (9, 4)],\n    4: [(2, 2), (0, 9), (11, 3), (3, 7), (8, 4), (10, 10), (7, 9), (6, 1), (5, 10), (1, 9)],\n    8: [(2, 3), (0, 1), (4, 4), (3, 2), (10, 3), (12, 10), (6, 7), (5, 2), (9, 5)],\n    10: [(2, 5), (0, 1), (4, 10), (8, 3), (3, 4), (5, 4), (1, 1), (9, 6)],\n    7: [(2, 9), (0, 7), (11, 2), (4, 9), (3, 5), (6, 2), (5, 5), (1, 7), (9, 9)],\n    12: [(2, 7), (0, 9), (8, 10), (3, 6), (5, 10), (1, 1), (9, 6)],\n    6: [(2, 5), (4, 1), (8, 7), (7, 2), (3, 6), (5, 7), (1, 10)],\n    5: [(2, 2), (4, 10), (8, 2), (10, 4), (7, 5), (12, 10), (6, 7), (3, 5), (1, 10), (9, 4)],\n    1: [(2, 3), (0, 8), (4, 9), (10, 1), (7, 7), (12, 1), (6, 10), (5, 10)],\n    9: [(2, 7), (0, 2), (11, 4), (8, 5), (10, 6), (7, 9), (12, 6), (5, 4), (3, 1)],\n    3: [(0, 9), (11, 2), (4, 7), (8, 2), (10, 4), (7, 5), (12, 6), (6, 6), (5, 5), (9, 1)]\n}\n\nstart_node = 1\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "55": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    11: [(0, 2)],\n    0: [(11, 2), (7, 5), (6, 8), (8, 2), (4, 7), (1, 5), (10, 5)],\n    7: [(0, 5)],\n    6: [(0, 8)],\n    8: [(0, 2), (2, 10), (5, 4), (3, 5)],\n    4: [(0, 7), (9, 4)],\n    1: [(0, 5)],\n    10: [(0, 5)],\n    2: [(8, 10)],\n    5: [(8, 4)],\n    3: [(8, 5)],\n    9: [(4, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue for the minimum distance\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 6 to node 7\nshortest_path_length = dijkstra(graph, 6, 7)\nprint(shortest_path_length)\n```"}, "56": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(5, 10), (8, 5)],\n    5: [(9, 10)],\n    8: [(9, 5), (0, 9), (10, 6), (1, 8), (2, 8), (6, 5)],\n    0: [(8, 9)],\n    10: [(8, 6)],\n    1: [(8, 8), (4, 5)],\n    2: [(8, 8), (7, 1)],\n    6: [(8, 5), (3, 10)],\n    4: [(1, 5)],\n    7: [(2, 1)],\n    3: [(6, 10)]\n}\n\nshortest_path_length = dijkstra(graph, 8, 7)\nprint(shortest_path_length)\n```"}, "57": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(6, 3), (1, 10), (5, 6), (12, 9), (8, 4), (4, 6), (11, 9), (7, 7), (9, 6), (0, 7)],\n    6: [(2, 3), (9, 6), (4, 3), (8, 8)],\n    1: [(2, 10), (9, 2), (3, 8), (8, 9), (0, 4)],\n    5: [(2, 6), (9, 4), (8, 6), (12, 6)],\n    12: [(2, 9), (5, 6), (9, 1), (7, 6), (3, 8)],\n    8: [(2, 4), (6, 8), (1, 9), (5, 6), (9, 4), (10, 7), (3, 10), (0, 3)],\n    4: [(2, 6), (6, 3), (9, 4), (7, 4)],\n    11: [(2, 9), (9, 7)],\n    7: [(2, 7), (12, 6), (4, 4), (9, 6), (0, 7), (3, 9)],\n    9: [(2, 6), (6, 6), (1, 2), (5, 4), (12, 1), (8, 4), (4, 4), (11, 7), (7, 6), (10, 5), (3, 6), (0, 7)],\n    0: [(2, 7), (1, 4), (8, 3), (7, 7), (9, 7)],\n    3: [(1, 8), (12, 8), (8, 10), (7, 9), (9, 6)],\n    10: [(8, 7), (9, 5)]\n}\n\nstart_node = 4\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "58": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 10), (13, 10), (7, 9), (2, 9), (4, 8)],\n    1: [(0, 10), (7, 9), (4, 5)],\n    13: [(0, 10), (6, 5), (4, 3), (7, 8), (5, 4), (9, 6), (12, 9), (11, 8)],\n    7: [(0, 9), (1, 9), (13, 8), (8, 2), (4, 2), (5, 4), (9, 3), (11, 4)],\n    2: [(0, 9), (3, 6), (11, 9)],\n    4: [(0, 8), (1, 5), (13, 3), (7, 2), (8, 1), (10, 7), (11, 8), (5, 7), (9, 4)],\n    6: [(13, 5), (8, 2), (11, 8)],\n    5: [(13, 4), (7, 4), (4, 7)],\n    9: [(13, 6), (7, 3), (4, 4), (3, 8), (12, 1)],\n    12: [(13, 9), (3, 7), (9, 1)],\n    11: [(13, 8), (7, 4), (2, 9), (4, 8), (6, 8), (3, 7)],\n    8: [(7, 2), (4, 1), (6, 2), (3, 6)],\n    3: [(2, 6), (8, 6), (9, 8), (11, 7), (12, 7)],\n    10: [(4, 7)]\n}\n\nstart_node = 10\nend_node = 13\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "59": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(1, 7), (10, 6), (0, 4)],\n    1: [(5, 7), (4, 9)],\n    10: [(5, 6), (11, 5), (8, 3)],\n    0: [(5, 4), (7, 10)],\n    4: [(1, 9)],\n    11: [(10, 5), (6, 4)],\n    8: [(10, 3), (3, 1), (6, 2)],\n    7: [(0, 10)],\n    9: [(3, 3), (2, 2)],\n    3: [(9, 3), (8, 1)],\n    2: [(9, 2)],\n    6: [(8, 2), (11, 4)]\n}\n\nresult = dijkstra(graph, 1, 7)\nprint(result)\n```"}, "60": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    2: [(8, 3)],\n    8: [(2, 3), (9, 7)],\n    9: [(8, 7), (0, 5), (4, 8)],\n    0: [(9, 5), (7, 6)],\n    4: [(9, 8), (10, 1)],\n    7: [(0, 6), (5, 3)],\n    5: [(7, 3), (1, 6)],\n    1: [(5, 6), (6, 8)],\n    6: [(1, 8), (3, 9)],\n    10: [(4, 1), (3, 10)],\n    3: [(10, 10), (6, 9)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate shortest path from node 9 to node 7\nshortest_path_length = dijkstra(graph, 9, 7)\nprint(shortest_path_length)\n```"}, "61": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(3, 2), (10, 4), (1, 3), (5, 7)],\n    3: [(6, 2), (0, 7), (10, 4), (9, 1)],\n    10: [(6, 4), (3, 4), (7, 9), (1, 7), (4, 5)],\n    1: [(6, 3), (10, 7), (2, 3), (9, 10), (5, 2)],\n    5: [(6, 7), (1, 2)],\n    0: [(3, 7), (2, 5), (8, 5)],\n    9: [(3, 1), (1, 10), (2, 10), (8, 1)],\n    7: [(10, 9), (11, 10)],\n    4: [(10, 5), (11, 10)],\n    2: [(1, 3), (0, 5), (9, 10), (8, 2)],\n    8: [(0, 5), (9, 1), (2, 2), (11, 1)],\n    11: [(8, 1), (7, 10), (4, 10)]\n}\n\nprint(dijkstra(graph, 2, 3))\n```"}, "62": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(5, 5), (1, 5), (3, 5), (8, 4), (10, 3), (6, 7)],\n    5: [(2, 5), (3, 9), (1, 9)],\n    1: [(2, 5), (5, 9), (8, 6), (0, 5), (7, 6), (4, 10), (10, 10), (9, 2)],\n    3: [(2, 5), (5, 9), (9, 9)],\n    8: [(2, 4), (1, 6), (6, 7), (7, 5), (9, 8), (10, 1)],\n    10: [(2, 3), (1, 10), (8, 1)],\n    6: [(2, 7), (8, 7), (9, 9)],\n    0: [(1, 5), (9, 9), (4, 1)],\n    7: [(1, 6), (8, 5), (9, 9)],\n    4: [(1, 10), (9, 10), (0, 1)],\n    9: [(1, 2), (3, 9), (8, 8), (6, 9), (0, 9), (7, 9), (4, 10)]\n}\n\nstart_node = 4\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "63": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(7, 3), (3, 4), (8, 3)],\n    7: [(10, 3), (0, 10), (5, 7), (4, 9), (3, 6)],\n    3: [(10, 4), (7, 6), (4, 9), (5, 2)],\n    8: [(10, 3), (2, 1), (4, 5), (11, 10)],\n    0: [(7, 10), (5, 8), (9, 3)],\n    5: [(7, 7), (3, 2), (0, 8), (2, 5), (6, 3), (9, 4)],\n    4: [(7, 9), (3, 9), (8, 5), (2, 7)],\n    2: [(8, 1), (5, 5), (4, 7), (1, 5)],\n    11: [(8, 10), (1, 1), (6, 7)],\n    9: [(0, 3), (5, 4), (1, 6), (6, 4)],\n    6: [(5, 3), (11, 7), (1, 2), (9, 4)],\n    1: [(2, 5), (11, 1), (9, 6), (6, 2)]\n}\n\nprint(dijkstra(graph, 0, 4))\n```"}, "64": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(12, 5), (10, 1)],\n    12: [(13, 3), (9, 2)],\n    13: [(0, 1), (12, 5), (10, 8)],\n    9: [(8, 7), (5, 7)],\n    0: [(13, 6), (4, 5)],\n    8: [(14, 10), (5, 10), (1, 6)],\n    5: [(4, 5), (8, 10), (6, 1)],\n    14: [(1, 10), (9, 6)],\n    1: [(3, 6), (4, 3), (14, 9), (6, 9), (10, 1), (7, 5)],\n    6: [(12, 5), (1, 9), (2, 5), (9, 3)],\n    3: [(12, 7)],\n    11: [(0, 6), (9, 6), (4, 10)],\n    7: [(9, 2), (8, 10)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 9)\nprint(shortest_path_length)\n```"}, "65": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    6: [(2, 6), (4, 8), (3, 2), (8, 8), (7, 1), (5, 3), (0, 7)],\n    2: [(6, 6)],\n    4: [(6, 8)],\n    3: [(6, 2), (1, 4)],\n    8: [(6, 8)],\n    7: [(6, 1)],\n    5: [(6, 3)],\n    0: [(6, 7)],\n    1: [(3, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue for the minimum distance\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 7 to node 0\nshortest_path_length = dijkstra(graph, 7, 0)\nprint(shortest_path_length)\n```"}, "66": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    11: [(6, 3)],\n    6: [(11, 3), (10, 6)],\n    10: [(6, 6), (2, 4), (8, 6)],\n    2: [(10, 4), (5, 2)],\n    8: [(10, 6), (0, 8), (1, 5)],\n    5: [(2, 2), (3, 7)],\n    0: [(8, 8), (4, 8)],\n    1: [(8, 5), (9, 3)],\n    4: [(0, 8)],\n    3: [(5, 7), (7, 6)],\n    7: [(3, 6), (9, 10)],\n    9: [(7, 10), (1, 3)]\n}\n\nstart_node = 1\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "67": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_node == end:\n            return current_distance\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return float('inf')\n\ngraph = {\n    4: [(12, 2), (1, 7), (11, 3), (8, 9), (3, 2)],\n    12: [(10, 9), (2, 10), (8, 8), (6, 8)],\n    1: [(8, 3), (3, 7), (0, 7), (6, 5), (2, 1), (7, 4)],\n    11: [(0, 2), (4, 1), (5, 9), (1, 7)],\n    8: [(3, 1), (0, 8), (4, 5), (2, 8), (7, 2)],\n    3: [(0, 9), (5, 6), (2, 8)],\n    10: [(2, 10), (3, 3), (4, 8), (9, 6)],\n    2: [(11, 10), (4, 2), (12, 3)],\n    6: [(9, 2), (1, 2), (11, 5), (3, 7), (4, 9)],\n    0: [(12, 2), (7, 9), (11, 8), (8, 10)],\n    7: [(8, 5), (3, 5), (12, 3), (10, 6), (2, 4)],\n    5: [(2, 7), (0, 3), (12, 9)],\n    9: [(10, 3), (2, 9), (7, 6), (11, 5), (3, 5)]\n}\n\nstart_node = 12\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "68": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Graph representation\ngraph = {\n    1: [(5, 1), (0, 4), (4, 8)],\n    5: [(1, 1), (2, 9)],\n    0: [(1, 4), (8, 2)],\n    4: [(1, 8), (6, 10), (3, 2)],\n    2: [(5, 9), (8, 3)],\n    8: [(0, 2), (2, 3)],\n    6: [(4, 10), (7, 9)],\n    3: [(4, 2)],\n    7: [(6, 9)]\n}\n\n# Calculate shortest path from node 5 to node 7\nshortest_path_length = dijkstra(graph, 5, 7)\nprint(shortest_path_length)\n```"}, "69": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: {3: 7, 4: 8, 5: 1, 7: 10, 2: 1},\n    3: {11: 3, 5: 7, 8: 2},\n    4: {5: 8, 7: 3, 8: 10, 1: 5, 9: 9, 3: 2},\n    5: {7: 2, 8: 9, 9: 10, 10: 2, 6: 7, 0: 5},\n    7: {1: 3, 9: 1, 3: 4, 5: 10},\n    2: {8: 9, 10: 2, 6: 8},\n    11: {2: 10, 3: 5, 10: 9},\n    8: {9: 4, 4: 9, 10: 10, 11: 6, 2: 8},\n    9: {4: 4, 0: 9, 5: 5, 2: 7},\n    10: {11: 7, 0: 3, 5: 9, 2: 3, 3: 4},\n    6: {0: 7, 1: 8, 3: 10},\n    0: {5: 7, 7: 7, 9: 5, 3: 4, 4: 6, 6: 6}\n}\n\nstart_node = 8\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "70": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    1: [(6, 6), (2, 6), (7, 7), (8, 9), (12, 4), (10, 10), (4, 7)],\n    6: [(1, 6), (12, 3), (5, 9), (9, 8), (0, 4)],\n    2: [(1, 6), (4, 9), (3, 1)],\n    7: [(1, 7), (12, 4)],\n    8: [(1, 9), (0, 7)],\n    12: [(1, 4), (6, 3), (7, 4)],\n    10: [(1, 10), (4, 4)],\n    4: [(1, 7), (2, 9), (10, 4), (0, 7), (3, 3), (9, 6)],\n    5: [(6, 9), (0, 3)],\n    9: [(6, 8), (4, 6), (11, 9)],\n    0: [(6, 4), (8, 7), (4, 7), (5, 3), (11, 5)],\n    3: [(2, 1), (4, 3)],\n    11: [(9, 9), (0, 5)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 11 to node 10\nshortest_path_length = dijkstra(graph, 11, 10)\nprint(shortest_path_length)\n```"}, "71": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    4: [(3, 4), (5, 8), (8, 6), (0, 1), (6, 9), (7, 1), (2, 8), (9, 10), (1, 4)],\n    3: [(4, 4), (9, 4), (0, 10), (8, 7)],\n    5: [(4, 8)],\n    8: [(4, 6), (3, 7), (2, 2)],\n    0: [(4, 1), (3, 10), (9, 1)],\n    6: [(4, 9), (7, 8), (9, 7)],\n    7: [(4, 1), (6, 8), (2, 7), (1, 1), (9, 2)],\n    2: [(4, 8), (8, 2), (7, 7), (1, 10), (9, 10)],\n    9: [(4, 10), (3, 4), (0, 1), (6, 7), (7, 2), (2, 10)],\n    1: [(4, 4), (7, 1), (2, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    shortest_paths = {node: float('inf') for node in graph}\n    shortest_paths[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > shortest_paths[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 8 to node 5\nshortest_path_length = dijkstra(graph, 8, 5)\nprint(shortest_path_length)\n```"}, "72": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    1: [(8, 4), (9, 9), (7, 5), (2, 4), (5, 10), (6, 3), (0, 4)],\n    8: [(1, 4), (10, 2), (9, 1)],\n    9: [(1, 9), (8, 1), (3, 6), (10, 8), (6, 3), (5, 3), (0, 3), (7, 1)],\n    7: [(1, 5), (9, 1), (11, 4), (0, 1)],\n    2: [(1, 4), (4, 2), (0, 9), (11, 2), (6, 7)],\n    5: [(1, 10), (9, 3), (10, 2), (11, 7)],\n    6: [(1, 3), (9, 3), (2, 7), (4, 9), (10, 8)],\n    0: [(1, 4), (9, 3), (7, 1), (2, 9), (4, 6)],\n    10: [(8, 2), (9, 8), (5, 2), (6, 8), (3, 1)],\n    3: [(9, 6), (10, 1)],\n    11: [(7, 4), (2, 2), (5, 7)],\n    4: [(2, 2), (6, 9), (0, 6)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor has been found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 6 to node 2\nshortest_path_length = dijkstra(graph, 6, 2)\nprint(shortest_path_length)\n```"}, "73": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 1), (4, 5)],\n    3: [(0, 1), (1, 6)],\n    4: [(0, 5), (7, 10), (1, 6)],\n    1: [(3, 6), (4, 6), (2, 2)],\n    7: [(4, 10), (8, 10)],\n    2: [(1, 2)],\n    8: [(7, 10), (6, 10)],\n    6: [(8, 10), (5, 5)],\n    5: [(6, 5)]\n}\n\nprint(dijkstra(graph, 4, 0))\n```"}, "74": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    8: [(5, 10), (4, 8), (9, 10), (6, 6)],\n    5: [(8, 10), (0, 3), (7, 3), (3, 9), (1, 9)],\n    4: [(8, 8), (0, 6), (7, 8), (3, 10)],\n    9: [(8, 10), (0, 7), (1, 4), (2, 8), (6, 10)],\n    6: [(8, 6), (9, 10), (1, 10)],\n    0: [(5, 3), (4, 6), (9, 7), (2, 4)],\n    7: [(5, 3), (4, 8), (2, 6), (3, 10)],\n    3: [(5, 9), (4, 10), (7, 10), (1, 5)],\n    1: [(5, 9), (9, 4), (6, 10), (3, 5)],\n    2: [(9, 8), (0, 4), (7, 6)]\n}\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 5 to node 7\nshortest_path_length = dijkstra(graph, 5, 7)\nprint(shortest_path_length)\n```"}, "75": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(3, 7), (6, 8), (1, 5), (2, 6), (10, 1)],\n    3: [(4, 7), (5, 4)],\n    6: [(4, 8)],\n    1: [(4, 5), (8, 10), (12, 5), (7, 9), (0, 5)],\n    2: [(4, 6)],\n    10: [(4, 1), (9, 3)],\n    5: [(3, 4), (11, 7)],\n    8: [(1, 10)],\n    12: [(1, 5)],\n    7: [(1, 9)],\n    0: [(1, 5)],\n    9: [(10, 3)],\n    11: [(5, 7)]\n}\n\nprint(dijkstra(graph, 6, 0))\n```"}, "76": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    \n    return float('inf')\n\n# Define the graph\ngraph = {\n    8: [(6, 2)],\n    6: [(8, 2), (7, 1)],\n    7: [(6, 1), (0, 5), (1, 10)],\n    0: [(7, 5), (1, 9), (2, 4)],\n    1: [(7, 10), (5, 1), (0, 9)],\n    3: [(5, 2)],\n    5: [(3, 2), (1, 1)],\n    2: [(0, 4), (4, 10)],\n    4: [(2, 10)]\n}\n\n# Calculate the shortest path from node 5 to node 0\nshortest_path_length = dijkstra(graph, 5, 0)\nprint(shortest_path_length)\n```"}, "77": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    12: [(11, 5), (5, 6), (4, 8), (1, 5), (9, 8), (3, 7)],\n    11: [(12, 5), (8, 1), (2, 3)],\n    5: [(12, 6), (6, 2), (10, 6), (0, 9), (7, 3)],\n    4: [(12, 8)],\n    1: [(12, 5)],\n    9: [(12, 8)],\n    3: [(12, 7)],\n    8: [(11, 1)],\n    2: [(11, 3)],\n    6: [(5, 2)],\n    10: [(5, 6)],\n    0: [(5, 9)],\n    7: [(5, 3)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 12 to node 2\nshortest_path_length = dijkstra(graph, 12, 2)\nprint(shortest_path_length)\n```"}, "78": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    5: [(9, 10), (10, 8)],\n    9: [(7, 8), (5, 2)],\n    10: [(8, 6), (5, 6), (9, 4)],\n    7: [(6, 2), (2, 9), (8, 7), (3, 1)],\n    8: [(0, 8), (5, 1)],\n    6: [(1, 4), (3, 3)],\n    2: [(0, 9)],\n    3: [(4, 5), (10, 5), (8, 7)],\n    4: [(9, 4)],\n    1: [(8, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 7)\nprint(shortest_path_length)\n```"}, "79": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 8), (9, 6), (11, 7)],\n    6: [(0, 8), (3, 9), (2, 9), (10, 9), (5, 4), (1, 2)],\n    9: [(0, 6), (11, 10), (5, 10), (4, 7)],\n    11: [(0, 7), (9, 10), (2, 7), (7, 7)],\n    3: [(6, 9), (8, 9), (13, 5), (5, 5)],\n    2: [(6, 9), (11, 7), (10, 9), (7, 8)],\n    10: [(6, 9), (2, 9), (13, 6), (7, 9)],\n    5: [(6, 4), (9, 10), (3, 5), (8, 7), (1, 10), (12, 1)],\n    1: [(6, 2), (5, 10), (8, 2), (13, 10), (12, 7)],\n    4: [(9, 7), (7, 9)],\n    7: [(11, 7), (2, 8), (10, 9), (4, 9)],\n    8: [(3, 9), (5, 7), (1, 2), (13, 5)],\n    13: [(3, 5), (10, 6), (1, 10), (8, 5)],\n    12: [(5, 1), (1, 7)]\n}\n\nprint(dijkstra(graph, 0, 12))\n```"}, "80": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    11: [(2, 2), (4, 3), (3, 9)],\n    2: [(10, 1), (8, 7), (9, 2), (6, 5)],\n    4: [(7, 6), (11, 6)],\n    3: [(8, 4), (5, 9), (1, 1)],\n    10: [(1, 10), (6, 4)],\n    8: [(5, 6), (1, 8), (2, 3)],\n    9: [(6, 3), (0, 2)],\n    7: [(0, 9), (1, 10)],\n    5: [(1, 3), (11, 4), (7, 6), (3, 6)],\n    1: [(6, 7)],\n    0: [(1, 9), (6, 2), (7, 9)],\n    12: [(10, 10), (1, 1), (11, 1)]\n}\n\nstart_node = 3\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "81": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    \n    return distances[end]\n\ngraph = {\n    5: [(6, 3), (1, 3), (7, 5)],\n    6: [(4, 9), (2, 8), (3, 4), (8, 1)],\n    1: [(0, 3), (5, 4), (4, 5)],\n    7: [(8, 1), (6, 9)],\n    4: [(8, 6)],\n    2: [(7, 7)],\n    3: [(5, 4), (4, 1)],\n    8: [(2, 3)],\n    0: [(8, 3), (2, 1)]\n}\n\nstart_node = 6\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "82": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    0: [(12, 10), (10, 4), (1, 7), (13, 9), (4, 4), (2, 4)],\n    12: [(0, 10)],\n    10: [(0, 4)],\n    1: [(0, 7), (9, 10)],\n    13: [(0, 9)],\n    4: [(0, 4)],\n    2: [(0, 4)],\n    9: [(1, 10), (11, 5)],\n    11: [(7, 8), (5, 3), (9, 5), (8, 10)],\n    7: [(11, 8)],\n    5: [(11, 3), (3, 7)],\n    8: [(11, 10)],\n    3: [(5, 7), (6, 5)],\n    6: [(3, 5)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Calculate the shortest path from node 1 to node 5\nshortest_path_length = dijkstra(graph, 1, 5)\nprint(shortest_path_length)\n```"}, "83": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (cost, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    shortest_paths = {node: float('inf') for node in graph}\n    shortest_paths[start] = 0\n    \n    while queue:\n        current_cost, current_node = heapq.heappop(queue)\n        \n        if current_node == end:\n            return current_cost\n        \n        for neighbor, weight in graph[current_node]:\n            cost = current_cost + weight\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n    \n    return float('inf')\n\ngraph = {\n    8: [(11, 9), (0, 10), (3, 1), (1, 5)],\n    11: [(10, 2)],\n    0: [(6, 10), (2, 8), (7, 8), (1, 1), (9, 8)],\n    3: [(6, 9), (2, 3), (7, 9), (4, 9), (9, 6), (0, 3)],\n    1: [(8, 10), (11, 6), (4, 8), (3, 5), (2, 6), (7, 6)],\n    10: [(4, 6), (9, 6)],\n    6: [(2, 6), (7, 2), (10, 3), (4, 4)],\n    2: [(7, 5), (5, 8), (1, 3), (11, 5), (4, 3), (6, 1)],\n    7: [(0, 7), (3, 7), (6, 2), (2, 9)],\n    9: [(3, 9), (2, 2), (7, 8), (8, 2), (10, 5), (11, 4), (4, 5)],\n    4: [(9, 6), (0, 5), (3, 8), (2, 5), (5, 6), (1, 4), (10, 10)],\n    5: [(11, 6), (9, 5), (6, 6), (2, 1), (7, 7)]\n}\n\nstart_node = 7\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "84": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    0: [(4, 6)],\n    1: [(4, 2)],\n    2: [(4, 1)],\n    3: [(4, 3)],\n    4: [(3, 3), (6, 2), (1, 2), (0, 6), (7, 7), (2, 1), (8, 3), (5, 6)],\n    5: [(4, 6)],\n    6: [(4, 2)],\n    7: [(4, 7)],\n    8: [(4, 3)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate shortest path from node 0 to node 8\nshortest_path_length = dijkstra(graph, 0, 8)\nprint(shortest_path_length)\n```"}, "85": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_node == end:\n            return current_distance\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return float('inf')\n\ngraph = {\n    9: [(0, 10), (1, 8), (8, 4), (2, 3)],\n    0: [(9, 10), (7, 1), (8, 4), (3, 6), (6, 7), (11, 5), (5, 5), (4, 7)],\n    1: [(9, 8), (7, 1), (8, 6), (10, 1), (3, 3), (5, 3)],\n    8: [(9, 4), (0, 4), (1, 6), (10, 5), (4, 8), (2, 4)],\n    2: [(9, 3), (8, 4)],\n    7: [(0, 1), (1, 1), (11, 2), (4, 3)],\n    3: [(0, 6), (1, 3), (10, 9), (4, 3)],\n    6: [(0, 7), (10, 3), (11, 4), (5, 2), (4, 9)],\n    11: [(0, 5), (7, 2), (6, 4), (4, 3)],\n    5: [(0, 5), (1, 3), (6, 2), (10, 9)],\n    4: [(0, 7), (8, 8), (7, 3), (3, 3), (6, 9), (11, 3)],\n    10: [(1, 1), (8, 5), (3, 9), (6, 3), (5, 9)]\n}\n\nstart_node = 6\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "86": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    1: [(5, 3), (0, 7), (7, 5), (8, 8), (6, 10), (3, 4)],\n    5: [(1, 3)],\n    0: [(1, 7)],\n    7: [(1, 5)],\n    8: [(1, 8), (2, 9), (4, 5)],\n    6: [(1, 10)],\n    3: [(1, 4)],\n    2: [(8, 9)],\n    4: [(8, 5)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 2 to node 4\nshortest_path_length = dijkstra(graph, 2, 4)\nprint(shortest_path_length)\n```"}, "87": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    11: [(7, 2), (2, 6), (3, 9), (5, 10), (6, 8), (4, 5), (0, 1), (9, 4)],\n    7: [(11, 2), (2, 6), (10, 5), (3, 2), (1, 3), (4, 10), (0, 3), (8, 10), (9, 1)],\n    2: [(11, 6), (7, 6), (10, 3), (3, 3), (4, 6), (9, 4)],\n    3: [(11, 9), (7, 2), (2, 3), (10, 8), (1, 6), (5, 2), (0, 10), (9, 8)],\n    5: [(11, 10), (3, 2), (10, 10), (0, 7), (8, 4), (9, 6)],\n    6: [(11, 8), (1, 7), (4, 7), (0, 1), (8, 5)],\n    4: [(11, 5), (7, 10), (2, 6), (6, 7), (10, 5), (1, 9), (0, 4), (8, 3)],\n    0: [(11, 1), (7, 3), (3, 10), (5, 7), (6, 1), (4, 4), (8, 7)],\n    9: [(11, 4), (7, 1), (2, 4), (3, 8), (5, 6), (10, 9), (1, 1), (8, 7)],\n    10: [(7, 5), (2, 3), (3, 8), (5, 10), (4, 5), (9, 9), (8, 7)],\n    1: [(7, 3), (3, 6), (6, 7), (4, 9), (9, 1)],\n    8: [(7, 10), (5, 4), (6, 5), (4, 3), (0, 7), (9, 7), (10, 7)]\n}\n\nstart_node = 9\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "88": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    9: [(12, 1), (4, 10), (6, 8), (7, 9)],\n    12: [(5, 10), (11, 2), (0, 8)],\n    4: [(1, 5), (9, 4)],\n    6: [(12, 9)],\n    7: [(0, 7), (8, 6)],\n    11: [(2, 3), (13, 9), (4, 4)],\n    0: [(9, 3), (3, 1), (11, 7)],\n    1: [(5, 9)],\n    8: [(7, 1)],\n    3: [(6, 3), (10, 6)],\n    10: [(12, 1), (5, 8), (11, 8), (0, 2)],\n    2: [(10, 9), (4, 3), (11, 6)],\n    14: [(6, 9)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 14 to node 4\nshortest_path_length = dijkstra(graph, 14, 4)\nprint(shortest_path_length)\n```"}, "89": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(6, 5), (4, 3), (5, 10), (3, 2), (8, 3), (9, 7)],\n    6: [(0, 5), (9, 7), (3, 9)],\n    4: [(0, 3), (5, 10), (3, 10), (7, 4), (10, 7)],\n    5: [(0, 10), (4, 10), (8, 6)],\n    3: [(0, 2), (6, 9), (4, 10), (2, 10), (1, 2)],\n    8: [(0, 3), (5, 6)],\n    9: [(0, 7), (6, 7)],\n    7: [(4, 4), (10, 7)],\n    10: [(4, 7), (7, 7), (1, 7), (2, 9)],\n    2: [(3, 10), (10, 9)],\n    1: [(3, 2), (10, 7)]\n}\n\nshortest_path_length = dijkstra(graph, 10, 7)\nprint(shortest_path_length)\n```"}, "90": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    7: [(4, 10), (2, 5), (10, 1)],\n    4: [(7, 10)],\n    2: [(7, 5), (5, 6), (1, 3)],\n    10: [(7, 1), (0, 3)],\n    5: [(2, 6), (0, 9)],\n    1: [(2, 3), (9, 3)],\n    0: [(10, 3), (8, 5), (5, 9)],\n    6: [(9, 2), (3, 6)],\n    9: [(6, 2), (1, 3)],\n    3: [(6, 6)],\n    8: [(0, 5)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 9 to node 6\nshortest_path_length = dijkstra(graph, 9, 6)\nprint(shortest_path_length)\n```"}, "91": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 7)],\n    1: [(2, 10), (3, 2)],\n    2: [(4, 6), (1, 10)],\n    3: [(1, 2), (6, 7)],\n    4: [(2, 6), (7, 3)],\n    5: [(7, 8), (6, 7)],\n    6: [(3, 7), (0, 7), (5, 7)],\n    7: [(4, 3), (5, 8)]\n}\n\nstart_node = 7\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "92": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(6, 8), (7, 9), (12, 9), (1, 2), (11, 5), (4, 1), (14, 9), (3, 9), (10, 9)],\n    6: [(2, 8), (13, 1), (7, 5), (12, 7), (4, 8), (8, 7), (5, 5), (3, 3), (0, 3)],\n    7: [(2, 9), (6, 5), (13, 6), (12, 1), (1, 3), (9, 6), (5, 3), (10, 1)],\n    12: [(2, 9), (6, 7), (7, 1), (13, 7), (9, 9), (11, 3), (4, 9), (14, 1), (3, 6)],\n    1: [(2, 2), (7, 3), (9, 8), (11, 5), (5, 8), (3, 5), (0, 1)],\n    11: [(2, 5), (12, 3), (1, 5), (13, 4), (9, 8), (5, 5), (0, 4)],\n    4: [(2, 1), (6, 8), (12, 9), (13, 10), (9, 1), (8, 10), (14, 5), (0, 2), (10, 5)],\n    14: [(2, 9), (12, 1), (4, 5), (13, 2), (9, 2), (3, 1), (0, 8), (10, 6)],\n    3: [(2, 9), (6, 3), (12, 6), (1, 5), (14, 1), (13, 5), (9, 4), (8, 3), (5, 1)],\n    10: [(2, 9), (7, 1), (4, 5), (14, 6), (13, 10), (9, 2)],\n    13: [(6, 1), (7, 6), (12, 7), (11, 4), (4, 10), (14, 2), (3, 5), (10, 10), (9, 5), (5, 3), (0, 4)],\n    8: [(6, 7), (4, 10), (3, 3), (9, 6), (5, 9)],\n    5: [(6, 5), (7, 3), (1, 8), (11, 5), (3, 1), (13, 3), (9, 9), (8, 9), (0, 8)],\n    0: [(6, 3), (1, 1), (11, 4), (4, 2), (14, 8), (13, 4), (9, 4), (5, 8)],\n    9: [(7, 6), (12, 9), (1, 8), (11, 8), (4, 1), (14, 2), (3, 4), (10, 2), (13, 5), (8, 6), (5, 9), (0, 4)]\n}\n\nstart_node = 5\nend_node = 14\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "93": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(6, 10), (8, 10), (1, 7), (4, 1), (0, 1)],\n    6: [(8, 2), (1, 5), (3, 8), (9, 4), (5, 1)],\n    8: [(6, 5), (2, 1)],\n    1: [(0, 6), (2, 2)],\n    4: [(7, 5), (6, 8), (2, 6)],\n    3: [(9, 4), (4, 8), (2, 3), (8, 9)],\n    9: [(5, 6)],\n    2: [(1, 3), (3, 2), (0, 2), (5, 4)],\n    7: [(5, 2), (8, 7), (1, 7)]\n}\n\nstart_node = 4\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "94": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(9, 4), (4, 3), (3, 1), (8, 5)],\n    9: [(4, 1)],\n    4: [(1, 6), (5, 4), (9, 1)],\n    3: [(1, 1), (7, 6), (2, 7), (9, 8)],\n    8: [(6, 4), (7, 1), (5, 8), (9, 7), (0, 7), (4, 7), (3, 10)],\n    1: [(5, 6)],\n    5: [(4, 1), (10, 9), (8, 4), (1, 5), (6, 6)],\n    7: [(2, 1), (0, 1), (3, 10), (8, 7), (1, 10), (6, 8)],\n    2: [(9, 9), (0, 7), (4, 7), (10, 1), (1, 8), (7, 9)],\n    0: [(8, 1), (1, 8)],\n    10: [(7, 10), (5, 3), (9, 2), (0, 10)]\n}\n\nstart_node = 3\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "95": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(7, 2), (4, 8)],\n    7: [(8, 2), (0, 5), (9, 10), (2, 8)],\n    4: [(8, 8), (5, 8), (9, 2), (3, 5)],\n    0: [(7, 5), (5, 4), (9, 10)],\n    9: [(7, 10), (4, 2), (5, 4), (1, 7), (0, 10)],\n    2: [(7, 8), (5, 2), (6, 10), (3, 4)],\n    5: [(4, 8), (1, 3), (0, 4), (9, 4), (2, 2), (6, 7)],\n    3: [(4, 5), (2, 4)],\n    1: [(5, 3), (9, 7)],\n    6: [(5, 7), (2, 10)]\n}\n\nprint(dijkstra(graph, 2, 8))\n```"}, "96": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(6, 8), (3, 9), (12, 9), (2, 5), (4, 3)],\n    6: [(10, 8)],\n    3: [(10, 9), (11, 10)],\n    12: [(10, 9), (7, 1), (9, 1), (1, 9), (0, 5), (13, 1)],\n    2: [(10, 5)],\n    4: [(10, 3)],\n    11: [(3, 10)],\n    7: [(12, 1)],\n    9: [(12, 1)],\n    1: [(12, 9)],\n    0: [(12, 5)],\n    13: [(12, 1), (8, 5), (5, 7)],\n    8: [(13, 5)],\n    5: [(13, 7)]\n}\n\nprint(dijkstra(graph, 9, 2))\n```"}, "97": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(4, 6), (0, 3)],\n    4: [(10, 6), (1, 1)],\n    0: [(10, 3), (6, 4), (1, 9), (11, 2), (7, 9)],\n    1: [(4, 1), (0, 9), (8, 8), (13, 7), (11, 8), (2, 8), (3, 8)],\n    6: [(0, 4), (13, 3), (11, 8)],\n    11: [(0, 2), (6, 8), (13, 10), (1, 8), (9, 2)],\n    7: [(0, 9), (12, 1), (5, 2)],\n    12: [(8, 5), (7, 1)],\n    8: [(12, 5), (14, 1), (13, 3), (5, 1), (1, 8)],\n    14: [(8, 1)],\n    13: [(8, 3), (6, 3), (1, 7), (11, 10)],\n    5: [(8, 1), (7, 2)],\n    9: [(11, 2)],\n    2: [(1, 8)],\n    3: [(1, 8)]\n}\n\nstart_node = 5\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "98": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(2, 9), (12, 2), (4, 8), (8, 8)],\n    2: [(10, 4), (7, 1), (5, 10)],\n    12: [(4, 9), (11, 3), (1, 1)],\n    4: [(0, 6)],\n    8: [(2, 10), (4, 10)],\n    10: [(0, 2), (2, 5)],\n    5: [(11, 1), (8, 1)],\n    11: [(9, 2)],\n    1: [(4, 8), (9, 5), (2, 6)],\n    0: [(12, 2), (8, 1)],\n    6: [(4, 5)],\n    9: [(7, 10), (0, 2), (1, 7), (3, 9), (4, 5)],\n    3: [(8, 9), (0, 6), (11, 7)]\n}\n\nstart_node = 1\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "99": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Graph representation\ngraph = {\n    8: [(1, 10), (9, 7), (7, 10), (6, 4)],\n    1: [(8, 6)],\n    9: [(4, 3), (0, 5), (5, 2)],\n    7: [(2, 5), (8, 10), (0, 8), (3, 8)],\n    6: [(1, 4), (0, 6), (2, 8)],\n    4: [(5, 5), (3, 6), (7, 4), (6, 1), (1, 7)],\n    0: [(5, 6), (3, 3), (6, 6), (8, 5), (1, 7)],\n    5: [(2, 7), (1, 7), (9, 10), (4, 3), (0, 10)],\n    2: [(1, 6), (4, 8), (3, 5)],\n    3: [(9, 7), (5, 6)]\n}\n\n# Calculate the shortest path from node 3 to node 5\nshortest_path_length = dijkstra(graph, 3, 5)\nprint(shortest_path_length)\n```"}, "100": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(6, 2), (1, 2)],\n    6: [(2, 2), (5, 4)],\n    1: [(2, 2), (0, 7)],\n    5: [(6, 4), (0, 10), (7, 8)],\n    0: [(1, 7), (5, 10)],\n    7: [(5, 8), (3, 6)],\n    3: [(7, 6), (4, 6)],\n    4: [(3, 6)]\n}\n\nstart_node = 7\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "101": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(0, 6), (8, 4), (9, 4)],\n    0: [(5, 6), (4, 2), (7, 10)],\n    8: [(5, 4), (6, 3)],\n    9: [(5, 4), (2, 2), (3, 7)],\n    4: [(0, 2), (1, 7)],\n    7: [(0, 10)],\n    6: [(8, 3), (1, 6)],\n    2: [(9, 2)],\n    3: [(9, 7)],\n    1: [(4, 7), (6, 6)]\n}\n\nstart_node = 7\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "102": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(9, 8), (8, 5), (1, 8), (7, 10), (5, 4)],\n    9: [(6, 8), (1, 3), (0, 1), (2, 10), (10, 2), (5, 1), (4, 6)],\n    8: [(6, 5), (1, 8), (0, 4), (2, 6), (10, 6), (4, 10)],\n    1: [(6, 8), (9, 3), (8, 8), (7, 5), (3, 7), (0, 3), (2, 6), (10, 3), (5, 10), (4, 5)],\n    7: [(6, 10), (1, 5), (3, 9), (2, 9), (10, 5), (5, 6), (4, 9)],\n    5: [(6, 4), (9, 1), (1, 10), (7, 6), (3, 8), (0, 7), (10, 4), (4, 1)],\n    0: [(9, 1), (8, 4), (1, 3), (5, 7), (3, 6), (2, 9), (4, 4)],\n    2: [(9, 10), (8, 6), (1, 6), (7, 9), (0, 9), (3, 9), (4, 4)],\n    10: [(9, 2), (8, 6), (1, 3), (7, 5), (5, 4)],\n    4: [(9, 6), (8, 10), (1, 5), (7, 9), (5, 1), (0, 4), (2, 4)],\n    3: [(1, 7), (7, 9), (5, 8), (0, 6), (2, 9)]\n}\n\nprint(dijkstra(graph, 4, 9))\n```"}, "103": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(2, 5), (4, 6)],\n    2: [(4, 7), (9, 10), (0, 4)],\n    9: [(3, 4), (7, 4), (6, 9)],\n    3: [(0, 2), (5, 4), (4, 5)],\n    7: [(2, 3)],\n    5: [(2, 9), (8, 3), (7, 4)],\n    8: [(9, 1)],\n    1: [(2, 5), (3, 5)]\n}\n\nstart_node = 7\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "104": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    9: [(3, 9), (5, 4), (2, 3), (8, 3)],\n    3: [(9, 9), (1, 8)],\n    5: [(9, 4), (6, 5), (8, 10)],\n    2: [(9, 3)],\n    8: [(9, 3), (5, 10), (7, 10)],\n    1: [(3, 8), (0, 1)],\n    6: [(5, 5)],\n    7: [(8, 10)],\n    0: [(1, 1), (4, 2)],\n    4: [(0, 2)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this node\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor has been found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 3 to node 6\nshortest_path_length = dijkstra(graph, 3, 6)\nprint(shortest_path_length)\n```"}, "105": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(6, 3), (4, 7), (3, 2), (7, 4), (5, 4)],\n    6: [(2, 3), (4, 3), (3, 3), (7, 9), (1, 9), (0, 3), (5, 10)],\n    4: [(2, 7), (6, 3), (3, 7), (7, 9), (1, 4), (0, 8), (5, 4)],\n    3: [(2, 2), (6, 3), (4, 7), (1, 6), (0, 1), (5, 9)],\n    7: [(2, 4), (6, 9), (4, 9), (0, 10), (5, 6)],\n    5: [(2, 4), (6, 10), (4, 4), (3, 9), (7, 6), (0, 6)],\n    1: [(6, 9), (4, 4), (3, 6)],\n    0: [(6, 3), (4, 8), (3, 1), (7, 10), (5, 6)]\n}\n\nprint(dijkstra(graph, 6, 1))\n```"}, "106": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    4: [(7, 5), (6, 7)],\n    7: [(4, 5), (0, 10)],\n    6: [(4, 7), (8, 10), (1, 2)],\n    0: [(7, 10), (5, 2)],\n    8: [(6, 10), (5, 7), (3, 5)],\n    1: [(6, 2), (2, 2)],\n    5: [(0, 2), (8, 7)],\n    3: [(8, 5)],\n    2: [(1, 2)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 5 to node 8\nshortest_path_length = dijkstra(graph, 5, 8)\nprint(shortest_path_length)\n```"}, "107": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(3, 9), (0, 2), (10, 1), (9, 6), (5, 9)],\n    3: [(0, 8), (10, 8), (6, 3), (5, 4), (7, 2), (2, 10)],\n    0: [(9, 3), (11, 8), (4, 4), (2, 7), (3, 2)],\n    10: [(1, 7), (9, 4), (7, 8), (11, 7), (2, 10), (0, 5)],\n    9: [(5, 7), (0, 3), (10, 7), (8, 2)],\n    5: [(11, 3), (3, 7), (0, 2), (8, 6)],\n    6: [(9, 1), (5, 7), (2, 10), (3, 5), (0, 4)],\n    7: [(11, 4), (4, 5), (3, 4), (0, 2), (1, 8)],\n    2: [(3, 8), (0, 2), (10, 9), (11, 8), (4, 3)],\n    11: [(4, 7), (10, 3), (6, 8), (5, 3)],\n    1: [(8, 1), (6, 10), (3, 8)],\n    8: [(6, 3), (5, 6), (11, 7), (2, 10), (0, 5)]\n}\n\nstart_node = 1\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "108": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(11, 5)],\n    11: [(6, 3), (2, 10), (0, 2), (9, 8)],\n    6: [(0, 9), (7, 9)],\n    2: [(0, 1), (8, 4), (11, 9), (1, 7), (6, 6)],\n    0: [(11, 2), (7, 7), (4, 2)],\n    9: [(1, 2), (0, 4)],\n    8: [(11, 5), (7, 4), (4, 8), (2, 10)],\n    1: [(10, 5), (0, 9), (3, 3)],\n    7: [(1, 10), (10, 5), (2, 6), (8, 3)],\n    4: [(6, 7), (2, 10), (3, 8), (7, 7)],\n    3: [(1, 6), (8, 2)],\n    5: [(8, 7), (1, 9), (4, 4), (2, 6)]\n}\n\nstart_node = 2\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "109": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    11: [(5, 6), (3, 3), (10, 2), (2, 10)],\n    5: [(11, 6), (9, 8), (6, 9), (8, 5), (10, 3), (1, 3)],\n    3: [(11, 3), (6, 6), (2, 8)],\n    10: [(11, 2), (5, 3), (6, 8), (0, 6)],\n    2: [(11, 10), (3, 8), (1, 1), (8, 8), (4, 1)],\n    9: [(5, 8), (7, 7), (1, 10), (8, 4)],\n    6: [(5, 9), (3, 6), (10, 8), (7, 1), (0, 7)],\n    8: [(5, 5), (2, 8), (9, 4), (1, 5)],\n    1: [(5, 3), (2, 1), (9, 10), (8, 5), (7, 7), (4, 5)],\n    0: [(10, 6), (6, 7)],\n    4: [(2, 1), (1, 5)],\n    7: [(9, 7), (6, 1), (1, 7)]\n}\n\nprint(dijkstra(graph, 8, 1))\n```"}, "110": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(5, 3), (3, 4), (1, 2), (4, 3), (11, 5), (7, 8)],\n    5: [(2, 3), (1, 1), (6, 2), (0, 9), (7, 5)],\n    3: [(2, 4), (6, 9), (0, 10), (4, 3)],\n    1: [(2, 2), (5, 1), (11, 8)],\n    4: [(2, 3), (3, 3), (6, 8), (12, 8)],\n    11: [(2, 5), (1, 8), (6, 2), (9, 7), (8, 9), (7, 10)],\n    7: [(2, 8), (5, 5), (11, 10), (12, 8)],\n    6: [(5, 2), (3, 9), (4, 8), (11, 2), (10, 4), (9, 8)],\n    0: [(5, 9), (3, 10)],\n    12: [(4, 8), (7, 8), (10, 1), (8, 10)],\n    9: [(11, 7), (6, 8), (8, 6)],\n    8: [(11, 9), (10, 7), (9, 6), (12, 10)],\n    10: [(6, 4), (12, 1), (8, 7)]\n}\n\nprint(dijkstra(graph, 5, 9))\n```"}, "111": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    7: [(5, 3), (0, 7), (2, 10), (1, 3), (4, 4), (3, 1), (6, 10)],\n    5: [(7, 3)],\n    0: [(7, 7)],\n    2: [(7, 10)],\n    1: [(7, 3)],\n    4: [(7, 4)],\n    3: [(7, 1)],\n    6: [(7, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue\n    queue = [(0, start)]\n    # Distances dictionary\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    \n    return float('inf')\n\n# Calculate the shortest path from node 5 to node 2\nshortest_path_length = dijkstra(graph, 5, 2)\nprint(shortest_path_length)\n```"}, "112": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    8: [(3, 3), (2, 9), (9, 8), (4, 2), (0, 3), (7, 5)],\n    3: [(8, 3)],\n    2: [(8, 9)],\n    9: [(8, 8)],\n    4: [(8, 2)],\n    0: [(8, 3), (1, 4), (5, 6), (6, 2)],\n    7: [(8, 5)],\n    1: [(0, 4)],\n    5: [(0, 6)],\n    6: [(0, 2)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue for the minimum distance\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        # If the current node is the destination, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to the current node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to the neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    \n    return float('inf')\n\n# Calculate the shortest path from node 4 to node 2\nshortest_path_length = dijkstra(graph, 4, 2)\nprint(shortest_path_length)\n```"}, "113": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(9, 10), (4, 3), (5, 4)],\n    9: [(8, 5), (7, 4), (0, 7), (6, 6), (3, 7)],\n    4: [(8, 5), (7, 4), (3, 8)],\n    5: [(1, 8), (2, 3), (8, 5)],\n    8: [(5, 1), (3, 3)],\n    7: [(9, 2), (2, 1), (4, 3), (8, 7)],\n    0: [(5, 2), (9, 7), (4, 10), (7, 6)],\n    6: [(5, 3), (2, 8), (7, 4)],\n    1: [(4, 9), (0, 2), (3, 9), (9, 3)],\n    2: [(8, 10), (7, 7), (3, 4), (9, 7), (1, 3)]\n}\n\nstart_node = 2\nend_node = 0\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "114": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(7, 1), (2, 7), (4, 8), (0, 8), (1, 2)],\n    7: [(5, 1), (3, 2), (4, 9), (0, 10)],\n    2: [(5, 7), (3, 3), (4, 3), (0, 9), (1, 4)],\n    4: [(5, 8), (7, 9), (2, 3), (0, 4)],\n    0: [(5, 8), (7, 10), (2, 9), (4, 4), (3, 1), (6, 4)],\n    1: [(5, 2), (2, 4), (3, 1), (6, 6)],\n    3: [(7, 2), (2, 3), (0, 1), (1, 1)],\n    6: [(0, 4), (1, 6)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 7)\nprint(shortest_path_length)\n```"}, "115": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    11: [(8, 8), (12, 8), (9, 7), (4, 6), (10, 1), (1, 9), (0, 8), (2, 2)],\n    8: [(11, 8), (6, 9), (10, 6)],\n    12: [(11, 8), (10, 6)],\n    9: [(11, 7), (5, 2)],\n    4: [(11, 6), (10, 5), (5, 7)],\n    10: [(11, 1), (8, 6), (12, 6), (4, 5), (6, 8), (3, 7), (7, 7), (1, 9), (0, 10), (5, 7)],\n    1: [(11, 9), (10, 9)],\n    0: [(11, 8), (10, 10)],\n    2: [(11, 2), (6, 3)],\n    6: [(8, 9), (10, 8), (2, 3), (7, 3)],\n    5: [(9, 2), (4, 7), (10, 7)],\n    3: [(10, 7)],\n    7: [(10, 7), (6, 3)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this node\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to the neighbor has been found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 8 to node 4\nshortest_path_length = dijkstra(graph, 8, 4)\nprint(shortest_path_length)\n```"}, "116": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 10), (7, 4)],\n    1: [(4, 2), (3, 9), (5, 10), (6, 10), (2, 8)],\n    2: [(1, 8), (6, 1), (0, 10)],\n    3: [(1, 9), (4, 6)],\n    4: [(1, 2), (7, 4), (3, 6), (6, 4)],\n    5: [(1, 10)],\n    6: [(1, 10), (4, 4), (2, 1), (7, 8)],\n    7: [(4, 4), (6, 8), (0, 4)]\n}\n\nstart_node = 3\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "117": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    11: [(3, 6), (12, 8), (4, 5)],\n    3: [(11, 6), (14, 5), (6, 7), (2, 6), (7, 1)],\n    12: [(11, 8), (4, 2), (5, 1), (8, 9)],\n    4: [(11, 5), (12, 2), (10, 9), (14, 6), (13, 8)],\n    14: [(3, 5), (4, 6), (10, 7), (8, 9), (5, 8), (9, 7), (13, 5), (6, 9)],\n    6: [(3, 7), (14, 9), (0, 7), (1, 7)],\n    2: [(3, 6), (10, 5)],\n    7: [(3, 1), (0, 5), (1, 10), (13, 6)],\n    5: [(12, 1), (14, 8)],\n    8: [(12, 9), (14, 9)],\n    10: [(4, 9), (14, 7), (2, 5)],\n    13: [(4, 8), (14, 5), (7, 6), (9, 6)],\n    9: [(14, 7), (13, 6)],\n    0: [(6, 7), (7, 5)],\n    1: [(6, 7), (7, 10)]\n}\n\nprint(dijkstra(graph, 10, 0))\n```"}, "118": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(9, 5), (14, 7), (13, 1), (2, 3), (7, 8), (5, 7)],\n    9: [(4, 5)],\n    14: [(4, 7)],\n    13: [(4, 1)],\n    2: [(4, 3), (11, 10)],\n    7: [(4, 8)],\n    5: [(4, 7), (3, 7), (8, 6), (1, 1)],\n    11: [(2, 10), (12, 8)],\n    3: [(5, 7), (6, 6), (10, 5)],\n    8: [(5, 6)],\n    1: [(5, 1), (0, 2)],\n    12: [(11, 8)],\n    6: [(3, 6)],\n    10: [(3, 5)],\n    0: [(1, 2)]\n}\n\nprint(dijkstra(graph, 9, 12))\n```"}, "119": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(10, 4), (14, 3), (6, 7), (12, 8), (4, 8), (7, 4), (13, 9), (11, 7)],\n    10: [(1, 4), (13, 10)],\n    14: [(1, 3), (5, 7), (13, 1)],\n    6: [(1, 7), (11, 4), (3, 3)],\n    12: [(1, 8), (11, 10)],\n    4: [(1, 8), (13, 6)],\n    7: [(1, 4), (3, 1)],\n    13: [(1, 9), (10, 10), (14, 1), (4, 6), (2, 2), (3, 6)],\n    11: [(1, 7), (6, 4), (12, 10), (5, 4), (8, 8)],\n    5: [(14, 7), (11, 4)],\n    3: [(6, 3), (7, 1), (13, 6), (8, 1), (2, 1), (9, 1), (0, 5)],\n    2: [(13, 2), (3, 1), (9, 4), (0, 4)],\n    8: [(11, 8), (3, 1)],\n    9: [(3, 1), (2, 4)],\n    0: [(3, 5), (2, 4)]\n}\n\nstart_node = 3\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "120": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(5, 9), (0, 6), (4, 2), (9, 5), (1, 10), (2, 6), (6, 1)],\n    5: [(7, 9), (0, 4), (4, 4), (1, 10), (6, 2)],\n    0: [(7, 6), (5, 4), (4, 9), (9, 8), (1, 7), (2, 5)],\n    4: [(7, 2), (5, 4), (0, 9), (8, 7), (9, 1), (1, 4), (3, 3), (6, 6)],\n    9: [(7, 5), (0, 8), (4, 1), (8, 8), (1, 3), (2, 8), (3, 1), (6, 3)],\n    1: [(7, 10), (5, 10), (0, 7), (4, 4), (9, 3), (2, 4)],\n    2: [(7, 6), (0, 5), (9, 8), (1, 4), (8, 6), (3, 1)],\n    6: [(7, 1), (5, 2), (4, 6), (9, 3), (8, 10), (3, 9)],\n    8: [(4, 7), (9, 8), (2, 6), (6, 10)],\n    3: [(4, 3), (9, 1), (2, 1), (6, 9)]\n}\n\nresult = dijkstra(graph, 9, 3)\nprint(result)\n```"}, "121": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(4, 6), (13, 9), (8, 1), (9, 1)],\n    4: [(5, 6)],\n    13: [(5, 9)],\n    8: [(5, 1), (12, 8)],\n    9: [(5, 1), (0, 7), (2, 5), (3, 1), (1, 4), (7, 9)],\n    12: [(8, 8)],\n    0: [(9, 7)],\n    2: [(9, 5)],\n    3: [(9, 1)],\n    1: [(9, 4), (6, 1)],\n    7: [(9, 9), (11, 8), (14, 4), (10, 6)],\n    6: [(1, 1)],\n    11: [(7, 8)],\n    14: [(7, 4)],\n    10: [(7, 6)]\n}\n\nstart_node = 11\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "122": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(3, 6), (7, 6), (4, 6), (5, 4), (6, 2), (10, 4), (1, 5)],\n    3: [(9, 6), (7, 10), (2, 9), (4, 7), (5, 10), (6, 2), (10, 8), (0, 5), (8, 8)],\n    7: [(9, 6), (3, 10), (2, 3), (4, 2), (5, 3), (6, 1), (10, 9), (0, 5)],\n    4: [(9, 6), (3, 7), (7, 2), (2, 5), (5, 8), (6, 6), (10, 4), (0, 9), (1, 7)],\n    5: [(9, 4), (3, 10), (7, 3), (4, 8), (2, 9), (6, 2), (10, 6), (0, 7), (8, 8), (1, 10)],\n    6: [(9, 2), (3, 2), (7, 1), (4, 6), (5, 2), (2, 4), (0, 8), (8, 5), (1, 8)],\n    10: [(9, 4), (3, 8), (7, 9), (4, 4), (5, 6), (2, 5), (0, 8), (8, 3), (1, 8)],\n    1: [(9, 5), (4, 7), (5, 10), (6, 8), (10, 8), (0, 10), (8, 7)],\n    2: [(3, 9), (7, 3), (4, 5), (5, 9), (6, 4), (10, 5), (8, 5)],\n    0: [(3, 5), (7, 5), (4, 9), (5, 7), (6, 8), (10, 8), (1, 10), (8, 1)],\n    8: [(3, 8), (5, 8), (6, 5), (10, 3), (1, 7), (2, 5), (0, 1)]\n}\n\nprint(dijkstra(graph, 2, 9))\n```"}, "123": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    13: [(4, 10), (7, 6), (3, 1), (0, 6), (2, 2), (10, 7), (8, 10), (6, 6), (5, 1), (9, 7), (1, 9), (11, 9)],\n    4: [(13, 10), (7, 5), (3, 8), (0, 10), (8, 9), (12, 9), (6, 3), (5, 2), (9, 2)],\n    7: [(13, 6), (4, 5), (14, 9), (10, 8), (12, 9), (6, 3), (5, 7), (9, 8), (1, 9), (11, 9)],\n    3: [(13, 1), (4, 8), (0, 7), (14, 6), (2, 5), (10, 3), (8, 3), (12, 2), (6, 2), (5, 9), (1, 10)],\n    0: [(13, 6), (4, 10), (3, 7), (14, 4), (2, 3), (10, 3), (12, 5), (6, 5), (5, 10), (9, 5), (1, 1), (11, 3)],\n    2: [(13, 2), (3, 5), (0, 3), (14, 5), (12, 9), (6, 1), (5, 5), (9, 6)],\n    10: [(13, 7), (7, 8), (3, 3), (0, 3), (14, 3), (8, 9), (6, 2), (5, 5), (1, 10)],\n    8: [(13, 10), (4, 9), (3, 3), (10, 9), (14, 4), (12, 1), (6, 1), (5, 10), (9, 2), (1, 4)],\n    6: [(13, 6), (4, 3), (7, 3), (3, 2), (0, 5), (2, 1), (10, 2), (8, 1), (14, 2), (12, 5), (5, 7), (11, 8)],\n    5: [(13, 1), (4, 2), (7, 7), (3, 9), (0, 10), (2, 5), (10, 5), (8, 10), (6, 7), (14, 5), (12, 8), (9, 7), (11, 2)],\n    9: [(13, 7), (4, 2), (7, 8), (0, 5), (2, 6), (8, 2), (5, 7), (1, 6), (11, 5)],\n    1: [(13, 9), (7, 9), (3, 10), (0, 1), (10, 10), (8, 4), (9, 6), (12, 4), (11, 7)],\n    11: [(13, 9), (7, 9), (0, 3), (6, 8), (5, 2), (9, 5), (1, 7), (14, 3)],\n    12: [(4, 9), (7, 9), (3, 2), (0, 5), (2, 9), (8, 1), (6, 5), (5, 8), (1, 4), (14, 6)],\n    14: [(7, 9), (3, 6), (0, 4), (2, 5), (10, 3), (8, 4), (6, 2), (5, 5), (11, 3), (12, 6)]\n}\n\nprint(dijkstra(graph, 13, 6))\n```"}, "124": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(8, 5), (6, 4)],\n    8: [(3, 5), (5, 3), (7, 5), (4, 7)],\n    6: [(3, 4)],\n    5: [(8, 3)],\n    7: [(8, 5), (4, 7)],\n    4: [(8, 7), (7, 7), (0, 5)],\n    0: [(4, 5), (1, 8), (2, 8)],\n    1: [(0, 8)],\n    2: [(0, 8)]\n}\n\nstart_node = 6\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "125": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    10: [(13, 4), (14, 2)],\n    13: [(10, 4)],\n    14: [(10, 2), (6, 8), (8, 10), (9, 1), (3, 3)],\n    6: [(14, 8), (2, 3)],\n    8: [(14, 10)],\n    9: [(14, 1), (7, 3)],\n    3: [(14, 3), (1, 6), (12, 8)],\n    2: [(6, 3)],\n    7: [(9, 3)],\n    1: [(3, 6), (11, 5), (5, 3)],\n    12: [(3, 8)],\n    11: [(1, 5), (4, 10), (0, 8)],\n    5: [(1, 3)],\n    4: [(11, 10)],\n    0: [(11, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 3 to node 4\nshortest_path_length = dijkstra(graph, 3, 4)\nprint(shortest_path_length)\n```"}, "126": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(4, 3), (5, 5)],\n    4: [(7, 3), (6, 7), (1, 9)],\n    5: [(7, 5), (3, 1)],\n    6: [(4, 7), (3, 2), (8, 2)],\n    1: [(4, 9), (2, 2)],\n    3: [(5, 1), (6, 2)],\n    8: [(6, 2)],\n    2: [(1, 2), (0, 7)],\n    0: [(2, 7)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 4)\nprint(shortest_path_length)\n```"}, "127": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(11, 1), (10, 7), (9, 3), (1, 7), (5, 7), (4, 10), (8, 9)],\n    11: [(6, 1), (10, 10), (5, 7), (0, 4), (2, 4), (8, 2)],\n    10: [(6, 7), (11, 10), (7, 7), (1, 5), (0, 4), (3, 9), (8, 7)],\n    9: [(6, 3), (1, 7)],\n    1: [(6, 7), (10, 5), (9, 7), (8, 2)],\n    5: [(6, 7), (11, 7), (7, 9), (4, 1), (2, 3), (8, 3)],\n    4: [(6, 10), (5, 1), (7, 3), (3, 9), (8, 8)],\n    8: [(6, 9), (11, 2), (10, 7), (1, 2), (5, 3), (4, 8), (2, 10)],\n    0: [(11, 4), (10, 4)],\n    2: [(11, 4), (5, 3), (8, 10), (7, 4), (3, 8)],\n    7: [(10, 7), (5, 9), (4, 3), (3, 4), (2, 4)],\n    3: [(10, 9), (4, 9), (7, 4), (2, 8)]\n}\n\nprint(dijkstra(graph, 1, 4))\n```"}, "128": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    7: [(13, 9), (6, 3)],\n    13: [(7, 9), (2, 7), (12, 2)],\n    6: [(7, 3), (11, 2), (5, 1)],\n    2: [(13, 7), (5, 6)],\n    12: [(13, 2)],\n    11: [(6, 2), (8, 7)],\n    5: [(6, 1), (2, 6)],\n    8: [(11, 7), (9, 3)],\n    9: [(8, 3), (1, 2)],\n    4: [(1, 9)],\n    1: [(4, 9), (9, 2), (3, 10)],\n    3: [(1, 10), (10, 3)],\n    10: [(3, 3), (0, 10)],\n    0: [(10, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 11 to node 4\nshortest_path_length = dijkstra(graph, 11, 4)\nprint(shortest_path_length)\n```"}, "129": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(6, 1), (7, 6)],\n    6: [(3, 1), (1, 8), (5, 4), (0, 1)],\n    7: [(3, 6), (8, 6), (0, 6), (9, 2)],\n    1: [(6, 8)],\n    5: [(6, 4)],\n    0: [(6, 1), (7, 6)],\n    8: [(7, 6), (4, 4)],\n    9: [(7, 2)],\n    4: [(8, 4), (2, 8)],\n    2: [(4, 8)]\n}\n\nstart_node = 7\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "130": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_node == end:\n            return current_distance\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return float('inf')\n\ngraph = {\n    6: [(2, 3), (4, 10), (3, 1), (1, 1)],\n    2: [(4, 4), (9, 3), (0, 1), (7, 1)],\n    3: [(5, 10), (0, 4)],\n    1: [(5, 10)],\n    9: [(4, 10)],\n    0: [(4, 10)],\n    7: [(2, 9), (8, 2), (9, 8)],\n    5: [(2, 5), (8, 6)],\n    8: [(1, 2), (5, 8), (9, 5), (2, 1)]\n}\n\nstart_node = 5\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "131": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    6: [(5, 5), (2, 1), (0, 6)],\n    5: [(6, 5), (4, 3)],\n    2: [(6, 1), (1, 2)],\n    0: [(6, 6)],\n    4: [(5, 3), (3, 10)],\n    1: [(2, 2), (7, 2)],\n    3: [(4, 10), (7, 7)],\n    7: [(1, 2), (3, 7), (8, 8)],\n    8: [(7, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 8 to node 3\nshortest_path_length = dijkstra(graph, 8, 3)\nprint(shortest_path_length)\n```"}, "132": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(3, 4), (10, 2)],\n    3: [(13, 8)],\n    10: [(1, 4), (14, 7)],\n    13: [(3, 1), (5, 7), (7, 3), (14, 1), (11, 7)],\n    1: [(2, 5), (13, 7), (8, 2), (3, 5)],\n    14: [(11, 5)],\n    0: [(13, 8), (9, 10), (8, 2)],\n    9: [(4, 10), (5, 1), (7, 10), (6, 4), (2, 2)],\n    5: [(3, 2)],\n    11: [(3, 3), (1, 2), (6, 2), (12, 1)],\n    4: [(13, 10)],\n    6: [(14, 5), (13, 9), (9, 2), (10, 8), (8, 10)],\n    12: [(8, 6)]\n}\n\nstart_node = 11\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "133": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 2), (4, 9), (3, 9), (11, 8), (9, 4)],\n    10: [(0, 2), (1, 8), (4, 3)],\n    4: [(0, 9), (10, 3), (1, 10), (9, 5), (6, 6), (7, 10), (2, 5), (5, 8), (11, 10)],\n    3: [(0, 9), (1, 7), (9, 10), (2, 8), (6, 8)],\n    11: [(0, 8), (4, 10), (8, 4)],\n    9: [(0, 4), (4, 5), (3, 10), (8, 6), (6, 6)],\n    1: [(10, 8), (4, 10), (3, 7), (6, 7)],\n    6: [(4, 6), (3, 8), (9, 6), (1, 7), (8, 2), (2, 10), (5, 8)],\n    7: [(4, 10)],\n    2: [(4, 5), (3, 8), (6, 10), (8, 5), (5, 4)],\n    5: [(4, 8), (6, 8), (2, 4)],\n    8: [(11, 4), (9, 6), (6, 2), (2, 5)]\n}\n\nstart_node = 4\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "134": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(3, 5), (0, 10), (7, 7), (2, 6), (10, 4), (1, 8)],\n    3: [(5, 5), (10, 7), (6, 4)],\n    0: [(5, 10), (7, 8), (9, 10)],\n    7: [(5, 7), (0, 8), (2, 10), (8, 1), (4, 6)],\n    2: [(5, 6), (7, 10), (9, 1)],\n    10: [(5, 4), (3, 7), (6, 9)],\n    1: [(5, 8), (8, 4)],\n    6: [(3, 4), (10, 9), (8, 10), (4, 7)],\n    9: [(0, 10), (2, 1)],\n    8: [(7, 1), (1, 4), (6, 10)],\n    4: [(7, 6), (6, 7)]\n}\n\nprint(dijkstra(graph, 3, 7))\n```"}, "135": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(7, 8), (1, 6), (0, 3)],\n    7: [(5, 8), (0, 5), (6, 9)],\n    1: [(5, 6)],\n    0: [(5, 3), (7, 5)],\n    6: [(7, 9), (4, 8)],\n    4: [(6, 8), (3, 8)],\n    3: [(4, 8), (2, 2)],\n    2: [(3, 2)]\n}\n\nprint(dijkstra(graph, 7, 2))\n```"}, "136": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(1, 7), (12, 2), (2, 6), (7, 9), (3, 7)],\n    1: [(12, 1), (2, 2), (11, 6), (9, 6)],\n    12: [(6, 9), (3, 3), (8, 1)],\n    2: [(5, 6), (4, 5), (9, 9), (12, 4), (10, 1), (6, 5)],\n    7: [(8, 8), (11, 3), (6, 8)],\n    3: [(8, 2), (9, 1), (0, 3), (1, 3), (10, 8), (6, 10), (5, 3), (7, 6)],\n    11: [(4, 2), (0, 3), (10, 4), (3, 5), (8, 8)],\n    6: [(2, 8), (5, 1), (8, 8), (11, 6), (4, 2), (1, 10), (12, 3)],\n    8: [(11, 10), (10, 10), (7, 6), (3, 7)],\n    5: [(8, 3), (4, 6), (0, 3), (2, 3)],\n    4: [(0, 10), (6, 6), (3, 7), (8, 4)],\n    10: [(7, 2), (8, 1), (12, 10)],\n    0: [(1, 7), (2, 5), (5, 5), (3, 8), (4, 5), (9, 4)]\n}\n\nstart_node = 7\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "137": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (4, 3)],\n    4: [(3, 6), (1, 10)],\n    3: [(0, 10), (7, 8), (4, 9)],\n    7: [(2, 2), (4, 10)],\n    2: [(4, 2)],\n    5: [(2, 4), (6, 1), (3, 1)],\n    6: [(3, 10), (1, 1), (4, 10)]\n}\n\nstart_node = 4\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "138": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(2, 9), (10, 1), (7, 7), (8, 3), (0, 3), (3, 5), (4, 7), (13, 7), (12, 10), (6, 4)],\n    2: [(1, 9), (10, 4), (7, 8), (8, 2), (9, 3), (11, 1), (5, 4), (12, 6), (6, 5)],\n    10: [(1, 1), (2, 4), (8, 10), (0, 9), (3, 9), (4, 6), (13, 10), (9, 2), (11, 7), (5, 7), (12, 9), (6, 6)],\n    7: [(1, 7), (2, 8), (8, 10), (0, 5), (4, 1), (13, 9), (9, 6), (11, 6), (5, 2), (12, 5), (6, 4)],\n    8: [(1, 3), (2, 2), (10, 10), (7, 10), (3, 7), (4, 9), (9, 8), (11, 5), (5, 9), (12, 5), (6, 5)],\n    0: [(1, 3), (10, 9), (7, 5), (3, 7), (4, 7), (13, 8), (9, 1), (11, 4)],\n    3: [(1, 5), (10, 9), (8, 7), (0, 7), (4, 9), (13, 1), (9, 7), (11, 8), (5, 10), (12, 3), (6, 6)],\n    4: [(1, 7), (10, 6), (7, 1), (8, 9), (0, 7), (3, 9), (13, 5), (9, 6), (11, 1), (5, 7)],\n    13: [(1, 7), (10, 10), (7, 9), (0, 8), (3, 1), (4, 5), (9, 3), (11, 1), (5, 4), (12, 3), (6, 7)],\n    12: [(1, 10), (2, 6), (10, 9), (7, 5), (8, 5), (3, 3), (13, 3), (9, 1), (5, 3), (6, 6)],\n    6: [(1, 4), (2, 5), (10, 6), (7, 4), (8, 5), (3, 6), (13, 7), (12, 6), (11, 3), (5, 9)],\n    9: [(2, 3), (10, 2), (7, 6), (8, 8), (0, 1), (3, 7), (4, 6), (13, 3), (12, 1), (11, 5), (5, 10)],\n    11: [(2, 1), (10, 7), (7, 6), (8, 5), (0, 4), (3, 8), (4, 1), (13, 1), (6, 3), (9, 5), (5, 8)],\n    5: [(2, 4), (10, 7), (7, 2), (8, 9), (3, 10), (4, 7), (13, 4), (12, 3), (6, 9), (9, 10), (11, 8)]\n}\n\nprint(dijkstra(graph, 12, 9))\n```"}, "139": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(0, 8), (5, 10), (7, 8), (8, 7)],\n    0: [(12, 1), (4, 1), (10, 8), (3, 7)],\n    5: [(3, 1)],\n    7: [(10, 9), (1, 9), (0, 4), (12, 4), (5, 7)],\n    8: [(10, 10), (1, 9), (0, 7), (6, 1), (11, 2)],\n    12: [(5, 2), (11, 7), (0, 5), (2, 4)],\n    4: [(8, 8), (10, 4), (12, 1)],\n    3: [(0, 4), (6, 8), (11, 3)],\n    1: [(6, 1), (3, 5)],\n    6: [(9, 7)],\n    11: [(8, 5), (10, 1), (1, 10), (6, 5)],\n    9: [(8, 3)],\n    2: [(12, 9), (5, 10), (9, 4)]\n}\n\nstart_node = 7\nend_node = 12\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "140": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    13: [(6, 7)],\n    6: [(13, 7), (1, 6)],\n    1: [(6, 6), (2, 10), (10, 2)],\n    2: [(1, 10), (12, 4), (5, 6)],\n    10: [(1, 2)],\n    9: [(8, 10), (7, 9)],\n    8: [(9, 10), (11, 10)],\n    7: [(9, 9), (0, 10)],\n    11: [(8, 10), (12, 4), (0, 7)],\n    0: [(7, 10), (11, 7), (3, 5)],\n    12: [(11, 4), (2, 4)],\n    3: [(0, 5)],\n    5: [(2, 6), (4, 7)],\n    4: [(5, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 9 to node 2\nshortest_path_length = dijkstra(graph, 9, 2)\nprint(shortest_path_length)\n```"}, "141": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(10, 8), (2, 7), (0, 7), (1, 4)],\n    10: [(7, 8), (3, 3), (2, 1), (0, 3), (6, 7)],\n    2: [(7, 7), (10, 1), (13, 9)],\n    0: [(7, 7), (10, 3), (3, 2), (6, 8), (8, 9)],\n    1: [(7, 4), (5, 6), (6, 5), (4, 5), (9, 3), (13, 8)],\n    3: [(10, 3), (0, 2), (11, 6), (9, 9), (14, 2)],\n    6: [(10, 7), (0, 8), (1, 5)],\n    13: [(2, 9), (1, 8), (4, 7), (11, 7)],\n    8: [(0, 9), (14, 8), (9, 2), (11, 4)],\n    5: [(1, 6), (14, 3), (4, 8)],\n    4: [(1, 5), (5, 8), (13, 7), (12, 1)],\n    9: [(1, 3), (3, 9), (14, 10), (8, 2)],\n    11: [(3, 6), (13, 7), (8, 4)],\n    14: [(3, 2), (5, 3), (9, 10), (12, 6), (8, 8)],\n    12: [(14, 6), (4, 1)]\n}\n\nprint(dijkstra(graph, 2, 13))\n```"}, "142": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(2, 10), (9, 3), (8, 3), (5, 1)],\n    2: [(6, 10)],\n    9: [(6, 3), (0, 10)],\n    8: [(6, 3), (3, 2)],\n    5: [(6, 1)],\n    0: [(9, 10), (7, 10), (4, 2)],\n    3: [(8, 2), (1, 2)],\n    1: [(3, 2)],\n    7: [(0, 10), (4, 1)],\n    4: [(0, 2), (7, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 2)\nprint(shortest_path_length)\n```"}, "143": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    3: [(8, 3), (7, 8), (2, 7)],\n    8: [(3, 3), (6, 2)],\n    7: [(3, 8)],\n    2: [(3, 7), (0, 5)],\n    6: [(8, 2), (5, 10)],\n    0: [(2, 5)],\n    5: [(6, 10), (4, 6), (1, 2)],\n    4: [(5, 6), (1, 6)],\n    1: [(5, 2), (4, 6)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')  # If the end node is not reachable\n\n# Calculate the shortest path from node 8 to node 5\nshortest_path_length = dijkstra(graph, 8, 5)\nprint(shortest_path_length)\n```"}, "144": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    12: [(2, 4), (3, 1)],\n    2: [(12, 4), (6, 2)],\n    3: [(12, 1)],\n    6: [(2, 2), (7, 3), (9, 9)],\n    7: [(6, 3), (11, 5)],\n    9: [(6, 9), (10, 8), (1, 1)],\n    11: [(7, 5), (1, 4)],\n    1: [(11, 4), (9, 1)],\n    10: [(9, 8), (8, 4)],\n    8: [(10, 4), (5, 7)],\n    5: [(8, 7), (4, 9)],\n    4: [(5, 9), (0, 7)],\n    0: [(4, 7)]\n}\n\nresult = dijkstra(graph, 2, 6)\nprint(result)\n```"}, "145": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(8, 4), (0, 1), (12, 1)],\n    8: [(2, 4), (6, 4), (5, 6), (13, 1)],\n    0: [(2, 1), (7, 8), (12, 5), (5, 3), (14, 3)],\n    12: [(2, 1), (0, 5), (7, 6), (14, 7)],\n    6: [(8, 4), (9, 9), (7, 4), (1, 5), (3, 3)],\n    5: [(8, 6), (0, 3), (13, 4), (14, 6)],\n    13: [(8, 1), (5, 4), (9, 7), (14, 2)],\n    7: [(0, 8), (12, 6), (6, 4), (1, 5)],\n    14: [(0, 3), (12, 7), (5, 6), (13, 2), (10, 10)],\n    9: [(6, 9), (13, 7), (10, 9), (11, 4)],\n    1: [(6, 5), (7, 5), (3, 5), (4, 10)],\n    3: [(6, 3), (11, 8), (1, 5), (4, 4)],\n    10: [(9, 9), (11, 7), (14, 10)],\n    11: [(10, 7), (9, 4), (4, 8), (3, 8)],\n    4: [(11, 8), (1, 10), (3, 4)]\n}\n\nstart_node = 7\nend_node = 13\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "146": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 4), (7, 6), (4, 5), (1, 7)],\n    2: [(0, 4), (7, 9), (5, 5)],\n    7: [(0, 6), (2, 9), (4, 9), (8, 9), (5, 9)],\n    4: [(0, 5), (7, 9), (3, 5), (8, 1), (5, 2), (6, 9)],\n    1: [(0, 7), (3, 7), (8, 1)],\n    5: [(2, 5), (7, 9), (4, 2), (3, 1)],\n    8: [(7, 9), (4, 1), (1, 1), (3, 3)],\n    3: [(4, 5), (1, 7), (5, 1), (8, 3), (6, 2)],\n    6: [(4, 9), (3, 2)]\n}\n\nstart_node = 6\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "147": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(2, 1), (1, 9)],\n    2: [(8, 1), (9, 9), (4, 9)],\n    1: [(8, 9), (9, 6)],\n    9: [(2, 9), (1, 6), (5, 8)],\n    4: [(2, 9), (10, 8)],\n    5: [(9, 8), (6, 4)],\n    10: [(4, 8), (0, 8)],\n    6: [(5, 4), (7, 5), (3, 9)],\n    7: [(6, 5)],\n    3: [(6, 9)],\n    0: [(10, 8)]\n}\n\nprint(dijkstra(graph, 1, 0))\n```"}, "148": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    12: [(2, 2), (5, 5), (13, 10)],\n    2: [(12, 2), (11, 7), (6, 8), (7, 10), (14, 3), (4, 8)],\n    5: [(12, 5)],\n    13: [(12, 10), (8, 5), (1, 8)],\n    11: [(2, 7)],\n    6: [(2, 8)],\n    7: [(2, 10)],\n    14: [(2, 3), (9, 1)],\n    4: [(2, 8)],\n    8: [(13, 5), (3, 4), (10, 2), (0, 4)],\n    1: [(13, 8)],\n    9: [(14, 1)],\n    3: [(8, 4)],\n    10: [(8, 2)],\n    0: [(8, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 12 to node 6\nshortest_path_length = dijkstra(graph, 12, 6)\nprint(shortest_path_length)\n```"}, "149": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    3: [(5, 4), (0, 7)],\n    5: [(3, 4), (7, 5)],\n    0: [(3, 7), (7, 2)],\n    7: [(5, 5), (0, 2), (4, 10)],\n    4: [(7, 10), (1, 3)],\n    1: [(4, 3), (6, 8)],\n    6: [(1, 8), (2, 7)],\n    2: [(6, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate shortest path from node 4 to node 6\nshortest_path_length = dijkstra(graph, 4, 6)\nprint(shortest_path_length)\n```"}, "150": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(9, 3), (0, 6), (12, 6), (5, 8), (6, 7), (1, 3)],\n    9: [(10, 3), (4, 3), (5, 7), (6, 9)],\n    0: [(10, 6), (13, 2), (7, 2), (6, 4), (2, 1), (1, 2)],\n    12: [(10, 6)],\n    5: [(10, 8), (9, 7), (4, 6), (13, 4), (6, 2)],\n    6: [(10, 7), (9, 9), (0, 4), (5, 2)],\n    1: [(10, 3), (0, 2), (8, 2), (13, 6)],\n    4: [(9, 3), (5, 6), (8, 9), (3, 7), (7, 9)],\n    13: [(0, 2), (5, 4), (1, 6), (8, 4), (2, 5)],\n    7: [(0, 2), (4, 9)],\n    2: [(0, 1), (8, 2), (11, 8), (13, 5)],\n    8: [(1, 2), (4, 9), (13, 4), (2, 2)],\n    3: [(4, 7), (11, 4)],\n    11: [(3, 4), (2, 8)]\n}\n\nprint(dijkstra(graph, 3, 10))\n```"}, "151": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(2, 4), (3, 8), (0, 7), (5, 9), (6, 5)],\n    2: [(8, 4), (4, 2), (6, 8)],\n    3: [(8, 8), (5, 4), (9, 1), (6, 8)],\n    0: [(8, 7), (9, 9), (7, 9)],\n    5: [(8, 9), (3, 4)],\n    6: [(8, 5), (2, 8), (3, 8), (9, 4)],\n    4: [(2, 2), (1, 3), (9, 4), (7, 10)],\n    9: [(3, 1), (0, 9), (6, 4), (4, 4)],\n    7: [(0, 9), (4, 10)],\n    1: [(4, 3)]\n}\n\nprint(dijkstra(graph, 6, 1))\n```"}, "152": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(2, 6), (5, 5)],\n    2: [(7, 6), (3, 4)],\n    5: [(7, 5), (3, 5), (1, 8), (0, 2)],\n    3: [(2, 4), (5, 5)],\n    1: [(5, 8), (6, 2)],\n    0: [(5, 2), (8, 3)],\n    4: [(8, 6)],\n    8: [(4, 6), (0, 3)],\n    6: [(1, 2)]\n}\n\nstart_node = 4\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "153": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 7), (6, 4), (2, 4)],\n    7: [(5, 2), (0, 3)],\n    6: [(5, 6), (2, 9)],\n    2: [(7, 1), (1, 4), (3, 2), (5, 8)],\n    5: [(0, 3), (1, 7), (3, 2)],\n    1: [(6, 5), (0, 7)],\n    3: [(6, 4), (2, 1), (7, 8), (1, 5), (4, 7)],\n    4: [(6, 7), (5, 1), (0, 6), (1, 2)]\n}\n\nstart_node = 1\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "154": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    5: [(3, 10)],\n    3: [(5, 10), (0, 5)],\n    0: [(3, 5), (8, 4)],\n    8: [(0, 4), (7, 8), (10, 5)],\n    4: [(9, 1)],\n    9: [(4, 1), (1, 4), (6, 3)],\n    1: [(9, 4), (2, 6)],\n    6: [(9, 3)],\n    2: [(1, 6), (10, 4)],\n    7: [(8, 8), (10, 6)],\n    10: [(8, 5), (7, 6), (2, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 3 to node 2\nshortest_path_length = dijkstra(graph, 3, 2)\nprint(shortest_path_length)\n```"}, "155": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(3, 6), (5, 10), (0, 7), (6, 7), (4, 9)],\n    3: [(8, 6), (4, 9), (13, 5)],\n    5: [(8, 10), (11, 2), (13, 10)],\n    0: [(8, 7), (12, 6), (13, 6), (10, 9), (2, 5)],\n    6: [(8, 7), (12, 10), (13, 4), (4, 3), (7, 3), (2, 7)],\n    4: [(8, 9), (3, 9), (6, 3), (13, 9), (11, 2)],\n    13: [(3, 5), (5, 10), (0, 6), (6, 4), (4, 9), (12, 6), (9, 1), (10, 9), (1, 2), (11, 10), (7, 4)],\n    11: [(5, 2), (4, 2), (13, 10), (7, 8), (2, 1)],\n    12: [(0, 6), (6, 10), (13, 6), (9, 3), (10, 1), (1, 5)],\n    10: [(0, 9), (13, 9), (12, 1)],\n    2: [(0, 5), (6, 7), (11, 1), (9, 6)],\n    7: [(6, 3), (13, 4), (11, 8), (1, 1)],\n    9: [(13, 1), (12, 3), (2, 6)],\n    1: [(13, 2), (12, 5), (7, 1)]\n}\n\nstart_node = 10\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "156": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(8, 1), (12, 4), (11, 4), (9, 6), (10, 2)],\n    8: [(3, 1), (7, 3), (2, 2)],\n    12: [(3, 4)],\n    11: [(3, 4), (1, 10)],\n    9: [(3, 6), (4, 10), (13, 2)],\n    10: [(3, 2)],\n    7: [(8, 3), (5, 9), (0, 6)],\n    2: [(8, 2)],\n    1: [(11, 10)],\n    4: [(9, 10)],\n    13: [(9, 2)],\n    5: [(7, 9)],\n    0: [(7, 6), (6, 1)],\n    6: [(0, 1)]\n}\n\nstart_node = 11\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "157": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 6), (12, 7), (1, 10), (14, 1), (13, 7), (8, 7), (6, 9), (2, 8), (5, 5)],\n    9: [(0, 6)],\n    12: [(0, 7), (3, 4), (14, 5), (8, 1), (7, 7), (11, 6), (10, 2), (1, 3), (6, 3)],\n    1: [(0, 10), (12, 3), (14, 9), (4, 2), (11, 1), (2, 1)],\n    14: [(0, 1), (12, 5), (1, 9), (8, 1), (7, 1), (5, 10), (10, 7), (4, 9), (6, 1), (11, 4)],\n    13: [(0, 7), (3, 7), (6, 9), (7, 3)],\n    8: [(0, 7), (12, 1), (14, 1)],\n    6: [(0, 9), (12, 3), (14, 1), (13, 9)],\n    2: [(0, 8), (1, 1), (5, 7), (11, 9)],\n    5: [(0, 5), (14, 10), (2, 7)],\n    3: [(12, 4), (13, 7), (7, 10), (10, 6)],\n    7: [(12, 7), (14, 1), (13, 3), (3, 10)],\n    11: [(12, 6), (1, 1), (14, 4), (2, 9), (4, 6)],\n    10: [(12, 2), (14, 7), (3, 6)],\n    4: [(1, 2), (14, 9), (11, 6)]\n}\n\nstart_node = 3\nend_node = 14\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "158": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    2: [(11, 7), (9, 4)],\n    11: [(2, 7), (4, 8), (1, 5), (8, 5), (6, 9), (0, 6), (3, 10)],\n    9: [(2, 4), (7, 8)],\n    4: [(11, 8)],\n    1: [(11, 5)],\n    8: [(11, 5)],\n    6: [(11, 9), (5, 6)],\n    0: [(11, 6), (14, 2), (10, 7), (12, 4), (13, 10)],\n    3: [(11, 10)],\n    7: [(9, 8)],\n    5: [(6, 6)],\n    14: [(0, 2)],\n    10: [(0, 7)],\n    12: [(0, 4)],\n    13: [(0, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 5 to node 3\nshortest_path_length = dijkstra(graph, 5, 3)\nprint(shortest_path_length)\n```"}, "159": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(11, 8), (8, 6), (12, 10), (3, 1), (9, 2)],\n    11: [(4, 8), (13, 3), (7, 1)],\n    8: [(4, 6), (0, 7), (14, 3), (3, 8), (10, 5), (13, 4), (6, 1)],\n    12: [(4, 10), (3, 9), (9, 8)],\n    3: [(4, 1), (8, 8), (12, 9), (0, 3), (14, 7), (2, 1), (1, 5), (5, 7), (6, 4), (9, 7)],\n    9: [(4, 2), (12, 8), (3, 7), (7, 5), (2, 3), (1, 5), (6, 5), (10, 4)],\n    13: [(11, 3), (8, 4), (7, 1), (5, 8), (6, 9)],\n    7: [(11, 1), (9, 5), (13, 1), (14, 9)],\n    0: [(8, 7), (3, 3), (2, 1)],\n    14: [(8, 3), (3, 7), (7, 9), (5, 2), (6, 2)],\n    10: [(8, 5), (9, 4), (2, 4)],\n    6: [(8, 1), (3, 4), (9, 5), (13, 9), (14, 2)],\n    2: [(3, 1), (9, 3), (0, 1), (10, 4), (1, 8)],\n    1: [(3, 5), (9, 5), (2, 8)],\n    5: [(3, 7), (13, 8), (14, 2)]\n}\n\nprint(dijkstra(graph, 1, 0))\n```"}, "160": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(4, 7), (0, 4)],\n    4: [(3, 7), (2, 3), (0, 1)],\n    0: [(3, 4), (4, 1), (5, 1), (9, 9), (7, 7), (6, 10), (2, 8)],\n    2: [(4, 3), (0, 8), (9, 4), (6, 7)],\n    5: [(0, 1), (9, 3), (6, 3), (1, 8), (10, 7)],\n    9: [(0, 9), (5, 3), (6, 8), (2, 4)],\n    7: [(0, 7), (6, 8), (10, 5)],\n    6: [(0, 10), (5, 3), (9, 8), (7, 8), (2, 7), (1, 4), (10, 5)],\n    1: [(5, 8), (6, 4)],\n    10: [(5, 7), (6, 5), (8, 10), (7, 5)],\n    8: [(10, 10)]\n}\n\nstart_node = 7\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "161": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    11: [(9, 3), (1, 4), (12, 6), (10, 8), (6, 5), (0, 1), (7, 9), (2, 3), (4, 2), (3, 1), (8, 3), (5, 7)],\n    9: [(11, 3), (0, 6), (4, 3), (7, 9), (1, 7), (8, 8), (6, 2)],\n    1: [(11, 4), (9, 7), (7, 4), (12, 8)],\n    12: [(11, 6), (1, 8), (3, 9)],\n    10: [(11, 8), (7, 5), (13, 6), (5, 3)],\n    6: [(11, 5), (9, 2), (13, 8), (3, 9)],\n    0: [(11, 1), (9, 6), (7, 9)],\n    7: [(11, 9), (9, 9), (1, 4), (10, 5), (0, 9), (13, 6), (2, 1), (8, 1)],\n    2: [(11, 3), (7, 1), (13, 8), (4, 1)],\n    4: [(11, 2), (9, 3), (2, 1)],\n    3: [(11, 1), (12, 9), (6, 9), (5, 5)],\n    8: [(11, 3), (9, 8), (7, 1)],\n    5: [(11, 7), (10, 3), (3, 5)],\n    13: [(10, 6), (6, 8), (7, 6), (2, 8)]\n}\n\nstart_node = 2\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "162": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    8: [(7, 6), (5, 10), (6, 5), (2, 4), (9, 10), (1, 9), (3, 5), (13, 10), (0, 6)],\n    7: [(8, 6), (10, 9)],\n    5: [(8, 10), (12, 3)],\n    6: [(8, 5), (11, 4), (14, 10)],\n    2: [(8, 4), (1, 7), (12, 9)],\n    9: [(8, 10), (0, 2)],\n    1: [(8, 9), (2, 7)],\n    3: [(8, 5), (11, 1), (0, 10), (12, 8)],\n    13: [(8, 10), (11, 4), (4, 4)],\n    0: [(8, 6), (9, 2), (3, 10)],\n    10: [(7, 9), (11, 8), (12, 10), (4, 1)],\n    12: [(5, 3), (2, 9), (3, 8), (10, 10), (11, 9)],\n    11: [(6, 4), (3, 1), (13, 4), (10, 8), (12, 9), (14, 5)],\n    14: [(6, 10), (11, 5)],\n    4: [(13, 4), (10, 1)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 7 to node 13\nshortest_path_length = dijkstra(graph, 7, 13)\nprint(shortest_path_length)\n```"}, "163": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 8), (4, 8), (2, 5), (1, 5), (7, 4), (6, 9)],\n    3: [(0, 8), (5, 6), (4, 1), (2, 10), (1, 2), (7, 4)],\n    4: [(0, 8), (3, 1), (5, 8), (2, 10), (1, 2), (7, 8), (6, 6)],\n    2: [(0, 5), (3, 10), (4, 10), (5, 5), (1, 4), (6, 3)],\n    1: [(0, 5), (3, 2), (4, 2), (2, 4), (5, 10), (7, 9)],\n    7: [(0, 4), (3, 4), (4, 8), (1, 9), (5, 7), (6, 2)],\n    6: [(0, 9), (4, 6), (2, 3), (7, 2), (5, 2)],\n    5: [(3, 6), (4, 8), (2, 5), (1, 10), (7, 7), (6, 2)]\n}\n\nstart_node = 4\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "164": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    6: [(1, 2), (2, 9), (5, 4)],\n    1: [(2, 7), (0, 6), (4, 7)],\n    2: [(8, 3), (5, 7), (4, 2), (1, 7)],\n    0: [(5, 1), (1, 9)],\n    4: [(3, 6), (8, 2)],\n    8: [(5, 3), (6, 8), (4, 8), (3, 2), (0, 10)],\n    3: [(2, 10), (0, 9), (5, 4), (6, 8)],\n    7: [(1, 6)]\n}\n\nstart_node = 0\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "165": {"gpt4": "```python\nimport heapq\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [(11, 9), (0, 8), (7, 7), (4, 6), (10, 1)],\n    11: [(9, 2), (1, 9), (10, 4), (8, 7), (5, 10)],\n    0: [(9, 5), (6, 5), (7, 7), (10, 2), (3, 7), (11, 3)],\n    7: [(10, 5), (8, 8), (3, 10), (11, 9), (0, 3), (9, 7), (12, 3), (6, 5)],\n    4: [(1, 1), (10, 6), (6, 4)],\n    10: [(8, 1), (2, 4)],\n    9: [(12, 9), (7, 7), (2, 8), (5, 3), (0, 3)],\n    1: [(10, 7), (8, 1), (11, 9), (0, 6), (9, 7), (12, 5), (6, 6), (7, 2), (2, 7)],\n    8: [(5, 5), (12, 5), (4, 5)],\n    5: [(3, 7), (0, 7), (12, 8), (6, 6), (8, 1)],\n    6: [(2, 5), (3, 9), (0, 10), (9, 3)],\n    12: [(2, 6), (10, 9), (8, 8), (5, 2), (11, 6), (9, 4)],\n    2: [(1, 7), (10, 5), (8, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 4 to node 12\nshortest_path_length = dijkstra(graph, 4, 12)\nprint(shortest_path_length)\n```"}, "166": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(4, 8), (10, 6), (1, 3), (6, 2), (9, 2)],\n    4: [(2, 8), (0, 4), (10, 6), (11, 1), (1, 2), (9, 10), (8, 9)],\n    10: [(2, 6), (4, 6), (11, 5), (7, 9), (5, 7), (9, 7), (8, 7)],\n    1: [(2, 3), (4, 2), (0, 1), (11, 2), (6, 8), (5, 3), (9, 10), (8, 1)],\n    6: [(2, 2), (1, 8), (3, 10), (0, 2), (11, 3), (7, 7), (9, 4), (8, 7)],\n    9: [(2, 2), (4, 10), (10, 7), (1, 10), (6, 4), (5, 1)],\n    0: [(4, 4), (1, 1), (6, 2), (3, 5), (11, 1), (8, 10)],\n    11: [(4, 1), (10, 5), (1, 2), (6, 3), (3, 10), (0, 1), (7, 8), (5, 9), (8, 7)],\n    8: [(4, 9), (10, 7), (1, 1), (6, 7), (3, 10), (0, 10), (11, 7), (5, 1)],\n    7: [(10, 9), (6, 7), (11, 8)],\n    5: [(10, 7), (1, 3), (9, 1), (3, 3), (11, 9), (8, 1)],\n    3: [(6, 10), (0, 5), (11, 10), (5, 3), (8, 10)]\n}\n\nprint(dijkstra(graph, 10, 3))\n```"}, "167": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(11, 8), (10, 8), (8, 10)],\n    11: [(9, 6), (5, 1), (7, 1)],\n    10: [(4, 1), (2, 8), (9, 7), (1, 8)],\n    8: [(2, 2), (6, 2), (3, 6), (1, 5), (10, 10)],\n    9: [(0, 8), (10, 7), (11, 9), (6, 10), (12, 9)],\n    5: [(0, 4), (7, 10), (1, 3), (2, 3), (11, 6), (12, 4)],\n    7: [(1, 7), (6, 10), (12, 5), (5, 10)],\n    4: [(2, 9), (11, 3), (0, 4), (10, 9)],\n    1: [(10, 7), (2, 10), (12, 7), (3, 1), (0, 9)],\n    6: [(0, 1), (10, 3), (2, 9), (11, 9)],\n    3: [(0, 8), (1, 5), (2, 6), (6, 6)],\n    0: [(1, 8), (10, 10), (11, 7), (9, 2), (5, 1), (3, 2)],\n    12: [(9, 6), (5, 5), (4, 10), (2, 6), (6, 1)]\n}\n\nstart_node = 7\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "168": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    4: [(5, 2), (8, 9), (1, 3)],\n    5: [(4, 2), (6, 8), (0, 9)],\n    8: [(4, 9), (7, 4)],\n    1: [(4, 3)],\n    6: [(5, 8), (2, 4), (3, 4)],\n    0: [(5, 9), (7, 10)],\n    7: [(8, 4), (0, 10)],\n    2: [(6, 4)],\n    3: [(6, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 3 to node 0\nshortest_path_length = dijkstra(graph, 3, 0)\nprint(shortest_path_length)\n```"}, "169": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(7, 8), (0, 4)],\n    7: [(4, 8), (3, 7)],\n    0: [(4, 4), (6, 6), (2, 8)],\n    3: [(7, 7)],\n    6: [(0, 6), (2, 3), (1, 2)],\n    2: [(0, 8), (6, 3)],\n    1: [(6, 2), (5, 3)],\n    5: [(1, 3)]\n}\n\nprint(dijkstra(graph, 4, 5))\n```"}, "170": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    2: [(3, 8), (4, 3)],\n    3: [(2, 8), (5, 1)],\n    4: [(2, 3), (6, 10)],\n    5: [(3, 1), (1, 8)],\n    6: [(4, 10), (0, 9)],\n    1: [(5, 8), (7, 2)],\n    0: [(6, 9), (7, 8)],\n    7: [(0, 8), (1, 2)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 7 to node 5\nshortest_path_length = dijkstra(graph, 7, 5)\nprint(shortest_path_length)\n```"}, "171": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(0, 9), (10, 1), (8, 1)],\n    0: [(4, 9), (7, 4)],\n    10: [(4, 1), (9, 5), (3, 4)],\n    8: [(4, 1)],\n    7: [(0, 4), (2, 3)],\n    9: [(10, 5)],\n    3: [(10, 4), (6, 5)],\n    2: [(7, 3), (6, 6), (1, 6)],\n    6: [(3, 5), (2, 6)],\n    1: [(2, 6), (5, 2)],\n    5: [(1, 2)]\n}\n\nprint(dijkstra(graph, 2, 9))\n```"}, "172": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 9)],\n    1: [(2, 3), (7, 3)],\n    2: [(1, 3), (7, 1)],\n    3: [(5, 7), (0, 9)],\n    4: [(5, 4), (6, 5)],\n    5: [(4, 4), (3, 7)],\n    6: [(7, 1), (4, 5)],\n    7: [(1, 3), (2, 1), (6, 1)]\n}\n\nstart_node = 0\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "173": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: {11: 3, 7: 8, 10: 10, 8: 3},\n    11: {5: 3, 9: 1, 1: 4, 2: 4, 8: 9},\n    7: {5: 8, 10: 10, 2: 4},\n    10: {5: 10, 7: 10, 3: 9, 1: 6, 2: 4},\n    8: {5: 3, 11: 9, 3: 10, 1: 1},\n    9: {11: 1, 12: 7, 6: 2, 3: 7, 0: 2},\n    1: {11: 4, 10: 6, 8: 1},\n    2: {11: 4, 7: 4, 10: 4, 12: 9},\n    3: {10: 9, 8: 10, 9: 7, 12: 4},\n    12: {9: 7, 2: 9, 0: 1, 6: 5, 3: 4},\n    6: {9: 2, 12: 5, 4: 3, 0: 7},\n    0: {9: 2, 12: 1, 6: 7, 4: 9},\n    4: {6: 3, 0: 9}\n}\n\nstart_node = 6\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "174": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    0: [(4, 7), (7, 3), (3, 9)],\n    1: [(7, 6), (2, 8)],\n    2: [(1, 8), (6, 2)],\n    3: [(0, 9), (6, 9)],\n    4: [(0, 7)],\n    5: [(7, 8)],\n    6: [(3, 9), (2, 2)],\n    7: [(0, 3), (1, 6), (5, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 5 to node 1\nshortest_path_length = dijkstra(graph, 5, 1)\nprint(shortest_path_length)\n```"}, "175": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(7, 4), (12, 10), (1, 7), (9, 10), (0, 1), (6, 8), (13, 2), (10, 8)],\n    7: [(2, 4), (9, 10), (12, 8), (11, 4)],\n    12: [(2, 10), (7, 8), (8, 9), (3, 2), (9, 9), (4, 4)],\n    1: [(2, 7), (0, 8), (9, 8)],\n    9: [(2, 10), (7, 10), (12, 9), (1, 8), (8, 3), (13, 9), (3, 5), (11, 7), (0, 8), (10, 5), (5, 6)],\n    0: [(2, 1), (1, 8), (9, 8), (13, 8), (11, 4)],\n    6: [(2, 8), (13, 4), (4, 6), (11, 8), (3, 9)],\n    13: [(2, 2), (9, 9), (0, 8), (6, 4)],\n    10: [(2, 8), (9, 5), (8, 4)],\n    11: [(7, 4), (9, 7), (0, 4), (6, 8), (8, 7)],\n    8: [(12, 9), (9, 3), (10, 4), (11, 7)],\n    3: [(12, 2), (9, 5), (6, 9), (4, 9)],\n    4: [(12, 4), (6, 6), (3, 9)],\n    5: [(9, 6)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 10)\nprint(shortest_path_length)\n```"}, "176": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    3: [(10, 4), (4, 5), (6, 3), (1, 8)],\n    10: [(3, 4), (0, 5)],\n    4: [(3, 5), (13, 4), (5, 7), (2, 6), (12, 9), (8, 7), (14, 10), (11, 1)],\n    6: [(3, 3)],\n    1: [(3, 8)],\n    0: [(10, 5)],\n    13: [(4, 4), (7, 9)],\n    5: [(4, 7)],\n    2: [(4, 6)],\n    12: [(4, 9)],\n    8: [(4, 7)],\n    14: [(4, 10)],\n    11: [(4, 1)],\n    7: [(13, 9), (9, 4)],\n    9: [(7, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor has been found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 8 to node 4\nshortest_path_length = dijkstra(graph, 8, 4)\nprint(shortest_path_length)\n```"}, "177": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(4, 9), (7, 1), (0, 10)],\n    4: [(6, 9), (1, 4)],\n    7: [(6, 1)],\n    0: [(6, 10), (5, 4)],\n    1: [(4, 4), (3, 3)],\n    5: [(0, 4), (3, 2), (8, 8)],\n    3: [(1, 3), (5, 2)],\n    2: [(8, 1), (9, 5)],\n    8: [(2, 1), (5, 8)],\n    9: [(2, 5)]\n}\n\nprint(dijkstra(graph, 4, 7))\n```"}, "178": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: {10: 7, 0: 3, 4: 6, 1: 5, 3: 2, 5: 1, 12: 4, 9: 10, 11: 3, 6: 6, 7: 9, 2: 9},\n    10: {8: 7, 0: 2, 13: 8, 4: 2, 1: 1, 5: 10, 11: 1, 6: 2, 7: 4, 2: 10},\n    0: {8: 3, 10: 2, 4: 5, 1: 10, 3: 7, 5: 5, 12: 9, 9: 1, 6: 9, 7: 6},\n    4: {8: 6, 10: 2, 0: 5, 13: 8, 3: 3, 5: 6, 11: 4, 6: 5},\n    1: {8: 5, 10: 1, 0: 10, 5: 1, 12: 9, 9: 6, 6: 5, 7: 10, 2: 10},\n    3: {8: 2, 0: 7, 4: 3, 13: 3, 12: 9, 9: 2, 7: 4, 2: 3},\n    5: {8: 1, 10: 10, 0: 5, 4: 6, 1: 1, 13: 1, 12: 6, 9: 1, 11: 4, 6: 5, 2: 2},\n    12: {8: 4, 0: 9, 1: 9, 3: 9, 5: 6, 6: 3, 7: 10, 2: 6},\n    9: {8: 10, 0: 1, 1: 6, 3: 2, 5: 1, 11: 8, 6: 7, 7: 6, 2: 2},\n    11: {8: 3, 10: 1, 4: 4, 5: 4, 9: 8, 13: 5, 2: 2},\n    6: {8: 6, 10: 2, 0: 9, 4: 5, 1: 5, 5: 5, 12: 3, 9: 7, 13: 1, 2: 10},\n    7: {8: 9, 10: 4, 0: 6, 1: 10, 3: 4, 12: 10, 9: 6, 13: 8, 2: 7},\n    2: {8: 9, 10: 10, 1: 10, 3: 3, 5: 2, 12: 6, 9: 2, 11: 2, 6: 10, 7: 7, 13: 2},\n    13: {10: 8, 4: 8, 3: 3, 5: 1, 11: 5, 6: 1, 7: 8, 2: 2}\n}\n\nprint(dijkstra(graph, 0, 11))\n```"}, "179": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    3: [(7, 3), (1, 3)],\n    7: [(3, 3)],\n    1: [(3, 3), (9, 4)],\n    9: [(1, 4), (5, 1), (6, 4), (8, 3)],\n    5: [(9, 1)],\n    6: [(9, 4), (4, 2), (2, 4), (0, 10)],\n    8: [(9, 3)],\n    4: [(6, 2)],\n    2: [(6, 4)],\n    0: [(6, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 6 to node 0\nshortest_path_length = dijkstra(graph, 6, 0)\nprint(shortest_path_length)\n```"}, "180": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(1, 5), (7, 6), (5, 7), (0, 9)],\n    1: [(10, 5), (4, 8), (3, 8), (7, 8), (5, 9), (6, 3)],\n    7: [(10, 6), (1, 8), (9, 2), (4, 2), (8, 1), (5, 2), (6, 3), (2, 2), (0, 6)],\n    5: [(10, 7), (1, 9), (7, 2), (9, 1), (8, 8), (3, 7), (6, 1)],\n    0: [(10, 9), (7, 6), (4, 9), (8, 1), (3, 2), (6, 6)],\n    4: [(1, 8), (7, 2), (0, 9)],\n    3: [(1, 8), (5, 7), (0, 2), (9, 6), (6, 8), (2, 4)],\n    6: [(1, 3), (7, 3), (5, 1), (0, 6), (9, 7), (3, 8), (8, 6), (2, 8)],\n    9: [(7, 2), (5, 1), (3, 6), (6, 7), (2, 7)],\n    8: [(7, 1), (5, 8), (0, 1), (6, 6), (2, 8)],\n    2: [(7, 2), (9, 7), (3, 4), (6, 8), (8, 8)]\n}\n\nprint(dijkstra(graph, 1, 8))\n```"}, "181": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(7, 5), (8, 10), (4, 1), (5, 4), (3, 7), (6, 4)],\n    7: [(2, 5), (0, 1), (1, 7), (4, 7)],\n    8: [(2, 10), (3, 8), (1, 7)],\n    4: [(2, 1), (7, 7), (3, 1)],\n    5: [(2, 4), (6, 7)],\n    3: [(2, 7), (8, 8), (4, 1), (0, 6)],\n    6: [(2, 4), (5, 7)],\n    0: [(7, 1), (3, 6)],\n    1: [(7, 7), (8, 7)]\n}\n\nshortest_path_length = dijkstra(graph, 8, 3)\nprint(shortest_path_length)\n```"}, "182": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 3), (9, 8)],\n    3: [(0, 3), (6, 2)],\n    9: [(0, 8), (1, 1), (2, 1)],\n    6: [(3, 2), (5, 5)],\n    1: [(9, 1), (10, 2)],\n    2: [(9, 1)],\n    5: [(6, 5), (4, 10), (7, 7)],\n    8: [(4, 10)],\n    4: [(8, 10), (5, 10)],\n    7: [(5, 7), (10, 5)],\n    10: [(1, 2), (7, 5)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 4)\nprint(shortest_path_length)\n```"}, "183": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(5, 6), (14, 9)],\n    5: [(8, 6), (1, 2), (10, 3)],\n    14: [(8, 9), (9, 7)],\n    1: [(5, 2), (11, 10), (4, 10)],\n    10: [(5, 3), (3, 10)],\n    9: [(14, 7), (0, 9)],\n    11: [(1, 10), (13, 7)],\n    4: [(1, 10), (3, 2)],\n    3: [(10, 10), (7, 10), (4, 2)],\n    2: [(6, 10), (12, 9)],\n    6: [(2, 10), (7, 6)],\n    12: [(2, 9)],\n    7: [(6, 6), (3, 10)],\n    13: [(11, 7)],\n    0: [(9, 9)]\n}\n\nstart_node = 13\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "184": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(3, 5)],\n    3: [(8, 10), (7, 3)],\n    8: [(6, 10)],\n    7: [(1, 3), (5, 9)],\n    5: [(9, 6), (3, 6)],\n    9: [(1, 6), (0, 7)],\n    1: [(2, 6), (9, 2)],\n    0: [(3, 2), (8, 7), (1, 4)],\n    4: [(1, 6), (7, 3), (3, 7), (8, 1)]\n}\n\nstart_node = 6\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "185": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (5, 10)],\n    4: [(0, 4), (3, 8)],\n    5: [(0, 10), (6, 1)],\n    3: [(4, 8), (7, 3)],\n    6: [(5, 1), (1, 4)],\n    7: [(3, 3), (1, 2)],\n    1: [(7, 2), (2, 8), (6, 4)],\n    2: [(1, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 6)\nprint(shortest_path_length)\n```"}, "186": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 1), (11, 10), (10, 10)],\n    3: [(6, 1)],\n    11: [(5, 2)],\n    10: [(6, 4), (0, 2), (7, 1)],\n    6: [(1, 10), (3, 7)],\n    5: [(11, 5), (6, 1), (0, 10)],\n    7: [(6, 9)],\n    1: [(8, 7)],\n    4: [(8, 6), (5, 4)],\n    8: [(1, 7)],\n    9: [(4, 2), (3, 3), (10, 10)],\n    2: [(10, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 10, 6)\nprint(shortest_path_length)\n```"}, "187": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(4, 8), (7, 9), (1, 9), (5, 1), (6, 6)],\n    4: [(3, 8), (6, 10)],\n    7: [(3, 9), (6, 10)],\n    1: [(3, 9), (5, 6)],\n    5: [(3, 1), (1, 6), (0, 9), (8, 7), (2, 1)],\n    6: [(3, 6), (4, 10), (7, 10), (0, 4), (2, 5)],\n    0: [(5, 9), (6, 4), (8, 3)],\n    8: [(5, 7), (0, 3)],\n    2: [(5, 1), (6, 5)]\n}\n\nprint(dijkstra(graph, 2, 4))\n```"}, "188": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(14, 10), (10, 10), (8, 10), (4, 10), (2, 3), (7, 1)],\n    14: [(1, 10), (0, 7), (4, 7)],\n    10: [(1, 10), (2, 3), (7, 5), (8, 9)],\n    8: [(1, 10), (10, 9), (2, 1), (0, 8)],\n    4: [(1, 10), (14, 7), (12, 3), (6, 9)],\n    2: [(1, 3), (10, 3), (8, 1), (13, 5), (3, 9), (12, 3)],\n    7: [(1, 1), (10, 5), (6, 7), (9, 7)],\n    0: [(14, 7), (8, 8), (6, 10), (11, 3)],\n    12: [(4, 3), (2, 3), (13, 4), (3, 5), (5, 6), (9, 8)],\n    6: [(4, 9), (7, 7), (0, 10)],\n    13: [(2, 5), (3, 8), (12, 4), (5, 8)],\n    3: [(2, 9), (13, 8), (12, 5), (11, 5)],\n    9: [(7, 7), (12, 8)],\n    11: [(0, 3), (3, 5), (5, 6)],\n    5: [(13, 8), (12, 6), (11, 6)]\n}\n\nstart_node = 12\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "189": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    6: [(4, 8), (1, 4)],\n    4: [(6, 8), (10, 4), (7, 9)],\n    1: [(6, 4), (0, 1), (7, 1)],\n    10: [(4, 4)],\n    7: [(4, 9), (1, 1), (3, 9)],\n    0: [(1, 1)],\n    3: [(7, 9), (13, 7), (9, 7), (2, 9)],\n    5: [(8, 4)],\n    8: [(5, 4), (13, 10)],\n    13: [(8, 10), (3, 7)],\n    9: [(3, 7)],\n    2: [(3, 9), (11, 7)],\n    11: [(2, 7), (12, 4)],\n    12: [(11, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 1 to node 10\nshortest_path_length = dijkstra(graph, 1, 10)\nprint(shortest_path_length)\n```"}, "190": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 5), (12, 3), (6, 1), (4, 2), (5, 6), (9, 3)],\n    2: [(0, 5), (12, 5), (1, 6), (9, 2)],\n    12: [(0, 3), (2, 5)],\n    6: [(0, 1), (8, 9), (7, 6)],\n    4: [(0, 2), (3, 9), (7, 2), (9, 4), (1, 7)],\n    5: [(0, 6), (9, 1), (11, 1), (8, 4)],\n    9: [(0, 3), (2, 2), (4, 4), (5, 1), (11, 5)],\n    1: [(2, 6), (4, 7), (3, 3), (10, 3)],\n    8: [(6, 9), (5, 4)],\n    7: [(6, 6), (4, 2)],\n    3: [(4, 9), (1, 3)],\n    11: [(5, 1), (9, 5), (10, 9)],\n    10: [(1, 3), (11, 9)]\n}\n\nresult = dijkstra(graph, 12, 2)\nprint(result)\n```"}, "191": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 9), (11, 3), (1, 3), (7, 10), (8, 8)],\n    6: [(0, 9)],\n    11: [(0, 3), (4, 4)],\n    1: [(0, 3), (5, 5), (9, 7), (3, 10)],\n    7: [(0, 10)],\n    8: [(0, 8)],\n    4: [(11, 4)],\n    5: [(1, 5)],\n    9: [(1, 7), (2, 7)],\n    3: [(1, 10), (10, 9)],\n    2: [(9, 7)],\n    10: [(3, 9)]\n}\n\nresult = dijkstra(graph, 8, 10)\nprint(result)\n```"}, "192": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(3, 4), (11, 1), (0, 6), (6, 3), (5, 8), (7, 4)],\n    3: [(4, 4), (7, 7)],\n    11: [(4, 1), (1, 6), (9, 7)],\n    0: [(4, 6), (7, 4)],\n    6: [(4, 3), (9, 7), (8, 6)],\n    5: [(4, 8), (7, 6), (10, 5)],\n    7: [(4, 4), (3, 7), (0, 4), (5, 6), (9, 7), (10, 3), (8, 3), (2, 6)],\n    1: [(11, 6), (9, 9)],\n    9: [(11, 7), (6, 7), (7, 7), (1, 9), (2, 7)],\n    8: [(6, 6), (7, 3)],\n    10: [(5, 5), (7, 3)],\n    2: [(7, 6), (9, 7)]\n}\n\nprint(dijkstra(graph, 9, 11))\n```"}, "193": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(11, 4), (2, 8)],\n    11: [(6, 9), (0, 5), (1, 7), (4, 7), (8, 3)],\n    2: [(7, 9), (8, 4)],\n    6: [(3, 10)],\n    0: [(7, 2), (1, 5), (8, 2), (2, 5), (3, 7)],\n    1: [(10, 6), (4, 8), (8, 7), (0, 2)],\n    4: [(3, 6), (6, 4), (9, 6), (10, 2)],\n    8: [(2, 5), (1, 1), (5, 4), (9, 4)],\n    7: [(1, 1), (5, 1), (9, 10), (8, 7), (3, 6), (11, 2)],\n    10: [(8, 2), (3, 10), (6, 6), (7, 1)],\n    9: [(2, 4), (3, 5), (11, 4), (6, 6), (0, 8), (7, 1)],\n    5: [(9, 1), (2, 8), (0, 5)]\n}\n\nstart_node = 10\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "194": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    12: [(2, 4), (6, 7), (10, 1), (4, 2)],\n    2: [(11, 7), (14, 6), (10, 6), (3, 8), (4, 6), (12, 2), (5, 9)],\n    6: [(0, 4), (8, 9), (14, 5), (10, 1), (3, 7), (12, 6), (5, 6)],\n    10: [(9, 8), (12, 6), (2, 6), (13, 3), (1, 1)],\n    4: [(12, 6), (2, 3), (6, 6), (1, 4), (3, 3)],\n    11: [(8, 7), (1, 2), (9, 2), (6, 2)],\n    14: [(3, 10), (5, 2), (11, 5)],\n    3: [(5, 5), (7, 1), (0, 1), (10, 9)],\n    5: [(7, 5), (13, 7), (6, 6), (9, 7), (4, 2)],\n    0: [(10, 2), (9, 7), (2, 8), (6, 3)],\n    8: [(14, 7), (9, 10), (4, 2), (2, 4)],\n    9: [(5, 9), (13, 2), (6, 2), (11, 4), (0, 3), (14, 10)],\n    13: [(6, 9), (11, 2), (10, 8), (3, 3), (5, 9), (2, 1)],\n    1: [(14, 3), (3, 6), (6, 8)],\n    7: [(0, 3), (8, 2), (10, 5), (9, 7), (5, 4)]\n}\n\nstart_node = 13\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "195": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (2, 5), (3, 7)],\n    4: [(8, 2), (5, 4)],\n    2: [(8, 8), (0, 1), (14, 1)],\n    3: [(9, 2)],\n    8: [(4, 4), (14, 1), (11, 2), (9, 8)],\n    5: [(13, 6), (11, 10), (12, 5)],\n    14: [(10, 5), (3, 9), (1, 7)],\n    9: [(8, 9), (1, 9), (6, 4)],\n    13: [(7, 6), (1, 7), (6, 2), (5, 8)],\n    11: [(5, 4), (14, 6)],\n    12: [(4, 3), (11, 9), (2, 10), (3, 5)],\n    7: [(2, 5), (4, 2)],\n    1: [(4, 2), (10, 8), (7, 3), (2, 1)],\n    6: [(5, 5), (4, 5), (14, 6), (1, 3), (12, 3)],\n    10: [(12, 10)]\n}\n\nstart_node = 4\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "196": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    4: [(10, 3), (2, 5)],\n    10: [(0, 2), (9, 1)],\n    2: [(8, 5)],\n    0: [(7, 8)],\n    9: [(4, 3), (6, 6), (5, 8)],\n    8: [(11, 4), (9, 8), (4, 6)],\n    11: [(0, 3), (4, 5), (6, 9)],\n    6: [(2, 8), (3, 3), (11, 7), (7, 7), (8, 9), (10, 10)],\n    5: [(2, 10), (11, 10), (7, 8)],\n    7: [(10, 1), (2, 2), (11, 6)],\n    3: [(0, 2), (9, 4), (10, 8), (6, 4), (5, 5)],\n    1: [(2, 8), (3, 9), (0, 9), (8, 7)]\n}\n\nstart_node = 8\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "197": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 1), (1, 9)],\n    1: [(0, 9)],\n    2: [(0, 1), (5, 6), (3, 1), (4, 9), (7, 10)],\n    3: [(2, 1)],\n    4: [(2, 9)],\n    5: [(2, 6), (6, 5)],\n    6: [(5, 5)],\n    7: [(2, 10)]\n}\n\nstart_node = 7\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "198": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    12: [(1, 10), (10, 5), (5, 3)],\n    1: [(3, 4), (7, 10), (12, 5)],\n    10: [(8, 5), (2, 8), (0, 1)],\n    5: [(12, 2), (0, 1), (10, 3), (4, 2), (7, 1)],\n    3: [(10, 8), (8, 10)],\n    7: [(5, 3), (9, 4), (3, 7), (4, 10)],\n    8: [(12, 7), (1, 9), (0, 7), (3, 8), (11, 3)],\n    2: [(4, 4)],\n    0: [(3, 9), (10, 10), (8, 8), (9, 4), (1, 8)],\n    4: [(7, 3), (12, 7), (1, 10)],\n    9: [(3, 4), (7, 4), (2, 2)],\n    11: [(8, 5), (2, 4), (1, 8)],\n    6: [(11, 5), (8, 4), (9, 9), (0, 2), (10, 1), (4, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate shortest path from node 2 to node 12\nshortest_path_length = dijkstra(graph, 2, 12)\nprint(shortest_path_length)\n```"}, "199": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(8, 4), (6, 5), (7, 10), (0, 9), (2, 2), (4, 3)],\n    8: [(5, 4), (4, 2), (2, 1)],\n    6: [(5, 5), (7, 6), (4, 1), (0, 7)],\n    7: [(5, 10), (6, 6), (1, 3), (9, 2), (2, 6)],\n    0: [(5, 9), (6, 7), (4, 2)],\n    2: [(5, 2), (8, 1), (7, 6), (1, 6), (4, 2)],\n    4: [(5, 3), (8, 2), (6, 1), (0, 2), (2, 2), (1, 5), (3, 7), (9, 1)],\n    1: [(7, 3), (2, 6), (4, 5)],\n    9: [(7, 2), (4, 1), (3, 8)],\n    3: [(4, 7), (9, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 0)\nprint(shortest_path_length)\n```"}, "200": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(1, 6), (5, 9), (6, 7), (3, 3), (2, 7), (0, 1)],\n    1: [(7, 6), (5, 4), (6, 8), (3, 9), (4, 5), (0, 10)],\n    5: [(7, 9), (1, 4), (4, 5), (2, 6)],\n    6: [(7, 7), (1, 8), (3, 1), (4, 6), (2, 2), (0, 7)],\n    3: [(7, 3), (1, 9), (6, 1), (4, 4), (2, 6), (0, 5)],\n    2: [(7, 7), (5, 6), (6, 2), (3, 6), (4, 6), (0, 3)],\n    0: [(7, 1), (1, 10), (6, 7), (3, 5), (2, 3), (4, 7)],\n    4: [(1, 5), (5, 5), (6, 6), (3, 4), (2, 6), (0, 7)]\n}\n\nstart_node = 2\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "201": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(5, 5), (3, 3), (9, 2), (1, 4), (8, 6)],\n    5: [(6, 5), (3, 7), (7, 1), (9, 3), (4, 10)],\n    3: [(6, 3), (5, 7), (4, 9), (1, 7), (0, 10), (9, 9), (7, 6)],\n    9: [(6, 2), (5, 3), (3, 9)],\n    1: [(6, 4), (3, 7), (4, 9), (0, 1), (7, 7), (2, 2)],\n    8: [(6, 6), (4, 4)],\n    7: [(5, 1), (3, 6), (1, 7)],\n    4: [(5, 10), (3, 9), (1, 9), (8, 4), (0, 9), (2, 4)],\n    0: [(3, 10), (1, 1), (4, 9)],\n    2: [(1, 2), (4, 4)]\n}\n\nprint(dijkstra(graph, 2, 9))\n```"}, "202": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    13: [(4, 3), (2, 1), (11, 3)],\n    4: [(13, 3), (12, 5), (7, 1), (1, 9), (5, 5)],\n    2: [(13, 1), (0, 5), (11, 9), (1, 2), (9, 5)],\n    11: [(13, 3), (2, 9), (5, 7), (6, 1), (10, 3), (14, 2), (1, 7), (3, 5)],\n    12: [(4, 5), (0, 1), (10, 7), (14, 6)],\n    7: [(4, 1), (6, 2), (3, 2)],\n    1: [(4, 9), (2, 2), (11, 7), (8, 3), (0, 1), (6, 1), (14, 1)],\n    5: [(4, 5), (11, 7), (8, 5), (10, 3), (14, 3), (9, 3)],\n    0: [(2, 5), (12, 1), (1, 1)],\n    9: [(2, 5), (5, 3), (14, 2)],\n    6: [(11, 1), (7, 2), (1, 1), (10, 3), (3, 8)],\n    10: [(11, 3), (12, 7), (5, 3), (6, 3), (14, 10), (3, 9)],\n    14: [(11, 2), (12, 6), (1, 1), (5, 3), (8, 2), (10, 10), (9, 2)],\n    3: [(11, 5), (7, 2), (10, 9), (6, 8)],\n    8: [(1, 3), (5, 5), (14, 2)]\n}\n\nstart_node = 6\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "203": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(0, 3), (10, 2), (7, 9), (5, 6), (4, 9)],\n    0: [(9, 3), (10, 2), (1, 7), (2, 6), (8, 6), (3, 7), (4, 8)],\n    10: [(9, 2), (0, 2), (1, 7), (6, 3), (2, 4), (5, 3), (8, 2), (3, 5), (4, 3)],\n    7: [(9, 9), (6, 1), (2, 7), (8, 10), (4, 6)],\n    5: [(9, 6), (10, 3), (6, 8), (3, 5)],\n    4: [(9, 9), (0, 8), (10, 3), (7, 6), (1, 4), (8, 9), (3, 5)],\n    1: [(0, 7), (10, 7), (4, 4), (3, 2)],\n    2: [(0, 6), (10, 4), (7, 7), (8, 3)],\n    8: [(0, 6), (10, 2), (7, 10), (4, 9), (2, 3)],\n    3: [(0, 7), (10, 5), (5, 5), (4, 5), (1, 2)],\n    6: [(10, 3), (7, 1), (5, 8)]\n}\n\nprint(dijkstra(graph, 1, 8))\n```"}, "204": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    1: [(7, 7), (6, 3), (9, 1), (4, 5), (0, 3), (10, 5)],\n    7: [(1, 7), (5, 3), (4, 4), (2, 4), (0, 5)],\n    6: [(1, 3), (5, 7), (9, 10), (2, 10), (0, 10), (10, 8)],\n    9: [(1, 1), (6, 10), (5, 4), (8, 10)],\n    4: [(1, 5), (7, 4), (10, 3), (8, 1)],\n    0: [(1, 3), (7, 5), (6, 10), (5, 9), (10, 1)],\n    10: [(1, 5), (6, 8), (4, 3), (0, 1), (2, 8), (8, 9), (3, 2)],\n    5: [(7, 3), (6, 7), (9, 4), (0, 9), (2, 10), (8, 2)],\n    2: [(7, 4), (6, 10), (10, 8), (5, 10), (8, 10), (3, 8)],\n    8: [(9, 10), (4, 1), (10, 9), (5, 2), (2, 10)],\n    3: [(10, 2), (2, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 3 to node 5\nshortest_path_length = dijkstra(graph, 3, 5)\nprint(shortest_path_length)\n```"}, "205": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    1: [(12, 10), (6, 10)],\n    12: [(1, 10), (9, 1), (2, 4)],\n    6: [(1, 10), (0, 6), (10, 6)],\n    9: [(12, 1)],\n    2: [(12, 4), (11, 9)],\n    0: [(6, 6)],\n    10: [(6, 6), (7, 8), (5, 3), (4, 3), (3, 4)],\n    11: [(2, 9)],\n    7: [(10, 8)],\n    5: [(10, 3)],\n    4: [(10, 3)],\n    3: [(10, 4), (8, 7)],\n    8: [(3, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue for the minimum distance\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 1 to node 9\nshortest_path_length = dijkstra(graph, 1, 9)\nprint(shortest_path_length)\n```"}, "206": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(0, 6), (6, 10), (10, 7), (1, 8), (3, 2), (2, 7)],\n    0: [(9, 6), (5, 9), (8, 9), (6, 6), (10, 10), (1, 1), (7, 1), (3, 4), (2, 2)],\n    6: [(9, 10), (0, 6), (5, 10), (10, 9), (7, 3), (3, 9), (2, 2)],\n    10: [(9, 7), (0, 10), (6, 9), (5, 10), (8, 7), (1, 9), (7, 3), (4, 5), (2, 8)],\n    1: [(9, 8), (0, 1), (10, 9), (5, 7), (7, 4), (3, 7), (2, 1)],\n    3: [(9, 2), (0, 4), (6, 9), (1, 7), (5, 3), (7, 10), (4, 4), (2, 2)],\n    2: [(9, 7), (0, 2), (6, 2), (10, 8), (1, 1), (3, 2), (5, 1), (8, 8), (7, 9), (4, 1)],\n    5: [(0, 9), (6, 10), (10, 10), (1, 7), (3, 3), (2, 1), (8, 6), (4, 2)],\n    8: [(0, 9), (10, 7), (2, 8), (5, 6), (7, 3), (4, 5)],\n    7: [(0, 1), (6, 3), (10, 3), (1, 4), (3, 10), (2, 9), (8, 3), (4, 8)],\n    4: [(10, 5), (3, 4), (2, 1), (5, 2), (8, 5), (7, 8)]\n}\n\nprint(dijkstra(graph, 4, 5))\n```"}, "207": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    0: [(4, 3), (11, 9), (1, 6)],\n    1: [(0, 6), (13, 6), (5, 8)],\n    2: [(9, 6)],\n    3: [(10, 1), (12, 4)],\n    4: [(0, 3)],\n    5: [(1, 8), (7, 8)],\n    6: [(7, 10), (9, 1), (8, 7)],\n    7: [(5, 8), (9, 1), (6, 10)],\n    8: [(6, 7)],\n    9: [(7, 1), (6, 1), (2, 6)],\n    10: [(11, 9), (3, 1)],\n    11: [(0, 9), (10, 9)],\n    12: [(3, 4)],\n    13: [(1, 6)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 2 to node 8\nshortest_path_length = dijkstra(graph, 2, 8)\nprint(shortest_path_length)\n```"}, "208": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(2, 1), (7, 4), (11, 6), (1, 6), (5, 3)],\n    2: [(8, 1), (14, 8)],\n    7: [(8, 4), (4, 10), (10, 5), (11, 3), (0, 1)],\n    11: [(8, 6), (7, 3)],\n    1: [(8, 6), (4, 5)],\n    5: [(8, 3), (3, 5), (14, 6), (0, 4), (13, 7)],\n    14: [(2, 8), (5, 6), (6, 4), (12, 1)],\n    4: [(7, 10), (1, 5), (3, 7), (12, 10), (9, 9), (0, 8)],\n    10: [(7, 5), (6, 5)],\n    0: [(7, 1), (5, 4), (4, 8), (12, 4), (13, 7), (6, 7)],\n    3: [(5, 5), (4, 7)],\n    13: [(5, 7), (0, 7)],\n    6: [(14, 4), (0, 7), (10, 5)],\n    12: [(14, 1), (4, 10), (0, 4), (9, 10)],\n    9: [(4, 9), (12, 10)]\n}\n\nprint(dijkstra(graph, 1, 12))\n```"}, "209": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(13, 5), (0, 5), (9, 4), (10, 1), (2, 4), (12, 10), (4, 8), (6, 2), (7, 2)],\n    13: [(8, 5)],\n    0: [(8, 5)],\n    9: [(8, 4), (3, 7), (11, 7)],\n    10: [(8, 1)],\n    2: [(8, 4)],\n    12: [(8, 10)],\n    4: [(8, 8)],\n    6: [(8, 2), (1, 7)],\n    7: [(8, 2)],\n    3: [(9, 7)],\n    11: [(9, 7), (5, 2)],\n    1: [(6, 7)],\n    5: [(11, 2)]\n}\n\nstart_node = 12\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "210": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(4, 7), (2, 6)],\n    4: [(6, 2), (2, 3), (1, 1), (7, 5)],\n    2: [(3, 10), (5, 10), (1, 3), (7, 6), (6, 5), (0, 10)],\n    6: [(2, 5), (7, 10), (4, 2)],\n    1: [(7, 4), (4, 7), (0, 10), (2, 2), (5, 8)],\n    7: [(4, 8), (0, 5), (3, 3)],\n    5: [(1, 9)],\n    0: [(3, 6), (1, 10), (4, 3)]\n}\n\nstart_node = 1\nend_node = 0\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "211": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(9, 2)],\n    9: [(10, 10), (1, 5)],\n    10: [(12, 6), (7, 2)],\n    1: [(4, 4), (2, 7)],\n    14: [(10, 4)],\n    12: [(2, 2), (10, 9)],\n    7: [(0, 4)],\n    0: [(5, 1), (12, 6), (2, 7)],\n    5: [(7, 2), (8, 4), (1, 5)],\n    2: [(8, 3), (14, 5), (5, 4), (4, 3), (12, 5)],\n    4: [(2, 2), (7, 8), (8, 5), (14, 9), (0, 8), (1, 5), (9, 5)],\n    6: [(12, 6), (0, 8)],\n    11: [(12, 3), (8, 10), (0, 1)],\n    13: [(2, 10), (0, 8)],\n    3: [(10, 1), (14, 10)]\n}\n\nprint(dijkstra(graph, 0, 12))\n```"}, "212": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(4, 3), (8, 6), (0, 9)],\n    4: [(1, 1), (0, 6)],\n    8: [(3, 2), (0, 8), (4, 5)],\n    0: [(4, 10), (3, 1), (1, 1), (6, 9)],\n    1: [(7, 3), (4, 5)],\n    3: [(6, 3), (4, 5)],\n    6: [(7, 8), (0, 8), (2, 7), (5, 6)],\n    5: [(3, 3), (1, 4), (6, 4), (0, 2)],\n    7: [(0, 6), (2, 6), (4, 10), (3, 6), (1, 10)]\n}\n\nstart_node = 8\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "213": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(11, 1), (7, 5), (13, 4), (6, 2)],\n    7: [(10, 1), (13, 5), (6, 4), (1, 5), (11, 8)],\n    13: [(0, 1), (10, 8)],\n    6: [(3, 6), (10, 2), (12, 1)],\n    10: [(4, 4), (6, 6), (1, 10), (11, 7)],\n    1: [(12, 1), (8, 5), (3, 3)],\n    0: [(10, 3)],\n    12: [(11, 3), (5, 10), (10, 10)],\n    8: [(6, 2), (3, 1), (1, 7), (5, 9)],\n    5: [(10, 4), (8, 2), (6, 4), (1, 10)],\n    2: [(12, 5), (9, 6), (0, 8), (8, 4)],\n    9: [(6, 5), (1, 7), (10, 2)],\n    4: [(8, 3), (1, 4), (13, 8)]\n}\n\nstart_node = 13\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "214": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    1: [(4, 3), (8, 8), (5, 1), (11, 9), (6, 1), (0, 10)],\n    4: [(1, 3)],\n    8: [(1, 8)],\n    5: [(1, 1), (7, 4), (3, 1), (9, 10)],\n    11: [(1, 9)],\n    6: [(1, 1)],\n    0: [(1, 10), (10, 9), (2, 7)],\n    7: [(5, 4)],\n    3: [(5, 1)],\n    9: [(5, 10)],\n    10: [(0, 9)],\n    2: [(0, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor has been found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 9 to node 11\nshortest_path_length = dijkstra(graph, 9, 11)\nprint(shortest_path_length)\n```"}, "215": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(2, 7), (8, 4), (1, 5)],\n    2: [(9, 7), (10, 6), (12, 4), (8, 4)],\n    8: [(9, 4), (2, 4), (4, 7), (12, 8)],\n    1: [(9, 5), (10, 1), (3, 9)],\n    10: [(2, 6), (1, 1), (6, 10), (0, 9), (11, 1)],\n    12: [(2, 4), (8, 8), (4, 9), (7, 5), (3, 4)],\n    4: [(8, 7), (12, 9), (6, 1), (7, 3)],\n    3: [(1, 9), (12, 4), (11, 6), (0, 7)],\n    6: [(10, 10), (11, 7), (7, 3), (4, 1), (5, 10)],\n    0: [(10, 9), (11, 2), (5, 1), (3, 7)],\n    11: [(10, 1), (6, 7), (0, 2), (3, 6)],\n    7: [(12, 5), (6, 3), (4, 3), (5, 4)],\n    5: [(6, 10), (7, 4), (0, 1)]\n}\n\nprint(dijkstra(graph, 6, 12))\n```"}, "216": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(2, 5), (9, 10), (0, 2), (4, 8)],\n    2: [(6, 5), (1, 9), (3, 6), (0, 9)],\n    9: [(6, 10), (7, 4), (0, 6), (4, 6)],\n    0: [(6, 2), (2, 9), (9, 6), (7, 7)],\n    4: [(6, 8), (9, 6), (8, 1), (7, 5), (10, 2)],\n    1: [(2, 9), (5, 1), (3, 2)],\n    3: [(2, 6), (1, 2), (5, 3), (10, 9)],\n    7: [(9, 4), (0, 7), (4, 5), (8, 9)],\n    8: [(4, 1), (5, 9), (7, 9), (10, 1)],\n    10: [(4, 2), (3, 9), (5, 8), (8, 1)],\n    5: [(1, 1), (3, 3), (8, 9), (10, 8)]\n}\n\nstart_node = 8\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "217": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(5, 8), (0, 3), (2, 10), (7, 1)],\n    5: [(3, 8), (4, 1)],\n    0: [(3, 3), (4, 2)],\n    2: [(3, 10), (4, 7), (6, 3), (7, 2), (1, 4)],\n    7: [(3, 1), (2, 2), (4, 2)],\n    4: [(5, 1), (0, 2), (2, 7), (7, 2), (6, 10)],\n    6: [(2, 3), (4, 10)],\n    1: [(2, 4)]\n}\n\nprint(dijkstra(graph, 5, 4))\n```"}, "218": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(7, 8), (4, 5)],\n    7: [(8, 4), (1, 4), (4, 7), (9, 9), (6, 8)],\n    4: [(9, 5), (7, 10)],\n    8: [(2, 5), (3, 2), (9, 3), (7, 2)],\n    1: [(3, 5), (9, 6), (5, 7)],\n    9: [(6, 9), (3, 8)],\n    6: [(5, 4), (8, 5), (2, 10), (4, 8), (0, 10)],\n    5: [(2, 6), (0, 7), (3, 2)],\n    2: [(4, 7), (7, 7), (5, 4), (8, 2)],\n    0: [(6, 4), (4, 1)]\n}\n\nstart_node = 2\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "219": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 10), (13, 6), (2, 9), (11, 8), (7, 8), (5, 9), (6, 10), (1, 1), (9, 4)],\n    4: [(0, 10), (1, 3)],\n    13: [(0, 6), (8, 3), (3, 10)],\n    2: [(0, 9), (8, 6), (11, 6)],\n    11: [(0, 8), (2, 6), (1, 1), (7, 3), (9, 7), (12, 5)],\n    7: [(0, 8), (11, 3)],\n    5: [(0, 9), (1, 10)],\n    6: [(0, 10), (1, 4)],\n    1: [(0, 1), (4, 3), (11, 1), (5, 10), (6, 4), (12, 6), (8, 5), (3, 8), (10, 7)],\n    9: [(0, 4), (11, 7)],\n    8: [(13, 3), (2, 6), (1, 5)],\n    3: [(13, 10), (1, 8)],\n    12: [(11, 5), (1, 6)],\n    10: [(1, 7)]\n}\n\nprint(dijkstra(graph, 9, 8))\n```"}, "220": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(2, 4), (0, 5), (5, 4), (12, 9)],\n    2: [(6, 4), (13, 8), (3, 9), (0, 4)],\n    0: [(6, 5), (2, 4), (12, 6), (10, 10)],\n    5: [(6, 4), (11, 2), (1, 8), (8, 6)],\n    12: [(6, 9), (0, 6), (4, 8)],\n    13: [(2, 8), (11, 4), (9, 1), (8, 3), (10, 2)],\n    3: [(2, 9), (11, 6), (10, 4)],\n    10: [(0, 10), (13, 2), (3, 4), (1, 9), (4, 5)],\n    11: [(5, 2), (13, 4), (3, 6), (8, 2), (7, 10)],\n    1: [(5, 8), (10, 9), (4, 2), (9, 4)],\n    8: [(5, 6), (13, 3), (11, 2), (7, 8), (9, 8)],\n    4: [(12, 8), (10, 5), (1, 2)],\n    9: [(13, 1), (8, 8), (7, 5), (1, 4)],\n    7: [(11, 10), (8, 8), (9, 5)]\n}\n\nprint(dijkstra(graph, 0, 8))\n```"}, "221": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(2, 4), (0, 1), (3, 1), (6, 6), (7, 10), (1, 6)],\n    2: [(4, 4), (3, 4), (8, 10), (6, 2), (7, 4)],\n    0: [(4, 1), (3, 4), (5, 6), (10, 9), (1, 8)],\n    3: [(4, 1), (2, 4), (0, 4), (9, 5), (8, 5), (10, 10), (1, 8)],\n    6: [(4, 6), (2, 2), (9, 7), (5, 5), (8, 3), (7, 3), (10, 4), (1, 10)],\n    7: [(4, 10), (2, 4), (6, 3), (9, 4), (5, 10), (8, 3), (10, 1), (1, 10)],\n    1: [(4, 6), (0, 8), (3, 8), (6, 10), (7, 10), (5, 5)],\n    8: [(2, 10), (3, 5), (6, 3), (7, 3), (9, 1), (5, 10), (10, 4)],\n    5: [(0, 6), (6, 5), (7, 10), (1, 5), (8, 10), (9, 6), (10, 2)],\n    10: [(0, 9), (3, 10), (6, 4), (7, 1), (8, 4), (5, 2)],\n    9: [(3, 5), (6, 7), (7, 4), (8, 1), (5, 6)]\n}\n\nprint(dijkstra(graph, 2, 0))\n```"}, "222": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    4: [(2, 1), (9, 7)],\n    2: [(4, 1), (8, 7)],\n    9: [(4, 7), (6, 10)],\n    8: [(2, 7), (0, 7)],\n    6: [(9, 10)],\n    0: [(8, 7), (3, 8)],\n    3: [(0, 8), (5, 10)],\n    5: [(3, 10), (1, 6)],\n    10: [(7, 7), (11, 4)],\n    7: [(10, 7), (1, 3)],\n    11: [(10, 4), (1, 5)],\n    1: [(7, 3), (11, 5), (5, 6)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 4 to node 6\nshortest_path_length = dijkstra(graph, 4, 6)\nprint(shortest_path_length)\n```"}, "223": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(1, 2), (7, 5), (5, 6), (6, 2), (4, 8)],\n    1: [(3, 2), (2, 10), (0, 10), (7, 3), (6, 1), (4, 9)],\n    7: [(3, 5), (1, 3), (2, 7), (5, 7), (6, 10), (4, 10)],\n    5: [(3, 6), (7, 7), (2, 9), (0, 10), (6, 1), (4, 9)],\n    6: [(3, 2), (1, 1), (7, 10), (5, 1), (2, 10), (0, 9), (4, 7)],\n    4: [(3, 8), (1, 9), (7, 10), (5, 9), (6, 7), (2, 3), (0, 2)],\n    2: [(1, 10), (7, 7), (5, 9), (6, 10), (4, 3), (0, 5)],\n    0: [(1, 10), (5, 10), (6, 9), (4, 2), (2, 5)]\n}\n\nprint(dijkstra(graph, 4, 6))\n```"}, "224": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    13: [(2, 6), (10, 2), (11, 10), (1, 4), (12, 7)],\n    2: [(13, 6), (9, 10), (3, 2), (11, 2)],\n    10: [(13, 2), (11, 6), (1, 4)],\n    11: [(13, 10), (2, 2), (10, 6), (0, 6)],\n    1: [(13, 4), (10, 4), (14, 10), (4, 5)],\n    12: [(13, 7), (9, 4), (6, 9), (4, 6)],\n    9: [(2, 10), (12, 4), (0, 1), (5, 9), (6, 9)],\n    3: [(2, 2), (5, 5), (8, 7), (7, 8), (0, 9)],\n    0: [(11, 6), (9, 1), (3, 9), (8, 7), (6, 6)],\n    14: [(1, 10), (6, 7), (4, 10)],\n    4: [(1, 5), (12, 6), (5, 10), (14, 10)],\n    6: [(12, 9), (9, 9), (0, 6), (5, 4), (14, 7)],\n    5: [(9, 9), (3, 5), (4, 10), (6, 4)],\n    8: [(3, 7), (0, 7), (7, 6)],\n    7: [(3, 8), (8, 6)]\n}\n\nstart_node = 7\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "225": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(2, 5), (1, 2), (4, 1), (0, 5), (7, 3), (5, 6)],\n    2: [(8, 5), (1, 7), (4, 8), (0, 10), (7, 4)],\n    1: [(8, 2), (2, 7), (4, 10), (0, 4), (6, 3), (3, 8), (7, 5)],\n    4: [(8, 1), (2, 8), (1, 10), (6, 9), (3, 9), (7, 4), (5, 8)],\n    0: [(8, 5), (2, 10), (1, 4), (3, 6), (5, 1)],\n    7: [(8, 3), (2, 4), (1, 5), (4, 4), (6, 3)],\n    5: [(8, 6), (4, 8), (0, 1), (3, 7)],\n    6: [(1, 3), (4, 9), (7, 3)],\n    3: [(1, 8), (4, 9), (0, 6), (5, 7)]\n}\n\nresult = dijkstra(graph, 0, 1)\nprint(result)\n```"}, "226": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(3, 2), (0, 4)],\n    3: [(8, 2), (4, 10)],\n    0: [(8, 4), (5, 10), (1, 5)],\n    4: [(3, 10)],\n    5: [(0, 10), (6, 3), (2, 5)],\n    1: [(0, 5)],\n    6: [(5, 3), (7, 3)],\n    7: [(6, 3)],\n    2: [(5, 5), (9, 9)],\n    9: [(2, 9)]\n}\n\nshortest_path_length = dijkstra(graph, 8, 5)\nprint(shortest_path_length)\n```"}, "227": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(10, 8), (7, 6), (6, 5), (14, 1), (5, 4), (2, 10), (11, 7), (0, 1), (3, 6), (8, 3), (4, 9), (9, 8)],\n    10: [(1, 8), (7, 3), (14, 1), (2, 5), (11, 7), (0, 8), (3, 5), (12, 6), (8, 7), (4, 3)],\n    7: [(1, 6), (10, 3), (6, 9), (14, 1), (5, 10), (2, 10), (11, 6), (0, 1), (3, 5), (8, 1), (4, 6), (13, 9), (9, 1)],\n    6: [(1, 5), (7, 9), (14, 1), (5, 6), (11, 9), (0, 9), (3, 1), (4, 2), (13, 3), (9, 5)],\n    14: [(1, 1), (10, 1), (7, 1), (6, 1), (5, 4), (11, 9), (12, 6), (8, 4), (4, 8), (13, 4), (9, 9)],\n    5: [(1, 4), (7, 10), (6, 6), (14, 4), (2, 5), (0, 3), (3, 6), (12, 9), (8, 7), (4, 2), (9, 5)],\n    2: [(1, 10), (10, 5), (7, 10), (5, 5), (11, 7), (0, 2), (3, 7), (12, 4), (8, 3), (4, 5), (13, 9), (9, 9)],\n    11: [(1, 7), (10, 7), (7, 6), (6, 9), (14, 9), (2, 7), (0, 4), (12, 1), (8, 6), (13, 10), (9, 4)],\n    0: [(1, 1), (10, 8), (7, 1), (6, 9), (5, 3), (2, 2), (11, 4), (12, 6), (4, 10)],\n    3: [(1, 6), (10, 5), (7, 5), (6, 1), (5, 6), (2, 7), (12, 9), (4, 5), (13, 3)],\n    8: [(1, 3), (10, 7), (7, 1), (14, 4), (5, 7), (2, 3), (11, 6), (12, 4), (4, 7), (9, 2)],\n    4: [(1, 9), (10, 3), (7, 6), (6, 2), (14, 8), (5, 2), (2, 5), (0, 10), (3, 5), (8, 7), (9, 10)],\n    9: [(1, 8), (7, 1), (6, 5), (14, 9), (5, 5), (2, 9), (11, 4), (8, 2), (4, 10), (12, 7)],\n    12: [(10, 6), (14, 6), (5, 9), (2, 4), (11, 1), (0, 6), (3, 9), (8, 4), (9, 7), (13, 3)],\n    13: [(7, 9), (6, 3), (14, 4), (2, 9), (11, 10), (3, 3), (12, 3)]\n}\n\nprint(dijkstra(graph, 5, 8))\n```"}, "228": {"gpt4": "```python\nimport heapq\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [(7, 6), (1, 7)],\n    1: [(5, 6), (6, 8)],\n    5: [(0, 7)],\n    6: [(4, 7), (5, 5), (8, 5)],\n    2: [(6, 2), (4, 6), (7, 2), (5, 1), (8, 6)],\n    4: [(1, 5), (5, 10), (2, 1)],\n    8: [(3, 5), (2, 9), (4, 10), (0, 1)],\n    0: [(3, 2), (4, 4), (7, 2), (1, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 0 to node 5\nshortest_path_length = dijkstra(graph, 0, 5)\nprint(shortest_path_length)\n```"}, "229": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(1, 9), (0, 4)],\n    1: [(5, 9), (6, 2)],\n    0: [(5, 4), (3, 8)],\n    6: [(1, 2), (7, 6)],\n    3: [(0, 8), (2, 6)],\n    7: [(6, 6), (4, 2)],\n    8: [(2, 6), (4, 3)],\n    2: [(8, 6), (3, 6)],\n    4: [(8, 3), (7, 2)]\n}\n\nstart_node = 7\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "230": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(7, 9), (2, 7), (9, 6), (1, 9), (4, 6), (3, 6)],\n    7: [(8, 9), (4, 5), (3, 7)],\n    2: [(8, 7), (6, 7), (1, 10), (4, 1)],\n    9: [(8, 6), (0, 2), (3, 5)],\n    1: [(8, 9), (2, 10), (0, 5), (3, 7)],\n    4: [(8, 6), (7, 5), (2, 1), (0, 3), (5, 6), (3, 4)],\n    3: [(8, 6), (7, 7), (9, 5), (1, 7), (4, 4), (6, 6), (0, 3), (5, 4)],\n    6: [(2, 7), (3, 6), (5, 6)],\n    0: [(9, 2), (1, 5), (4, 3), (3, 3)],\n    5: [(4, 6), (3, 4), (6, 6)]\n}\n\nstart_node = 1\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "231": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (8, 6), (6, 2)],\n    1: [(2, 2), (0, 1)],\n    2: [(1, 2), (7, 10), (9, 3), (5, 2), (3, 6), (4, 1)],\n    3: [(2, 6), (10, 1)],\n    4: [(2, 1), (6, 4)],\n    5: [(2, 2), (9, 5), (8, 4), (6, 1)],\n    6: [(7, 6), (5, 1), (4, 4), (0, 2), (8, 6), (10, 10)],\n    7: [(2, 10), (6, 6)],\n    8: [(5, 4), (0, 6), (6, 6), (10, 1)],\n    9: [(2, 3), (5, 5)],\n    10: [(3, 1), (6, 10), (8, 1)]\n}\n\nstart_node = 10\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "232": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(2, 1), (0, 1), (9, 7), (6, 9)],\n    2: [(8, 8), (4, 1), (5, 10), (1, 3), (7, 2)],\n    0: [(3, 2), (4, 2), (7, 5)],\n    9: [(3, 1), (4, 7), (5, 6), (1, 8)],\n    6: [(0, 2)],\n    8: [(3, 7), (4, 9), (5, 3), (1, 7), (10, 5)],\n    4: [(5, 9), (1, 4), (9, 1), (3, 10)],\n    5: [(7, 10), (2, 1), (0, 7), (10, 3), (3, 7)],\n    1: [(7, 10), (9, 1), (10, 9), (4, 4)],\n    3: [(7, 6), (2, 2), (9, 4), (8, 1), (6, 9)],\n    10: [(8, 8), (5, 3), (0, 10), (9, 4)]\n}\n\nstart_node = 9\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "233": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (8, 2), (7, 8)],\n    2: [(3, 10), (1, 9), (8, 3), (9, 8), (5, 9)],\n    8: [(0, 10), (11, 1), (6, 7)],\n    7: [(11, 3), (2, 2), (1, 2), (4, 8), (9, 7)],\n    3: [(1, 8), (8, 2), (10, 5), (11, 5), (6, 5)],\n    1: [(4, 9), (0, 1), (6, 4), (2, 7), (3, 8)],\n    9: [(7, 8), (0, 3), (11, 9), (6, 3), (1, 4), (4, 1)],\n    5: [(3, 1), (7, 6)],\n    11: [(2, 3), (4, 2), (7, 2)],\n    6: [(5, 7), (8, 8), (10, 5), (9, 10), (0, 6), (11, 6)],\n    4: [(0, 7), (6, 7), (2, 4)],\n    10: [(11, 5), (5, 2), (3, 4)]\n}\n\nstart_node = 1\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "234": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    8: [(4, 4), (11, 8), (2, 7), (7, 1), (10, 6), (5, 1), (6, 10)],\n    4: [(8, 4), (10, 4), (0, 6), (1, 10), (11, 2)],\n    11: [(8, 8), (4, 2), (9, 1), (7, 1), (2, 9), (5, 2), (3, 9), (0, 4)],\n    2: [(8, 7), (11, 9)],\n    7: [(8, 1), (11, 1)],\n    10: [(8, 6), (4, 4)],\n    5: [(8, 1), (11, 2), (6, 9)],\n    6: [(8, 10), (5, 9), (1, 5)],\n    0: [(4, 6), (11, 4)],\n    1: [(4, 10), (6, 5)],\n    9: [(11, 1), (3, 10)],\n    3: [(11, 9), (9, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If the current distance is greater than the recorded shortest distance, skip\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to the neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate the shortest path from node 4 to node 0\nshortest_path_length = dijkstra(graph, 4, 0)\nprint(shortest_path_length)\n```"}, "235": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 7), (9, 7), (10, 8), (6, 8), (5, 1), (8, 2), (4, 10), (1, 9)],\n    1: [(0, 9), (8, 3), (7, 2), (9, 3), (10, 4), (5, 7), (11, 5), (4, 4)],\n    2: [(3, 3), (9, 4), (11, 7)],\n    3: [(0, 7), (8, 6), (7, 5), (2, 3)],\n    4: [(0, 10), (8, 1), (5, 8), (1, 4), (11, 4)],\n    5: [(0, 1), (8, 4), (9, 10), (10, 9), (11, 4), (4, 8), (1, 7)],\n    6: [(0, 8), (8, 2), (7, 1), (9, 5)],\n    7: [(3, 5), (9, 6), (10, 4), (6, 1), (1, 2)],\n    8: [(3, 6), (0, 2), (9, 10), (10, 1), (6, 2), (5, 4), (11, 3), (4, 1), (1, 3)],\n    9: [(0, 7), (8, 10), (7, 6), (2, 4), (10, 1), (6, 5), (5, 10), (1, 3)],\n    10: [(0, 8), (8, 1), (7, 4), (9, 1), (5, 9), (11, 6), (1, 4)],\n    11: [(8, 3), (2, 7), (10, 6), (5, 4), (1, 5), (4, 4)]\n}\n\nprint(dijkstra(graph, 9, 10))\n```"}, "236": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    3: [(1, 4), (6, 8), (2, 2)],\n    1: [(5, 8), (0, 2), (3, 8)],\n    6: [(1, 2)],\n    5: [(7, 2)],\n    0: [(4, 7)],\n    7: [(6, 3), (5, 3)],\n    4: [(2, 4), (3, 10), (7, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 6)\nprint(shortest_path_length)\n```"}, "237": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    3: [(1, 6), (12, 9), (10, 10)],\n    1: [(4, 8), (12, 4), (9, 9), (5, 4), (11, 2), (7, 2)],\n    12: [(8, 5), (7, 9), (4, 9)],\n    10: [(2, 4), (5, 2), (11, 10), (8, 1), (6, 6), (1, 6), (4, 6), (12, 8)],\n    4: [(11, 2), (8, 6)],\n    9: [(5, 7), (3, 3), (4, 5), (12, 10), (0, 8), (10, 7), (2, 10)],\n    5: [(3, 9), (12, 8), (0, 1)],\n    11: [(8, 7), (1, 4), (12, 4), (10, 8), (2, 9), (3, 10)],\n    7: [(4, 10), (12, 10), (2, 10), (9, 1), (5, 5), (8, 1)],\n    8: [(7, 8), (1, 5), (4, 2), (9, 5), (5, 1), (11, 9)],\n    2: [(3, 3), (12, 8)],\n    6: [(7, 4), (1, 3), (4, 8), (12, 2), (9, 2), (8, 7)],\n    0: [(10, 9), (2, 4), (3, 2), (11, 1), (8, 6), (6, 6), (7, 6), (1, 7)]\n}\n\nstart_node = 9\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "238": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(8, 4), (9, 3), (12, 8), (10, 7)],\n    8: [(6, 4), (2, 4), (5, 9), (9, 1), (3, 4)],\n    9: [(6, 3), (8, 1), (10, 2), (2, 3)],\n    12: [(6, 8), (10, 4), (1, 9)],\n    10: [(6, 7), (9, 2), (12, 4), (3, 4), (1, 8)],\n    2: [(8, 4), (9, 3), (5, 1), (4, 4)],\n    5: [(8, 9), (2, 1), (11, 9), (13, 1)],\n    3: [(8, 4), (10, 4), (11, 1), (13, 2), (0, 9), (7, 10)],\n    1: [(12, 9), (10, 8), (4, 3), (0, 9)],\n    4: [(2, 4), (1, 3), (0, 2)],\n    11: [(5, 9), (3, 1), (7, 8)],\n    13: [(5, 1), (3, 2), (7, 1)],\n    0: [(3, 9), (1, 9), (7, 7), (4, 2)],\n    7: [(3, 10), (11, 8), (13, 1), (0, 7)]\n}\n\nprint(dijkstra(graph, 13, 12))\n```"}, "239": {"gpt4": "```python\nimport heapq\n\n# Define the graph as an adjacency list\ngraph = {\n    5: [(3, 9), (4, 8), (6, 6)],\n    4: [(10, 9), (7, 7), (9, 7), (5, 7), (8, 2)],\n    6: [(3, 6), (0, 6)],\n    10: [(9, 3), (4, 1), (6, 10)],\n    7: [(9, 9), (5, 3), (10, 6)],\n    9: [(6, 7), (10, 7)],\n    8: [(1, 3), (10, 7), (9, 8), (5, 5)],\n    0: [(7, 6), (9, 8), (3, 9), (2, 6)],\n    1: [(6, 1), (10, 7), (7, 2), (3, 6)],\n    2: [(6, 2)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Calculate the shortest path from node 9 to node 5\nshortest_path_length = dijkstra(graph, 9, 5)\nprint(shortest_path_length)\n```"}, "240": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(0, 2), (1, 1), (4, 9)],\n    0: [(1, 8), (3, 6), (2, 9), (7, 10), (6, 10)],\n    1: [(5, 7), (0, 7)],\n    4: [(7, 10), (5, 3), (0, 3), (2, 9)],\n    3: [(4, 5), (7, 1), (6, 8), (0, 9), (1, 1)],\n    2: [(6, 3), (5, 9)],\n    6: [(3, 5), (2, 3)],\n    5: [(0, 4), (8, 7), (3, 9), (6, 1)],\n    8: [(6, 5), (5, 10)]\n}\n\nstart_node = 2\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "241": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(5, 10), (7, 10), (1, 5), (2, 5), (13, 7)],\n    5: [(1, 4), (13, 7), (3, 7), (0, 5), (8, 10)],\n    7: [(2, 5), (13, 5), (10, 2), (3, 5)],\n    1: [(11, 5), (6, 3), (8, 7), (4, 2)],\n    2: [(11, 9), (6, 1), (10, 4), (12, 3), (0, 10)],\n    13: [(0, 6), (8, 1), (9, 3), (5, 8), (7, 2), (1, 3)],\n    3: [(9, 10), (5, 9), (7, 8), (11, 8), (6, 1), (10, 8)],\n    0: [(9, 7), (1, 1), (12, 9)],\n    8: [(9, 4), (13, 9), (6, 4), (10, 10), (3, 4)],\n    10: [(0, 7), (8, 10), (4, 1), (9, 5), (1, 1), (2, 3), (13, 2)],\n    11: [(10, 4), (12, 7), (8, 3)],\n    6: [(12, 9), (5, 2), (2, 9), (13, 1)],\n    4: [(7, 10), (1, 6), (11, 8), (6, 7), (10, 10), (12, 5)],\n    12: [(0, 5), (4, 2), (5, 2), (7, 6), (11, 4), (6, 4), (10, 6)]\n}\n\nstart_node = 3\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "242": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(8, 2), (11, 10), (0, 5), (1, 7), (9, 1), (10, 10), (6, 1), (7, 3)],\n    8: [(2, 2), (5, 10), (0, 3), (3, 10), (1, 6), (4, 3), (9, 3), (10, 5), (7, 9)],\n    11: [(2, 10), (5, 5), (0, 9), (1, 10), (9, 7), (10, 4)],\n    0: [(2, 5), (8, 3), (11, 9), (5, 6), (1, 6), (9, 1), (6, 9), (7, 1)],\n    1: [(2, 7), (8, 6), (11, 10), (0, 6), (3, 5), (4, 2), (9, 8), (10, 2), (6, 10), (7, 5)],\n    9: [(2, 1), (8, 3), (11, 7), (0, 1), (1, 8), (3, 2), (4, 2), (6, 9), (7, 5)],\n    10: [(2, 10), (8, 5), (11, 4), (1, 2), (5, 5), (6, 8), (7, 4)],\n    6: [(2, 1), (0, 9), (1, 10), (9, 9), (10, 8), (5, 10), (3, 7)],\n    7: [(2, 3), (8, 9), (0, 1), (1, 5), (9, 5), (10, 4), (3, 6), (4, 7)],\n    5: [(8, 10), (11, 5), (0, 6), (10, 5), (6, 10), (3, 6), (4, 5)],\n    3: [(8, 10), (1, 5), (9, 2), (6, 7), (7, 6), (5, 6), (4, 4)],\n    4: [(8, 3), (1, 2), (9, 2), (7, 7), (5, 5), (3, 4)]\n}\n\nprint(dijkstra(graph, 7, 6))\n```"}, "243": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [],\n    1: [(3, 10), (5, 4)],\n    2: [(5, 6), (4, 10), (8, 10)],\n    3: [(0, 6), (1, 8)],\n    4: [(6, 6)],\n    5: [(4, 1), (7, 2)],\n    6: [(1, 5), (8, 5), (3, 10)],\n    7: [(5, 3)],\n    8: []\n}\n\nstart_node = 6\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "244": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(8, 3), (4, 1), (7, 9), (5, 9), (0, 1), (3, 8)],\n    8: [(4, 7), (6, 3)],\n    4: [(7, 1), (1, 7), (2, 2), (8, 7)],\n    7: [(1, 3), (0, 5), (3, 9), (6, 5), (8, 1)],\n    5: [(3, 8), (1, 2)],\n    0: [(5, 10)],\n    3: [(9, 6), (6, 3), (5, 3), (0, 5)],\n    6: [(5, 10), (0, 1), (2, 8), (3, 5), (9, 9)],\n    1: [(6, 8), (8, 2), (7, 6)],\n    2: [(7, 8), (1, 1)]\n}\n\nstart_node = 7\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "245": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    11: [(7, 10), (4, 3), (2, 6), (6, 5), (13, 7), (12, 6), (1, 1), (3, 8), (8, 5)],\n    7: [(11, 10), (10, 4), (5, 4), (6, 2), (4, 4), (3, 7)],\n    4: [(11, 3), (7, 4)],\n    2: [(11, 6), (5, 10), (13, 1), (3, 8), (12, 3)],\n    6: [(11, 5), (7, 2)],\n    13: [(11, 7), (2, 1)],\n    12: [(11, 6), (2, 3)],\n    1: [(11, 1), (3, 3), (10, 2), (8, 7)],\n    3: [(11, 8), (7, 7), (2, 8), (1, 3), (9, 10), (0, 9)],\n    8: [(11, 5), (1, 7)],\n    10: [(7, 4), (1, 2)],\n    5: [(7, 4), (2, 10), (9, 2)],\n    9: [(3, 10), (5, 2)],\n    0: [(3, 9)]\n}\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate shortest path from node 10 to node 3\nshortest_path_length = dijkstra(graph, 10, 3)\nprint(shortest_path_length)\n```"}, "246": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    13: [(12, 3), (6, 1), (11, 2), (4, 1), (5, 2)],\n    12: [(13, 3)],\n    6: [(13, 1), (3, 2), (8, 10), (2, 1), (7, 4)],\n    11: [(13, 2), (10, 2), (8, 1), (14, 9), (4, 8)],\n    4: [(13, 1), (11, 8), (8, 3), (9, 1), (14, 6), (5, 5), (7, 3)],\n    5: [(13, 2), (4, 5), (3, 4), (14, 9)],\n    3: [(6, 2), (5, 4), (14, 6), (7, 2)],\n    8: [(6, 10), (11, 1), (4, 3), (14, 5)],\n    2: [(6, 1)],\n    7: [(6, 4), (4, 3), (3, 2), (0, 5)],\n    10: [(11, 2)],\n    14: [(11, 9), (4, 6), (5, 9), (3, 6), (8, 5), (0, 8), (1, 9)],\n    9: [(4, 1), (0, 9), (1, 8)],\n    0: [(14, 8), (7, 5), (9, 9), (1, 6)],\n    1: [(14, 9), (9, 8), (0, 6)]\n}\n\nprint(dijkstra(graph, 8, 12))\n```"}, "247": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(10, 6), (5, 8), (0, 10), (3, 10), (11, 4), (1, 10), (8, 1), (6, 6)],\n    10: [(9, 6), (1, 2), (0, 4), (4, 2)],\n    5: [(9, 8), (1, 3), (7, 4), (2, 1)],\n    0: [(9, 10), (10, 4), (1, 2), (2, 1), (8, 6), (4, 4), (3, 3), (7, 9)],\n    3: [(9, 10), (0, 3), (1, 8), (6, 6)],\n    11: [(9, 4), (1, 8), (7, 4)],\n    1: [(9, 10), (10, 2), (5, 3), (0, 2), (3, 8), (11, 8), (6, 7), (7, 4)],\n    8: [(9, 1), (0, 6)],\n    6: [(9, 6), (3, 6), (1, 7), (4, 9)],\n    4: [(10, 2), (0, 4), (6, 9)],\n    7: [(5, 4), (0, 9), (11, 4), (1, 4)],\n    2: [(5, 1), (0, 1)]\n}\n\nstart_node = 3\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "248": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    13: [(10, 9), (6, 8), (0, 2), (4, 2)],\n    10: [(11, 6), (4, 9), (3, 9)],\n    6: [(12, 4), (7, 2), (13, 9), (3, 8), (10, 9)],\n    0: [(13, 5), (2, 9), (1, 1), (12, 2), (11, 10), (7, 5)],\n    4: [(2, 1), (5, 9), (11, 5)],\n    11: [(0, 10), (13, 2), (3, 2), (5, 8), (10, 6)],\n    12: [(8, 10), (1, 8), (5, 9)],\n    7: [(0, 6), (2, 8), (6, 3)],\n    2: [(1, 8), (5, 10), (6, 1), (12, 5)],\n    1: [(12, 6), (4, 8), (13, 8)],\n    5: [(0, 10), (13, 6), (3, 10), (2, 5)],\n    8: [(11, 5)],\n    9: [(4, 5), (10, 5)]\n}\n\nstart_node = 12\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "249": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    14: [(9, 1), (11, 4), (12, 6)],\n    9: [(4, 1), (11, 4), (10, 5), (3, 1)],\n    11: [(1, 10), (10, 10), (12, 8), (9, 6)],\n    12: [(14, 5), (5, 10), (2, 9)],\n    4: [(2, 4), (3, 3)],\n    10: [(14, 9), (9, 5), (13, 9), (5, 1), (6, 4)],\n    3: [(5, 5), (2, 2), (10, 6), (7, 4)],\n    1: [(10, 6), (14, 10), (3, 10), (9, 6), (4, 9), (13, 3)],\n    2: [(10, 5), (0, 7), (3, 7), (13, 1), (1, 8)],\n    7: [(14, 3), (6, 5)],\n    0: [(9, 10), (2, 7)],\n    13: [(14, 4)],\n    6: [(10, 7)],\n    8: [(2, 9), (10, 10), (5, 10), (1, 9)]\n}\n\nstart_node = 2\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "250": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(8, 1), (5, 5), (11, 2), (10, 3), (12, 8)],\n    8: [(2, 1), (13, 7), (11, 7), (10, 7), (3, 3), (6, 5), (4, 3)],\n    5: [(2, 5), (13, 8), (1, 2), (11, 3), (10, 4), (12, 4)],\n    11: [(2, 2), (8, 7), (5, 3), (14, 9), (3, 10)],\n    10: [(2, 3), (8, 7), (5, 4), (14, 1)],\n    12: [(2, 8), (5, 4), (3, 4), (6, 1)],\n    13: [(8, 7), (5, 8), (7, 9), (14, 9), (6, 4)],\n    3: [(8, 3), (11, 10), (12, 4), (7, 6), (0, 7), (1, 9)],\n    6: [(8, 5), (12, 1), (13, 4)],\n    4: [(8, 3), (7, 9)],\n    1: [(5, 2), (3, 9), (14, 7)],\n    14: [(11, 9), (10, 1), (13, 9), (1, 7), (9, 5)],\n    7: [(13, 9), (3, 6), (4, 9)],\n    0: [(3, 7)],\n    9: [(14, 5)]\n}\n\nstart_node = 14\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "251": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    11: [(5, 6), (6, 4)],\n    5: [(1, 6), (9, 1), (13, 9), (10, 7)],\n    6: [(0, 1), (4, 10), (12, 1), (10, 9), (5, 2), (3, 10), (7, 2), (9, 5)],\n    1: [(14, 4), (7, 3), (6, 6), (0, 4), (11, 9), (4, 4), (12, 8), (13, 8)],\n    9: [(12, 6), (2, 10), (13, 10), (14, 9)],\n    13: [(5, 9), (9, 1), (4, 1), (12, 3), (2, 4)],\n    10: [(5, 6), (7, 9), (9, 1), (0, 3), (8, 9), (11, 1), (4, 2)],\n    0: [(11, 2), (2, 10), (10, 7), (5, 8), (14, 9), (3, 6), (9, 7)],\n    4: [(12, 8), (2, 6), (1, 7), (9, 7), (0, 5), (8, 8)],\n    12: [(6, 4), (0, 8), (11, 3)],\n    3: [(13, 5), (10, 5)],\n    7: [(9, 1), (6, 9), (0, 2), (8, 9), (12, 7), (13, 6), (3, 10)],\n    2: [(13, 10), (5, 9), (4, 5), (12, 8)],\n    8: [(11, 4), (12, 1), (7, 9)],\n    14: [(7, 5), (4, 7), (2, 7), (13, 10), (10, 2), (5, 6)]\n}\n\nstart_node = 1\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "252": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(10, 4), (9, 2), (4, 4)],\n    10: [(8, 4), (3, 4), (2, 4), (6, 9)],\n    9: [(8, 2), (2, 1), (7, 10)],\n    4: [(8, 4), (5, 2), (11, 6), (6, 5), (1, 4)],\n    3: [(10, 4), (0, 10), (11, 9), (12, 1)],\n    2: [(10, 4), (9, 1), (0, 9), (12, 5)],\n    6: [(10, 9), (4, 5), (1, 9), (7, 1), (12, 5)],\n    7: [(9, 10), (6, 1), (1, 1)],\n    5: [(4, 2), (0, 7), (12, 6), (11, 7)],\n    11: [(4, 6), (3, 9), (0, 6), (5, 7)],\n    1: [(4, 4), (6, 9), (7, 1)],\n    0: [(3, 10), (2, 9), (5, 7), (12, 2), (11, 6)],\n    12: [(3, 1), (2, 5), (6, 5), (0, 2), (5, 6)]\n}\n\nstart_node = 7\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "253": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    10: [(0, 3), (2, 3), (5, 9), (7, 3), (1, 5), (8, 3), (9, 7)],\n    0: [(10, 3), (3, 8), (5, 5), (6, 8), (7, 7), (1, 2), (4, 2), (8, 6), (9, 6)],\n    2: [(10, 3), (3, 3), (5, 5), (7, 5), (4, 8), (8, 9), (9, 10)],\n    5: [(10, 9), (0, 5), (2, 5), (3, 8), (6, 8), (7, 1), (1, 1), (4, 5), (8, 6)],\n    7: [(10, 3), (0, 7), (2, 5), (5, 1), (3, 2), (6, 9), (1, 7), (4, 2), (8, 4), (9, 1)],\n    1: [(10, 5), (0, 2), (5, 1), (7, 7), (3, 5), (6, 8), (4, 8), (8, 3), (9, 2)],\n    8: [(10, 3), (0, 6), (2, 9), (5, 6), (7, 4), (1, 3), (4, 3), (9, 10)],\n    9: [(10, 7), (0, 6), (2, 10), (7, 1), (1, 2), (8, 10), (3, 10), (6, 7), (4, 6)],\n    3: [(0, 8), (2, 3), (5, 8), (7, 2), (1, 5), (9, 10), (6, 8)],\n    6: [(0, 8), (5, 8), (7, 9), (1, 8), (9, 7), (3, 8)],\n    4: [(0, 2), (2, 8), (5, 5), (7, 2), (1, 8), (8, 3), (9, 6)]\n}\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\n# Calculate shortest path from node 0 to node 2\nshortest_path_length = dijkstra(graph, 0, 2)\nprint(shortest_path_length)\n```"}, "254": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    6: [(3, 9), (1, 9), (5, 9)],\n    3: [(6, 9), (7, 10), (2, 9)],\n    1: [(6, 9), (0, 2), (4, 8)],\n    5: [(6, 9)],\n    7: [(3, 10), (2, 2)],\n    2: [(3, 9), (7, 2)],\n    0: [(1, 2)],\n    4: [(1, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 4 to node 3\nshortest_path_length = dijkstra(graph, 4, 3)\nprint(shortest_path_length)\n```"}, "255": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    6: [(1, 3), (7, 6), (5, 2), (4, 10)],\n    1: [(6, 3), (2, 6), (10, 5)],\n    7: [(6, 6), (9, 2)],\n    5: [(6, 2), (8, 7)],\n    4: [(6, 10), (13, 6)],\n    2: [(1, 6)],\n    10: [(1, 5), (8, 8), (12, 2)],\n    9: [(7, 2), (3, 10)],\n    8: [(5, 7), (10, 8)],\n    13: [(4, 6)],\n    12: [(10, 2)],\n    0: [(3, 7)],\n    3: [(0, 7), (9, 10), (11, 1)],\n    11: [(3, 1)]\n}\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\n# Calculate shortest path from node 2 to node 4\nshortest_path_length = dijkstra(graph, 2, 4)\nprint(shortest_path_length)\n```"}, "256": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    9: [(10, 9)],\n    10: [(9, 9), (5, 4)],\n    5: [(10, 4), (8, 5), (1, 6)],\n    8: [(5, 5), (4, 1), (12, 3), (2, 10)],\n    1: [(5, 6)],\n    4: [(8, 1), (3, 6)],\n    12: [(8, 3), (2, 10)],\n    2: [(8, 10), (12, 10), (13, 3)],\n    3: [(4, 6), (11, 7)],\n    13: [(2, 3), (14, 10), (0, 3)],\n    14: [(13, 10), (7, 4)],\n    7: [(14, 4)],\n    0: [(13, 3), (6, 4)],\n    6: [(0, 4)],\n    11: [(3, 7)]\n}\n\nstart_node = 10\nend_node = 13\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "257": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(6, 9), (5, 10), (1, 4), (11, 2), (13, 10)],\n    6: [(13, 5), (3, 3), (9, 4)],\n    5: [(3, 5), (2, 9)],\n    1: [(13, 9), (12, 1)],\n    11: [(8, 1), (0, 6)],\n    13: [(12, 10)],\n    3: [(12, 10), (1, 3), (13, 4)],\n    9: [(2, 5), (6, 6), (1, 7)],\n    2: [(12, 6), (11, 3), (3, 7), (7, 9), (9, 4)],\n    12: [(10, 4), (0, 3)],\n    8: [(10, 7), (3, 4), (9, 9), (1, 7), (11, 5)],\n    10: [(4, 1), (5, 2)],\n    7: [(2, 5), (12, 3), (1, 9)],\n    4: [(2, 10), (5, 10)]\n}\n\nstart_node = 12\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "258": {"gpt4": "```python\nimport heapq\n\n# Define the graph as an adjacency list\ngraph = {\n    3: [(14, 8)],\n    14: [(6, 7), (7, 7), (12, 2), (4, 6)],\n    6: [(11, 10), (4, 7), (9, 2), (5, 4), (2, 2)],\n    7: [(8, 4), (4, 4), (9, 2)],\n    12: [(11, 5)],\n    4: [(10, 6)],\n    11: [(8, 7), (3, 10)],\n    8: [(7, 7)],\n    9: [(2, 10), (1, 3), (0, 3)],\n    10: [(1, 2)],\n    2: [(0, 4)],\n    1: [(2, 10), (3, 8), (7, 9)],\n    0: [(6, 2), (7, 5), (1, 10)],\n    13: [(10, 1), (8, 5), (12, 4)],\n    5: [(8, 6), (14, 1)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Calculate the shortest path from node 10 to node 14\nshortest_path_length = dijkstra(graph, 10, 14)\nprint(shortest_path_length)\n```"}, "259": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    12: [(11, 3), (7, 10), (3, 2), (9, 1), (8, 9), (4, 3), (10, 10), (1, 3), (13, 4)],\n    11: [(12, 3)],\n    7: [(12, 10)],\n    3: [(12, 2)],\n    9: [(12, 1)],\n    8: [(12, 9)],\n    4: [(12, 3)],\n    10: [(12, 10)],\n    1: [(12, 3)],\n    13: [(12, 4), (14, 10), (2, 6)],\n    14: [(13, 10), (6, 3), (0, 10), (5, 8)],\n    2: [(13, 6)],\n    6: [(14, 3)],\n    0: [(14, 10)],\n    5: [(14, 8)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 5 to node 2\nshortest_path_length = dijkstra(graph, 5, 2)\nprint(shortest_path_length)\n```"}, "260": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(1, 2), (3, 8)],\n    1: [(7, 4), (0, 2), (2, 5)],\n    2: [(1, 5), (6, 10)],\n    3: [(0, 8), (4, 3)],\n    4: [(3, 3)],\n    5: [(7, 9), (6, 6)],\n    6: [(2, 10), (5, 6)],\n    7: [(1, 4), (5, 9)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 2)\nprint(shortest_path_length)\n```"}, "261": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(3, 4), (0, 6), (10, 6), (2, 6), (7, 6), (1, 1)],\n    3: [(8, 4), (9, 7), (2, 2), (10, 3)],\n    0: [(8, 6), (6, 9), (4, 7), (5, 7)],\n    10: [(8, 6), (3, 3), (2, 5), (9, 1)],\n    2: [(8, 6), (3, 2), (10, 5), (1, 5)],\n    7: [(8, 6), (4, 3), (1, 5)],\n    1: [(8, 1), (2, 5), (7, 5)],\n    9: [(3, 7), (10, 1), (6, 10), (5, 8), (11, 9)],\n    6: [(0, 9), (9, 10), (5, 4), (11, 5)],\n    4: [(0, 7), (7, 3), (11, 9)],\n    5: [(0, 7), (9, 8), (6, 4), (11, 7)],\n    11: [(9, 9), (6, 5), (4, 9), (5, 7)]\n}\n\nprint(dijkstra(graph, 10, 7))\n```"}, "262": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    4: [(7, 4), (3, 3)],\n    7: [(4, 4)],\n    3: [(4, 3), (0, 7), (2, 4)],\n    0: [(3, 7), (6, 6), (5, 5)],\n    2: [(3, 4), (1, 5)],\n    6: [(0, 6)],\n    5: [(0, 5)],\n    1: [(2, 5)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue\n    queue = [(0, start)]\n    # Distances dictionary\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    \n    return distances[end]\n\n# Calculate shortest path from node 0 to node 2\nshortest_path_length = dijkstra(graph, 0, 2)\nprint(shortest_path_length)\n```"}, "263": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: [(9, 10), (2, 1), (8, 6)],\n    9: [(10, 10), (4, 4)],\n    2: [(10, 1), (6, 9), (3, 1)],\n    8: [(10, 6)],\n    4: [(9, 4), (5, 1), (6, 10)],\n    6: [(2, 9), (4, 10)],\n    3: [(2, 1)],\n    5: [(4, 1), (7, 3)],\n    7: [(5, 3), (1, 9)],\n    1: [(7, 9), (0, 5)],\n    0: [(1, 5)]\n}\n\nstart_node = 2\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "264": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    8: [(3, 1), (2, 10), (4, 2), (1, 9), (7, 3)],\n    3: [(1, 7), (5, 2)],\n    2: [(0, 8), (6, 6), (8, 4)],\n    4: [(5, 3), (0, 4), (3, 7)],\n    1: [(5, 9), (3, 10)],\n    7: [(2, 4), (4, 8), (1, 2), (5, 8), (0, 6)],\n    5: [(7, 6), (3, 10)],\n    0: [(6, 5), (8, 7), (3, 3)],\n    6: [(8, 6), (3, 7), (5, 3), (0, 2)]\n}\n\nstart_node = 6\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "265": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(7, 8), (11, 10), (1, 5), (2, 7)],\n    7: [(6, 4), (10, 6)],\n    11: [(0, 7), (1, 7), (2, 8), (3, 10)],\n    1: [(6, 2), (11, 7), (10, 8), (0, 8)],\n    2: [(11, 5)],\n    6: [(8, 10)],\n    10: [(8, 1), (11, 5)],\n    0: [(4, 1), (2, 2), (3, 3)],\n    3: [(8, 3), (11, 7), (1, 6), (2, 8)],\n    9: [(1, 1), (8, 5)],\n    4: [(8, 10), (7, 8), (11, 9)],\n    5: [(7, 7), (1, 1)]\n}\n\nstart_node = 9\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "266": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(0, 5), (3, 6), (2, 5), (1, 10)],\n    0: [(4, 10), (6, 8), (3, 4), (1, 2)],\n    3: [(7, 3), (10, 10), (8, 8), (5, 3)],\n    2: [(1, 10), (9, 3), (11, 6), (3, 3), (10, 10)],\n    1: [(9, 7), (5, 3), (3, 10), (10, 5)],\n    4: [(11, 1), (1, 1), (8, 6), (0, 2), (9, 3)],\n    6: [(11, 4), (3, 1), (2, 3), (1, 1), (8, 5)],\n    7: [(10, 10), (8, 2), (5, 8)],\n    5: [(7, 1), (2, 8)],\n    9: [(5, 4), (6, 8), (3, 9)],\n    11: [(10, 9), (9, 4)]\n}\n\nstart_node = 7\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "267": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(0, 1), (6, 4), (1, 10)],\n    0: [(2, 1), (6, 9)],\n    6: [(2, 4), (0, 9), (3, 9)],\n    1: [(2, 10), (5, 3)],\n    3: [(6, 9)],\n    5: [(1, 3), (8, 8)],\n    4: [(8, 1), (7, 10)],\n    8: [(4, 1), (5, 8)],\n    7: [(4, 10)]\n}\n\nstart_node = 5\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "268": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    2: [(3, 10), (8, 1), (7, 10), (0, 2), (5, 10)],\n    3: [(2, 10), (1, 10), (0, 7), (5, 2)],\n    8: [(2, 1), (6, 2), (4, 4), (0, 8)],\n    7: [(2, 10), (6, 3)],\n    0: [(2, 2), (3, 7), (8, 8)],\n    5: [(2, 10), (3, 2), (6, 10), (1, 5)],\n    1: [(3, 10), (5, 5), (6, 4)],\n    6: [(8, 2), (7, 3), (5, 10), (1, 4)],\n    4: [(8, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate shortest path from node 1 to node 7\nshortest_path_length = dijkstra(graph, 1, 7)\nprint(shortest_path_length)\n```"}, "269": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(3, 9), (6, 4), (4, 7)],\n    3: [(7, 7), (5, 5), (0, 9), (1, 4)],\n    6: [(2, 4)],\n    4: [(8, 10), (1, 5), (5, 10)],\n    7: [(5, 5), (4, 2), (0, 6), (2, 5)],\n    5: [(4, 2), (0, 5), (2, 6), (8, 10), (7, 5)],\n    0: [(6, 4)],\n    1: [(2, 5)],\n    2: [(1, 8)]\n}\n\nprint(dijkstra(graph, 5, 6))\n```"}, "270": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    9: [(8, 6), (0, 6), (10, 9), (3, 7)],\n    8: [(9, 6), (2, 9)],\n    0: [(9, 6), (5, 6)],\n    10: [(9, 9), (1, 9)],\n    3: [(9, 7), (6, 9)],\n    2: [(8, 9), (7, 7)],\n    5: [(0, 6)],\n    1: [(10, 9), (7, 9)],\n    6: [(3, 9)],\n    7: [(2, 7), (1, 9), (11, 7)],\n    11: [(7, 7), (4, 10)],\n    4: [(11, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 9 to node 5\nshortest_path_length = dijkstra(graph, 9, 5)\nprint(shortest_path_length)\n```"}, "271": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    10: {7: 3, 9: 3, 4: 5, 6: 6, 3: 2, 0: 6, 12: 2, 13: 8, 11: 9, 1: 1, 5: 6},\n    7: {10: 3, 4: 7, 6: 8, 0: 8, 12: 2, 13: 7, 5: 3},\n    9: {10: 3, 4: 1, 3: 8, 0: 8, 8: 2, 12: 9},\n    4: {10: 5, 7: 7, 9: 1, 6: 10, 3: 1, 12: 1, 13: 2, 11: 10, 1: 9, 5: 4},\n    6: {10: 6, 7: 8, 4: 10, 3: 1, 0: 4, 12: 3, 11: 8, 1: 3, 5: 8, 2: 2},\n    3: {10: 2, 9: 8, 4: 1, 6: 1, 8: 10, 12: 5, 11: 10, 1: 7, 2: 4},\n    0: {10: 6, 7: 8, 9: 8, 6: 4, 8: 8, 12: 7, 13: 4, 5: 4, 2: 4},\n    12: {10: 2, 7: 2, 9: 9, 4: 1, 6: 3, 3: 5, 0: 7, 8: 3, 13: 6, 11: 6, 5: 9, 2: 7},\n    13: {10: 8, 7: 7, 4: 2, 0: 4, 12: 6, 8: 3, 5: 6, 2: 3},\n    11: {10: 9, 4: 10, 6: 8, 3: 10, 12: 6, 8: 9, 1: 7, 5: 7, 2: 4},\n    1: {10: 1, 4: 9, 6: 3, 3: 7, 11: 7, 8: 3, 2: 2},\n    5: {10: 6, 7: 3, 4: 4, 6: 8, 0: 4, 12: 9, 13: 6, 11: 7, 8: 9},\n    8: {9: 2, 3: 10, 0: 8, 12: 3, 13: 3, 11: 9, 1: 3, 5: 9, 2: 6},\n    2: {6: 2, 3: 4, 0: 4, 12: 7, 13: 3, 11: 4, 1: 2, 8: 6}\n}\n\nstart_node = 8\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "272": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 5), (7, 2), (6, 5), (12, 5), (2, 7)],\n    13: [(0, 5), (2, 7), (8, 1), (7, 7)],\n    7: [(0, 2), (13, 7), (12, 1)],\n    6: [(0, 5), (5, 8), (12, 8)],\n    12: [(0, 5), (7, 1), (6, 8), (5, 6)],\n    2: [(0, 7), (13, 7), (3, 10), (11, 3)],\n    8: [(13, 1), (3, 7), (9, 10)],\n    5: [(6, 8), (12, 6), (4, 5), (10, 10)],\n    3: [(2, 10), (8, 7), (1, 7), (9, 7)],\n    11: [(2, 3), (4, 6), (14, 6), (1, 6), (9, 4)],\n    9: [(8, 10), (10, 7), (11, 4), (1, 6), (3, 7)],\n    4: [(5, 5), (14, 3), (10, 8), (11, 6)],\n    10: [(5, 10), (4, 8), (14, 9), (9, 7)],\n    14: [(4, 3), (10, 9), (11, 6), (1, 7)],\n    1: [(14, 7), (11, 6), (3, 7), (9, 6)]\n}\n\nresult = dijkstra(graph, 9, 6)\nprint(result)\n```"}, "273": {"gpt4": "```python\nimport heapq\n\n# Define the graph as an adjacency list\ngraph = {\n    13: [(10, 9)],\n    10: [(9, 1)],\n    9: [(2, 1)],\n    8: [(5, 6), (1, 6)],\n    5: [(0, 2), (2, 4), (8, 8)],\n    1: [(10, 7), (12, 1)],\n    2: [(6, 7), (4, 10), (5, 2)],\n    12: [(1, 5), (5, 3), (0, 2)],\n    6: [(1, 3), (13, 9), (9, 2)],\n    3: [(8, 6)],\n    7: [(6, 4)],\n    11: [(2, 6), (4, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 7 to node 1\nshortest_path_length = dijkstra(graph, 7, 1)\nprint(shortest_path_length)\n```"}, "274": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(7, 6), (0, 10), (2, 9), (6, 10)],\n    7: [(1, 6), (3, 10), (2, 5)],\n    0: [(1, 10), (4, 4)],\n    2: [(1, 9), (7, 5), (3, 6), (4, 4), (5, 9), (6, 2)],\n    6: [(1, 10), (2, 2), (5, 7)],\n    3: [(7, 10), (2, 6), (4, 7), (5, 9)],\n    4: [(0, 4), (2, 4), (3, 7)],\n    5: [(2, 9), (6, 7), (3, 9)]\n}\n\nstart_node = 3\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "275": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(4, 8)],\n    4: [(1, 10), (3, 9)],\n    1: [(2, 10)],\n    3: [(8, 4), (0, 8), (6, 7), (1, 2)],\n    7: [(8, 8), (4, 6)],\n    8: [(4, 2), (5, 4), (1, 2), (3, 10)],\n    5: [(6, 3), (3, 6), (8, 1)],\n    2: [(0, 3), (7, 5)],\n    6: [(0, 3)]\n}\n\n# Calculate shortest path from node 2 to node 3\nshortest_path_length = dijkstra(graph, 2, 3)\nprint(shortest_path_length)\n```"}, "276": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    \n    return distances[end]\n\ngraph = {\n    12: [(11, 8), (8, 9), (1, 8), (7, 3), (6, 8), (0, 10), (9, 5)],\n    11: [(8, 7), (1, 7), (4, 5), (7, 5)],\n    8: [(3, 5), (4, 3)],\n    1: [(4, 6), (0, 2), (9, 4), (11, 4)],\n    7: [(0, 3), (2, 3), (8, 5)],\n    6: [(0, 5), (9, 6), (8, 6), (10, 7), (7, 1)],\n    0: [(11, 3), (2, 2), (8, 9), (1, 5), (6, 2)],\n    9: [(7, 4)],\n    4: [(6, 1), (0, 5), (8, 1), (10, 2), (3, 10), (1, 10)],\n    3: [(0, 9), (12, 2), (5, 6), (11, 1), (2, 1), (8, 2), (10, 7)],\n    2: [(8, 8), (10, 9), (7, 10), (6, 2), (0, 2), (11, 5)],\n    10: [(1, 3), (4, 6), (7, 9), (0, 6), (12, 4), (8, 5)],\n    5: [(11, 7), (8, 6), (3, 2), (6, 3), (0, 10)]\n}\n\nstart_node = 0\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "277": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    8: [(11, 3), (3, 9), (1, 10)],\n    11: [(8, 3), (6, 7), (2, 2)],\n    3: [(8, 9), (13, 1), (4, 5), (10, 8)],\n    1: [(8, 10), (0, 8)],\n    6: [(11, 7), (4, 6), (2, 1), (0, 1)],\n    2: [(11, 2), (4, 5), (7, 2), (9, 10), (6, 1), (0, 9)],\n    13: [(3, 1), (4, 1), (10, 3)],\n    4: [(3, 5), (13, 1), (6, 6), (2, 5)],\n    10: [(3, 8), (13, 3), (5, 1)],\n    0: [(1, 8), (14, 8), (2, 9), (6, 1)],\n    5: [(10, 1), (14, 10)],\n    12: [(7, 3)],\n    7: [(12, 3), (14, 9), (2, 2)],\n    14: [(7, 9), (5, 10), (0, 8)],\n    9: [(2, 10)]\n}\n\nstart_node = 12\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "278": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 8), (2, 7)],\n    1: [(5, 4)],\n    2: [(5, 8), (7, 9), (3, 7), (4, 1), (0, 7)],\n    3: [(5, 10), (2, 7)],\n    4: [(5, 4), (2, 1)],\n    5: [(6, 7), (7, 9), (3, 10), (4, 4), (2, 8), (0, 8), (1, 4)],\n    6: [(5, 7), (7, 3)],\n    7: [(5, 9), (6, 3), (2, 9)]\n}\n\nprint(dijkstra(graph, 0, 3))\n```"}, "279": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    1: [(4, 4), (0, 5), (3, 4), (2, 4), (6, 9), (7, 6), (5, 10)],\n    4: [(1, 4), (6, 6)],\n    0: [(1, 5), (5, 8), (7, 1)],\n    3: [(1, 4), (7, 3)],\n    2: [(1, 4), (6, 4)],\n    6: [(1, 9), (4, 6), (2, 4), (7, 4)],\n    7: [(1, 6), (0, 1), (3, 3), (6, 4), (8, 1)],\n    5: [(1, 10), (0, 8)],\n    8: [(7, 1)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances[end]\n\n# Calculate the shortest path from node 2 to node 7\nshortest_path_length = dijkstra(graph, 2, 7)\nprint(shortest_path_length)\n```"}, "280": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(2, 8), (1, 6), (7, 5), (5, 6), (6, 7)],\n    2: [(4, 8), (1, 10), (7, 5), (3, 5), (6, 8)],\n    1: [(4, 6), (2, 10), (0, 9), (7, 9), (5, 6), (6, 9)],\n    7: [(4, 5), (2, 5), (1, 9), (0, 10), (5, 3)],\n    5: [(4, 6), (1, 6), (7, 3), (3, 6)],\n    6: [(4, 7), (2, 8), (1, 9), (0, 3)],\n    3: [(2, 5), (5, 6)],\n    0: [(1, 9), (7, 10), (6, 3)]\n}\n\nprint(dijkstra(graph, 2, 0))\n```"}, "281": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    10: [(5, 3), (2, 8)],\n    5: [(11, 2), (7, 2), (6, 10)],\n    2: [(8, 10), (9, 8), (5, 8)],\n    11: [(7, 7), (3, 9), (1, 1), (9, 7)],\n    7: [(4, 1)],\n    8: [(9, 1), (3, 9)],\n    9: [(5, 4), (10, 4), (3, 4), (6, 5)],\n    3: [(8, 10), (5, 1), (7, 4), (10, 1)],\n    4: [(0, 9), (5, 8), (7, 4), (10, 8), (3, 6)],\n    1: [(4, 10), (9, 2), (5, 1), (11, 2), (7, 3)],\n    0: [(9, 8), (6, 7), (4, 6)]\n}\n\nstart_node = 3\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "282": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(3, 1), (2, 5), (9, 2)],\n    3: [(1, 1), (12, 10), (11, 3), (0, 5), (8, 9)],\n    2: [(1, 5), (7, 9), (5, 7), (9, 8)],\n    9: [(1, 2), (2, 8), (7, 9), (4, 8)],\n    12: [(3, 10), (10, 7), (5, 8), (13, 6)],\n    11: [(3, 3), (0, 1), (7, 8), (8, 5)],\n    0: [(3, 5), (11, 1), (13, 3), (7, 5), (10, 2)],\n    8: [(3, 9), (11, 5), (5, 10)],\n    7: [(2, 9), (9, 9), (11, 8), (0, 5), (5, 9)],\n    5: [(2, 7), (12, 8), (8, 10), (10, 6), (7, 9)],\n    4: [(9, 8), (10, 10), (6, 2)],\n    10: [(12, 7), (0, 2), (6, 4), (5, 6), (4, 10)],\n    13: [(12, 6), (0, 3), (6, 2)],\n    6: [(10, 4), (13, 2), (4, 2)]\n}\n\nprint(dijkstra(graph, 11, 0))\n```"}, "283": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(6, 4), (4, 6), (5, 5), (0, 6), (3, 3), (1, 3), (2, 3), (8, 9), (9, 5)],\n    6: [(7, 4), (10, 9), (5, 8), (0, 9), (1, 10), (2, 9), (8, 6), (9, 8)],\n    4: [(7, 6), (10, 2), (5, 10), (0, 3), (3, 10), (1, 3), (2, 1), (9, 8)],\n    5: [(7, 5), (6, 8), (4, 10), (0, 9), (3, 8), (2, 10), (9, 4)],\n    0: [(7, 6), (6, 9), (4, 3), (5, 9), (10, 3), (3, 7), (2, 4), (8, 5)],\n    3: [(7, 3), (4, 10), (5, 8), (0, 7), (10, 7), (1, 8), (2, 2), (8, 5), (9, 5)],\n    1: [(7, 3), (6, 10), (4, 3), (3, 8), (9, 3)],\n    2: [(7, 3), (6, 9), (4, 1), (5, 10), (0, 4), (3, 2), (10, 2)],\n    8: [(7, 9), (6, 6), (0, 5), (3, 5), (10, 1), (9, 7)],\n    9: [(7, 5), (6, 8), (4, 8), (5, 4), (3, 5), (1, 3), (8, 7), (10, 5)],\n    10: [(6, 9), (4, 2), (0, 3), (3, 7), (2, 2), (8, 1), (9, 5)]\n}\n\nprint(dijkstra(graph, 9, 6))\n```"}, "284": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(6, 7)],\n    6: [(5, 7), (1, 5), (2, 1), (8, 5)],\n    1: [(6, 5)],\n    2: [(6, 1), (9, 3), (3, 2)],\n    8: [(6, 5), (0, 8)],\n    9: [(2, 3), (7, 1)],\n    3: [(2, 2), (0, 6)],\n    0: [(8, 8), (3, 6)],\n    7: [(9, 1), (4, 4)],\n    4: [(7, 4)]\n}\n\nstart_node = 8\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "285": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    4: [(9, 8), (6, 6), (5, 1), (0, 10), (1, 8)],\n    9: [(6, 5), (5, 7), (3, 4), (1, 9)],\n    6: [(4, 7), (8, 9)],\n    5: [(3, 8), (2, 6), (7, 6), (9, 8)],\n    0: [(1, 9), (4, 8), (8, 4), (7, 10), (3, 1)],\n    1: [(3, 3), (0, 9), (2, 4)],\n    3: [(0, 8), (1, 2), (4, 4)],\n    8: [(3, 9)],\n    2: [(1, 1), (4, 6), (5, 5), (0, 9)],\n    7: [(6, 9), (3, 7), (2, 7), (4, 1), (8, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 2)\nprint(shortest_path_length)\n```"}, "286": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(9, 5), (7, 10), (6, 9), (4, 1), (8, 6), (1, 8)],\n    9: [(5, 5), (3, 9)],\n    7: [(5, 10), (3, 4)],\n    6: [(5, 9), (0, 7)],\n    4: [(5, 1), (3, 9), (2, 1), (0, 1), (8, 4), (1, 2)],\n    8: [(5, 6), (4, 4)],\n    1: [(5, 8), (4, 2)],\n    3: [(9, 9), (7, 4), (4, 9), (2, 5), (0, 10)],\n    0: [(6, 7), (4, 1), (3, 10)],\n    2: [(4, 1), (3, 5)]\n}\n\nstart_node = 6\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "287": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    2: [(4, 9), (3, 9)],\n    4: [(2, 9), (5, 3)],\n    3: [(2, 9)],\n    5: [(4, 3), (0, 2), (1, 8)],\n    0: [(5, 2), (6, 3)],\n    1: [(5, 8), (7, 5)],\n    6: [(0, 3), (7, 4)],\n    7: [(6, 4), (1, 5)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 7)\nprint(shortest_path_length)\n```"}, "288": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(2, 8), (13, 2)],\n    2: [(7, 3), (0, 7), (5, 8), (8, 7)],\n    13: [(7, 9), (0, 2)],\n    7: [(0, 6), (11, 6), (10, 3), (9, 10)],\n    0: [(8, 3), (9, 4), (13, 6)],\n    5: [(12, 1), (0, 4), (6, 10)],\n    8: [(9, 5), (7, 10), (6, 4), (5, 5)],\n    12: [(1, 10), (8, 9), (2, 10)],\n    6: [(5, 5), (12, 4), (0, 7)],\n    11: [(1, 1), (2, 8), (4, 3), (3, 7), (7, 10)],\n    10: [(5, 6), (8, 9)],\n    4: [(0, 8), (14, 7), (5, 2), (2, 5)],\n    14: [(2, 8), (4, 10), (12, 4), (3, 10)]\n}\n\nstart_node = 4\nend_node = 12\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "289": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(8, 5), (4, 8), (0, 9), (12, 3), (9, 1)],\n    8: [(1, 5), (0, 5), (5, 10)],\n    4: [(1, 8), (12, 5), (13, 1)],\n    0: [(1, 9), (8, 5), (6, 8), (5, 1)],\n    12: [(1, 3), (4, 5), (7, 5), (13, 1)],\n    9: [(1, 1), (3, 6), (10, 6)],\n    5: [(8, 10), (0, 1), (3, 7), (6, 3)],\n    13: [(4, 1), (12, 1), (7, 8), (11, 2), (2, 1)],\n    6: [(0, 8), (5, 3), (3, 1), (10, 8)],\n    7: [(12, 5), (13, 8), (3, 1), (10, 6), (11, 7)],\n    3: [(9, 6), (5, 7), (6, 1), (7, 1), (10, 2)],\n    10: [(9, 6), (6, 8), (7, 6), (3, 2), (2, 4)],\n    11: [(13, 2), (7, 7), (2, 6)],\n    2: [(13, 1), (10, 4), (11, 6)]\n}\n\nstart_node = 9\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "290": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    6: [(3, 7), (8, 2), (4, 9), (7, 2), (10, 8)],\n    3: [(8, 8), (6, 1)],\n    8: [(1, 7), (7, 7)],\n    4: [(10, 3)],\n    7: [(6, 9), (3, 3), (8, 5), (9, 6), (4, 6)],\n    10: [(5, 7), (1, 7), (7, 6)],\n    1: [(6, 8), (9, 7), (0, 4)],\n    9: [(4, 5), (6, 8), (8, 5)],\n    5: [(3, 3), (0, 9)],\n    0: [(8, 10), (9, 6)],\n    2: [(6, 5)]\n}\n\nstart_node = 2\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "291": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    5: [(1, 2), (9, 1), (7, 5), (0, 2), (8, 4), (6, 10), (3, 9), (10, 9), (11, 7), (2, 8)],\n    1: [(5, 2), (3, 1), (0, 2), (7, 3), (4, 3), (10, 6), (8, 7)],\n    9: [(5, 1), (7, 9), (2, 5)],\n    7: [(5, 5), (1, 3), (9, 9), (10, 3), (2, 9), (6, 1)],\n    0: [(5, 2), (1, 2), (10, 3)],\n    8: [(5, 4), (1, 7), (10, 6)],\n    6: [(5, 10), (7, 1), (10, 8), (3, 1), (4, 8)],\n    3: [(5, 9), (1, 1), (6, 1), (4, 10)],\n    10: [(5, 9), (1, 6), (7, 3), (0, 3), (8, 6), (6, 8)],\n    11: [(5, 7)],\n    2: [(5, 8), (9, 5), (7, 9)],\n    4: [(1, 3), (6, 8), (3, 10)]\n}\n\nstart_node = 3\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "292": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    10: [(7, 1), (5, 10)],\n    7: [(10, 1)],\n    5: [(10, 10), (3, 5), (0, 2), (6, 2), (9, 10)],\n    3: [(5, 5), (2, 10), (1, 5)],\n    0: [(5, 2)],\n    6: [(5, 2)],\n    9: [(5, 10)],\n    2: [(3, 10), (4, 10), (8, 4)],\n    1: [(3, 5)],\n    4: [(2, 10)],\n    8: [(2, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Calculate the shortest path from node 7 to node 4\nshortest_path_length = dijkstra(graph, 7, 4)\nprint(shortest_path_length)\n```"}, "293": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    11: {13: 4, 10: 5, 2: 4, 5: 7, 4: 10, 0: 10, 6: 5, 8: 10},\n    13: {11: 4, 12: 1, 10: 3, 5: 7, 4: 10, 0: 5, 8: 10, 7: 9},\n    10: {11: 5, 13: 3, 12: 10, 2: 7, 1: 2, 5: 1, 4: 5, 0: 6, 6: 8, 7: 4},\n    2: {11: 4, 10: 7, 1: 10, 5: 8, 4: 2, 9: 10, 0: 8, 3: 8},\n    5: {11: 7, 13: 7, 10: 1, 2: 8, 12: 7, 1: 5, 4: 7, 9: 10, 0: 4, 6: 7, 8: 3},\n    4: {11: 10, 13: 10, 10: 5, 2: 2, 5: 7, 1: 1, 9: 7, 0: 6, 8: 8, 3: 3, 7: 8},\n    0: {11: 10, 13: 5, 10: 6, 2: 8, 5: 4, 4: 6, 12: 6, 1: 6, 9: 1, 8: 9, 3: 1, 7: 5},\n    6: {11: 5, 10: 8, 5: 7, 12: 7, 1: 3, 3: 10, 7: 3},\n    8: {11: 10, 13: 10, 5: 3, 4: 8, 0: 9, 1: 5, 3: 8, 7: 5},\n    12: {13: 1, 10: 10, 5: 7, 0: 6, 6: 7, 1: 7, 3: 6},\n    7: {13: 9, 10: 4, 4: 8, 0: 5, 6: 3, 8: 5, 1: 1, 9: 10},\n    1: {10: 2, 2: 10, 5: 5, 4: 1, 0: 6, 6: 3, 8: 5, 12: 7, 3: 10, 7: 1},\n    9: {2: 10, 5: 10, 4: 7, 0: 1, 7: 10},\n    3: {2: 8, 4: 3, 0: 1, 6: 10, 8: 8, 12: 6, 1: 10}\n}\n\nprint(dijkstra(graph, 2, 3))\n```"}, "294": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    1: [(4, 8), (8, 9), (6, 2), (7, 6), (9, 3), (3, 5)],\n    4: [(6, 7), (0, 9), (9, 10), (3, 2)],\n    8: [(5, 10), (6, 3), (0, 2), (3, 7), (2, 6)],\n    6: [(10, 3), (11, 9), (1, 8), (4, 6), (5, 2)],\n    7: [(11, 1), (3, 4), (4, 9), (8, 8), (10, 6)],\n    9: [(3, 10), (8, 9), (10, 2), (7, 2)],\n    3: [(5, 1), (0, 2), (9, 9)],\n    0: [(7, 1), (11, 10), (3, 3), (6, 9)],\n    5: [(0, 8), (7, 1), (11, 7), (4, 3)],\n    2: [(1, 9), (4, 8), (8, 3), (5, 2), (0, 4), (7, 10), (11, 4), (9, 8), (3, 2)],\n    10: [(0, 10)],\n    11: [(3, 2), (8, 4)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue for Dijkstra's algorithm\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 11 to node 4\nshortest_path_length = dijkstra(graph, 11, 4)\nprint(shortest_path_length)\n```"}, "295": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    4: [(6, 2), (2, 8)],\n    6: [(4, 2), (1, 3)],\n    2: [(4, 8), (5, 8)],\n    1: [(6, 3), (3, 1)],\n    5: [(2, 8), (7, 7)],\n    3: [(1, 1), (0, 6)],\n    0: [(3, 6), (7, 9)],\n    7: [(0, 9), (5, 7)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 7 to node 3\nshortest_path_length = dijkstra(graph, 7, 3)\nprint(shortest_path_length)\n```"}, "296": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    1: [(8, 6), (5, 7), (2, 3), (6, 7), (7, 3), (3, 4), (0, 7)],\n    8: [(1, 6), (5, 2), (2, 2), (6, 3), (7, 7), (0, 4), (9, 10)],\n    5: [(1, 7), (8, 2), (7, 1), (4, 6), (3, 3), (9, 7)],\n    2: [(1, 3), (8, 2), (6, 8), (7, 5), (4, 2), (3, 9), (9, 6)],\n    6: [(1, 7), (8, 3), (2, 8), (7, 4), (3, 10), (0, 8)],\n    7: [(1, 3), (8, 7), (5, 1), (2, 5), (6, 4), (3, 4), (0, 9), (9, 6)],\n    3: [(1, 4), (5, 3), (2, 9), (6, 10), (7, 4), (4, 6)],\n    0: [(1, 7), (8, 4), (6, 8), (7, 9), (4, 6), (9, 7)],\n    9: [(8, 10), (5, 7), (2, 6), (7, 6), (0, 7), (4, 7)],\n    4: [(5, 6), (2, 2), (3, 6), (0, 6), (9, 7)]\n}\n\nstart_node = 6\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "297": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    7: [(1, 7), (11, 3), (3, 6), (14, 10), (0, 7)],\n    1: [(7, 7), (3, 3), (0, 3), (4, 8), (5, 2)],\n    11: [(7, 3), (8, 8), (3, 4), (10, 9), (2, 3), (14, 1), (0, 5)],\n    3: [(7, 6), (1, 3), (11, 4), (10, 6), (2, 8), (12, 3), (0, 10), (9, 8)],\n    14: [(7, 10), (11, 1), (8, 5), (13, 9), (10, 2), (2, 5), (12, 6), (0, 1), (4, 3)],\n    0: [(7, 7), (1, 3), (11, 5), (3, 10), (14, 1), (8, 10), (6, 3), (10, 8), (12, 1), (9, 5), (5, 4)],\n    4: [(1, 8), (14, 3), (8, 3), (13, 4), (6, 6), (10, 10), (12, 3)],\n    5: [(1, 2), (0, 4), (8, 9), (13, 10), (12, 4)],\n    8: [(11, 8), (14, 5), (0, 10), (4, 3), (5, 9), (13, 2), (6, 4), (10, 1), (2, 1)],\n    10: [(11, 9), (3, 6), (14, 2), (0, 8), (4, 10), (8, 1), (12, 3)],\n    2: [(11, 3), (3, 8), (14, 5), (8, 1), (12, 10), (9, 5)],\n    12: [(3, 3), (14, 6), (0, 1), (4, 3), (5, 4), (13, 9), (10, 3), (2, 10), (9, 1)],\n    9: [(3, 8), (0, 5), (13, 3), (2, 5), (12, 1)],\n    13: [(14, 9), (4, 4), (5, 10), (8, 2), (12, 9), (9, 3)],\n    6: [(0, 3), (4, 6), (8, 4)]\n}\n\nprint(dijkstra(graph, 12, 11))\n```"}, "298": {"gpt4": "```python\nimport heapq\n\n# Define the graph as an adjacency list\ngraph = {\n    4: [(7, 8), (5, 9)],\n    7: [(9, 10), (0, 6)],\n    5: [(8, 9), (3, 3)],\n    9: [(5, 10), (0, 1), (8, 5), (1, 9), (2, 9)],\n    0: [(8, 3), (7, 1), (9, 5), (3, 8), (6, 5)],\n    8: [(2, 7), (3, 1), (0, 1)],\n    3: [(5, 9), (4, 1), (9, 3)],\n    6: [(5, 10), (2, 8), (9, 3)],\n    2: [(4, 8), (0, 4)],\n    1: [(2, 6), (4, 10), (8, 1)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 9 to node 5\nshortest_path_length = dijkstra(graph, 9, 5)\nprint(shortest_path_length)\n```"}, "299": {"gpt4": "```python\nimport heapq\n\n# Graph representation\ngraph = {\n    0: [(1, 10)],\n    1: [(0, 10), (2, 7), (10, 10), (9, 2), (5, 8), (7, 7), (8, 10), (3, 2)],\n    2: [(1, 7)],\n    3: [(1, 2)],\n    4: [(6, 10)],\n    5: [(1, 8)],\n    6: [(8, 1), (4, 10)],\n    7: [(1, 7)],\n    8: [(1, 10), (6, 1)],\n    9: [(1, 2)],\n    10: [(1, 10)]\n}\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Calculate the shortest path from node 10 to node 4\nshortest_path_length = dijkstra(graph, 10, 4)\nprint(shortest_path_length)\n```"}}