{"0": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 4), (3, 4), (2, 3), (4, 1)],\n    1: [(0, 4), (3, 3), (4, 1)],\n    2: [(0, 3), (3, 3), (4, 2)],\n    3: [(0, 4), (1, 3), (2, 3), (4, 1)],\n    4: [(0, 1), (1, 1), (2, 2), (3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 2)\nprint(shortest_path_length)\n```"}, "1": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    shortest_paths = {node: float('inf') for node in graph}\n    shortest_paths[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > shortest_paths[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(3, 4), (13, 7), (14, 8), (6, 5)],\n    1: [(16, 5), (12, 2), (11, 9)],\n    2: [(4, 9), (3, 9), (6, 8)],\n    3: [(0, 4), (16, 4), (10, 8), (13, 1), (6, 9)],\n    4: [(2, 9), (11, 2), (15, 2), (8, 10)],\n    5: [(16, 9), (15, 5)],\n    6: [(0, 5), (2, 8), (9, 3), (10, 4), (7, 6)],\n    7: [(6, 6), (10, 6), (13, 10)],\n    8: [(4, 10), (11, 3)],\n    9: [(6, 3), (15, 3)],\n    10: [(3, 8), (6, 4), (7, 6), (12, 4)],\n    11: [(1, 9), (4, 2), (8, 3), (16, 9)],\n    12: [(1, 2), (10, 4)],\n    13: [(0, 7), (3, 1), (7, 10)],\n    14: [(0, 8), (16, 3)],\n    15: [(4, 2), (5, 5), (9, 3)],\n    16: [(1, 5), (3, 4), (5, 9), (11, 9), (14, 3)]\n}\n\n# Calculate shortest path from node 9 to node 1\nshortest_path_length = dijkstra(graph, 9, 1)\nprint(shortest_path_length)\n```"}, "2": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 9), (9, 1), (10, 7), (4, 9)],\n    1: [(2, 3), (7, 3)],\n    2: [(1, 3), (3, 3), (9, 6), (10, 6), (7, 7), (8, 1)],\n    3: [(0, 9), (2, 3), (7, 7)],\n    4: [(0, 9), (9, 10)],\n    5: [(7, 2), (11, 9)],\n    6: [(7, 6)],\n    7: [(1, 3), (2, 7), (3, 7), (5, 2), (6, 6), (8, 5)],\n    8: [(2, 1), (7, 5)],\n    9: [(0, 1), (2, 6), (4, 10), (11, 7)],\n    10: [(0, 7), (2, 6)],\n    11: [(5, 9), (9, 7)]\n}\n\nshortest_path_length = dijkstra(graph, 11, 10)\nprint(shortest_path_length)\n```"}, "3": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 7), (3, 2), (8, 10)],\n    1: [(2, 2), (6, 9)],\n    2: [(1, 2), (5, 9), (11, 2), (6, 2)],\n    3: [(0, 2), (7, 3), (5, 2), (11, 9)],\n    4: [(7, 2), (9, 9), (5, 6)],\n    5: [(2, 9), (3, 2), (4, 6), (9, 8)],\n    6: [(1, 9), (2, 2), (10, 10)],\n    7: [(0, 7), (3, 3), (4, 2), (8, 4)],\n    8: [(0, 10), (7, 4), (9, 8)],\n    9: [(4, 9), (5, 8), (8, 8)],\n    10: [(6, 10)],\n    11: [(2, 2), (3, 9), (12, 8)],\n    12: [(11, 8)]\n}\n\nstart_node = 3\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "4": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    shortest_paths = {node: float('inf') for node in graph}\n    shortest_paths[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > shortest_paths[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')  # If there's no path from start to end\n\n# Graph representation\ngraph = {\n    0: [(16, 2), (12, 5), (2, 7)],\n    1: [(3, 9), (8, 9), (13, 5)],\n    2: [(0, 7), (3, 6), (12, 2), (15, 10), (4, 9)],\n    3: [(1, 9), (2, 6), (6, 2), (17, 2), (10, 7), (15, 6), (13, 7)],\n    4: [(2, 9), (6, 4), (13, 3)],\n    5: [(6, 9), (14, 8)],\n    6: [(3, 2), (4, 4), (5, 9)],\n    7: [(11, 10)],\n    8: [(1, 9), (12, 6), (15, 3), (13, 10)],\n    9: [(14, 9)],\n    10: [(3, 7), (15, 6)],\n    11: [(7, 10), (12, 5), (17, 9)],\n    12: [(0, 5), (2, 2), (8, 6), (11, 5), (13, 5)],\n    13: [(1, 5), (3, 7), (4, 3), (8, 10), (12, 5)],\n    14: [(5, 8), (9, 9)],\n    15: [(2, 10), (3, 6), (8, 3), (10, 6), (17, 7)],\n    16: [(0, 2)],\n    17: [(3, 2), (11, 9), (15, 7)]\n}\n\n# Calculate shortest path from node 11 to node 9\nshortest_path_length = dijkstra(graph, 11, 9)\nprint(shortest_path_length)\n```"}, "5": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 3), (5, 10)],\n    1: [(7, 6), (2, 1), (3, 3), (6, 2), (12, 6)],\n    2: [(8, 4), (4, 9), (6, 6)],\n    3: [(7, 3), (4, 3), (13, 1)],\n    4: [],\n    5: [],\n    6: [(9, 6)],\n    7: [(10, 9), (11, 1)],\n    8: [(12, 5)],\n    9: [],\n    10: [(12, 6)],\n    11: [],\n    12: [],\n    13: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if u not in [x[0] for x in graph[v]]:\n            graph[v].append((u, w))\n\nshortest_path_length = dijkstra(graph, 13, 5)\nprint(shortest_path_length)\n```"}, "6": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(18, 4), (8, 5), (2, 9), (15, 3), (6, 10)],\n    1: [(8, 8), (10, 2), (3, 2)],\n    2: [(16, 6)],\n    3: [(18, 9), (15, 10), (4, 6), (9, 9)],\n    4: [(18, 5), (12, 3), (14, 4), (5, 1), (9, 5)],\n    5: [(17, 5)],\n    6: [(14, 7), (9, 8)],\n    7: [(8, 6)],\n    8: [(16, 2)],\n    9: [(18, 5), (10, 10), (11, 6)],\n    10: [(16, 4), (13, 9)],\n    11: [(15, 8), (14, 3)],\n    12: [(14, 8)],\n    13: [],\n    14: [(18, 5)],\n    15: [(16, 5)],\n    16: [],\n    17: [],\n    18: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if v not in graph:\n            graph[v] = []\n        graph[v].append((u, w))\n\n# Calculate shortest path from node 17 to node 7\nshortest_path_length = dijkstra(graph, 17, 7)\nprint(shortest_path_length)\n```"}, "7": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(5, 3), (6, 5)],\n    1: [(14, 2), (2, 1), (6, 9)],\n    2: [(8, 2), (12, 10), (7, 3)],\n    3: [(8, 7), (7, 9)],\n    4: [(5, 2), (10, 8), (6, 6)],\n    5: [(0, 3), (14, 6), (11, 2), (4, 2)],\n    6: [(0, 5), (1, 9), (12, 2), (7, 1), (4, 6)],\n    7: [(2, 3), (3, 9), (6, 1), (9, 2)],\n    8: [(2, 2), (3, 7)],\n    9: [(7, 2)],\n    10: [(4, 8), (13, 7)],\n    11: [(5, 2), (13, 3)],\n    12: [(2, 10), (6, 2)],\n    13: [(10, 7), (11, 3), (14, 8)],\n    14: [(1, 2), (5, 6), (13, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 13, 9)\nprint(shortest_path_length)\n```"}, "8": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 8), (4, 2), (2, 2)],\n    1: [(9, 5), (5, 1), (6, 7), (2, 7)],\n    2: [(0, 2), (1, 7), (7, 7), (3, 10), (14, 10)],\n    3: [(2, 10), (5, 8)],\n    4: [(0, 2)],\n    5: [(1, 1), (3, 8), (8, 2), (14, 5), (6, 10)],\n    6: [(1, 7), (5, 10), (11, 2), (14, 5), (12, 3)],\n    7: [(2, 7)],\n    8: [(5, 2)],\n    9: [(1, 5), (11, 4), (15, 10)],\n    10: [(11, 3)],\n    11: [(6, 2), (9, 4), (10, 3), (13, 9), (14, 10)],\n    12: [(6, 3), (13, 1)],\n    13: [(0, 8), (11, 9), (12, 1)],\n    14: [(2, 10), (5, 5), (6, 5), (11, 10)],\n    15: [(9, 10)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 9)\nprint(shortest_path_length)\n```"}, "9": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_node == end:\n            return current_distance\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return float('inf')\n\ngraph = {\n    0: [(4, 3), (3, 1), (1, 1), (2, 4)],\n    1: [(0, 1), (4, 2), (3, 4), (2, 2)],\n    2: [(0, 4), (1, 2), (4, 1), (3, 2)],\n    3: [(0, 1), (1, 4), (2, 2)],\n    4: [(0, 3), (1, 2), (2, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 3)\nprint(shortest_path_length)\n```"}, "10": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (1, 1), (4, 1)],\n    1: [(0, 1), (2, 3), (3, 2), (4, 4)],\n    2: [(0, 3), (1, 3), (3, 2), (4, 4)],\n    3: [(1, 2), (2, 2), (4, 2)],\n    4: [(0, 1), (1, 4), (2, 4), (3, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 3)\nprint(shortest_path_length)\n```"}, "11": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 4), (3, 3), (2, 2), (4, 3)],\n    1: [(0, 4), (3, 1), (2, 2)],\n    2: [(0, 2), (1, 2), (3, 4), (4, 4)],\n    3: [(0, 3), (1, 1), (2, 4), (4, 3)],\n    4: [(0, 3), (2, 4), (3, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 4)\nprint(shortest_path_length)\n```"}, "12": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 1), (5, 2), (3, 3), (2, 3)],\n    1: [(4, 3), (5, 1), (3, 3), (2, 2)],\n    2: [(4, 3), (5, 1), (3, 3), (0, 3), (1, 2)],\n    3: [(4, 2), (5, 3), (0, 3), (1, 3), (2, 3)],\n    4: [(0, 1), (1, 3), (2, 3), (3, 2), (5, 2)],\n    5: [(0, 2), (1, 1), (2, 1), (3, 3), (4, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 1)\nprint(shortest_path_length)\n```"}, "13": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 6), (4, 4)],\n    1: [(8, 1), (15, 1)],\n    2: [(16, 8)],\n    3: [(4, 10), (14, 10), (18, 6), (6, 5), (9, 3)],\n    4: [(0, 4), (3, 10), (7, 5), (6, 9)],\n    5: [(17, 1), (14, 4), (9, 8)],\n    6: [(3, 5), (4, 9), (17, 9), (9, 8)],\n    7: [(4, 5), (10, 8)],\n    8: [(1, 1)],\n    9: [(3, 3), (5, 8), (6, 8), (10, 4), (16, 3), (15, 4), (18, 4)],\n    10: [(0, 6), (7, 8), (9, 4), (12, 4)],\n    11: [(14, 4)],\n    12: [(10, 4), (17, 10), (16, 3)],\n    13: [(17, 1)],\n    14: [(3, 10), (5, 4), (11, 4)],\n    15: [(1, 1), (9, 4)],\n    16: [(2, 8), (9, 3), (12, 3)],\n    17: [(5, 1), (6, 9), (12, 10), (13, 1)],\n    18: [(3, 6), (9, 4)]\n}\n\nstart_node = 13\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "14": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(1, 1)],\n    1: [(0, 1), (7, 4), (6, 2), (4, 2), (5, 2)],\n    2: [(4, 2)],\n    3: [(6, 1)],\n    4: [(1, 2), (2, 2), (7, 3)],\n    5: [(1, 2), (7, 3), (6, 1)],\n    6: [(1, 2), (3, 1), (5, 1), (7, 3)],\n    7: [(1, 4), (4, 3), (5, 3), (6, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 0)\nprint(shortest_path_length)\n```"}, "15": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 2), (1, 2), (3, 3), (5, 3)],\n    1: [(0, 2), (4, 1), (6, 1), (2, 2), (3, 3), (8, 1)],\n    2: [(1, 2), (9, 1), (4, 2), (6, 1), (3, 2), (8, 3)],\n    3: [(0, 3), (1, 3), (2, 2)],\n    4: [(1, 1), (2, 2), (6, 2), (5, 3)],\n    5: [(0, 3), (4, 3), (9, 4), (6, 4), (7, 3), (8, 3)],\n    6: [(0, 2), (1, 1), (2, 1), (4, 2), (5, 4)],\n    7: [(5, 3), (9, 3)],\n    8: [(1, 1), (2, 3), (5, 3), (9, 4)],\n    9: [(2, 1), (5, 4), (7, 3), (8, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 4)\nprint(shortest_path_length)\n```"}, "16": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 4), (15, 1), (10, 6)],\n    1: [(8, 3), (12, 9), (16, 1), (10, 4)],\n    2: [(11, 9), (12, 4), (6, 2), (14, 7)],\n    3: [(8, 2), (9, 7)],\n    4: [(6, 5), (5, 2), (14, 4)],\n    5: [],\n    6: [(11, 5), (16, 7), (14, 8), (10, 5)],\n    7: [(12, 4), (13, 6), (15, 4), (14, 9)],\n    8: [(9, 3), (13, 1)],\n    9: [],\n    10: [(13, 5)],\n    11: [(16, 10), (15, 1), (14, 1)],\n    12: [],\n    13: [(15, 9)],\n    14: [],\n    15: [],\n    16: []\n}\n\nshortest_path_length = dijkstra(graph, 4, 3)\nprint(shortest_path_length)\n```"}, "17": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_node == end:\n            return current_distance\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return float('inf')\n\nedges = [\n    (0, 6, 8), (0, 7, 2), (0, 12, 3), (0, 10, 10), (0, 1, 4),\n    (1, 6, 7), (1, 14, 7), (1, 4, 1), (1, 18, 8), (1, 5, 4),\n    (1, 16, 4), (1, 8, 10), (1, 2, 1), (1, 17, 8), (2, 7, 6),\n    (2, 18, 10), (2, 12, 6), (2, 16, 8), (2, 8, 2), (3, 7, 6),\n    (4, 6, 4), (4, 14, 10), (4, 10, 5), (4, 8, 8), (5, 11, 2),\n    (5, 16, 3), (5, 8, 1), (5, 19, 9), (5, 17, 10), (6, 10, 3),\n    (6, 13, 1), (7, 18, 1), (8, 10, 4), (8, 16, 1), (9, 11, 9),\n    (10, 14, 2), (11, 17, 6), (11, 13, 1), (12, 19, 10), (13, 15, 1),\n    (13, 16, 1), (13, 19, 10), (13, 17, 4), (14, 15, 6)\n]\n\ngraph = {i: [] for i in range(20)}\nfor u, v, w in edges:\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\nstart_node = 3\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "18": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 4), (1, 1), (3, 2), (7, 1)],\n    1: [(0, 1), (6, 3), (4, 1), (3, 2), (7, 2)],\n    2: [(4, 3)],\n    3: [(0, 2), (1, 2), (6, 3)],\n    4: [(1, 1), (2, 3), (6, 3), (5, 1), (7, 2)],\n    5: [(4, 1)],\n    6: [(0, 4), (1, 3), (3, 3), (4, 3), (7, 2)],\n    7: [(0, 1), (1, 2), (4, 2), (6, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 6, 5)\nprint(shortest_path_length)\n```"}, "19": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 6), (11, 5), (10, 9), (1, 7)],\n    1: [(0, 7), (11, 4), (10, 4), (3, 1), (4, 6)],\n    2: [(7, 7)],\n    3: [(1, 1), (5, 9), (7, 3), (9, 7)],\n    4: [(1, 6), (12, 4)],\n    5: [(3, 9), (7, 4), (6, 1)],\n    6: [(5, 1), (7, 4), (9, 9)],\n    7: [(2, 7), (3, 3), (5, 4), (6, 4), (10, 8), (9, 1)],\n    8: [(12, 9), (11, 3)],\n    9: [(3, 7), (6, 9), (7, 1)],\n    10: [(0, 9), (1, 4), (7, 8), (12, 1)],\n    11: [(0, 5), (1, 4), (8, 3)],\n    12: [(0, 6), (4, 4), (8, 9), (10, 1)]\n}\n\nstart_node = 6\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "20": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (3, 1)],\n    1: [(2, 2), (4, 2), (3, 3)],\n    2: [(0, 2), (1, 2), (4, 3), (3, 3)],\n    3: [(0, 1), (1, 3), (2, 3), (4, 1)],\n    4: [(1, 2), (2, 3), (3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 1)\nprint(shortest_path_length)\n```"}, "21": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 4), (4, 4)],\n    1: [(4, 4), (2, 2)],\n    2: [(1, 2), (4, 2), (5, 2)],\n    3: [(6, 3), (4, 3), (5, 2)],\n    4: [(0, 4), (1, 4), (2, 2), (3, 3)],\n    5: [(2, 2), (3, 2)],\n    6: [(0, 4), (3, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 0)\nprint(shortest_path_length)\n```"}, "22": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 4), (5, 1), (4, 3), (3, 2)],\n    1: [(0, 4), (5, 3), (4, 4), (2, 2), (3, 1)],\n    2: [(1, 2), (5, 1), (4, 4), (3, 2)],\n    3: [(0, 2), (1, 1), (2, 2), (5, 2), (4, 2)],\n    4: [(0, 3), (1, 4), (2, 4), (3, 2), (5, 2)],\n    5: [(0, 1), (1, 3), (2, 1), (3, 2), (4, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 2)\nprint(shortest_path_length)\n```"}, "23": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(6, 3), (4, 2), (7, 4)],\n    1: [(2, 1), (6, 4), (4, 3), (8, 1), (5, 2)],\n    2: [(1, 1), (6, 1), (3, 1), (5, 3)],\n    3: [(2, 1), (6, 3), (4, 4), (8, 4), (5, 3), (7, 2), (9, 1)],\n    4: [(0, 2), (1, 3), (3, 4), (6, 1), (8, 3), (7, 2), (9, 2)],\n    5: [(1, 2), (2, 3), (3, 3), (6, 1), (8, 2), (7, 4)],\n    6: [(0, 3), (1, 4), (2, 1), (3, 3), (4, 1), (5, 1), (7, 1), (9, 4)],\n    7: [(0, 4), (3, 2), (4, 2), (5, 4), (6, 1), (8, 1)],\n    8: [(1, 1), (3, 4), (4, 3), (5, 2), (7, 1)],\n    9: [(3, 1), (4, 2), (6, 4)]\n}\n\nprint(dijkstra(graph, 2, 4))\n```"}, "24": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 7)],\n    1: [(8, 2)],\n    2: [(6, 8)],\n    3: [(9, 8)],\n    4: [(10, 9), (7, 5), (6, 9)],\n    5: [(7, 1), (6, 1)],\n    6: [(0, 7), (2, 8), (4, 9), (5, 1)],\n    7: [(4, 5), (5, 1), (9, 4), (8, 1)],\n    8: [(1, 2), (7, 1)],\n    9: [(3, 8), (7, 4)],\n    10: [(4, 9)]\n}\n\nstart_node = 5\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "25": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 2), (3, 8), (7, 3)],\n    1: [(10, 2), (11, 8), (9, 10), (2, 9), (8, 5), (7, 8), (12, 8)],\n    2: [(9, 8), (7, 6)],\n    3: [(12, 7)],\n    4: [(8, 4), (13, 10), (6, 8)],\n    5: [(0, 2), (11, 1), (13, 2)],\n    6: [(4, 8), (12, 10)],\n    7: [(0, 3), (1, 8), (2, 6), (11, 6)],\n    8: [(1, 5), (4, 4), (11, 3)],\n    9: [(1, 10), (2, 8), (13, 2), (12, 2)],\n    10: [(1, 2)],\n    11: [(1, 8), (5, 1), (7, 6), (8, 3)],\n    12: [(1, 8), (3, 7), (6, 10), (9, 2)],\n    13: [(4, 10), (5, 2), (9, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 4)\nprint(shortest_path_length)\n```"}, "26": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (3, 4), (1, 2)],\n    1: [(0, 2), (2, 2)],\n    2: [(1, 2), (4, 2), (3, 3)],\n    3: [(0, 4), (2, 3), (4, 2)],\n    4: [(0, 4), (2, 2), (3, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 1)\nprint(shortest_path_length)\n```"}, "27": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 10), (3, 5), (10, 10)],\n    1: [(12, 5)],\n    2: [(11, 10), (9, 3), (4, 1), (5, 4), (13, 7), (8, 9)],\n    3: [(11, 8), (7, 2), (4, 3), (0, 5)],\n    4: [(7, 8), (10, 8), (6, 7), (2, 1), (3, 3)],\n    5: [(12, 7), (10, 4), (2, 4)],\n    6: [(7, 8), (8, 10), (4, 7)],\n    7: [(12, 2), (8, 7), (3, 2), (4, 8), (6, 8)],\n    8: [(12, 9), (2, 9), (6, 10), (7, 7)],\n    9: [(0, 10), (2, 3)],\n    10: [(0, 10), (4, 8), (5, 4)],\n    11: [(2, 10), (3, 8)],\n    12: [(1, 5), (5, 7), (7, 2), (8, 9)],\n    13: [(2, 7)]\n}\n\nstart_node = 10\nend_node = 13\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "28": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(len(graph))}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(17, 1), (15, 8)],\n    1: [(9, 1), (11, 9), (15, 9)],\n    2: [(17, 5)],\n    3: [(9, 10), (7, 7), (11, 10)],\n    4: [(16, 6), (8, 10), (17, 10)],\n    5: [(7, 9), (11, 1), (6, 10)],\n    6: [(14, 10), (16, 4), (17, 7)],\n    7: [(8, 8), (11, 10), (12, 7), (10, 5)],\n    8: [(14, 7)],\n    9: [(13, 6), (12, 8)],\n    10: [(14, 6), (13, 3), (11, 9)],\n    11: [],\n    12: [],\n    13: [],\n    14: [(17, 10), (15, 10)],\n    15: [(16, 8)],\n    16: [(17, 10)],\n    17: []\n}\n\nprint(dijkstra(graph, 3, 2))\n```"}, "29": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 6), (16, 7)],\n    1: [(2, 5), (5, 2), (12, 8)],\n    2: [(1, 5), (6, 6), (5, 10), (11, 1), (14, 6)],\n    3: [(13, 6), (14, 7), (8, 1)],\n    4: [(6, 3), (7, 8), (11, 10), (14, 9), (8, 8)],\n    5: [(1, 2), (2, 10), (11, 4)],\n    6: [(2, 6), (4, 3), (10, 6), (13, 8)],\n    7: [(0, 6), (4, 8), (10, 1), (8, 8)],\n    8: [(3, 1), (4, 8), (7, 8)],\n    9: [(13, 8)],\n    10: [(6, 6), (7, 1), (11, 5), (14, 4)],\n    11: [(2, 1), (4, 10), (5, 4), (10, 5)],\n    12: [(1, 8), (15, 3), (16, 6)],\n    13: [(3, 6), (6, 8), (9, 8)],\n    14: [(2, 6), (3, 7), (4, 9), (10, 4)],\n    15: [(12, 3), (16, 8)],\n    16: [(0, 7), (12, 6), (15, 8)]\n}\n\nstart_node = 15\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "30": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 4), (7, 1), (3, 4), (1, 4), (4, 4), (6, 2), (2, 1)],\n    1: [(0, 4), (5, 4), (3, 3), (4, 2), (6, 3), (2, 1)],\n    2: [(0, 1), (5, 4), (7, 2), (3, 4), (4, 2), (6, 3), (1, 1)],\n    3: [(0, 4), (8, 3), (5, 4), (7, 1), (4, 2), (6, 4), (1, 3), (2, 4)],\n    4: [(0, 4), (8, 3), (5, 2), (7, 4), (6, 3), (1, 2), (2, 2), (3, 2)],\n    5: [(0, 4), (8, 1), (7, 3), (6, 3), (1, 4), (2, 4), (3, 4), (4, 2)],\n    6: [(0, 2), (5, 3), (7, 2), (1, 3), (2, 3), (3, 4), (4, 3)],\n    7: [(0, 1), (5, 3), (8, 4), (6, 2), (2, 2), (3, 1), (4, 4)],\n    8: [(3, 3), (4, 3), (5, 1), (7, 4)]\n}\n\nprint(dijkstra(graph, 8, 1))\n```"}, "31": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 10), (1, 8), (11, 2)],\n    1: [(14, 2), (12, 6), (3, 9), (10, 9), (2, 6)],\n    2: [(10, 9), (6, 5), (9, 8)],\n    3: [(12, 9), (7, 10), (13, 5)],\n    4: [(9, 3)],\n    5: [(12, 8), (7, 10)],\n    6: [],\n    7: [(14, 1)],\n    8: [(13, 5)],\n    9: [],\n    10: [],\n    11: [(14, 8), (12, 7)],\n    12: [(13, 1)],\n    13: [],\n    14: []\n}\n\nprint(dijkstra(graph, 2, 13))\n```"}, "32": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(15, 5), (14, 9), (3, 3)],\n    1: [(3, 7), (12, 9)],\n    2: [(15, 7), (11, 5)],\n    3: [(0, 3), (1, 7), (11, 4), (12, 9)],\n    4: [(5, 3)],\n    5: [(4, 3), (13, 4), (6, 10), (10, 6)],\n    6: [(15, 3), (7, 1), (13, 4), (11, 2), (9, 1)],\n    7: [(6, 1)],\n    8: [(10, 4)],\n    9: [(6, 1), (13, 9)],\n    10: [(5, 6), (8, 4)],\n    11: [(2, 5), (3, 4), (6, 2), (13, 3)],\n    12: [(1, 9), (3, 9)],\n    13: [(5, 4), (6, 4), (9, 9), (11, 3), (14, 3)],\n    14: [(0, 9), (13, 3)],\n    15: [(0, 5), (2, 7), (6, 3)]\n}\n\nstart_node = 12\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "33": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 1), (2, 1)],\n    1: [(3, 3), (4, 4)],\n    2: [(0, 1), (4, 3)],\n    3: [(0, 1), (1, 3), (4, 4)],\n    4: [(1, 4), (2, 3), (3, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 2)\nprint(shortest_path_length)\n```"}, "34": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 3), (3, 3), (6, 3), (9, 1), (4, 3), (5, 3), (7, 4), (2, 1)],\n    1: [(0, 3), (3, 4), (8, 2), (6, 3), (9, 2), (4, 2), (5, 2), (7, 2), (2, 3)],\n    2: [(0, 1), (3, 4), (6, 3), (9, 2), (4, 2), (5, 1), (7, 2), (1, 3)],\n    3: [(0, 3), (1, 4), (8, 1), (6, 1), (9, 3), (5, 2), (7, 4), (2, 4)],\n    4: [(0, 3), (1, 2), (8, 3), (6, 4), (9, 3), (5, 4), (7, 4), (2, 2)],\n    5: [(0, 3), (1, 2), (8, 3), (6, 3), (9, 1), (4, 4), (7, 3), (2, 1), (3, 2)],\n    6: [(0, 3), (1, 3), (8, 1), (9, 3), (4, 4), (5, 3), (7, 1), (2, 3), (3, 1)],\n    7: [(0, 4), (1, 2), (8, 2), (6, 1), (9, 2), (4, 4), (5, 3), (2, 2), (3, 4)],\n    8: [(1, 2), (3, 1), (6, 1), (4, 3), (5, 3), (7, 2)],\n    9: [(0, 1), (1, 2), (6, 3), (4, 3), (5, 1), (2, 2), (3, 3), (7, 2)]\n}\n\nprint(dijkstra(graph, 3, 4))\n```"}, "35": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 6), (3, 6)],\n    1: [(7, 8), (6, 3), (8, 3)],\n    2: [(7, 10), (5, 2), (9, 8), (6, 9), (4, 3)],\n    3: [(0, 6), (6, 5)],\n    4: [(6, 3), (11, 9), (8, 9), (2, 3)],\n    5: [(2, 2), (7, 3), (11, 4)],\n    6: [(1, 3), (2, 9), (3, 5), (4, 3), (12, 4), (9, 4)],\n    7: [(0, 6), (1, 8), (2, 10), (5, 3), (12, 5)],\n    8: [(1, 3), (4, 9)],\n    9: [(2, 8), (6, 4)],\n    10: [(11, 10)],\n    11: [(4, 9), (5, 4), (10, 10)],\n    12: [(6, 4), (7, 5)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 4)\nprint(shortest_path_length)\n```"}, "36": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 5), (10, 8)],\n    1: [(0, 5), (6, 8), (5, 10)],\n    2: [(6, 10), (3, 8), (9, 9), (8, 10), (10, 4)],\n    3: [(2, 8), (6, 2), (11, 5)],\n    4: [(6, 8)],\n    5: [(1, 10)],\n    6: [(1, 8), (2, 10), (3, 2), (4, 8), (7, 2)],\n    7: [(6, 2), (9, 9), (8, 4), (10, 10)],\n    8: [(2, 10), (7, 4), (9, 2)],\n    9: [(2, 9), (7, 9), (8, 2)],\n    10: [(0, 8), (2, 4), (7, 10)],\n    11: [(3, 5)]\n}\n\nprint(dijkstra(graph, 6, 0))\n```"}, "37": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 1), (11, 5)],\n    1: [(7, 3), (8, 1), (10, 8), (6, 10), (3, 8)],\n    2: [(5, 2), (9, 3), (11, 10)],\n    3: [(4, 2), (5, 4), (1, 8)],\n    4: [(8, 2), (10, 3), (6, 2), (12, 4), (3, 2)],\n    5: [(0, 1), (2, 2), (3, 4), (8, 8)],\n    6: [(1, 10), (4, 2), (11, 8)],\n    7: [(1, 3)],\n    8: [(1, 1), (4, 2), (5, 8)],\n    9: [(2, 3), (12, 4)],\n    10: [(1, 8), (4, 3)],\n    11: [(0, 5), (2, 10), (6, 8)],\n    12: [(4, 4), (9, 4)]\n}\n\nprint(dijkstra(graph, 1, 9))\n```"}, "38": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 2)],\n    1: [(12, 3), (9, 6), (5, 2), (2, 3)],\n    2: [(9, 3), (1, 3)],\n    3: [(8, 6), (13, 3)],\n    4: [(12, 7), (9, 6), (6, 8), (11, 3)],\n    5: [(12, 2), (6, 5), (8, 7), (11, 1), (1, 2)],\n    6: [(12, 5), (14, 2), (5, 5), (4, 8)],\n    7: [(10, 2), (8, 8)],\n    8: [(14, 3), (10, 4), (13, 3), (11, 9), (3, 6), (5, 7), (7, 8)],\n    9: [(14, 10), (1, 6), (2, 3), (4, 6)],\n    10: [(0, 2), (7, 2), (8, 4)],\n    11: [(4, 3), (5, 1), (8, 9)],\n    12: [(1, 3), (4, 7), (5, 2), (6, 5), (14, 2)],\n    13: [(3, 3), (8, 3)],\n    14: [(6, 2), (8, 3), (9, 10), (12, 2)]\n}\n\nprint(dijkstra(graph, 0, 2))\n```"}, "39": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(20)}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 10), (10, 4)],\n    1: [(18, 3), (17, 9), (12, 5)],\n    2: [(16, 7), (4, 8), (8, 3), (5, 5)],\n    3: [(7, 8), (14, 7), (13, 5), (4, 2)],\n    4: [(3, 2), (7, 2), (10, 10), (9, 8)],\n    5: [(2, 5), (7, 5), (18, 7), (10, 3)],\n    6: [(0, 10)],\n    7: [(3, 8), (4, 2), (5, 5), (18, 9), (17, 3)],\n    8: [(2, 3), (11, 9), (19, 5)],\n    9: [(4, 8), (18, 9)],\n    10: [(0, 4), (4, 10), (5, 3), (16, 1), (14, 2), (12, 1)],\n    11: [(8, 9), (14, 10), (17, 9), (12, 4)],\n    12: [(1, 5), (10, 1), (11, 4), (13, 2)],\n    13: [(3, 5), (12, 2), (16, 5)],\n    14: [(3, 7), (10, 2), (11, 10)],\n    15: [(19, 1)],\n    16: [(2, 7), (10, 1), (13, 5), (19, 8)],\n    17: [(1, 9), (7, 3), (11, 9), (19, 5)],\n    18: [(1, 3), (5, 7), (7, 9), (9, 9), (19, 6)],\n    19: [(8, 5), (15, 1), (16, 8), (17, 5), (18, 6)]\n}\n\nprint(dijkstra(graph, 15, 6))\n```"}, "40": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 3), (1, 7), (12, 8)],\n    1: [(0, 7), (12, 2), (6, 9), (8, 1), (2, 5)],\n    2: [(1, 5), (9, 4), (6, 3)],\n    3: [(10, 7)],\n    4: [(9, 9), (11, 5), (5, 2), (10, 3)],\n    5: [(4, 2), (9, 10), (7, 10)],\n    6: [(1, 9), (2, 3)],\n    7: [(5, 10), (8, 7), (10, 7)],\n    8: [(1, 1), (7, 7)],\n    9: [(0, 3), (2, 4), (4, 9), (11, 4), (10, 5)],\n    10: [(3, 7), (4, 3), (7, 7), (9, 5)],\n    11: [(4, 5), (9, 4)],\n    12: [(0, 8), (1, 2)]\n}\n\nstart_node = 8\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "41": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 4), (3, 5), (9, 6), (7, 2), (1, 8)],\n    1: [(0, 8), (10, 10), (13, 2), (8, 7)],\n    2: [(11, 8)],\n    3: [(0, 5), (5, 7), (10, 8), (6, 2), (12, 7), (15, 2)],\n    4: [(7, 8)],\n    5: [(3, 7), (6, 3), (9, 10), (14, 7), (15, 8)],\n    6: [(0, 4), (3, 2), (5, 3), (10, 1), (16, 1)],\n    7: [(0, 2), (4, 8)],\n    8: [(1, 7), (10, 8), (14, 5)],\n    9: [(0, 6), (5, 10), (16, 6)],\n    10: [(1, 10), (3, 8), (6, 1), (8, 8)],\n    11: [(2, 8), (12, 9), (16, 1)],\n    12: [(3, 7), (11, 9)],\n    13: [(1, 2), (16, 9), (14, 8)],\n    14: [(5, 7), (8, 5), (13, 8)],\n    15: [(3, 2), (5, 8), (16, 6)],\n    16: [(6, 1), (9, 6), (11, 1), (13, 9), (15, 6)]\n}\n\nstart_node = 8\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "42": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 8), (1, 1), (11, 2)],\n    1: [(0, 1), (10, 8), (6, 9), (4, 3), (5, 1)],\n    2: [(13, 10), (12, 5)],\n    3: [(10, 8), (8, 9), (13, 3), (5, 3), (15, 2)],\n    4: [(16, 8), (14, 9), (7, 1), (1, 3)],\n    5: [(10, 4), (6, 7), (3, 3), (1, 1)],\n    6: [(1, 9), (8, 7), (9, 6), (13, 10), (11, 10), (16, 5), (5, 7)],\n    7: [(4, 1), (13, 10), (16, 3)],\n    8: [(0, 8), (3, 9), (6, 7), (9, 3)],\n    9: [(8, 3), (6, 6), (11, 1), (12, 2)],\n    10: [(1, 8), (3, 8), (5, 4), (11, 10), (15, 4), (14, 6)],\n    11: [(0, 2), (9, 1), (10, 10), (6, 10), (13, 3), (15, 3)],\n    12: [(2, 5), (9, 2)],\n    13: [(2, 10), (3, 3), (6, 10), (7, 10), (11, 3), (15, 5)],\n    14: [(4, 9), (10, 6), (16, 9)],\n    15: [(3, 2), (10, 4), (11, 3), (13, 5)],\n    16: [(4, 8), (6, 5), (7, 3), (14, 9)]\n}\n\nstart_node = 4\nend_node = 12\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "43": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 4), (3, 1), (7, 3), (8, 4), (5, 2), (4, 3), (1, 3), (2, 1)],\n    1: [(6, 4), (3, 4), (7, 2), (8, 1), (5, 2), (4, 2), (2, 2), (0, 3)],\n    2: [(6, 2), (3, 3), (7, 4), (8, 3), (5, 4), (4, 2), (0, 1), (1, 2)],\n    3: [(6, 4), (7, 3), (8, 4), (5, 2), (4, 2), (0, 1), (1, 4), (2, 3)],\n    4: [(6, 2), (7, 4), (8, 1), (5, 3), (0, 3), (1, 2), (2, 2), (3, 2)],\n    5: [(6, 3), (7, 2), (8, 3), (0, 2), (1, 2), (2, 4), (3, 2), (4, 3)],\n    6: [(7, 3), (8, 2), (0, 4), (1, 4), (2, 2), (3, 4), (4, 2), (5, 3)],\n    7: [(0, 3), (1, 2), (2, 4), (3, 3), (4, 4), (5, 2), (6, 3)],\n    8: [(0, 4), (1, 1), (2, 3), (3, 4), (4, 1), (5, 3), (6, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 8)\nprint(shortest_path_length)\n```"}, "44": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (3, 2), (4, 2), (1, 3)],\n    1: [(0, 3), (2, 3), (3, 1)],\n    2: [(0, 3), (1, 3), (6, 1), (3, 1), (5, 1)],\n    3: [(0, 2), (1, 1), (2, 1), (5, 1), (4, 3)],\n    4: [(0, 2), (3, 3), (6, 2), (5, 2)],\n    5: [(2, 1), (3, 1), (4, 2), (6, 4)],\n    6: [(2, 1), (4, 2), (5, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 6, 3)\nprint(shortest_path_length)\n```"}, "45": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 5)],\n    1: [(2, 5), (4, 3), (3, 4)],\n    2: [(1, 5), (10, 7), (15, 1), (12, 1), (16, 9), (9, 6), (11, 2)],\n    3: [(1, 4), (17, 2), (18, 10), (7, 8)],\n    4: [(1, 3), (15, 2), (12, 3), (5, 8), (16, 2), (9, 4), (14, 4)],\n    5: [(4, 8), (11, 2)],\n    6: [(15, 8), (16, 1), (9, 10), (14, 5)],\n    7: [(3, 8), (15, 4), (16, 10), (11, 3)],\n    8: [(0, 5), (17, 2), (13, 10), (9, 1), (11, 3)],\n    9: [(2, 6), (4, 4), (6, 10), (8, 1), (17, 5), (13, 6), (16, 1)],\n    10: [(2, 7), (18, 1), (14, 1)],\n    11: [(2, 2), (5, 2), (7, 3), (8, 3), (18, 3)],\n    12: [(2, 1), (4, 3), (17, 10)],\n    13: [(8, 10), (9, 6), (15, 8), (16, 9), (14, 6)],\n    14: [(4, 4), (6, 5), (10, 1), (13, 6)],\n    15: [(2, 1), (4, 2), (6, 8), (7, 4), (13, 8), (16, 7)],\n    16: [(2, 9), (4, 2), (6, 1), (7, 10), (9, 1), (13, 9), (15, 7), (17, 2), (18, 3)],\n    17: [(3, 2), (8, 2), (9, 5), (12, 10), (16, 2)],\n    18: [(3, 10), (10, 1), (11, 3), (16, 3)]\n}\n\nprint(dijkstra(graph, 10, 0))\n```"}, "46": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (8, 3), (11, 3), (5, 7), (2, 3), (10, 3), (4, 2)],\n    1: [(0, 1), (5, 5), (2, 5), (4, 3)],\n    2: [(0, 3), (1, 5), (8, 4), (10, 9)],\n    3: [(9, 2)],\n    4: [(0, 2), (1, 3), (8, 2), (6, 8)],\n    5: [(0, 7), (1, 5)],\n    6: [(4, 8), (11, 8)],\n    7: [(10, 7), (9, 7)],\n    8: [(0, 3), (2, 4), (4, 2)],\n    9: [(3, 2), (7, 7)],\n    10: [(0, 3), (2, 9), (7, 7)],\n    11: [(0, 3), (6, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 11)\nprint(shortest_path_length)\n```"}, "47": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 4), (9, 4), (8, 4), (7, 2), (4, 3), (5, 4), (2, 1), (1, 1)],\n    1: [(3, 3), (6, 1), (9, 1), (8, 1), (7, 3), (4, 2), (5, 1), (2, 3), (0, 1)],\n    2: [(3, 4), (6, 4), (9, 3), (8, 3), (7, 2), (5, 3), (0, 1), (1, 3)],\n    3: [(6, 3), (9, 2), (8, 4), (7, 3), (4, 1), (5, 1), (1, 3), (2, 4)],\n    4: [(6, 2), (9, 3), (8, 4), (7, 3), (5, 4), (0, 3), (1, 2), (3, 1)],\n    5: [(6, 2), (9, 3), (8, 3), (7, 2), (0, 4), (1, 1), (2, 3), (3, 1), (4, 4)],\n    6: [(9, 3), (8, 1), (7, 3), (0, 4), (1, 1), (2, 4), (3, 3), (4, 2), (5, 2)],\n    7: [(8, 3), (0, 2), (1, 3), (2, 2), (3, 3), (4, 3), (5, 2), (6, 3)],\n    8: [(9, 3), (0, 4), (1, 1), (2, 3), (3, 4), (4, 4), (5, 3), (6, 1), (7, 3)],\n    9: [(0, 4), (1, 1), (2, 3), (3, 2), (4, 3), (5, 3), (6, 3), (8, 3)]\n}\n\nprint(dijkstra(graph, 3, 0))\n```"}, "48": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 2), (4, 2), (3, 4)],\n    1: [(0, 2), (3, 3)],\n    2: [(4, 4), (3, 2)],\n    3: [(0, 4), (1, 3), (2, 2), (4, 3)],\n    4: [(0, 2), (2, 4), (3, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 2)\nprint(shortest_path_length)\n```"}, "49": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 4), (14, 9), (10, 8), (4, 10)],\n    1: [(15, 1), (14, 5), (6, 2), (2, 3), (8, 3), (10, 3), (4, 3), (9, 1)],\n    2: [(7, 7), (14, 4), (10, 6), (9, 9)],\n    3: [(7, 4), (15, 6), (5, 7), (12, 7)],\n    4: [(14, 10), (16, 4)],\n    5: [(7, 9), (16, 4)],\n    6: [(14, 5), (16, 7), (10, 5), (12, 8), (13, 8)],\n    7: [(0, 4), (2, 7), (3, 4), (17, 6), (13, 4), (5, 9)],\n    8: [(1, 3), (18, 2), (9, 2), (17, 7), (13, 4)],\n    9: [(1, 1), (2, 9), (8, 2), (11, 3)],\n    10: [(0, 8), (1, 3), (2, 6), (15, 7), (16, 10), (11, 9), (6, 5)],\n    11: [(9, 3), (18, 8), (16, 9), (12, 4), (13, 1), (10, 9)],\n    12: [(3, 7), (6, 8), (11, 4)],\n    13: [(7, 4), (8, 4), (6, 8), (11, 1), (15, 10), (16, 3)],\n    14: [(0, 9), (1, 5), (2, 4), (4, 10), (6, 5)],\n    15: [(1, 1), (3, 6), (10, 7), (13, 10)],\n    16: [(4, 4), (5, 4), (6, 7), (10, 10), (11, 9), (13, 3), (18, 9), (17, 6)],\n    17: [(7, 6), (8, 7), (16, 6), (18, 1)],\n    18: [(8, 2), (11, 8), (16, 9), (17, 1)]\n}\n\nprint(dijkstra(graph, 15, 6))\n```"}, "50": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(15, 10), (6, 10)],\n    1: [(12, 8)],\n    2: [(4, 1), (12, 3), (14, 8)],\n    3: [(14, 2), (13, 4)],\n    4: [(12, 5), (14, 2), (5, 5)],\n    5: [(15, 8), (7, 8), (10, 6)],\n    6: [(15, 2), (8, 2)],\n    7: [(10, 10)],\n    8: [(14, 10)],\n    9: [(11, 8), (13, 6), (10, 8)],\n    10: [(11, 7), (15, 2), (14, 5), (13, 9)],\n    11: [(14, 7), (13, 10)],\n    12: [],\n    13: [],\n    14: [],\n    15: []\n}\n\nshortest_path_length = dijkstra(graph, 3, 7)\nprint(shortest_path_length)\n```"}, "51": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 5), (3, 9)],\n    1: [(13, 6), (7, 10)],\n    2: [(13, 8)],\n    3: [(13, 10), (10, 6), (12, 9), (0, 9)],\n    4: [(10, 9)],\n    5: [(11, 10), (10, 9), (12, 6)],\n    6: [(9, 2)],\n    7: [(0, 5), (1, 10), (13, 4), (9, 6)],\n    8: [(11, 10), (13, 4)],\n    9: [(6, 2), (7, 6)],\n    10: [(3, 6), (4, 9), (5, 9)],\n    11: [(5, 10), (8, 10), (13, 8), (12, 5)],\n    12: [(3, 9), (5, 6), (11, 5)],\n    13: [(1, 6), (2, 8), (3, 10), (7, 4), (8, 4), (11, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 6, 4)\nprint(shortest_path_length)\n```"}, "52": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (4, 2), (8, 4), (6, 2)],\n    1: [(0, 1), (7, 3), (6, 4)],\n    2: [(7, 3), (4, 4), (8, 3)],\n    3: [(8, 2)],\n    4: [(0, 2), (2, 4), (5, 3)],\n    5: [(4, 3), (7, 4), (8, 2), (6, 1)],\n    6: [(0, 2), (1, 4), (5, 1), (7, 3), (8, 3)],\n    7: [(1, 3), (2, 3), (5, 4), (6, 3), (8, 3)],\n    8: [(0, 4), (2, 3), (3, 2), (5, 2), (6, 3), (7, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 3)\nprint(shortest_path_length)\n```"}, "53": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 4)],\n    1: [(8, 3), (2, 10), (5, 8)],\n    2: [(1, 10), (4, 2), (5, 5), (6, 3)],\n    3: [(10, 1)],\n    4: [(2, 2), (8, 3), (5, 5), (9, 8)],\n    5: [(1, 8), (2, 5), (4, 5), (8, 4), (7, 9), (6, 1)],\n    6: [(2, 3), (5, 1), (9, 3)],\n    7: [(5, 9)],\n    8: [(0, 4), (1, 3), (4, 3), (5, 4), (10, 2)],\n    9: [(4, 8), (6, 3)],\n    10: [(3, 1), (8, 2), (11, 2)],\n    11: [(10, 2)]\n}\n\nstart_node = 5\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "54": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(11, 7), (9, 10), (2, 3), (5, 7), (3, 9)],\n    1: [(11, 10)],\n    2: [(0, 3)],\n    3: [(0, 9), (5, 2)],\n    4: [(11, 8), (6, 3)],\n    5: [(0, 7), (3, 2), (11, 8)],\n    6: [(4, 3), (7, 8)],\n    7: [(6, 8)],\n    8: [(9, 3), (10, 8)],\n    9: [(0, 10), (8, 3)],\n    10: [(8, 8)],\n    11: [(0, 7), (1, 10), (4, 8), (5, 8)]\n}\n\nstart_node = 10\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "55": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(12, 1), (16, 10), (11, 1), (2, 10), (9, 4), (18, 6)],\n    1: [(6, 4), (16, 8), (2, 4)],\n    2: [(15, 1), (5, 10), (16, 1), (8, 2)],\n    3: [(7, 7), (12, 9), (16, 7), (4, 5)],\n    4: [(11, 2), (14, 5), (8, 3), (18, 7)],\n    5: [(18, 5)],\n    6: [(10, 7), (8, 2)],\n    7: [(10, 8), (9, 2), (17, 6), (8, 8)],\n    8: [],\n    9: [(13, 3), (16, 9), (11, 9)],\n    10: [],\n    11: [(15, 5), (12, 8), (16, 7)],\n    12: [],\n    13: [(17, 3), (18, 6)],\n    14: [(15, 3)],\n    15: [(16, 4), (17, 10)],\n    16: [],\n    17: [(18, 8)],\n    18: []\n}\n\n# Find the shortest path from node 0 to node 14\nshortest_path_length = dijkstra(graph, 0, 14)\nprint(shortest_path_length)\n```"}, "56": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 4), (2, 4), (5, 1), (3, 2), (4, 1), (1, 4), (7, 3)],\n    1: [(8, 1), (2, 4), (6, 2), (5, 2), (9, 2), (0, 4)],\n    2: [(8, 1), (6, 2), (5, 4), (9, 4), (4, 3), (7, 3), (0, 4), (1, 4)],\n    3: [(8, 1), (6, 2), (5, 4), (9, 3), (4, 2), (0, 2)],\n    4: [(8, 1), (6, 1), (5, 1), (7, 1), (0, 1), (2, 3), (3, 2)],\n    5: [(8, 1), (6, 4), (9, 2), (7, 1), (0, 1), (1, 2), (2, 4), (3, 4), (4, 1)],\n    6: [(8, 3), (9, 4), (7, 2), (1, 2), (2, 2), (3, 2), (4, 1), (5, 4)],\n    7: [(8, 4), (9, 2), (0, 3), (2, 3), (4, 1), (5, 1), (6, 2)],\n    8: [(9, 1), (0, 4), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 3), (7, 4)],\n    9: [(8, 1), (1, 2), (2, 4), (3, 3), (5, 2), (6, 4), (7, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 3)\nprint(shortest_path_length)\n```"}, "57": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(15, 8), (7, 2)],\n    1: [(6, 5), (5, 1), (15, 10)],\n    2: [(5, 3), (4, 2)],\n    3: [(13, 1), (17, 4), (8, 3), (15, 4), (7, 6), (10, 9)],\n    4: [(12, 6), (8, 6)],\n    5: [(12, 5), (8, 7), (15, 3), (16, 9)],\n    6: [(11, 1), (9, 6)],\n    7: [(17, 9)],\n    8: [(18, 10)],\n    9: [(14, 10), (18, 2), (16, 10), (10, 4)],\n    10: [(12, 10), (17, 1)],\n    11: [(17, 3)],\n    12: [(13, 6), (17, 5)],\n    13: [],\n    14: [(18, 4)],\n    15: [],\n    16: [],\n    17: [],\n    18: []\n}\n\n# Calculate shortest path from node 10 to node 1\nshortest_path_length = dijkstra(graph, 10, 1)\nprint(shortest_path_length)\n```"}, "58": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 6), (9, 7)],\n    1: [(0, 6), (7, 1), (9, 5)],\n    2: [(4, 9), (6, 2), (3, 10)],\n    3: [(2, 10), (9, 2), (4, 3), (8, 2)],\n    4: [(2, 9), (3, 3), (8, 10)],\n    5: [(9, 6), (10, 10)],\n    6: [(2, 2), (10, 4), (8, 9)],\n    7: [(1, 1), (8, 4)],\n    8: [(3, 2), (4, 10), (6, 9), (7, 4)],\n    9: [(0, 7), (1, 5), (3, 2), (5, 6)],\n    10: [(5, 10), (6, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 2)\nprint(shortest_path_length)\n```"}, "59": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (6, 2), (5, 2), (1, 1), (4, 2)],\n    1: [(0, 1), (2, 4), (6, 4), (5, 2), (4, 2), (3, 4)],\n    2: [(0, 2), (1, 4), (6, 1), (4, 3)],\n    3: [(1, 4), (4, 1)],\n    4: [(0, 2), (1, 2), (2, 3), (3, 1), (5, 4)],\n    5: [(0, 2), (1, 2), (4, 4), (6, 2)],\n    6: [(0, 2), (1, 4), (2, 1), (5, 2)]\n}\n\nprint(dijkstra(graph, 2, 5))\n```"}, "60": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(6, 4), (9, 9), (7, 9)],\n    1: [(2, 3)],\n    2: [(1, 3), (3, 10)],\n    3: [(2, 10), (6, 6), (5, 8), (4, 10)],\n    4: [(3, 10)],\n    5: [(3, 8), (10, 2)],\n    6: [(0, 4), (3, 6), (10, 5)],\n    7: [(0, 9), (9, 8), (10, 3)],\n    8: [(9, 9)],\n    9: [(0, 9), (7, 8), (8, 9)],\n    10: [(5, 2), (6, 5), (7, 3)]\n}\n\nstart_node = 8\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "61": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 3), (2, 1), (4, 1), (1, 2), (6, 3)],\n    1: [(0, 2), (3, 2), (2, 3), (4, 4), (5, 1)],\n    2: [(0, 1), (1, 3), (3, 2), (4, 4)],\n    3: [(0, 3), (1, 2), (2, 2), (4, 1), (6, 2)],\n    4: [(0, 1), (1, 4), (2, 4), (3, 1), (5, 1), (6, 1)],\n    5: [(1, 1), (4, 1), (6, 4)],\n    6: [(0, 3), (3, 2), (4, 1), (5, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 5)\nprint(shortest_path_length)\n```"}, "62": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 3), (6, 3), (4, 3), (5, 4), (3, 4), (2, 3)],\n    1: [(0, 3), (6, 3), (4, 4), (5, 2), (3, 2), (2, 3)],\n    2: [(0, 3), (6, 2), (4, 1), (5, 4), (3, 4), (1, 3)],\n    3: [(0, 4), (6, 1), (4, 1), (5, 4), (1, 2), (2, 4)],\n    4: [(0, 3), (6, 3), (1, 4), (3, 1), (2, 1)],\n    5: [(0, 4), (6, 2), (1, 2), (3, 4), (2, 4)],\n    6: [(0, 3), (1, 3), (4, 3), (5, 2), (3, 1), (2, 2)]\n}\n\nprint(dijkstra(graph, 4, 5))\n```"}, "63": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 3), (7, 1)],\n    1: [(11, 5), (13, 2)],\n    2: [(8, 1), (7, 9), (16, 8), (6, 5)],\n    3: [(0, 3), (4, 5), (13, 1), (12, 8)],\n    4: [(3, 5), (16, 10)],\n    5: [(9, 1), (7, 8)],\n    6: [(2, 5), (13, 7), (7, 9), (15, 5)],\n    7: [(0, 1), (2, 9), (5, 8), (6, 9), (15, 9)],\n    8: [(2, 1)],\n    9: [(5, 1), (10, 5)],\n    10: [(9, 5)],\n    11: [(1, 5), (14, 3)],\n    12: [(3, 8), (15, 8)],\n    13: [(1, 2), (3, 1), (6, 7)],\n    14: [(11, 3), (16, 8)],\n    15: [(6, 5), (7, 9), (12, 8), (17, 9)],\n    16: [(2, 8), (4, 10), (14, 8)],\n    17: [(15, 9)]\n}\n\nprint(dijkstra(graph, 1, 10))\n```"}, "64": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (3, 3)],\n    1: [(4, 1), (2, 2), (3, 1)],\n    2: [(4, 3), (3, 3)],\n    3: [(0, 3), (1, 1), (2, 3), (4, 1)],\n    4: [(0, 4), (1, 1), (2, 3), (3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 2)\nprint(shortest_path_length)\n```"}, "65": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 3), (4, 2), (2, 1), (3, 1)],\n    1: [(0, 3), (4, 4), (3, 2)],\n    2: [(0, 1), (4, 3), (3, 3)],\n    3: [(0, 1), (1, 2), (2, 3)],\n    4: [(0, 2), (1, 4), (2, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 2)\nprint(shortest_path_length)\n```"}, "66": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(20)}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 3), (16, 1)],\n    1: [(12, 7), (15, 2), (3, 6), (8, 3)],\n    2: [(15, 9), (18, 9), (3, 5), (8, 10), (4, 7), (6, 7), (17, 1)],\n    3: [(15, 5), (9, 8), (17, 1), (1, 6), (2, 5)],\n    4: [(2, 7)],\n    5: [(10, 9), (16, 1), (13, 7)],\n    6: [(18, 6), (9, 1), (16, 3), (17, 7), (13, 5), (2, 7)],\n    7: [(12, 8), (16, 1), (17, 8)],\n    8: [(18, 2), (11, 4), (9, 1), (1, 3), (2, 10)],\n    9: [(15, 7), (11, 7), (16, 10), (3, 8), (6, 1), (8, 1)],\n    10: [(14, 5), (13, 2), (5, 9)],\n    11: [(15, 4), (8, 4), (9, 7)],\n    12: [(18, 3), (13, 10), (19, 5), (0, 3), (1, 7), (7, 8)],\n    13: [(10, 2), (5, 7), (6, 5), (12, 10)],\n    14: [(10, 5)],\n    15: [(18, 8), (1, 2), (2, 9), (3, 5), (9, 7), (11, 4)],\n    16: [(19, 6), (0, 1), (5, 1), (6, 3), (7, 1), (9, 10)],\n    17: [(18, 2), (19, 4), (2, 1), (3, 1), (6, 7), (7, 8)],\n    18: [(2, 9), (6, 6), (8, 2), (12, 3), (15, 8), (17, 2)],\n    19: [(12, 5), (16, 6), (17, 4)]\n}\n\nprint(dijkstra(graph, 3, 14))\n```"}, "67": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 4), (5, 2), (6, 2)],\n    1: [(0, 4), (4, 4), (5, 2), (6, 3)],\n    2: [(3, 4), (4, 4), (5, 1), (6, 1)],\n    3: [(2, 4), (4, 1), (6, 2)],\n    4: [(1, 4), (2, 4), (3, 1), (5, 3), (6, 4)],\n    5: [(0, 2), (1, 2), (2, 1), (4, 3)],\n    6: [(0, 2), (1, 3), (2, 1), (3, 2), (4, 4)]\n}\n\nprint(dijkstra(graph, 3, 0))\n```"}, "68": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 1), (3, 1), (1, 2)],\n    1: [(0, 2), (4, 4), (5, 4), (2, 2), (3, 3)],\n    2: [(1, 2)],\n    3: [(0, 1), (1, 3), (5, 1)],\n    4: [(0, 1), (1, 4)],\n    5: [(1, 4), (3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 5)\nprint(shortest_path_length)\n```"}, "69": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(1, 1)],\n    1: [(0, 1), (9, 8), (6, 3)],\n    2: [(11, 9), (15, 1)],\n    3: [(14, 2), (6, 6), (5, 5)],\n    4: [(9, 6), (6, 1), (15, 6)],\n    5: [(3, 5), (9, 6)],\n    6: [(1, 3), (3, 6), (4, 1), (9, 3), (12, 4)],\n    7: [(9, 1), (12, 2)],\n    8: [(11, 2)],\n    9: [(1, 8), (4, 6), (5, 6), (6, 3), (7, 1)],\n    10: [(13, 1)],\n    11: [(2, 9), (8, 2), (15, 3)],\n    12: [(6, 4), (7, 2), (14, 6)],\n    13: [(10, 1), (15, 3)],\n    14: [(3, 2), (12, 6)],\n    15: [(2, 1), (4, 6), (11, 3), (13, 3)]\n}\n\nstart_node = 14\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "70": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 3), (4, 8)],\n    1: [(0, 3), (16, 2), (2, 3), (8, 6), (4, 7)],\n    2: [(1, 3), (8, 2)],\n    3: [(6, 6), (10, 8), (15, 5)],\n    4: [(0, 8), (1, 7), (7, 8), (12, 6)],\n    5: [(6, 3), (11, 1), (9, 4)],\n    6: [(3, 6), (5, 3), (14, 10), (16, 1)],\n    7: [(4, 8), (16, 8)],\n    8: [(1, 6), (2, 2), (10, 4), (15, 8)],\n    9: [(5, 4)],\n    10: [(3, 8), (8, 4), (11, 4)],\n    11: [(5, 1), (10, 4)],\n    12: [(4, 6), (15, 6)],\n    13: [(16, 6)],\n    14: [(6, 10)],\n    15: [(3, 5), (8, 8), (12, 6)],\n    16: [(1, 2), (6, 1), (7, 8), (13, 6)]\n}\n\nprint(dijkstra(graph, 12, 9))\n```"}, "71": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 3), (2, 4)],\n    1: [(3, 4), (2, 3)],\n    2: [(0, 4), (1, 3), (3, 3), (4, 3)],\n    3: [(0, 3), (1, 4), (2, 3)],\n    4: [(2, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 1)\nprint(shortest_path_length)\n```"}, "72": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 9)],\n    1: [(8, 2), (4, 1)],\n    2: [(8, 4)],\n    3: [(5, 6), (10, 4)],\n    4: [(1, 1), (5, 4)],\n    5: [(3, 6), (4, 4), (6, 5), (10, 1)],\n    6: [(5, 5), (9, 10)],\n    7: [(9, 4)],\n    8: [(1, 2), (2, 4)],\n    9: [(0, 9), (6, 10), (7, 4)],\n    10: [(3, 4), (5, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 2)\nprint(shortest_path_length)\n```"}, "73": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(len(graph))}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 6), (8, 5), (6, 6), (7, 5), (11, 2), (12, 10)],\n    1: [(4, 4), (6, 7), (13, 3), (15, 1)],\n    2: [(10, 6), (16, 8), (13, 2), (7, 7), (11, 1)],\n    3: [(8, 3), (7, 5), (15, 9), (12, 2)],\n    4: [(0, 6), (1, 4), (9, 3), (10, 5), (6, 9), (16, 5), (17, 9), (11, 4), (12, 10)],\n    5: [(10, 2), (15, 2)],\n    6: [(0, 6), (1, 7), (4, 9)],\n    7: [(0, 5), (2, 7), (3, 5), (17, 8), (15, 4), (11, 10)],\n    8: [(0, 5), (3, 3), (13, 2), (15, 5)],\n    9: [(4, 3)],\n    10: [(2, 6), (4, 5), (5, 2), (11, 7)],\n    11: [(0, 2), (2, 1), (4, 4), (7, 10), (10, 7), (16, 5)],\n    12: [(0, 10), (3, 2), (4, 10), (14, 1)],\n    13: [(1, 3), (2, 2), (8, 2)],\n    14: [(12, 1)],\n    15: [(1, 1), (3, 9), (5, 2), (7, 4), (8, 5)],\n    16: [(2, 8), (4, 5), (11, 5)],\n    17: [(4, 9), (7, 8)]\n}\n\nstart_node = 5\nend_node = 14\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "74": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(16, 10), (1, 3), (17, 10)],\n    1: [(0, 3), (16, 2), (3, 2)],\n    2: [(10, 8), (6, 3), (15, 3), (11, 4)],\n    3: [(1, 2), (13, 6), (5, 7)],\n    4: [(10, 9), (11, 6), (9, 10)],\n    5: [(3, 7), (13, 2), (16, 10)],\n    6: [(2, 3), (15, 8), (12, 3), (9, 2), (18, 3)],\n    7: [(15, 8), (12, 2), (13, 7)],\n    8: [(15, 8), (12, 8), (16, 8)],\n    9: [(4, 10), (10, 2), (15, 1), (12, 9), (16, 8), (6, 2)],\n    10: [(2, 8), (4, 9), (9, 2), (18, 8), (17, 7)],\n    11: [(2, 4), (4, 6), (14, 2)],\n    12: [(6, 3), (7, 2), (8, 8), (9, 9), (15, 8), (18, 3)],\n    13: [(3, 6), (5, 2), (7, 7)],\n    14: [(11, 2)],\n    15: [(2, 3), (6, 8), (7, 8), (8, 8), (9, 1), (12, 8), (18, 1), (16, 6)],\n    16: [(0, 10), (1, 2), (5, 10), (8, 8), (9, 8), (15, 6)],\n    17: [(0, 10), (10, 7)],\n    18: [(6, 3), (10, 8), (12, 3), (15, 1)]\n}\n\nstart_node = 11\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "75": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 2)],\n    1: [(0, 2), (8, 9), (3, 7), (2, 7)],\n    2: [(1, 7), (3, 9), (6, 3)],\n    3: [(1, 7), (2, 9), (4, 4)],\n    4: [(3, 4), (8, 6), (5, 3), (11, 8)],\n    5: [(4, 3), (13, 9), (7, 10)],\n    6: [(2, 3), (11, 9)],\n    7: [(5, 10), (9, 7), (10, 6)],\n    8: [(1, 9), (4, 6), (12, 8), (11, 8)],\n    9: [(7, 7)],\n    10: [(7, 6)],\n    11: [(4, 8), (6, 9), (8, 8)],\n    12: [(8, 8)],\n    13: [(5, 9)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 0)\nprint(shortest_path_length)\n```"}, "76": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (3, 3), (1, 3)],\n    1: [(0, 3), (4, 4)],\n    2: [(4, 2), (3, 1)],\n    3: [(0, 3), (2, 1), (4, 1)],\n    4: [(0, 4), (1, 4), (2, 2), (3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 2)\nprint(shortest_path_length)\n```"}, "77": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(16, 3), (1, 8)],\n    1: [(0, 8), (5, 6)],\n    2: [(12, 9), (14, 8)],\n    3: [(11, 7), (5, 8), (6, 1), (8, 3), (13, 9), (4, 6)],\n    4: [(3, 6), (16, 9), (14, 6), (15, 10)],\n    5: [(1, 6), (3, 8)],\n    6: [(3, 1), (9, 4), (8, 4)],\n    7: [(11, 4), (9, 10), (10, 9), (8, 5)],\n    8: [(3, 3), (6, 4), (7, 5)],\n    9: [(6, 4), (7, 10)],\n    10: [(7, 9), (15, 8)],\n    11: [(3, 7), (7, 4), (14, 10)],\n    12: [(2, 9)],\n    13: [(3, 9)],\n    14: [(2, 8), (4, 6), (11, 10)],\n    15: [(4, 10), (10, 8)],\n    16: [(0, 3), (4, 9)]\n}\n\nshortest_path_length = dijkstra(graph, 11, 0)\nprint(shortest_path_length)\n```"}, "78": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 2), (4, 2), (1, 2), (2, 1)],\n    1: [(0, 2), (3, 2), (4, 1), (2, 4)],\n    2: [(0, 1), (1, 4), (3, 3)],\n    3: [(0, 2), (1, 2), (2, 3), (4, 1)],\n    4: [(0, 2), (1, 1), (3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 2)\nprint(shortest_path_length)\n```"}, "79": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 3), (4, 1), (7, 4), (9, 4)],\n    1: [(4, 1), (5, 1)],\n    2: [(3, 2), (4, 4), (9, 4)],\n    3: [(0, 3), (2, 2), (4, 3), (7, 4), (5, 3)],\n    4: [(0, 1), (1, 1), (2, 4), (3, 3), (8, 1), (5, 3), (6, 4), (9, 4)],\n    5: [(1, 1), (3, 3), (4, 3), (8, 3), (7, 4), (6, 4), (9, 2)],\n    6: [(4, 4), (5, 4), (9, 1)],\n    7: [(0, 4), (3, 4), (5, 4), (8, 4)],\n    8: [(4, 1), (5, 3), (7, 4), (9, 1)],\n    9: [(0, 4), (2, 4), (4, 4), (5, 2), (6, 1), (8, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 8)\nprint(shortest_path_length)\n```"}, "80": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 1), (2, 2), (3, 3), (6, 4), (1, 2), (4, 2), (7, 4)],\n    1: [(0, 2), (5, 4), (2, 4), (3, 3), (6, 4), (4, 4), (7, 3)],\n    2: [(0, 2), (5, 4), (3, 1), (6, 3), (4, 2), (7, 4), (1, 4)],\n    3: [(0, 3), (5, 3), (2, 1), (4, 1), (1, 3)],\n    4: [(0, 2), (5, 2), (3, 1), (6, 3), (7, 2), (1, 4), (2, 2)],\n    5: [(0, 1), (6, 1), (7, 1), (1, 4), (2, 4), (3, 3), (4, 2)],\n    6: [(0, 4), (5, 1), (7, 3), (1, 4), (2, 3), (4, 3)],\n    7: [(0, 4), (5, 1), (6, 3), (1, 3), (2, 4), (4, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 6)\nprint(shortest_path_length)\n```"}, "81": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 5), (18, 1)],\n    1: [(16, 8), (12, 5), (8, 5), (17, 10)],\n    2: [(15, 4), (11, 10), (7, 10), (12, 2), (9, 3), (3, 1)],\n    3: [(18, 7), (2, 1)],\n    4: [(10, 7)],\n    5: [(11, 7)],\n    6: [(16, 2), (12, 6), (17, 6)],\n    7: [(0, 5), (2, 10)],\n    8: [(1, 5)],\n    9: [(15, 7), (18, 4), (2, 3)],\n    10: [(14, 9), (18, 10), (17, 9), (4, 7)],\n    11: [(15, 7), (2, 10), (5, 7)],\n    12: [(15, 4), (16, 10), (1, 5), (2, 2), (6, 6)],\n    13: [(15, 4), (16, 1), (18, 9), (17, 10)],\n    14: [(10, 9)],\n    15: [(2, 4), (9, 7), (11, 7), (12, 4), (13, 4), (16, 9)],\n    16: [(1, 8), (6, 2), (12, 10), (13, 1), (15, 9)],\n    17: [(1, 10), (6, 6), (10, 9), (13, 10)],\n    18: [(0, 1), (3, 7), (9, 4), (10, 10), (13, 9)]\n}\n\nprint(dijkstra(graph, 5, 4))\n```"}, "82": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (5, 2)],\n    1: [(2, 1), (4, 1), (6, 4), (3, 3)],\n    2: [(0, 3), (1, 1), (5, 3), (6, 3), (3, 1)],\n    3: [(1, 3), (2, 1), (4, 4), (5, 1), (6, 3)],\n    4: [(1, 1), (3, 4), (5, 4), (6, 3)],\n    5: [(0, 2), (2, 3), (3, 1), (4, 4), (6, 3)],\n    6: [(1, 4), (2, 3), (3, 3), (4, 3), (5, 3)]\n}\n\nprint(dijkstra(graph, 2, 4))\n```"}, "83": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 10), (13, 1), (8, 8), (9, 8), (6, 5), (7, 10)],\n    1: [(4, 8), (5, 4)],\n    2: [(3, 6)],\n    3: [(2, 6), (13, 9), (4, 10), (8, 6), (7, 1), (12, 2)],\n    4: [(1, 8), (3, 10), (11, 1), (6, 5), (7, 4), (12, 5)],\n    5: [(1, 4), (7, 5)],\n    6: [(0, 5), (4, 5), (7, 5), (12, 5)],\n    7: [(0, 10), (3, 1), (4, 4), (5, 5), (6, 5), (13, 6), (11, 7), (9, 6)],\n    8: [(0, 8), (3, 6), (10, 3)],\n    9: [(0, 8), (7, 6)],\n    10: [(0, 10), (8, 3)],\n    11: [(4, 1), (7, 7)],\n    12: [(3, 2), (4, 5), (6, 5)],\n    13: [(0, 1), (3, 9), (7, 6)]\n}\n\nstart_node = 10\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "84": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 3), (3, 4)],\n    1: [(13, 7), (11, 2), (5, 9)],\n    2: [(13, 10), (10, 6)],\n    3: [(0, 4), (4, 7), (11, 3), (5, 1), (12, 1)],\n    4: [(3, 7), (10, 8), (8, 10), (12, 2)],\n    5: [(1, 9), (3, 1), (10, 8), (11, 9), (12, 6)],\n    6: [(13, 6), (10, 7)],\n    7: [(14, 2)],\n    8: [(4, 10)],\n    9: [(0, 3)],\n    10: [(2, 6), (4, 8), (5, 8), (6, 7), (12, 1)],\n    11: [(1, 2), (3, 3), (5, 9), (14, 8)],\n    12: [(3, 1), (4, 2), (5, 6), (10, 1), (13, 2)],\n    13: [(1, 7), (2, 10), (6, 6), (12, 2)],\n    14: [(7, 2), (11, 8)]\n}\n\nstart_node = 8\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "85": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 2), (6, 1), (1, 2)],\n    1: [(0, 2), (6, 3), (2, 1)],\n    2: [(1, 1), (6, 4), (3, 2)],\n    3: [(2, 2), (6, 2), (5, 2)],\n    4: [(0, 2), (6, 1)],\n    5: [(3, 2), (6, 2)],\n    6: [(0, 1), (1, 3), (2, 4), (3, 2), (4, 1), (5, 2)]\n}\n\nstart_node = 4\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "86": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 7), (8, 1), (7, 5)],\n    1: [(12, 7), (6, 9), (2, 8)],\n    2: [(10, 8), (14, 6), (7, 1), (11, 7)],\n    3: [(13, 3), (12, 5), (7, 2), (5, 1)],\n    4: [(7, 7)],\n    5: [(13, 10), (9, 3), (7, 5)],\n    6: [(13, 2), (12, 2)],\n    7: [(12, 8)],\n    8: [],\n    9: [],\n    10: [(14, 2)],\n    11: [],\n    12: [],\n    13: [],\n    14: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if u not in [x[0] for x in graph[v]]:\n            graph[v].append((u, w))\n\nprint(dijkstra(graph, 14, 12))\n```"}, "87": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    shortest_paths = {node: float('inf') for node in graph}\n    shortest_paths[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > shortest_paths[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')  # If there's no path from start to end\n\n# Graph representation\ngraph = {\n    0: [(12, 2), (6, 3), (15, 1), (14, 8), (8, 7)],\n    1: [(16, 10), (2, 9), (8, 10)],\n    2: [(15, 9), (14, 4), (4, 7)],\n    3: [(12, 10), (7, 5), (5, 7), (15, 8), (9, 10)],\n    4: [(15, 3), (10, 3)],\n    5: [(7, 4), (6, 3), (15, 10), (17, 4)],\n    6: [(11, 5), (15, 3), (10, 9), (8, 9)],\n    7: [(13, 6), (18, 4)],\n    8: [(12, 4), (11, 2)],\n    9: [(15, 2)],\n    10: [(11, 6), (17, 8)],\n    11: [(18, 5)],\n    12: [],\n    13: [],\n    14: [],\n    15: [(16, 8), (18, 6)],\n    16: [(18, 1)],\n    17: [],\n    18: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if v not in graph:\n            graph[v] = []\n        graph[v].append((u, w))\n\n# Find shortest path from node 13 to node 14\nshortest_path_length = dijkstra(graph, 13, 14)\nprint(shortest_path_length)\n```"}, "88": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 4), (1, 3)],\n    1: [(0, 3), (3, 4), (15, 9), (11, 8)],\n    2: [(5, 1), (14, 4), (10, 8), (11, 10), (16, 7)],\n    3: [(1, 4), (4, 6), (14, 2), (10, 4), (9, 6)],\n    4: [(3, 6), (5, 9), (10, 4), (6, 10)],\n    5: [(0, 4), (2, 1), (4, 9), (10, 7), (9, 6)],\n    6: [(4, 10), (7, 7)],\n    7: [(6, 7), (13, 8), (14, 5), (11, 4)],\n    8: [(17, 8), (10, 6)],\n    9: [(3, 6), (5, 6), (12, 9)],\n    10: [(2, 8), (3, 4), (4, 4), (5, 7), (8, 6)],\n    11: [(1, 8), (2, 10), (7, 4)],\n    12: [(9, 9), (17, 7), (16, 8)],\n    13: [(7, 8)],\n    14: [(2, 4), (3, 2), (7, 5)],\n    15: [(1, 9)],\n    16: [(2, 7), (12, 8)],\n    17: [(8, 8), (12, 7)]\n}\n\nstart_node = 17\nend_node = 13\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "89": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(20)}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 1), (3, 9), (17, 2), (14, 2)],\n    1: [(9, 8), (2, 2), (19, 1)],\n    2: [(3, 10), (12, 4), (11, 3)],\n    3: [(6, 4), (5, 1), (18, 6), (12, 1)],\n    4: [(15, 1)],\n    5: [(14, 3)],\n    6: [(13, 5), (14, 9)],\n    7: [(10, 8), (18, 7)],\n    8: [(18, 7), (19, 3)],\n    9: [(16, 5), (12, 6)],\n    10: [(14, 7), (15, 4)],\n    11: [(19, 10)],\n    12: [(13, 8), (16, 8), (17, 5), (18, 1), (15, 4)],\n    13: [(16, 3), (18, 10), (14, 8)],\n    14: [(18, 7)],\n    15: [],\n    16: [(18, 9)],\n    17: [(18, 4)],\n    18: [],\n    19: []\n}\n\nshortest_path_length = dijkstra(graph, 4, 19)\nprint(shortest_path_length)\n```"}, "90": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 2), (7, 4), (1, 2), (4, 1), (2, 1), (5, 3), (6, 1)],\n    1: [(0, 2), (3, 4), (7, 2), (2, 4), (5, 4), (6, 3)],\n    2: [(0, 1), (7, 3), (4, 2), (5, 4), (6, 1), (1, 4)],\n    3: [(0, 2), (7, 4), (4, 4), (5, 1), (6, 2), (1, 4)],\n    4: [(0, 1), (7, 4), (3, 4), (5, 3), (2, 2)],\n    5: [(0, 3), (7, 3), (3, 1), (4, 3), (6, 2), (1, 4), (2, 4)],\n    6: [(0, 1), (3, 2), (5, 2), (1, 3), (2, 1)],\n    7: [(0, 4), (3, 4), (1, 2), (2, 3), (4, 4), (5, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 2)\nprint(shortest_path_length)\n```"}, "91": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in range(len(graph))}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(13, 1)],\n    1: [(11, 1), (4, 4), (5, 1), (18, 7), (2, 8)],\n    2: [(9, 5), (7, 1), (8, 1)],\n    3: [(17, 4), (12, 7), (5, 6), (18, 2), (7, 3)],\n    4: [(11, 7), (9, 1), (16, 9)],\n    5: [(12, 9)],\n    6: [(13, 4)],\n    7: [(11, 8), (19, 1), (10, 10)],\n    8: [(18, 10)],\n    9: [(15, 5), (10, 10)],\n    10: [(17, 10), (14, 3)],\n    11: [(18, 2)],\n    12: [(17, 3)],\n    13: [(16, 10)],\n    14: [(19, 6)],\n    15: [(19, 6), (18, 10)],\n    16: [],\n    17: [],\n    18: [],\n    19: []\n}\n\n# Calculate shortest path from node 4 to node 15\nshortest_path_length = dijkstra(graph, 4, 15)\nprint(shortest_path_length)\n```"}, "92": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 2), (1, 3), (2, 1), (5, 1)],\n    1: [(0, 3), (6, 3), (3, 3), (5, 1)],\n    2: [(0, 1)],\n    3: [(0, 2), (1, 3), (4, 4), (5, 1)],\n    4: [(3, 4), (6, 2)],\n    5: [(0, 1), (1, 1), (3, 1)],\n    6: [(1, 3), (4, 2)]\n}\n\nstart_node = 6\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "93": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 3), (1, 3), (2, 3), (3, 1), (7, 4), (8, 1)],\n    1: [(0, 3), (2, 4), (8, 4)],\n    2: [(0, 3), (1, 4), (5, 2), (3, 4), (8, 3), (4, 2)],\n    3: [(0, 1), (2, 4), (5, 1), (7, 3), (4, 3)],\n    4: [(2, 2), (3, 3), (7, 2), (8, 4)],\n    5: [(2, 2), (3, 1), (8, 3)],\n    6: [(0, 3), (8, 4)],\n    7: [(0, 4), (3, 3), (4, 2)],\n    8: [(0, 1), (1, 4), (2, 3), (4, 4), (5, 3), (6, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 0)\nprint(shortest_path_length)\n```"}, "94": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 8), (5, 2), (2, 6), (9, 6)],\n    1: [(7, 9), (3, 9), (5, 6), (2, 9)],\n    2: [(0, 6), (1, 9), (8, 4)],\n    3: [(0, 8), (1, 9), (8, 7)],\n    4: [(8, 9)],\n    5: [(0, 2), (1, 6), (6, 2), (10, 5)],\n    6: [(5, 2), (7, 6), (10, 5)],\n    7: [(1, 9), (6, 6)],\n    8: [(2, 4), (3, 7), (4, 9)],\n    9: [(0, 6)],\n    10: [(5, 5), (6, 5)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 8)\nprint(shortest_path_length)\n```"}, "95": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 5), (1, 1), (9, 9)],\n    1: [(0, 1), (8, 1), (2, 1), (3, 4), (9, 6), (5, 9)],\n    2: [(1, 1), (10, 2), (4, 1), (9, 1)],\n    3: [(1, 4), (8, 5), (6, 10), (4, 4)],\n    4: [(2, 1), (3, 4), (10, 6)],\n    5: [(1, 9), (12, 7)],\n    6: [(0, 5), (3, 10), (10, 7)],\n    7: [(10, 9), (12, 10)],\n    8: [(1, 1), (3, 5)],\n    9: [(0, 9), (1, 6), (2, 1), (12, 9)],\n    10: [(2, 2), (4, 6), (6, 7), (7, 9)],\n    11: [(12, 4)],\n    12: [(5, 7), (7, 10), (9, 9), (11, 4)]\n}\n\nstart_node = 3\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "96": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 7), (13, 6), (2, 9)],\n    1: [(0, 7), (4, 7)],\n    2: [(0, 9), (16, 4), (14, 5), (17, 6)],\n    3: [(14, 3), (10, 10), (13, 8), (17, 7)],\n    4: [(1, 7), (16, 8), (5, 4), (12, 2), (15, 9)],\n    5: [(4, 4), (9, 3)],\n    6: [(17, 7)],\n    7: [(16, 5), (14, 6), (8, 10)],\n    8: [(7, 10), (13, 7)],\n    9: [(5, 3), (12, 6)],\n    10: [(3, 10), (13, 3), (15, 1)],\n    11: [(12, 5)],\n    12: [(4, 2), (9, 6), (11, 5), (16, 7)],\n    13: [(0, 6), (3, 8), (8, 7), (10, 3), (16, 3)],\n    14: [(2, 5), (3, 3), (7, 6), (15, 1)],\n    15: [(4, 9), (10, 1), (14, 1)],\n    16: [(2, 4), (4, 8), (7, 5), (12, 7), (13, 3)],\n    17: [(2, 6), (3, 7), (6, 7)]\n}\n\nstart_node = 17\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "97": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 1), (6, 1), (5, 1), (1, 2), (2, 4)],\n    1: [(0, 2), (4, 2)],\n    2: [(0, 4), (3, 2), (6, 1), (4, 1), (5, 3)],\n    3: [(0, 1), (2, 2), (5, 2), (7, 4)],\n    4: [(1, 2), (2, 1), (6, 2), (5, 1), (7, 3)],\n    5: [(0, 1), (2, 3), (3, 2), (4, 1), (7, 3)],\n    6: [(0, 1), (2, 1), (4, 2)],\n    7: [(3, 4), (4, 3), (5, 3)]\n}\n\nprint(dijkstra(graph, 0, 4))\n```"}, "98": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 4), (5, 4), (7, 4), (2, 4), (4, 1), (6, 3)],\n    1: [(3, 1), (8, 3), (5, 4), (7, 2), (4, 2), (6, 1)],\n    2: [(3, 3), (8, 3), (5, 1), (7, 1), (4, 2), (6, 2)],\n    3: [(8, 4), (5, 4), (7, 3), (4, 4), (6, 4)],\n    4: [(7, 4)],\n    5: [(8, 4), (7, 2), (6, 2)],\n    6: [(7, 4)],\n    7: [],\n    8: []\n}\n\nshortest_path_length = dijkstra(graph, 3, 0)\nprint(shortest_path_length)\n```"}, "99": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 9), (3, 3), (6, 7)],\n    1: [(7, 10), (5, 1), (6, 9), (12, 8), (8, 3)],\n    2: [(11, 4), (13, 6), (10, 5)],\n    3: [(14, 5), (13, 7), (0, 3)],\n    4: [(11, 1), (5, 3), (6, 2), (13, 3)],\n    5: [(1, 1), (4, 3), (7, 10), (9, 3), (6, 7), (12, 8), (8, 2)],\n    6: [(0, 7), (1, 9), (4, 2), (5, 7), (11, 8), (15, 4)],\n    7: [(0, 9), (1, 10), (5, 10)],\n    8: [(1, 3), (5, 2), (15, 1), (13, 4), (10, 4)],\n    9: [(5, 3), (11, 7), (12, 9)],\n    10: [(2, 5), (8, 4), (13, 10)],\n    11: [(2, 4), (4, 1), (6, 8), (9, 7), (14, 6)],\n    12: [(1, 8), (5, 8), (9, 9)],\n    13: [(2, 6), (3, 7), (4, 3), (8, 4), (10, 10), (15, 8)],\n    14: [(3, 5), (11, 6)],\n    15: [(6, 4), (8, 1), (13, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 4)\nprint(shortest_path_length)\n```"}, "100": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (2, 2), (7, 10), (12, 2), (9, 1)],\n    1: [(0, 1), (4, 8), (2, 1)],\n    2: [(0, 2), (1, 1)],\n    3: [(8, 4), (10, 6), (7, 7)],\n    4: [(1, 8), (11, 3), (7, 3), (12, 2)],\n    5: [(8, 8)],\n    6: [(8, 1), (10, 9)],\n    7: [(0, 10), (3, 7), (4, 3), (8, 6), (12, 10)],\n    8: [(3, 4), (5, 8), (6, 1), (7, 6), (9, 6)],\n    9: [(0, 1), (8, 6)],\n    10: [(3, 6), (6, 9), (12, 1)],\n    11: [(4, 3)],\n    12: [(0, 2), (4, 2), (7, 10), (10, 1)]\n}\n\nstart_node = 6\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "101": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 2), (4, 2)],\n    1: [(6, 4), (4, 4)],\n    2: [(3, 2), (5, 1)],\n    3: [(0, 2), (2, 2), (6, 4), (4, 4)],\n    4: [(0, 2), (1, 4), (3, 4), (6, 2), (5, 4)],\n    5: [(2, 1), (4, 4), (6, 1)],\n    6: [(1, 4), (3, 4), (4, 2), (5, 1)]\n}\n\nprint(dijkstra(graph, 6, 0))\n```"}, "102": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 1)],\n    1: [(5, 3)],\n    2: [(8, 2), (3, 4)],\n    3: [(0, 1), (2, 4)],\n    4: [(9, 6)],\n    5: [(1, 3), (6, 5), (8, 6)],\n    6: [(5, 5), (10, 5)],\n    7: [(9, 6)],\n    8: [(2, 2), (5, 6), (9, 9)],\n    9: [(4, 6), (7, 6), (8, 9)],\n    10: [(6, 5)]\n}\n\nshortest_path_length = dijkstra(graph, 10, 0)\nprint(shortest_path_length)\n```"}, "103": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 2), (3, 4), (5, 4), (1, 3)],\n    1: [(0, 3), (6, 1), (2, 2), (3, 2), (4, 3), (7, 4)],\n    2: [(1, 2), (6, 1), (4, 3), (5, 4)],\n    3: [(0, 4), (1, 2), (7, 2)],\n    4: [(1, 3), (2, 3), (6, 1), (8, 1)],\n    5: [(0, 4), (2, 4), (6, 4), (8, 2)],\n    6: [(0, 2), (1, 1), (2, 1), (4, 1), (5, 4)],\n    7: [(1, 4), (3, 2), (8, 3)],\n    8: [(4, 1), (5, 2), (7, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 6, 3)\nprint(shortest_path_length)\n```"}, "104": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (3, 1), (4, 3), (7, 2)],\n    1: [(3, 2), (4, 3), (6, 4), (5, 1), (7, 4)],\n    2: [(0, 2), (3, 1), (4, 2), (6, 2), (7, 1)],\n    3: [(0, 1), (1, 2), (2, 1), (4, 1), (6, 4), (7, 4)],\n    4: [(0, 3), (1, 3), (2, 2), (3, 1), (6, 4), (5, 2), (7, 1)],\n    5: [(1, 1), (4, 2), (6, 3), (7, 2)],\n    6: [(1, 4), (2, 2), (3, 4), (4, 4), (5, 3), (7, 4)],\n    7: [(0, 2), (1, 4), (2, 1), (3, 4), (4, 1), (5, 2), (6, 4)]\n}\n\nprint(dijkstra(graph, 0, 6))\n```"}, "105": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 8), (4, 6), (9, 9)],\n    1: [(3, 5), (7, 5)],\n    2: [(10, 3), (3, 3), (7, 7)],\n    3: [(1, 5), (2, 3), (6, 3), (5, 3), (8, 8)],\n    4: [(0, 6), (10, 7), (8, 6)],\n    5: [(3, 3)],\n    6: [(3, 3)],\n    7: [(0, 8), (1, 5), (2, 7), (10, 5)],\n    8: [(3, 8), (4, 6)],\n    9: [(0, 9), (10, 2)],\n    10: [(2, 3), (4, 7), (7, 5), (9, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 5)\nprint(shortest_path_length)\n```"}, "106": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 10), (13, 3)],\n    1: [(2, 5)],\n    2: [(1, 5), (14, 9), (9, 2)],\n    3: [(6, 4), (5, 7), (10, 7), (11, 10)],\n    4: [(15, 5), (8, 7), (12, 5)],\n    5: [(0, 10), (3, 7), (10, 7)],\n    6: [(3, 4), (8, 3), (7, 9)],\n    7: [(6, 9)],\n    8: [(4, 7), (6, 3), (11, 10), (13, 2)],\n    9: [(2, 2), (11, 9)],\n    10: [(3, 7), (5, 7), (11, 5)],\n    11: [(3, 10), (8, 10), (9, 9), (10, 5), (15, 3)],\n    12: [(4, 5), (13, 9)],\n    13: [(0, 3), (8, 2), (12, 9)],\n    14: [(2, 9), (15, 5)],\n    15: [(4, 5), (11, 3), (14, 5)]\n}\n\nstart_node = 7\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "107": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 4), (1, 4), (4, 3), (5, 2), (8, 2), (2, 1), (3, 1), (7, 4)],\n    1: [(0, 4), (9, 1), (6, 2), (4, 4), (5, 3), (8, 2), (3, 3), (7, 4)],\n    2: [(0, 1), (9, 4), (6, 1), (4, 3), (3, 1), (7, 1)],\n    3: [(0, 1), (6, 2), (4, 2), (8, 1), (7, 2), (2, 1)],\n    4: [(0, 3), (1, 4), (6, 4), (5, 4), (2, 3), (3, 2)],\n    5: [(0, 2), (1, 3), (9, 3), (8, 2), (4, 4), (7, 3)],\n    6: [(0, 4), (1, 2), (9, 2), (8, 3), (2, 1), (3, 2), (4, 4), (7, 3)],\n    7: [(0, 4), (1, 4), (9, 1), (2, 1), (3, 2), (5, 3), (6, 3)],\n    8: [(0, 2), (1, 2), (5, 2), (3, 1), (6, 3)],\n    9: [(1, 1), (2, 4), (5, 3), (6, 2), (7, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 0)\nprint(shortest_path_length)\n```"}, "108": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(15, 1), (14, 7), (8, 7), (11, 9), (6, 4)],\n    1: [(2, 6), (17, 6), (3, 8)],\n    2: [(13, 5), (16, 9), (12, 1)],\n    3: [(10, 2), (13, 6), (16, 9), (7, 6), (8, 1)],\n    4: [(13, 8), (7, 5), (9, 7)],\n    5: [(13, 4), (15, 1), (7, 9), (8, 9), (11, 6)],\n    6: [(12, 3), (8, 5), (11, 7)],\n    7: [(17, 6), (12, 4), (11, 5)],\n    8: [],\n    9: [],\n    10: [(16, 10)],\n    11: [(16, 3), (12, 7)],\n    12: [(16, 5)],\n    13: [(16, 4)],\n    14: [],\n    15: [(17, 9)],\n    16: [],\n    17: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if v not in graph:\n            graph[v] = []\n        graph[v].append((u, w))\n\n# Find shortest path from node 9 to node 14\nshortest_path_length = dijkstra(graph, 9, 14)\nprint(shortest_path_length)\n```"}, "109": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (5, 4), (4, 2), (1, 3)],\n    1: [(0, 3), (2, 1), (3, 2), (5, 1), (4, 4)],\n    2: [(0, 3), (1, 1), (3, 2), (5, 1), (4, 2)],\n    3: [(1, 2), (2, 2), (5, 3), (4, 1)],\n    4: [(0, 2), (1, 4), (2, 2), (3, 1), (5, 4)],\n    5: [(0, 4), (1, 1), (2, 1), (3, 3), (4, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 3)\nprint(shortest_path_length)\n```"}, "110": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(16, 7), (12, 2), (8, 5), (7, 5), (3, 2), (1, 10)],\n    1: [(12, 7), (8, 4), (5, 1), (17, 3), (6, 4), (0, 10)],\n    2: [(15, 2), (17, 1)],\n    3: [(12, 4), (8, 4), (7, 3), (14, 4), (0, 2)],\n    4: [(18, 1)],\n    5: [(16, 9), (18, 10), (13, 5), (1, 1)],\n    6: [(9, 5), (1, 4)],\n    7: [(15, 1), (0, 5), (3, 3)],\n    8: [(11, 10), (16, 1), (10, 9), (0, 5), (1, 4), (3, 4)],\n    9: [(17, 5), (18, 4), (6, 5)],\n    10: [(8, 9)],\n    11: [(14, 6), (8, 10)],\n    12: [(19, 5), (14, 1), (0, 2), (1, 7), (3, 4)],\n    13: [(19, 4), (15, 5), (5, 5)],\n    14: [(15, 9), (18, 5), (3, 4), (12, 1), (11, 6)],\n    15: [(2, 2), (7, 1), (13, 5), (14, 9)],\n    16: [(0, 7), (5, 9), (8, 1)],\n    17: [(1, 3), (2, 1), (9, 5), (18, 3)],\n    18: [(4, 1), (5, 10), (9, 4), (14, 5), (17, 3), (19, 6)],\n    19: [(12, 5), (13, 4), (18, 6)]\n}\n\nprint(dijkstra(graph, 9, 2))\n```"}, "111": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 3), (16, 6)],\n    1: [(2, 3), (3, 1)],\n    2: [(1, 3), (4, 7), (8, 9), (5, 9)],\n    3: [(1, 1), (15, 2), (8, 6)],\n    4: [(2, 7), (14, 8), (7, 8), (13, 8), (16, 3), (5, 9)],\n    5: [(2, 9), (4, 9)],\n    6: [(17, 2), (18, 3), (16, 4)],\n    7: [(4, 8), (12, 3), (15, 6), (16, 3)],\n    8: [(0, 3), (2, 9), (3, 6), (12, 1), (9, 8), (17, 1), (14, 3)],\n    9: [(8, 8), (16, 1)],\n    10: [(18, 3)],\n    11: [(14, 5)],\n    12: [(7, 3), (8, 1), (13, 5)],\n    13: [(4, 8), (12, 5)],\n    14: [(4, 8), (8, 3), (11, 5), (15, 5), (18, 1)],\n    15: [(3, 2), (7, 6), (14, 5)],\n    16: [(0, 6), (4, 3), (6, 4), (7, 3), (9, 1)],\n    17: [(6, 2), (8, 1)],\n    18: [(6, 3), (10, 3), (14, 1)]\n}\n\nstart_node = 10\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "112": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(6, 1), (2, 2)],\n    1: [(5, 4), (7, 3), (2, 4), (3, 3)],\n    2: [(0, 2), (1, 4), (4, 4), (3, 3)],\n    3: [(1, 3), (2, 3), (5, 3), (4, 3)],\n    4: [(2, 4), (3, 3), (5, 4)],\n    5: [(1, 4), (3, 3), (4, 4), (7, 2)],\n    6: [(0, 1), (7, 2)],\n    7: [(1, 3), (5, 2), (6, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 6)\nprint(shortest_path_length)\n```"}, "113": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 4), (2, 1), (6, 4), (1, 4), (7, 4), (4, 3), (3, 3)],\n    1: [(0, 4), (5, 1), (2, 4), (6, 3), (4, 3), (3, 1)],\n    2: [(0, 1), (5, 4), (6, 4), (7, 1), (3, 2), (1, 4)],\n    3: [(0, 3), (5, 2), (6, 2), (7, 4), (4, 2), (1, 1), (2, 2)],\n    4: [(0, 3), (5, 4), (7, 1), (1, 3), (3, 2)],\n    5: [(0, 4), (1, 1), (2, 4), (6, 4), (7, 2), (3, 2), (4, 4)],\n    6: [(0, 4), (1, 3), (2, 4), (5, 4), (7, 3), (3, 2)],\n    7: [(0, 4), (2, 1), (3, 4), (4, 1), (5, 2), (6, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 4)\nprint(shortest_path_length)\n```"}, "114": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 3), (2, 3), (4, 4), (1, 4), (8, 3), (3, 3), (6, 1), (7, 4)],\n    1: [(5, 3), (2, 1), (4, 2), (8, 4), (3, 3), (6, 3), (7, 4), (0, 4)],\n    2: [(5, 1), (4, 1), (8, 1), (3, 3), (7, 4), (0, 3), (1, 1)],\n    3: [(5, 1), (4, 4), (8, 2), (6, 1), (7, 3), (0, 3), (1, 3), (2, 3)],\n    4: [(5, 2), (6, 4), (0, 4), (1, 2), (2, 1), (3, 4)],\n    5: [(8, 3), (6, 2), (7, 1), (0, 3), (1, 3), (2, 1), (3, 1), (4, 2)],\n    6: [(8, 2), (0, 1), (1, 3), (3, 1), (4, 4), (5, 2)],\n    7: [(8, 4), (0, 4), (1, 4), (2, 4), (3, 3), (5, 1)],\n    8: [(0, 3), (1, 4), (2, 1), (3, 2), (5, 3), (6, 2), (7, 4)]\n}\n\nprint(dijkstra(graph, 2, 6))\n```"}, "115": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 2), (4, 2), (2, 2), (7, 2), (3, 3), (1, 3), (8, 1), (5, 3)],\n    1: [(6, 4), (4, 4), (2, 1), (9, 3), (7, 1), (3, 3)],\n    2: [(4, 1), (9, 2), (7, 2), (3, 3), (8, 1)],\n    3: [(6, 4), (4, 1), (7, 1), (8, 2), (5, 1)],\n    4: [(7, 1), (5, 1)],\n    5: [(7, 1), (8, 1)],\n    6: [(9, 3), (7, 2), (8, 4)],\n    7: [(9, 2), (8, 3)],\n    8: [(9, 2)],\n    9: []\n}\n\nshortest_path_length = dijkstra(graph, 6, 4)\nprint(shortest_path_length)\n```"}, "116": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (4, 1)],\n    1: [(2, 4), (3, 4), (4, 4)],\n    2: [(0, 2), (1, 4), (3, 1), (5, 2), (4, 3)],\n    3: [(1, 4), (2, 1), (5, 2), (4, 3)],\n    4: [(0, 1), (1, 4), (2, 3), (3, 3), (5, 2)],\n    5: [(2, 2), (3, 2), (4, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 0)\nprint(shortest_path_length)\n```"}, "117": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 6), (9, 2)],\n    1: [(4, 8), (2, 10), (7, 3)],\n    2: [(0, 6), (1, 10)],\n    3: [(8, 3)],\n    4: [(1, 8)],\n    5: [(9, 4), (8, 5)],\n    6: [(9, 3), (7, 2)],\n    7: [(1, 3), (6, 2), (10, 4)],\n    8: [(3, 3), (5, 5)],\n    9: [(0, 2), (5, 4), (6, 3)],\n    10: [(7, 4)]\n}\n\nstart_node = 9\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "118": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(6, 4), (5, 2), (4, 3), (7, 1), (8, 2), (2, 2), (3, 3), (1, 4)],\n    1: [(6, 2), (5, 1), (7, 3), (8, 3), (2, 1), (3, 2), (0, 4)],\n    2: [(6, 1), (5, 1), (4, 4), (7, 1), (8, 3), (0, 2), (1, 1)],\n    3: [(6, 3), (5, 2), (4, 1), (7, 3), (8, 2), (0, 3), (1, 2)],\n    4: [(6, 4), (7, 2), (8, 3), (0, 3), (2, 4), (3, 1)],\n    5: [(6, 4), (7, 2), (0, 2), (1, 1), (2, 1), (3, 2)],\n    6: [(0, 4), (1, 2), (2, 1), (3, 3), (4, 4), (5, 4), (7, 3)],\n    7: [(0, 1), (1, 3), (2, 1), (3, 3), (4, 2), (5, 2), (6, 3), (8, 1)],\n    8: [(0, 2), (1, 3), (2, 3), (3, 2), (4, 3), (7, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 6, 8)\nprint(shortest_path_length)\n```"}, "119": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 6), (2, 7)],\n    1: [(8, 9), (2, 9), (3, 10)],\n    2: [(0, 7), (1, 9), (13, 10), (6, 2)],\n    3: [(1, 10)],\n    4: [(11, 6), (5, 1), (8, 1), (10, 6)],\n    5: [(0, 6), (4, 1), (7, 8), (10, 1)],\n    6: [(2, 2), (9, 10), (14, 5), (12, 4)],\n    7: [(5, 8), (9, 9), (13, 8), (10, 4)],\n    8: [(1, 9), (4, 1), (11, 1), (10, 1)],\n    9: [(6, 10), (7, 9), (13, 3)],\n    10: [(4, 6), (5, 1), (8, 1), (7, 4), (14, 4), (13, 4)],\n    11: [(4, 6), (8, 1)],\n    12: [(6, 4)],\n    13: [(2, 10), (7, 8), (9, 3), (10, 4)],\n    14: [(6, 5), (10, 4)]\n}\n\nprint(dijkstra(graph, 12, 11))\n```"}, "120": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (1, 3)],\n    1: [(0, 3), (3, 1), (2, 3)],\n    2: [(0, 3), (1, 3), (4, 2)],\n    3: [(1, 1), (4, 4)],\n    4: [(2, 2), (3, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 2)\nprint(shortest_path_length)\n```"}, "121": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 3), (9, 1), (5, 3), (8, 1), (1, 3)],\n    1: [(7, 4), (4, 2), (9, 1), (6, 4), (8, 1), (2, 2)],\n    2: [(4, 2), (3, 4), (6, 2), (5, 2), (8, 2)],\n    3: [(7, 2), (4, 2), (5, 2), (8, 4)],\n    4: [(9, 1), (6, 4), (5, 1), (8, 1)],\n    5: [(7, 3), (9, 1)],\n    6: [(7, 2), (9, 2), (8, 4)],\n    7: [(9, 2)],\n    8: [(9, 1)],\n    9: []\n}\n\nshortest_path_length = dijkstra(graph, 7, 4)\nprint(shortest_path_length)\n```"}, "122": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(1, 3), (3, 4), (5, 1), (4, 3), (2, 1)],\n    1: [(0, 3), (5, 1), (2, 1)],\n    2: [(0, 1), (1, 1), (3, 4), (5, 1), (4, 4)],\n    3: [(0, 4), (2, 4), (5, 2), (4, 1)],\n    4: [(0, 3), (2, 4), (3, 1), (5, 1)],\n    5: [(0, 1), (1, 1), (2, 1), (3, 2), (4, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 3)\nprint(shortest_path_length)\n```"}, "123": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 2), (10, 10), (8, 1)],\n    1: [(7, 9), (3, 7), (13, 10)],\n    2: [(8, 10), (5, 7)],\n    3: [(10, 2), (5, 8)],\n    4: [(7, 10), (8, 3), (6, 5), (9, 1), (5, 2)],\n    5: [(12, 1), (7, 3), (11, 4), (10, 9), (8, 2)],\n    6: [(10, 7)],\n    7: [(13, 7), (10, 4), (9, 3)],\n    8: [(9, 6)],\n    9: [(12, 1)],\n    10: [(11, 1)],\n    11: [(13, 7)],\n    12: [],\n    13: []\n}\n\nstart_node = 4\nend_node = 0\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "124": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 2), (5, 2), (6, 2), (2, 1), (7, 3), (1, 2)],\n    1: [(0, 2), (9, 4), (4, 1), (2, 1), (8, 1), (3, 2)],\n    2: [(0, 1), (9, 2), (5, 1), (4, 2), (8, 1), (1, 1)],\n    3: [(9, 3), (5, 2), (4, 1), (6, 4), (8, 1), (1, 2)],\n    4: [(1, 1), (9, 4), (7, 1), (8, 4), (2, 2), (3, 1)],\n    5: [(0, 2), (9, 1), (2, 1), (3, 2), (7, 3), (8, 3)],\n    6: [(0, 2), (9, 4), (3, 4), (7, 2)],\n    7: [(0, 3), (4, 1), (5, 3), (6, 2), (9, 1), (8, 1)],\n    8: [(1, 1), (2, 1), (3, 1), (4, 4), (5, 3), (7, 1), (9, 4)],\n    9: [(0, 2), (1, 4), (2, 2), (3, 3), (4, 4), (5, 1), (6, 4), (7, 1), (8, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 4)\nprint(shortest_path_length)\n```"}, "125": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 2), (3, 1), (8, 4), (7, 1), (5, 2)],\n    1: [(0, 2), (2, 4), (4, 3)],\n    2: [(1, 4), (3, 2), (8, 3), (6, 3), (4, 4)],\n    3: [(0, 1), (2, 2), (8, 2), (7, 2), (5, 4), (6, 4)],\n    4: [(1, 3), (2, 4), (8, 2), (5, 2), (6, 3)],\n    5: [(0, 2), (3, 4), (8, 2), (7, 2), (4, 2)],\n    6: [(2, 3), (3, 4), (4, 3), (8, 4)],\n    7: [(0, 1), (3, 2), (5, 2), (8, 4)],\n    8: [(0, 4), (2, 3), (3, 2), (4, 2), (5, 2), (6, 4), (7, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 0)\nprint(shortest_path_length)\n```"}, "126": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 2), (1, 3), (4, 3)],\n    1: [(0, 3), (3, 2)],\n    2: [(3, 2)],\n    3: [(0, 2), (1, 2), (2, 2), (4, 1)],\n    4: [(0, 3), (3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 2)\nprint(shortest_path_length)\n```"}, "127": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 1), (8, 1), (7, 2)],\n    1: [(3, 3), (4, 1), (5, 2), (7, 3)],\n    2: [(9, 2), (6, 3)],\n    3: [(1, 3), (5, 2), (8, 2)],\n    4: [(0, 1), (1, 1), (9, 4), (8, 2), (7, 1)],\n    5: [(1, 2), (3, 2), (7, 4)],\n    6: [(2, 3), (8, 4)],\n    7: [(0, 2), (1, 3), (4, 1), (5, 4), (8, 1)],\n    8: [(0, 1), (3, 2), (4, 2), (6, 4), (7, 1)],\n    9: [(2, 2), (4, 4)]\n}\n\nprint(dijkstra(graph, 3, 9))\n```"}, "128": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(16)}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(14, 5), (5, 10), (7, 7), (8, 4), (6, 10), (10, 3), (11, 6)],\n    1: [(3, 6), (8, 1), (13, 9)],\n    2: [(15, 6), (4, 7), (13, 1), (10, 1)],\n    3: [(14, 3), (5, 7), (7, 9), (11, 7)],\n    5: [(14, 10), (7, 8), (8, 4), (11, 8)],\n    6: [(9, 8), (10, 1)],\n    7: [(8, 8)],\n    11: [(12, 9)],\n    12: [(13, 2)],\n    13: [(15, 7)],\n    14: [],\n    15: [],\n    4: [],\n    8: [],\n    9: [],\n    10: [],\n}\n\nshortest_path_length = dijkstra(graph, 11, 4)\nprint(shortest_path_length)\n```"}, "129": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 3), (8, 2), (4, 4), (7, 1), (3, 1), (2, 4)],\n    1: [(5, 2), (8, 1), (6, 1), (4, 4), (7, 3), (3, 4), (2, 1)],\n    2: [(5, 2), (6, 1), (7, 1), (3, 3)],\n    3: [(5, 3), (8, 3), (6, 1), (4, 3), (7, 4)],\n    4: [(5, 3), (8, 4), (6, 4), (7, 4)],\n    5: [(8, 2), (6, 1), (7, 1)],\n    6: [(8, 2), (7, 1)],\n    7: [(8, 2)],\n    8: []\n}\n\nprint(dijkstra(graph, 0, 6))\n```"}, "130": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 4), (2, 2), (4, 4), (1, 4)],\n    1: [(0, 4), (3, 1), (2, 2), (4, 2)],\n    2: [(0, 2), (1, 2), (3, 4), (4, 1)],\n    3: [(0, 4), (1, 1), (2, 4)],\n    4: [(0, 4), (1, 2), (2, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 4)\nprint(shortest_path_length)\n```"}, "131": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 9), (3, 6)],\n    1: [(0, 9), (2, 9)],\n    2: [(1, 9), (7, 9), (6, 3)],\n    3: [(0, 6), (6, 3)],\n    4: [(8, 3), (7, 4)],\n    5: [(11, 8), (10, 5)],\n    6: [(2, 3), (3, 3)],\n    7: [(2, 9), (4, 4)],\n    8: [(4, 3), (9, 7)],\n    9: [(8, 7), (10, 2)],\n    10: [(5, 5), (9, 2)],\n    11: [(5, 8)]\n}\n\nstart_node = 10\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "132": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 8), (1, 10)],\n    1: [(0, 10), (13, 5), (6, 5), (12, 2)],\n    2: [(14, 10), (11, 9), (5, 3), (12, 10)],\n    3: [(11, 6), (8, 5), (9, 8)],\n    4: [(8, 9)],\n    5: [(2, 3), (14, 6)],\n    6: [(1, 5), (7, 9), (13, 10)],\n    7: [(6, 9), (14, 5), (15, 3)],\n    8: [(3, 5), (4, 9), (10, 3), (11, 6), (13, 7)],\n    9: [(3, 8), (14, 8), (10, 4), (12, 1), (16, 5)],\n    10: [(0, 8), (8, 3), (9, 4), (12, 5), (16, 10)],\n    11: [(2, 9), (3, 6), (8, 6), (12, 2)],\n    12: [(1, 2), (2, 10), (9, 1), (10, 5), (11, 2), (13, 6)],\n    13: [(1, 5), (6, 10), (8, 7), (12, 6), (16, 8)],\n    14: [(2, 10), (5, 6), (7, 5), (9, 8), (16, 3)],\n    15: [(7, 3)],\n    16: [(9, 5), (10, 10), (13, 8), (14, 3)]\n}\n\nstart_node = 15\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "133": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 3), (2, 4), (4, 4), (1, 3), (9, 1), (8, 1)],\n    1: [(0, 3), (5, 1), (2, 4), (3, 4), (4, 4), (9, 1)],\n    2: [(0, 4), (1, 4), (5, 3), (4, 4), (6, 1), (8, 4)],\n    3: [(1, 4), (7, 2), (4, 3), (6, 3)],\n    4: [(0, 4), (1, 4), (2, 4), (3, 3), (6, 4)],\n    5: [(1, 1), (2, 3), (7, 1), (6, 2)],\n    6: [(2, 1), (3, 3), (4, 4), (5, 2), (9, 1)],\n    7: [(0, 3), (3, 2), (5, 1)],\n    8: [(0, 1), (2, 4)],\n    9: [(0, 1), (1, 1), (6, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 2)\nprint(shortest_path_length)\n```"}, "134": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(len(graph))}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 4), (8, 9), (7, 8)],\n    1: [(12, 1), (14, 10), (11, 1), (3, 2), (8, 3)],\n    2: [(6, 6), (12, 7), (7, 1)],\n    3: [(0, 4), (12, 10), (11, 4), (10, 7), (1, 2)],\n    4: [(6, 6), (15, 5), (7, 8)],\n    5: [(12, 9), (8, 3)],\n    6: [(2, 6), (4, 6), (11, 6)],\n    7: [(0, 8), (2, 1), (15, 3), (13, 9), (14, 8), (4, 8)],\n    8: [(0, 9), (1, 3), (5, 3), (15, 2), (12, 9), (17, 9), (13, 7), (11, 4)],\n    9: [(12, 4)],\n    10: [(3, 7), (12, 1), (13, 5)],\n    11: [(1, 1), (3, 4), (6, 6), (15, 6), (17, 8), (16, 6), (8, 4)],\n    12: [(1, 1), (2, 7), (3, 10), (5, 9), (8, 9), (9, 4), (10, 1), (17, 10)],\n    13: [(7, 9), (10, 5), (8, 7)],\n    14: [(1, 10), (7, 8), (17, 10)],\n    15: [(4, 5), (7, 3), (8, 2), (11, 6)],\n    16: [(11, 6)],\n    17: [(8, 9), (11, 8), (12, 10), (14, 10)]\n}\n\nstart_node = 16\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "135": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(20)}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 5), (12, 5)],\n    1: [(13, 6), (5, 5), (19, 4)],\n    2: [(7, 2), (11, 2)],\n    3: [(10, 5), (8, 8), (17, 5), (14, 4)],\n    4: [(19, 7), (9, 8)],\n    5: [(1, 5), (16, 10)],\n    6: [(13, 10), (17, 4), (15, 9), (12, 1)],\n    7: [(2, 2), (11, 10)],\n    8: [(0, 5), (3, 8), (13, 7), (9, 2), (15, 7)],\n    9: [(4, 8), (8, 2), (18, 8), (11, 6), (17, 5)],\n    10: [(3, 5), (13, 6), (18, 1)],\n    11: [(2, 2), (7, 10), (9, 6), (17, 3)],\n    12: [(0, 5), (6, 1), (16, 1)],\n    13: [(1, 6), (6, 10), (8, 7), (10, 6), (19, 3)],\n    14: [(3, 4), (18, 8), (17, 4)],\n    15: [(6, 9), (8, 7), (18, 10), (16, 10)],\n    16: [(5, 10), (12, 1), (15, 10)],\n    17: [(3, 5), (6, 4), (9, 5), (11, 3), (14, 4), (18, 6)],\n    18: [(9, 8), (10, 1), (14, 8), (15, 10), (17, 6)],\n    19: [(1, 4), (4, 7), (13, 3)]\n}\n\nprint(dijkstra(graph, 2, 5))\n```"}, "136": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 4), (16, 7)],\n    1: [(14, 10), (2, 7)],\n    2: [(15, 7), (10, 2), (9, 2), (8, 3), (1, 7)],\n    3: [(14, 2), (15, 9), (12, 4)],\n    4: [(10, 9), (7, 6)],\n    5: [(15, 8), (9, 1)],\n    6: [(16, 8), (9, 1)],\n    7: [(4, 6)],\n    8: [(14, 4), (13, 9), (9, 9), (2, 3)],\n    9: [(11, 2), (16, 1), (8, 9), (6, 1), (5, 1), (2, 2)],\n    10: [(4, 9), (2, 2)],\n    11: [(9, 2)],\n    12: [(15, 7), (3, 4)],\n    13: [(0, 4), (8, 9)],\n    14: [(1, 10), (3, 2), (8, 4), (15, 4), (16, 2)],\n    15: [(2, 7), (3, 9), (5, 8), (12, 7), (14, 4)],\n    16: [(0, 7), (6, 8), (9, 1), (14, 2)]\n}\n\nstart_node = 16\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "137": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 4), (2, 3), (6, 4)],\n    1: [(4, 3), (5, 4)],\n    2: [(0, 3), (3, 1), (6, 4)],\n    3: [(0, 4), (2, 1), (4, 3)],\n    4: [(1, 3), (3, 3), (5, 1)],\n    5: [(1, 4), (4, 1), (6, 2)],\n    6: [(0, 4), (2, 4), (5, 2)]\n}\n\nstart_node = 3\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "138": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 1)],\n    1: [(3, 4)],\n    2: [(6, 9), (9, 1)],\n    3: [(1, 4), (4, 7), (8, 10), (9, 7)],\n    4: [(0, 1), (3, 7), (10, 2)],\n    5: [(10, 4), (9, 10)],\n    6: [(2, 9)],\n    7: [(8, 6)],\n    8: [(3, 10), (7, 6)],\n    9: [(2, 1), (3, 7), (5, 10)],\n    10: [(4, 2), (5, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 6)\nprint(shortest_path_length)\n```"}, "139": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 1), (6, 4), (9, 2), (7, 2), (4, 2), (1, 3), (2, 1), (8, 2), (3, 4)],\n    1: [(0, 3), (5, 1), (6, 3), (9, 1), (7, 4), (4, 1), (8, 2), (3, 4)],\n    2: [(0, 1), (5, 2), (6, 1), (7, 2), (4, 4), (8, 2), (3, 2)],\n    3: [(0, 4), (5, 3), (6, 3), (9, 4), (7, 2), (8, 4)],\n    4: [(0, 2), (1, 1), (5, 4), (6, 3), (9, 2), (7, 1), (8, 4)],\n    5: [(0, 1), (1, 1), (2, 2), (3, 3), (4, 4), (6, 3), (9, 3), (7, 1), (8, 1)],\n    6: [(0, 4), (1, 3), (2, 1), (3, 3), (4, 3), (5, 3), (9, 3), (7, 4), (8, 4)],\n    7: [(0, 2), (1, 4), (2, 2), (3, 2), (4, 1), (5, 1), (6, 4), (8, 4)],\n    8: [(0, 2), (1, 2), (2, 2), (3, 4), (4, 4), (5, 1), (6, 4), (7, 4), (9, 3)],\n    9: [(0, 2), (1, 1), (3, 4), (4, 2), (5, 3), (6, 3), (8, 3)]\n}\n\nprint(dijkstra(graph, 9, 7))\n```"}, "140": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 1), (5, 4), (6, 1), (4, 4), (3, 3)],\n    1: [(2, 2), (5, 4), (6, 3), (3, 2)],\n    2: [(0, 1), (1, 2), (6, 4), (4, 1), (3, 2)],\n    3: [(0, 3), (1, 2), (2, 2), (5, 2), (6, 4)],\n    4: [(0, 4), (2, 1), (6, 1)],\n    5: [(0, 4), (1, 4), (3, 2), (6, 1)],\n    6: [(0, 1), (1, 3), (2, 4), (3, 4), (4, 1), (5, 1)]\n}\n\nprint(dijkstra(graph, 2, 5))\n```"}, "141": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (6, 2), (7, 2), (2, 3), (3, 4)],\n    1: [(4, 2), (6, 3), (2, 3), (5, 2)],\n    2: [(0, 3), (1, 3), (4, 2), (7, 3), (3, 4), (5, 2)],\n    3: [(0, 4), (2, 4), (4, 1), (6, 4), (7, 2), (5, 4)],\n    4: [(0, 4), (1, 2), (2, 2), (3, 1), (7, 4), (5, 3)],\n    5: [(1, 2), (2, 2), (3, 4), (4, 3), (6, 3), (7, 1)],\n    6: [(0, 2), (1, 3), (3, 4), (5, 3), (7, 1)],\n    7: [(0, 2), (2, 3), (3, 2), (4, 4), (5, 1), (6, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 6)\nprint(shortest_path_length)\n```"}, "142": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 5), (15, 3), (14, 2), (11, 7), (9, 5)],\n    1: [(14, 10), (9, 4)],\n    2: [(4, 9), (3, 4), (13, 3), (11, 5), (6, 1)],\n    3: [(4, 1), (12, 10), (5, 5), (13, 9)],\n    4: [(0, 5), (2, 9), (3, 1), (16, 1)],\n    5: [(3, 5), (6, 3)],\n    6: [(2, 1), (5, 3), (17, 2)],\n    7: [(14, 9), (16, 4)],\n    8: [(13, 1)],\n    9: [(0, 5), (1, 4), (17, 5), (13, 6)],\n    10: [(12, 9)],\n    11: [(0, 7), (2, 5), (12, 8), (13, 10)],\n    12: [(3, 10), (10, 9), (11, 8), (14, 5)],\n    13: [(2, 3), (3, 9), (8, 1), (9, 6), (11, 10), (17, 9)],\n    14: [(0, 2), (1, 10), (7, 9), (12, 5), (16, 8)],\n    15: [(0, 3)],\n    16: [(4, 1), (7, 4), (14, 8)],\n    17: [(6, 2), (9, 5), (13, 9)]\n}\n\nstart_node = 7\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "143": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(5, 3), (6, 2), (4, 1), (2, 3), (9, 1), (1, 4), (8, 1), (3, 4)],\n    1: [(5, 1), (6, 2), (4, 2), (2, 4), (7, 3), (9, 3), (3, 1)],\n    2: [(5, 2), (6, 4), (4, 1), (9, 4), (8, 4)],\n    3: [(5, 2), (6, 4), (7, 4), (8, 3)],\n    4: [(5, 4), (6, 2), (7, 3), (9, 1), (8, 4)],\n    5: [(6, 2), (7, 1), (8, 3)],\n    6: [(7, 2), (9, 3), (8, 1)],\n    7: [(9, 3), (8, 4)],\n    8: [(9, 3)],\n    9: []\n}\n\nprint(dijkstra(graph, 5, 9))\n```"}, "144": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 2), (6, 3), (7, 1)],\n    1: [(0, 2), (2, 4), (7, 2), (4, 4)],\n    2: [(1, 4), (3, 2), (6, 3), (5, 4)],\n    3: [(2, 2), (7, 4), (5, 4), (4, 3)],\n    4: [(1, 4), (3, 3), (6, 3), (5, 3)],\n    5: [(2, 4), (3, 4), (4, 3), (6, 1), (7, 1)],\n    6: [(0, 3), (2, 3), (4, 3), (5, 1), (7, 3)],\n    7: [(0, 1), (1, 2), (3, 4), (5, 1), (6, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 0)\nprint(shortest_path_length)\n```"}, "145": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 5), (7, 6), (10, 7), (13, 10), (11, 7)],\n    1: [(10, 2)],\n    2: [(8, 10)],\n    3: [(9, 1), (8, 3)],\n    4: [(0, 5), (6, 5)],\n    5: [(11, 9)],\n    6: [(4, 5), (8, 2)],\n    7: [(0, 6), (9, 6)],\n    8: [(2, 10), (3, 3), (6, 2), (12, 8)],\n    9: [(3, 1), (7, 6)],\n    10: [(0, 7), (1, 2)],\n    11: [(0, 7), (5, 9)],\n    12: [(8, 8), (13, 6)],\n    13: [(0, 10), (12, 6)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 5)\nprint(shortest_path_length)\n```"}, "146": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 2), (2, 3), (9, 2), (4, 1), (7, 3)],\n    1: [(2, 3), (9, 1), (8, 3), (4, 3), (3, 1)],\n    2: [(0, 3), (1, 3), (9, 3), (8, 3), (7, 2), (3, 2), (6, 1)],\n    3: [(1, 1), (5, 4), (9, 2), (4, 4), (7, 4), (6, 3), (2, 2)],\n    4: [(0, 1), (1, 3), (9, 3), (8, 4), (7, 4), (6, 3), (3, 4)],\n    5: [(0, 2), (9, 3), (8, 4), (7, 4), (6, 4), (3, 4)],\n    6: [(2, 1), (3, 3), (4, 3), (9, 3), (8, 2), (7, 4), (5, 4)],\n    7: [(0, 3), (2, 2), (3, 4), (4, 4), (5, 4), (6, 4), (8, 1)],\n    8: [(1, 3), (2, 3), (4, 4), (5, 4), (6, 2), (7, 1), (9, 2)],\n    9: [(0, 2), (1, 1), (2, 3), (3, 2), (4, 3), (5, 3), (6, 3), (8, 2)]\n}\n\nprint(dijkstra(graph, 5, 1))\n```"}, "147": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 2), (9, 3), (2, 7)],\n    1: [(0, 2), (9, 5)],\n    2: [(0, 7), (9, 2)],\n    3: [(6, 9), (4, 1)],\n    4: [(3, 1), (7, 3), (10, 2)],\n    5: [(7, 3)],\n    6: [(3, 9)],\n    7: [(4, 3), (5, 3), (9, 2)],\n    8: [(9, 5)],\n    9: [(0, 3), (1, 5), (2, 2), (7, 2), (8, 5)],\n    10: [(4, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 6)\nprint(shortest_path_length)\n```"}, "148": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 2), (3, 4), (2, 2)],\n    1: [(4, 1), (2, 2)],\n    2: [(0, 2), (1, 2), (4, 3)],\n    3: [(0, 4), (4, 4)],\n    4: [(1, 1), (2, 3), (3, 4)],\n    5: [(0, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 5)\nprint(shortest_path_length)\n```"}, "149": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 3)],\n    1: [(2, 1), (10, 6), (4, 5)],\n    2: [(0, 3), (1, 1), (10, 10), (7, 6), (8, 2)],\n    3: [(9, 2), (7, 10), (5, 10)],\n    4: [(1, 5), (9, 5), (10, 4), (5, 7)],\n    5: [(3, 10), (4, 7), (9, 9), (6, 5), (7, 10)],\n    6: [(5, 5), (8, 4)],\n    7: [(2, 6), (3, 10), (5, 10), (10, 6)],\n    8: [(2, 2), (6, 4)],\n    9: [(3, 2), (4, 5), (5, 9)],\n    10: [(1, 6), (2, 10), (4, 4), (7, 6), (11, 10)],\n    11: [(10, 10)]\n}\n\nprint(dijkstra(graph, 11, 6))\n```"}, "150": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(7, 9), (14, 3)],\n    1: [(5, 9), (9, 4), (10, 5), (7, 3), (17, 6), (3, 2)],\n    2: [(8, 6), (5, 4), (13, 10), (7, 9), (14, 6), (17, 8)],\n    3: [(5, 1), (9, 5), (14, 10), (12, 1)],\n    4: [(8, 5), (13, 3)],\n    5: [(1, 9), (2, 4), (3, 1), (8, 9), (6, 7)],\n    6: [(5, 7), (8, 5), (11, 8)],\n    7: [(0, 9), (1, 3), (2, 9), (14, 9), (15, 3)],\n    8: [(2, 6), (4, 5), (5, 9), (6, 5), (9, 9), (12, 4)],\n    9: [(1, 4), (3, 5), (8, 9), (14, 5)],\n    10: [(1, 5), (14, 6), (15, 6), (12, 5)],\n    11: [(6, 8), (16, 4)],\n    12: [(3, 1), (8, 4), (10, 5), (14, 8)],\n    13: [(2, 10), (4, 3), (17, 1)],\n    14: [(0, 3), (2, 6), (3, 10), (7, 9), (9, 5), (10, 6), (12, 8)],\n    15: [(7, 3), (10, 6)],\n    16: [(11, 4)],\n    17: [(1, 6), (2, 8), (13, 1)]\n}\n\n# Find shortest path from node 15 to node 16\nshortest_path_length = dijkstra(graph, 15, 16)\nprint(shortest_path_length)\n```"}, "151": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 1), (6, 4), (5, 3), (4, 4), (1, 2), (3, 1)],\n    1: [(0, 2), (2, 2), (6, 4), (5, 2), (4, 3), (3, 1)],\n    2: [(0, 1), (1, 2), (6, 1), (5, 3), (4, 1), (3, 3)],\n    3: [(0, 1), (1, 1), (2, 3), (6, 1), (5, 4), (4, 4)],\n    4: [(0, 4), (1, 3), (2, 1), (3, 4), (6, 1)],\n    5: [(0, 3), (1, 2), (2, 3), (3, 4), (6, 1)],\n    6: [(0, 4), (1, 4), (2, 1), (3, 1), (4, 1), (5, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 4)\nprint(shortest_path_length)\n```"}, "152": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 8), (2, 3)],\n    1: [(6, 4), (11, 7)],\n    2: [(0, 3), (6, 10), (7, 7)],\n    3: [(9, 6), (4, 7)],\n    4: [(3, 7), (6, 8), (8, 6)],\n    5: [(6, 10), (7, 9)],\n    6: [(1, 4), (2, 10), (4, 8), (5, 10)],\n    7: [(2, 7), (5, 9)],\n    8: [(4, 6), (10, 5), (11, 7)],\n    9: [(0, 8), (3, 6)],\n    10: [(8, 5)],\n    11: [(1, 7), (8, 7)]\n}\n\nstart_node = 10\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "153": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 2), (7, 1), (6, 1), (2, 2), (4, 3), (8, 4), (3, 4)],\n    1: [(9, 4), (7, 4), (6, 2), (2, 4), (4, 3), (5, 3)],\n    2: [(9, 3), (7, 2), (6, 3), (4, 1), (3, 4)],\n    3: [(9, 4), (7, 1), (4, 2), (5, 1)],\n    4: [(9, 3), (7, 4), (6, 2)],\n    5: [(7, 1)],\n    6: [(7, 2), (8, 1)],\n    7: [(9, 2)],\n    8: [(9, 3)],\n    9: []\n}\n\nshortest_path_length = dijkstra(graph, 9, 6)\nprint(shortest_path_length)\n```"}, "154": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 3), (8, 2), (1, 1), (2, 4), (7, 2), (6, 1)],\n    1: [(0, 1), (3, 2), (9, 4), (4, 3), (6, 4)],\n    2: [(0, 4), (3, 4), (9, 2), (8, 4)],\n    3: [(1, 2), (2, 4), (4, 2), (6, 1)],\n    4: [(1, 3), (3, 2), (9, 3), (7, 1), (6, 3)],\n    5: [(9, 2), (7, 4), (6, 2)],\n    6: [(0, 1), (1, 4), (3, 1), (4, 3), (5, 2), (9, 4)],\n    7: [(0, 2), (4, 1), (5, 4)],\n    8: [(0, 2), (2, 4)],\n    9: [(0, 3), (1, 4), (2, 2), (4, 3), (5, 2), (6, 4)]\n}\n\nprint(dijkstra(graph, 3, 9))\n```"}, "155": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(len(graph))}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 3), (5, 10), (8, 7), (14, 5)],\n    1: [(6, 8), (5, 6), (14, 9), (15, 7)],\n    2: [(12, 1), (10, 2)],\n    3: [(17, 4)],\n    4: [(6, 6), (16, 7), (7, 9), (13, 6)],\n    5: [(0, 10), (1, 6), (11, 3), (13, 2)],\n    6: [(0, 3), (1, 8), (4, 6), (13, 4), (15, 9)],\n    7: [(4, 9), (13, 6), (17, 4), (14, 10)],\n    8: [(0, 7), (9, 1)],\n    9: [(8, 1), (13, 5), (15, 7)],\n    10: [(2, 2), (16, 1)],\n    11: [(5, 3)],\n    12: [(2, 1), (13, 6), (15, 4)],\n    13: [(4, 6), (5, 2), (6, 4), (7, 6), (9, 5), (12, 6)],\n    14: [(0, 5), (1, 9), (7, 10)],\n    15: [(1, 7), (6, 9), (9, 7), (12, 4)],\n    16: [(4, 7), (10, 1)],\n    17: [(3, 4), (7, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 8, 10)\nprint(shortest_path_length)\n```"}, "156": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 1), (2, 1), (1, 1), (4, 2)],\n    1: [(0, 1), (5, 3), (2, 3), (3, 1)],\n    2: [(0, 1), (1, 3), (3, 3), (4, 4)],\n    3: [(1, 1), (2, 3), (5, 3), (4, 4)],\n    4: [(0, 2), (2, 4), (3, 4), (5, 1)],\n    5: [(0, 1), (1, 3), (3, 3), (4, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 2)\nprint(shortest_path_length)\n```"}, "157": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(len(graph))}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 3), (16, 8), (18, 9), (5, 6)],\n    1: [(3, 4), (19, 5), (9, 2), (14, 7), (18, 5)],\n    2: [(4, 3), (3, 2), (9, 1)],\n    3: [(6, 10), (12, 9), (14, 3)],\n    4: [(19, 10), (13, 10), (9, 4), (11, 2), (17, 6)],\n    5: [(14, 8), (8, 1)],\n    6: [(14, 9), (7, 1), (15, 4), (8, 6)],\n    7: [(12, 9), (13, 10), (11, 10), (15, 8), (8, 5)],\n    8: [(19, 8)],\n    9: [(18, 10)],\n    10: [(14, 9), (18, 10), (15, 5)],\n    11: [(16, 3), (18, 10)],\n    12: [(15, 4)],\n    13: [(15, 6)],\n    14: [(18, 5)],\n    15: [(19, 10)],\n    16: [(18, 4)],\n    18: [(19, 7)],\n    19: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if v not in graph:\n            graph[v] = []\n        graph[v].append((u, w))\n\nprint(dijkstra(graph, 5, 9))\n```"}, "158": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 4), (4, 1), (5, 2), (6, 1), (3, 3)],\n    1: [(0, 4), (2, 2), (4, 2), (5, 4), (6, 4), (3, 3)],\n    2: [(1, 2), (4, 2), (5, 2), (6, 2), (3, 1)],\n    3: [(0, 3), (1, 3), (2, 1), (4, 4), (6, 4)],\n    4: [(0, 1), (1, 2), (2, 2), (3, 4), (5, 3), (6, 3)],\n    5: [(0, 2), (1, 4), (2, 2), (4, 3), (6, 1)],\n    6: [(0, 1), (1, 4), (2, 2), (3, 4), (4, 3), (5, 1)]\n}\n\nprint(dijkstra(graph, 2, 0))\n```"}, "159": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 3), (2, 3)],\n    1: [(4, 4), (2, 1), (3, 4)],\n    2: [(0, 3), (1, 1), (4, 2), (3, 3)],\n    3: [(1, 4), (2, 3)],\n    4: [(0, 3), (1, 4), (2, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 3)\nprint(shortest_path_length)\n```"}, "160": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(14, 1), (9, 1)],\n    1: [(10, 7), (11, 9), (7, 4)],\n    2: [(5, 4), (12, 2), (13, 10), (7, 2)],\n    3: [(8, 2), (13, 1)],\n    4: [(5, 7), (9, 3), (10, 4)],\n    5: [(2, 4), (4, 7), (15, 9), (10, 1), (11, 1)],\n    6: [(9, 1)],\n    7: [(1, 4), (2, 2), (9, 1), (12, 3)],\n    8: [(3, 2)],\n    9: [(0, 1), (4, 3), (6, 1), (7, 1), (11, 2)],\n    10: [(1, 7), (4, 4), (5, 1), (15, 2)],\n    11: [(1, 9), (5, 1), (9, 2), (15, 10), (12, 4)],\n    12: [(2, 2), (7, 3), (11, 4)],\n    13: [(2, 10), (3, 1)],\n    14: [(0, 1)],\n    15: [(5, 9), (10, 2), (11, 10)]\n}\n\nshortest_path_length = dijkstra(graph, 14, 8)\nprint(shortest_path_length)\n```"}, "161": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 3), (1, 3), (2, 4), (8, 2)],\n    1: [(0, 3), (4, 2), (2, 3)],\n    2: [(0, 4), (1, 3), (4, 2), (5, 3), (8, 4)],\n    3: [(4, 1), (5, 4), (6, 1)],\n    4: [(0, 3), (1, 2), (2, 2), (3, 1), (7, 1)],\n    5: [(2, 3), (3, 4), (6, 4), (8, 1)],\n    6: [(3, 1), (5, 4), (7, 1)],\n    7: [(4, 1), (6, 1)],\n    8: [(0, 2), (2, 4), (5, 1)]\n}\n\nprint(dijkstra(graph, 3, 7))\n```"}, "162": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (5, 2), (4, 1), (1, 4), (3, 4)],\n    1: [(0, 4), (2, 2), (5, 1), (4, 3), (3, 3)],\n    2: [(0, 2), (1, 2), (4, 2), (3, 2)],\n    3: [(0, 4), (1, 3), (2, 2), (5, 4), (4, 1)],\n    4: [(0, 1), (1, 3), (2, 2), (3, 1), (5, 4)],\n    5: [(0, 2), (1, 1), (3, 4), (4, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 5)\nprint(shortest_path_length)\n```"}, "163": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 2), (1, 1)],\n    1: [(0, 1), (5, 1), (3, 4), (2, 2), (4, 4)],\n    2: [(1, 2), (5, 3)],\n    3: [(1, 4), (4, 4)],\n    4: [(0, 2), (1, 4), (3, 4), (5, 4)],\n    5: [(1, 1), (2, 3), (4, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 0)\nprint(shortest_path_length)\n```"}, "164": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 4), (4, 3), (3, 3)],\n    1: [(2, 3)],\n    2: [(0, 4), (1, 3), (4, 4)],\n    3: [(0, 3), (4, 3), (6, 1)],\n    4: [(0, 3), (2, 4), (3, 3), (6, 2), (5, 2)],\n    5: [(4, 2), (6, 1)],\n    6: [(3, 1), (4, 2), (5, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 6)\nprint(shortest_path_length)\n```"}, "165": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 10), (9, 9)],\n    1: [(10, 5), (8, 5), (11, 9), (6, 2), (5, 9)],\n    2: [(3, 2), (11, 8)],\n    3: [(2, 2), (10, 5), (13, 6), (5, 6)],\n    4: [(8, 9), (9, 6)],\n    5: [(0, 10), (1, 9), (3, 6), (12, 9), (8, 4)],\n    6: [(1, 2), (12, 5), (7, 8)],\n    7: [(6, 8), (12, 10), (9, 3)],\n    8: [(1, 5), (4, 9), (5, 4), (10, 1), (11, 1)],\n    9: [(0, 9), (4, 6), (7, 3), (10, 10), (12, 2)],\n    10: [(1, 5), (3, 5), (8, 1), (9, 10)],\n    11: [(1, 9), (2, 8), (8, 1), (12, 4)],\n    12: [(5, 9), (6, 5), (7, 10), (9, 2), (11, 4), (13, 9)],\n    13: [(3, 6), (12, 9)]\n}\n\nprint(dijkstra(graph, 13, 8))\n```"}, "166": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(12, 6), (7, 7)],\n    1: [(10, 6), (5, 7), (8, 2), (6, 10), (16, 8), (17, 5), (3, 1)],\n    2: [(10, 3), (9, 6), (17, 10), (13, 2)],\n    3: [(18, 10), (5, 1), (1, 1)],\n    4: [(9, 8), (15, 6), (6, 5), (13, 5)],\n    5: [(10, 6), (7, 1), (11, 1), (17, 1), (1, 7), (3, 1)],\n    6: [(7, 4), (11, 1), (16, 7), (1, 10), (4, 5)],\n    7: [(9, 4), (15, 9), (8, 10), (11, 9), (0, 7), (5, 1), (6, 4)],\n    8: [(9, 6), (11, 8), (13, 5), (1, 2), (7, 10)],\n    9: [(11, 4), (2, 6), (4, 8), (7, 4), (8, 6)],\n    10: [(11, 7), (1, 6), (2, 3), (5, 6)],\n    11: [(15, 6), (5, 1), (6, 1), (7, 9), (8, 8), (9, 4), (10, 7)],\n    12: [(0, 6)],\n    13: [(2, 2), (4, 5), (8, 5)],\n    14: [(18, 7)],\n    15: [(4, 6), (7, 9), (11, 6)],\n    16: [(1, 8), (6, 7), (17, 1)],\n    17: [(1, 5), (2, 10), (5, 1), (16, 1)],\n    18: [(3, 10), (14, 7)]\n}\n\n# Calculate shortest path from node 12 to node 14\nshortest_path_length = dijkstra(graph, 12, 14)\nprint(shortest_path_length)\n```"}, "167": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 4), (2, 1), (3, 1), (7, 3), (6, 3), (4, 2)],\n    1: [(0, 4), (5, 1), (2, 2), (3, 1), (7, 1), (6, 4), (4, 1)],\n    2: [(0, 1), (1, 2), (3, 2), (7, 3), (6, 3)],\n    3: [(0, 1), (1, 1), (2, 2), (5, 4), (7, 2), (6, 3), (4, 4)],\n    4: [(0, 2), (1, 1), (3, 4), (5, 2), (7, 3), (6, 2)],\n    5: [(1, 1), (3, 4), (4, 2), (7, 2), (6, 3)],\n    6: [(0, 3), (1, 4), (2, 3), (3, 3), (4, 2), (5, 3), (7, 4)],\n    7: [(0, 3), (1, 1), (2, 3), (3, 2), (4, 3), (5, 2), (6, 4)]\n}\n\nprint(dijkstra(graph, 0, 5))\n```"}, "168": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(5, 10), (8, 3)],\n    1: [(7, 9), (3, 10), (2, 4)],\n    2: [(1, 4)],\n    3: [(1, 10)],\n    4: [(6, 5), (8, 5)],\n    5: [(0, 10)],\n    6: [(4, 5)],\n    7: [(1, 9), (10, 10)],\n    8: [(0, 3), (4, 5), (9, 9)],\n    9: [(8, 9), (10, 3)],\n    10: [(7, 10), (9, 3)]\n}\n\nprint(dijkstra(graph, 0, 2))\n```"}, "169": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (6, 4), (4, 1), (5, 3), (2, 1), (3, 4)],\n    1: [(0, 1), (6, 2), (4, 3), (7, 4), (5, 2), (3, 2)],\n    2: [(0, 1), (6, 3), (4, 2), (7, 2), (5, 4)],\n    3: [(0, 4), (6, 2), (4, 3), (5, 2)],\n    4: [(0, 1), (1, 3), (2, 2), (3, 3), (6, 4), (7, 2), (5, 2)],\n    5: [(0, 3), (1, 2), (2, 4), (3, 2), (4, 2), (6, 2)],\n    6: [(0, 4), (1, 2), (2, 3), (3, 2), (4, 4), (5, 2)],\n    7: [(1, 4), (2, 2), (4, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 2)\nprint(shortest_path_length)\n```"}, "170": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 1), (13, 2), (9, 2), (5, 10), (6, 7), (8, 2)],\n    1: [(2, 10), (9, 2), (11, 2)],\n    2: [(0, 1), (1, 10), (10, 1)],\n    3: [(9, 4), (12, 4)],\n    4: [(14, 10), (5, 9), (8, 9)],\n    5: [(0, 10), (4, 9), (14, 3)],\n    6: [(0, 7), (10, 1), (7, 2)],\n    7: [(6, 2), (8, 10)],\n    8: [(0, 2), (4, 9), (7, 10), (10, 4), (9, 6), (11, 9), (12, 7)],\n    9: [(0, 2), (1, 2), (3, 4), (8, 6), (12, 7)],\n    10: [(2, 1), (6, 1), (8, 4), (14, 4)],\n    11: [(1, 2), (8, 9), (13, 10)],\n    12: [(3, 4), (8, 7), (9, 7)],\n    13: [(0, 2), (11, 10), (14, 2)],\n    14: [(4, 10), (5, 3), (10, 4), (13, 2)]\n}\n\nstart_node = 11\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "171": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (8, 4), (1, 2), (6, 3)],\n    1: [(0, 2), (2, 1), (5, 1), (3, 2), (7, 1)],\n    2: [(0, 2), (1, 1), (5, 3), (7, 4), (8, 1), (6, 1)],\n    3: [(1, 2), (4, 3), (5, 1), (7, 3), (8, 2)],\n    4: [(3, 3), (5, 3), (7, 2), (8, 3), (6, 2)],\n    5: [(1, 1), (2, 3), (3, 1), (4, 3), (7, 3), (6, 2)],\n    6: [(0, 3), (2, 1), (4, 2), (5, 2), (7, 2)],\n    7: [(1, 1), (2, 4), (3, 3), (4, 2), (5, 3), (6, 2)],\n    8: [(0, 4), (2, 1), (3, 2), (4, 3)]\n}\n\nprint(dijkstra(graph, 2, 4))\n```"}, "172": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (6, 2), (2, 4), (3, 2), (1, 3), (5, 3)],\n    1: [(0, 3), (4, 2), (6, 1), (2, 3), (3, 4), (5, 2)],\n    2: [(0, 4), (1, 3), (4, 1), (6, 3), (3, 4)],\n    3: [(0, 2), (1, 4), (2, 4), (4, 4), (6, 4), (5, 1)],\n    4: [(0, 4), (1, 2), (2, 1), (3, 4), (6, 3), (5, 3)],\n    5: [(0, 3), (1, 2), (3, 1), (4, 3), (6, 2)],\n    6: [(0, 2), (1, 1), (2, 3), (3, 4), (4, 3), (5, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 5)\nprint(shortest_path_length)\n```"}, "173": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 4), (4, 1), (1, 4)],\n    1: [(0, 4), (3, 3), (5, 1), (4, 1), (2, 4)],\n    2: [(1, 4), (3, 2), (5, 2), (4, 4)],\n    3: [(0, 4), (1, 3), (2, 2), (5, 1), (4, 2)],\n    4: [(0, 1), (1, 1), (2, 4), (3, 2), (5, 3)],\n    5: [(1, 1), (2, 2), (3, 1), (4, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 0)\nprint(shortest_path_length)\n```"}, "174": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (3, 3)],\n    1: [(4, 3), (2, 2), (3, 4)],\n    2: [(0, 3), (1, 2), (4, 1)],\n    3: [(0, 3), (1, 4)],\n    4: [(1, 3), (2, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 0)\nprint(shortest_path_length)\n```"}, "175": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 1), (3, 3), (7, 4), (1, 2), (6, 4)],\n    1: [(0, 2), (2, 2), (5, 1), (3, 3), (6, 4)],\n    2: [(1, 2), (4, 4), (5, 3)],\n    3: [(0, 3), (1, 3), (5, 3), (7, 4), (6, 3)],\n    4: [(0, 1), (2, 4), (7, 4), (6, 3)],\n    5: [(1, 1), (2, 3), (3, 3), (7, 3), (6, 4)],\n    6: [(0, 4), (1, 4), (3, 3), (4, 3), (5, 4), (7, 2)],\n    7: [(0, 4), (3, 4), (4, 4), (5, 3), (6, 2)]\n}\n\nstart_node = 4\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "176": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 3), (4, 1), (1, 1), (3, 4), (2, 3)],\n    1: [(0, 1), (5, 4), (4, 4), (3, 1), (2, 2)],\n    2: [(0, 3), (1, 2), (5, 1), (3, 2)],\n    3: [(0, 4), (1, 1), (2, 2), (5, 2)],\n    4: [(0, 1), (1, 4), (5, 4)],\n    5: [(0, 3), (1, 4), (2, 1), (3, 2), (4, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 3)\nprint(shortest_path_length)\n```"}, "177": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(7, 2), (2, 1), (5, 1), (6, 4), (9, 1), (1, 2), (8, 4), (4, 4)],\n    1: [(0, 2), (3, 4), (7, 3), (5, 4), (6, 2), (8, 3), (4, 1)],\n    2: [(0, 1), (3, 3), (5, 2), (6, 3), (8, 4), (4, 1)],\n    3: [(1, 4), (2, 3), (7, 2), (5, 3), (6, 1), (9, 1), (8, 2), (4, 3)],\n    4: [(0, 4), (1, 1), (2, 1), (3, 3), (7, 3), (5, 3), (6, 1), (9, 4), (8, 1)],\n    5: [(0, 1), (1, 4), (2, 2), (3, 3), (7, 3), (6, 4), (9, 4), (8, 3)],\n    6: [(0, 4), (1, 2), (2, 3), (3, 1), (4, 1), (5, 4), (7, 2), (9, 4)],\n    7: [(0, 2), (1, 3), (3, 2), (4, 3), (5, 3), (6, 2), (8, 3)],\n    8: [(0, 4), (1, 3), (2, 4), (3, 2), (4, 1), (5, 3), (7, 3), (9, 4)],\n    9: [(0, 1), (3, 1), (4, 4), (5, 4), (6, 4), (8, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 0)\nprint(shortest_path_length)\n```"}, "178": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 1), (3, 4), (5, 2), (4, 3), (1, 4), (6, 2)],\n    1: [(0, 4), (2, 2), (3, 3), (4, 3), (6, 2)],\n    2: [(0, 1), (1, 2), (5, 4), (4, 3), (6, 2)],\n    3: [(0, 4), (1, 3), (5, 1), (4, 2), (6, 4)],\n    4: [(0, 3), (1, 3), (2, 3), (3, 2), (5, 3), (6, 1)],\n    5: [(0, 2), (2, 4), (3, 1), (4, 3), (6, 2)],\n    6: [(0, 2), (1, 2), (2, 2), (3, 4), (4, 1), (5, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 3)\nprint(shortest_path_length)\n```"}, "179": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 8), (7, 6), (9, 4), (11, 10)],\n    1: [(11, 8), (16, 10), (6, 5)],\n    2: [(5, 2), (12, 2), (7, 9), (4, 8), (9, 10), (10, 2), (14, 1)],\n    3: [(8, 4), (7, 3)],\n    4: [(10, 1), (13, 9)],\n    5: [(2, 2), (14, 2), (6, 9)],\n    6: [(1, 5), (5, 9), (15, 4)],\n    7: [(0, 6), (2, 9), (3, 3), (10, 4), (16, 1)],\n    8: [(3, 4), (10, 8)],\n    9: [(0, 4), (2, 10), (10, 3)],\n    10: [(2, 2), (4, 1), (7, 4), (8, 8), (9, 3), (12, 2)],\n    11: [(0, 10), (1, 8), (15, 7), (12, 4), (13, 1)],\n    12: [(0, 8), (2, 2), (10, 2), (11, 4), (14, 6)],\n    13: [(4, 9), (11, 1), (15, 2), (14, 9)],\n    14: [(2, 1), (5, 2), (12, 6), (13, 9)],\n    15: [(6, 4), (11, 7), (13, 2)],\n    16: [(1, 10), (7, 1)]\n}\n\nprint(dijkstra(graph, 12, 5))\n```"}, "180": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (2, 4)],\n    1: [(4, 2), (2, 1)],\n    2: [(0, 4), (1, 1), (4, 4), (5, 1), (3, 3)],\n    3: [(2, 3), (4, 4)],\n    4: [(0, 4), (1, 2), (2, 4), (3, 4), (5, 3)],\n    5: [(2, 1), (4, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 5)\nprint(shortest_path_length)\n```"}, "181": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(16, 10), (4, 10), (19, 6), (2, 7)],\n    1: [(16, 9), (5, 1), (17, 5)],\n    2: [(18, 5), (19, 9), (0, 7)],\n    3: [(13, 9), (16, 5), (5, 9), (9, 5), (19, 10), (6, 3)],\n    4: [(0, 10), (5, 10)],\n    5: [(1, 1), (3, 9), (14, 2), (10, 2), (16, 6), (4, 10)],\n    6: [(3, 3), (11, 9)],\n    7: [(18, 2), (19, 3)],\n    8: [(9, 7)],\n    9: [(3, 5), (8, 7), (18, 8)],\n    10: [(5, 2), (13, 1), (19, 10)],\n    11: [(6, 9), (15, 8), (12, 2)],\n    12: [(11, 2), (15, 3), (14, 1), (17, 3)],\n    13: [(3, 9), (10, 1), (15, 7), (14, 9)],\n    14: [(5, 2), (12, 1), (13, 9), (15, 4), (19, 6)],\n    15: [(11, 8), (12, 3), (13, 7), (14, 4), (16, 10)],\n    16: [(0, 10), (1, 9), (3, 5), (5, 6), (15, 10)],\n    17: [(1, 5), (12, 3), (18, 6)],\n    18: [(2, 5), (7, 2), (9, 8), (17, 6)],\n    19: [(0, 6), (2, 9), (3, 10), (7, 3), (10, 10), (14, 6)]\n}\n\nprint(dijkstra(graph, 7, 11))\n```"}, "182": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 1), (4, 4)],\n    1: [(2, 2)],\n    2: [(1, 2), (3, 4)],\n    3: [(0, 1), (2, 4), (5, 1), (4, 2)],\n    4: [(0, 4), (3, 2)],\n    5: [(3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 0)\nprint(shortest_path_length)\n```"}, "183": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(4, 6), (11, 3)],\n    1: [(8, 10)],\n    2: [(5, 5)],\n    3: [(11, 5)],\n    4: [(0, 6), (10, 3), (8, 10)],\n    5: [(2, 5), (7, 6), (11, 3), (6, 1)],\n    6: [(5, 1)],\n    7: [(5, 6)],\n    8: [(1, 10), (4, 10), (11, 7)],\n    9: [(11, 8)],\n    10: [(4, 3)],\n    11: [(0, 3), (3, 5), (5, 3), (8, 7), (9, 8)]\n}\n\n# Find the shortest path from node 7 to node 10\nshortest_path_length = dijkstra(graph, 7, 10)\nprint(shortest_path_length)\n```"}, "184": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 2)],\n    1: [(5, 7), (6, 1), (10, 10)],\n    2: [(3, 8), (10, 5)],\n    3: [(2, 8), (4, 10), (8, 6), (6, 4), (10, 9)],\n    4: [(3, 10), (7, 4)],\n    5: [(1, 7), (9, 7)],\n    6: [(1, 1), (3, 4)],\n    7: [(4, 4), (8, 6)],\n    8: [(3, 6), (7, 6)],\n    9: [(0, 2), (5, 7)],\n    10: [(1, 10), (2, 5), (3, 9)]\n}\n\nshortest_path_length = dijkstra(graph, 8, 0)\nprint(shortest_path_length)\n```"}, "185": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 2), (6, 5)],\n    1: [(2, 4), (11, 6), (9, 1), (8, 5)],\n    2: [(1, 4), (3, 7), (12, 4), (8, 8)],\n    3: [(2, 7), (10, 10), (12, 9)],\n    4: [(7, 3), (8, 2)],\n    5: [(0, 2), (11, 3)],\n    6: [(0, 5)],\n    7: [(4, 3)],\n    8: [(1, 5), (2, 8), (4, 2), (11, 7), (12, 4)],\n    9: [(1, 1), (11, 6), (12, 9)],\n    10: [(3, 10)],\n    11: [(1, 6), (5, 3), (8, 7), (9, 6), (12, 3)],\n    12: [(2, 4), (3, 9), (8, 4), (9, 9), (11, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 10, 6)\nprint(shortest_path_length)\n```"}, "186": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 3), (3, 4), (7, 2), (6, 4), (1, 2), (4, 4)],\n    1: [(0, 2), (5, 1), (3, 1), (7, 1), (6, 1), (4, 3), (2, 1)],\n    2: [(1, 1), (5, 2), (3, 1), (7, 2), (6, 2)],\n    3: [(0, 4), (1, 1), (2, 1), (5, 4), (7, 3), (6, 1), (4, 1)],\n    4: [(0, 4), (1, 3), (3, 1), (5, 3), (7, 2), (6, 4)],\n    5: [(0, 3), (1, 1), (2, 2), (3, 4), (4, 3), (7, 2), (6, 3)],\n    6: [(0, 4), (1, 1), (2, 2), (3, 1), (4, 4), (5, 3)],\n    7: [(0, 2), (1, 1), (2, 2), (3, 3), (4, 2), (5, 2)]\n}\n\nstart_node = 7\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "187": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 2), (1, 4), (2, 4), (3, 3)],\n    1: [(0, 4), (4, 2), (3, 3)],\n    2: [(0, 4), (4, 3), (3, 4)],\n    3: [(0, 3), (1, 3), (2, 4), (4, 2)],\n    4: [(0, 2), (1, 2), (2, 3), (3, 2)]\n}\n\nprint(dijkstra(graph, 1, 2))\n```"}, "188": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 8), (3, 1), (6, 4), (2, 5), (9, 2)],\n    1: [(0, 8), (8, 3)],\n    2: [(0, 5), (8, 10), (7, 8)],\n    3: [(0, 1), (10, 6), (8, 1), (7, 1)],\n    4: [(5, 2), (7, 3)],\n    5: [(4, 2), (11, 10)],\n    6: [(0, 4), (8, 10), (9, 4)],\n    7: [(2, 8), (3, 1), (4, 3)],\n    8: [(1, 3), (2, 10), (3, 1), (6, 10)],\n    9: [(0, 2), (6, 4), (11, 8)],\n    10: [(3, 6)],\n    11: [(5, 10), (9, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 10)\nprint(shortest_path_length)\n```"}, "189": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 7), (15, 4), (14, 3)],\n    1: [(10, 3), (11, 1)],\n    2: [(15, 8), (13, 7)],\n    3: [(5, 2), (15, 6), (10, 10)],\n    4: [(14, 9), (6, 3), (13, 2)],\n    5: [(14, 9), (12, 10)],\n    6: [(8, 8), (15, 8), (14, 7)],\n    7: [(15, 7)],\n    8: [(10, 10), (12, 10)],\n    9: [(14, 3)],\n    10: [(11, 9)],\n    11: [(13, 8)],\n    12: [],\n    13: [(14, 9)],\n    14: [(15, 1)],\n    15: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if u not in [x[0] for x in graph[v]]:\n            graph[v].append((u, w))\n\nshortest_path_length = dijkstra(graph, 2, 12)\nprint(shortest_path_length)\n```"}, "190": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 4), (1, 1), (4, 4), (2, 4)],\n    1: [(0, 1), (3, 2)],\n    2: [(0, 4), (3, 4)],\n    3: [(0, 4), (1, 2), (2, 4), (4, 4)],\n    4: [(0, 4), (3, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 4)\nprint(shortest_path_length)\n```"}, "191": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 4), (5, 1), (6, 3), (4, 1)],\n    1: [(5, 4), (3, 1)],\n    2: [(0, 4), (5, 3), (6, 1), (3, 3)],\n    3: [(1, 1), (2, 3), (5, 3), (6, 1), (4, 4)],\n    4: [(0, 1), (3, 4), (5, 1), (6, 4)],\n    5: [(0, 1), (1, 4), (2, 3), (3, 3), (4, 1)],\n    6: [(0, 3), (2, 1), (3, 1), (4, 4)]\n}\n\nprint(dijkstra(graph, 1, 2))\n```"}, "192": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (4, 3)],\n    1: [(3, 4), (4, 3)],\n    2: [(0, 3), (3, 4), (4, 3)],\n    3: [(1, 4), (2, 4), (4, 3)],\n    4: [(0, 3), (1, 3), (2, 3), (3, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 1)\nprint(shortest_path_length)\n```"}, "193": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 8), (1, 2)],\n    1: [(0, 2), (10, 2), (8, 8)],\n    2: [(4, 2), (7, 4), (8, 9)],\n    3: [(4, 3), (10, 8), (8, 4)],\n    4: [(2, 2), (3, 3)],\n    5: [(0, 8), (9, 1)],\n    6: [(8, 9)],\n    7: [(2, 4), (11, 1), (8, 9)],\n    8: [(1, 8), (2, 9), (3, 4), (6, 9), (7, 9)],\n    9: [(5, 1)],\n    10: [(1, 2), (3, 8)],\n    11: [(7, 1)]\n}\n\nstart_node = 11\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "194": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (2, 2), (7, 2)],\n    1: [(0, 1), (8, 4), (3, 4), (6, 1)],\n    2: [(0, 2), (8, 2), (7, 4)],\n    3: [(1, 4), (6, 4), (7, 1)],\n    4: [(5, 1), (6, 4)],\n    5: [(4, 1), (6, 3), (7, 3)],\n    6: [(1, 1), (3, 4), (4, 4), (5, 3)],\n    7: [(0, 2), (2, 4), (3, 1), (5, 3), (8, 2)],\n    8: [(1, 4), (2, 2), (7, 2)]\n}\n\nstart_node = 5\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "195": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 4), (13, 2), (2, 10)],\n    1: [(10, 10), (12, 8), (3, 6), (6, 10)],\n    2: [(9, 4), (11, 6), (13, 8), (0, 10)],\n    3: [(14, 3), (10, 8), (1, 6)],\n    4: [(5, 6), (6, 9)],\n    5: [(9, 10), (11, 1), (13, 3), (4, 6)],\n    6: [(1, 10), (4, 9)],\n    7: [(0, 4)],\n    8: [(10, 8)],\n    9: [(2, 4), (5, 10)],\n    10: [(1, 10), (3, 8), (8, 8), (11, 9)],\n    11: [(2, 6), (5, 1), (10, 9), (12, 6), (13, 3)],\n    12: [(1, 8), (11, 6), (13, 3)],\n    13: [(0, 2), (2, 8), (5, 3), (11, 3), (12, 3)],\n    14: [(3, 3)]\n}\n\nprint(dijkstra(graph, 6, 7))\n```"}, "196": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 10), (8, 5), (4, 2)],\n    1: [(10, 1), (3, 8), (8, 4)],\n    2: [(6, 7), (11, 2)],\n    3: [(0, 10), (1, 8), (9, 8)],\n    4: [(0, 2), (7, 9)],\n    5: [(10, 8)],\n    6: [(2, 7), (8, 5), (7, 7)],\n    7: [(4, 9), (6, 7), (9, 10)],\n    8: [(0, 5), (1, 4), (6, 5)],\n    9: [(3, 8), (7, 10)],\n    10: [(1, 1), (5, 8)],\n    11: [(2, 2)]\n}\n\nstart_node = 6\nend_node = 10\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "197": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 1), (4, 2)],\n    1: [(3, 2), (4, 2)],\n    2: [(3, 1), (4, 4)],\n    3: [(0, 1), (1, 2), (2, 1), (5, 4)],\n    4: [(0, 2), (1, 2), (2, 4), (5, 2)],\n    5: [(3, 4), (4, 2)]\n}\n\nprint(dijkstra(graph, 0, 2))\n```"}, "198": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    shortest_paths = {node: float('inf') for node in graph}\n    shortest_paths[start] = 0\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n        \n        # If a shorter path to current_node has been found, skip processing\n        if current_distance > shortest_paths[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path to neighbor is found\n            if distance < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(10, 9)],\n    1: [(2, 7), (12, 5)],\n    2: [(1, 7), (14, 1), (3, 10)],\n    3: [(2, 10), (11, 9), (4, 2), (10, 7), (5, 2)],\n    4: [(3, 2), (11, 5), (8, 6), (5, 7), (9, 8)],\n    5: [(3, 2), (11, 2), (8, 3), (9, 5), (4, 7)],\n    6: [(8, 5), (9, 3)],\n    7: [(10, 2), (9, 8)],\n    8: [(4, 6), (5, 3), (6, 5), (9, 6)],\n    9: [(4, 8), (5, 5), (6, 3), (7, 8), (8, 6)],\n    10: [(0, 9), (3, 7), (7, 2), (11, 9), (12, 10)],\n    11: [(3, 9), (4, 5), (5, 2), (10, 9), (13, 6)],\n    12: [(1, 5), (10, 10)],\n    13: [(11, 6)],\n    14: [(2, 1)]\n}\n\n# Calculate shortest path from node 6 to node 1\nshortest_path_length = dijkstra(graph, 6, 1)\nprint(shortest_path_length)\n```"}, "199": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 3), (4, 2), (5, 4), (2, 2), (1, 3)],\n    1: [(0, 3), (3, 3), (6, 4), (7, 1), (4, 3), (5, 3), (2, 1)],\n    2: [(0, 2), (1, 1), (3, 3), (6, 4), (7, 3), (4, 4), (5, 3)],\n    3: [(1, 3), (2, 3), (6, 1), (7, 1), (5, 3)],\n    4: [(0, 2), (1, 3), (2, 4), (6, 2), (5, 1)],\n    5: [(0, 4), (1, 3), (2, 3), (3, 3), (4, 1), (6, 4), (7, 2)],\n    6: [(0, 3), (1, 4), (2, 4), (3, 1), (4, 2), (5, 4), (7, 2)],\n    7: [(1, 1), (2, 3), (3, 1), (5, 2), (6, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 0)\nprint(shortest_path_length)\n```"}, "200": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 3), (4, 1), (2, 4)],\n    1: [(3, 2), (2, 3)],\n    2: [(0, 4), (1, 3), (3, 4)],\n    3: [(0, 3), (1, 2), (2, 4), (4, 2)],\n    4: [(0, 1), (3, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 1)\nprint(shortest_path_length)\n```"}, "201": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 2), (3, 2), (4, 2), (7, 2), (2, 4), (1, 3), (6, 3)],\n    1: [(3, 2), (4, 3), (7, 1), (2, 3), (0, 3)],\n    2: [(5, 2), (4, 4), (0, 4), (1, 3)],\n    3: [(5, 4), (4, 2), (6, 2), (0, 2), (1, 2)],\n    4: [(7, 3), (0, 2), (1, 3), (2, 4), (3, 2)],\n    5: [(0, 2), (2, 2), (3, 4), (7, 2)],\n    6: [(0, 3), (3, 2), (7, 3)],\n    7: [(0, 2), (1, 1), (4, 3), (5, 2), (6, 3)]\n}\n\nprint(dijkstra(graph, 5, 4))\n```"}, "202": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(11, 10), (8, 10), (12, 8), (6, 8)],\n    1: [(9, 2), (10, 8)],\n    2: [(8, 2), (4, 9), (12, 1)],\n    3: [(15, 2)],\n    4: [(13, 4), (10, 7)],\n    5: [(11, 8), (9, 3), (6, 7)],\n    6: [(10, 9), (7, 1)],\n    7: [(14, 6)],\n    8: [(15, 9)],\n    9: [],\n    10: [(11, 10)],\n    11: [(14, 8)],\n    12: [(13, 1)],\n    13: [],\n    14: [],\n    15: []\n}\n\nshortest_path_length = dijkstra(graph, 5, 3)\nprint(shortest_path_length)\n```"}, "203": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 2), (2, 3), (4, 1), (3, 3)],\n    1: [(2, 1), (4, 4), (3, 2)],\n    2: [(0, 3), (1, 1), (5, 3), (7, 4), (4, 4), (6, 4)],\n    3: [(0, 3), (1, 2), (4, 2), (6, 3)],\n    4: [(0, 1), (1, 4), (2, 4), (3, 2), (6, 3)],\n    5: [(2, 3), (7, 3)],\n    6: [(2, 4), (3, 3), (4, 3), (7, 4)],\n    7: [(0, 2), (2, 4), (5, 3), (6, 4)]\n}\n\nprint(dijkstra(graph, 5, 0))\n```"}, "204": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 10), (14, 4), (4, 8), (7, 2)],\n    1: [(9, 2), (2, 10), (5, 2)],\n    2: [(13, 2), (3, 2), (6, 3), (7, 7)],\n    3: [(12, 5)],\n    4: [(9, 2), (10, 5), (6, 10)],\n    5: [(11, 7), (8, 10), (6, 1)],\n    6: [],\n    7: [(13, 4), (10, 9), (12, 9)],\n    8: [(13, 2), (9, 8)],\n    9: [(12, 3)],\n    10: [(14, 10)],\n    11: [],\n    12: [(13, 5)],\n    13: [],\n    14: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if v not in graph:\n            graph[v] = []\n        graph[v].append((u, w))\n\nstart_node = 14\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "205": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 1), (9, 8), (8, 9)],\n    1: [(13, 1), (5, 4), (2, 9)],\n    2: [(4, 8), (10, 3), (8, 3)],\n    3: [(4, 4), (13, 1), (9, 6), (8, 8)],\n    4: [(0, 1), (2, 8), (3, 4), (6, 6), (12, 6), (13, 2), (8, 7)],\n    5: [(1, 4), (13, 8), (11, 2), (8, 8)],\n    6: [(4, 6), (12, 6), (11, 1)],\n    7: [(13, 9), (11, 1), (9, 1)],\n    8: [(0, 9), (2, 3), (3, 8), (4, 7), (5, 8), (10, 6)],\n    9: [(0, 8), (3, 6), (7, 1)],\n    10: [(2, 3), (8, 6)],\n    11: [(5, 2), (6, 1), (7, 1)],\n    12: [(4, 6), (6, 6), (13, 3)],\n    13: [(1, 1), (3, 1), (4, 2), (5, 8), (7, 9), (12, 3)]\n}\n\nprint(dijkstra(graph, 7, 2))\n```"}, "206": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (6, 3), (3, 1), (5, 4), (2, 4), (1, 2)],\n    1: [(0, 2), (4, 2), (3, 1), (5, 3), (2, 1)],\n    2: [(0, 4), (6, 3), (3, 2), (5, 1), (1, 1), (7, 2)],\n    3: [(0, 1), (4, 3), (6, 1), (5, 4), (1, 1), (2, 2), (7, 3)],\n    4: [(0, 4), (6, 1), (3, 3), (1, 2), (7, 1)],\n    5: [(0, 4), (6, 1), (3, 4), (1, 3), (2, 1), (7, 1)],\n    6: [(0, 3), (4, 1), (3, 1), (2, 3), (5, 1), (7, 2)],\n    7: [(4, 1), (6, 2), (5, 1), (2, 2), (3, 3)]\n}\n\nprint(dijkstra(graph, 0, 7))\n```"}, "207": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 4), (1, 1), (16, 10)],\n    1: [(0, 1), (12, 2), (6, 5), (3, 2)],\n    2: [(12, 2), (5, 10), (11, 7)],\n    3: [(1, 2), (10, 6), (16, 8), (15, 4), (11, 10), (9, 10), (13, 5), (8, 3)],\n    4: [(14, 5), (8, 4)],\n    5: [(0, 4), (2, 10), (14, 6)],\n    6: [(1, 5)],\n    7: [(11, 7), (9, 3), (13, 4), (8, 10)],\n    8: [(3, 3), (4, 4), (7, 10), (12, 3), (16, 9)],\n    9: [(3, 10), (7, 3), (16, 4)],\n    10: [(3, 6), (12, 1), (11, 4)],\n    11: [(2, 7), (3, 10), (7, 7), (10, 4), (12, 1)],\n    12: [(1, 2), (2, 2), (8, 3), (10, 1), (11, 1)],\n    13: [(3, 5), (7, 4), (14, 3)],\n    14: [(4, 5), (5, 6), (13, 3)],\n    15: [(3, 4)],\n    16: [(0, 10), (3, 8), (8, 9), (9, 4)]\n}\n\nstart_node = 16\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "208": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest distance to each node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reached the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')\n\n# Graph representation\ngraph = {\n    0: [(1, 2), (6, 5), (2, 3), (4, 4), (10, 4)],\n    1: [(0, 2), (12, 3), (6, 9), (13, 1), (5, 2)],\n    2: [(0, 3), (16, 10)],\n    3: [(6, 10), (4, 1), (5, 10)],\n    4: [(0, 4), (3, 1), (8, 9)],\n    5: [(1, 2), (3, 10), (13, 5), (10, 9)],\n    6: [(0, 5), (1, 9), (3, 10), (14, 9), (11, 10), (16, 1), (7, 7), (17, 1)],\n    7: [(6, 7), (12, 8), (11, 3), (9, 3), (10, 7), (17, 4)],\n    8: [(4, 9), (16, 7), (13, 5)],\n    9: [(7, 3), (11, 4), (10, 8)],\n    10: [(0, 4), (5, 9), (7, 7), (9, 8), (14, 10), (11, 5), (15, 5)],\n    11: [(6, 10), (7, 3), (9, 4), (10, 5)],\n    12: [(1, 3), (7, 8), (14, 9), (15, 5)],\n    13: [(1, 1), (5, 5), (8, 5), (16, 9)],\n    14: [(6, 9), (10, 10), (12, 9)],\n    15: [(10, 5), (12, 5)],\n    16: [(2, 10), (6, 1), (8, 7), (13, 9)],\n    17: [(6, 1), (7, 4)]\n}\n\n# Find the shortest path from node 11 to node 2\nshortest_path_length = dijkstra(graph, 11, 2)\nprint(shortest_path_length)\n```"}, "209": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 2), (2, 7), (3, 10)],\n    1: [(4, 2), (2, 2), (12, 6), (6, 3), (13, 1)],\n    2: [(0, 7), (1, 2)],\n    3: [(0, 10), (7, 4), (4, 8), (8, 3), (5, 3), (10, 9)],\n    4: [(1, 2), (3, 8), (7, 7), (8, 5), (9, 8), (14, 9), (11, 2)],\n    5: [(3, 3), (13, 4)],\n    6: [(1, 3), (7, 3), (12, 7)],\n    7: [(3, 4), (4, 7), (6, 3), (13, 7), (11, 9)],\n    8: [(3, 3), (4, 5), (13, 1), (11, 6)],\n    9: [(4, 8)],\n    10: [(0, 2), (3, 9), (12, 3), (13, 1)],\n    11: [(4, 2), (7, 9), (8, 6)],\n    12: [(1, 6), (6, 7), (10, 3)],\n    13: [(1, 1), (5, 4), (7, 7), (8, 1), (10, 1)],\n    14: [(4, 9)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 9)\nprint(shortest_path_length)\n```"}, "210": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(1, 2), (4, 2), (3, 1)],\n    1: [(0, 2), (2, 1)],\n    2: [(1, 1), (4, 2), (3, 3)],\n    3: [(0, 1), (2, 3)],\n    4: [(0, 2), (2, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 0)\nprint(shortest_path_length)\n```"}, "211": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    # Priority queue to store (distance, node)\n    pq = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    shortest_paths = {node: float('inf') for node in graph}\n    shortest_paths[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we reach the end node, return the distance\n        if current_node == end:\n            return current_distance\n\n        # If a shorter path to current_node has been found, skip this one\n        if current_distance > shortest_paths[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # Only consider this new path if it's better\n            if distance < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return float('inf')  # If there's no path from start to end\n\n# Graph representation\ngraph = {\n    0: [(9, 2), (12, 2), (14, 8), (1, 9), (10, 6)],\n    1: [(5, 2), (12, 2), (8, 4), (4, 10), (0, 9)],\n    2: [(8, 7), (7, 5)],\n    3: [(15, 6), (14, 5), (13, 9), (10, 7)],\n    4: [(9, 7), (1, 10)],\n    5: [(12, 4), (11, 8), (14, 2), (1, 2)],\n    6: [(9, 10), (8, 5)],\n    7: [(9, 10), (2, 5)],\n    8: [(16, 2), (15, 5), (14, 7), (1, 4), (2, 7), (6, 5)],\n    9: [(0, 2), (4, 7), (6, 10), (7, 10), (15, 10)],\n    10: [(0, 6), (3, 7), (14, 9)],\n    11: [(5, 8)],\n    12: [(0, 2), (1, 2), (5, 4), (16, 2)],\n    13: [(3, 9)],\n    14: [(0, 8), (5, 2), (3, 5), (8, 7), (10, 9)],\n    15: [(3, 6), (8, 5), (9, 10), (16, 2)],\n    16: [(8, 2), (12, 2), (15, 2)]\n}\n\n# Calculate shortest path from node 11 to node 7\nshortest_path_length = dijkstra(graph, 11, 7)\nprint(shortest_path_length)\n```"}, "212": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 2), (1, 4), (6, 1), (2, 3)],\n    1: [(0, 4), (3, 2), (4, 4), (2, 2)],\n    2: [(0, 3), (1, 2), (5, 2), (6, 3), (4, 2)],\n    3: [(0, 2), (1, 2), (5, 1), (4, 3)],\n    4: [(1, 4), (2, 2), (3, 3), (5, 2)],\n    5: [(2, 2), (3, 1), (4, 2), (6, 4)],\n    6: [(0, 1), (2, 3), (5, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 6)\nprint(shortest_path_length)\n```"}, "213": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 8), (14, 6), (7, 5), (11, 1), (10, 1), (1, 5), (5, 7)],\n    1: [(18, 10), (14, 5), (15, 4), (12, 3), (0, 5)],\n    2: [(15, 6), (10, 4), (17, 4), (12, 10)],\n    3: [(16, 10), (0, 8)],\n    4: [(7, 5), (5, 6), (12, 5)],\n    5: [(10, 2), (17, 5), (0, 7), (4, 6)],\n    6: [(18, 4), (8, 8)],\n    7: [(15, 9), (13, 6), (0, 5), (4, 5)],\n    8: [(6, 8)],\n    9: [(11, 7), (13, 9)],\n    10: [(14, 7), (11, 6), (13, 6), (0, 1), (2, 4), (5, 2)],\n    11: [(14, 3), (15, 8), (12, 6), (0, 1), (9, 7), (10, 6)],\n    12: [(18, 1), (13, 7), (17, 6), (1, 3), (2, 10), (4, 5), (11, 6)],\n    13: [(7, 6), (9, 9), (10, 6), (12, 7)],\n    14: [(0, 6), (1, 5), (10, 7), (11, 3)],\n    15: [(1, 4), (2, 6), (7, 9), (11, 8), (18, 4)],\n    16: [(3, 10)],\n    17: [(2, 4), (5, 5), (12, 6)],\n    18: [(1, 10), (6, 4), (12, 1), (15, 4)]\n}\n\nprint(dijkstra(graph, 16, 8))\n```"}, "214": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (4, 2), (8, 1), (9, 4)],\n    1: [(0, 1), (7, 4), (3, 4), (6, 1), (2, 1), (4, 3), (8, 1), (9, 2)],\n    2: [(1, 1), (7, 1), (5, 4), (3, 4), (4, 1), (8, 1), (9, 2)],\n    3: [(1, 4), (7, 3), (5, 2), (6, 3), (8, 2), (9, 1)],\n    4: [(0, 2), (1, 3), (2, 1), (7, 3), (5, 4), (8, 4), (9, 1)],\n    5: [(2, 4), (3, 2), (4, 4), (6, 3), (8, 4), (9, 3)],\n    6: [(1, 1), (3, 3), (5, 3), (7, 2), (8, 4), (9, 1)],\n    7: [(1, 4), (2, 1), (3, 3), (4, 3), (6, 2), (8, 3), (9, 2)],\n    8: [(0, 1), (1, 1), (2, 1), (3, 2), (4, 4), (5, 4), (6, 4), (7, 3), (9, 4)],\n    9: [(0, 4), (1, 2), (2, 2), (3, 1), (4, 1), (5, 3), (6, 1), (7, 2), (8, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 5)\nprint(shortest_path_length)\n```"}, "215": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(11, 6), (5, 1)],\n    1: [(8, 4), (12, 3)],\n    2: [(10, 6), (12, 10)],\n    3: [(4, 6), (9, 6), (10, 1)],\n    4: [(9, 2), (7, 8), (10, 6)],\n    5: [(0, 1), (11, 3), (10, 4)],\n    6: [(12, 7)],\n    7: [(4, 8)],\n    8: [(1, 4), (11, 6)],\n    9: [(3, 6), (4, 2), (12, 3)],\n    10: [(2, 6), (3, 1), (4, 6), (5, 4)],\n    11: [(0, 6), (5, 3), (8, 6)],\n    12: [(1, 3), (2, 10), (6, 7), (9, 3)]\n}\n\nprint(dijkstra(graph, 0, 6))\n```"}, "216": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 2), (6, 2), (7, 1), (3, 1), (2, 4)],\n    1: [(6, 3), (2, 1)],\n    2: [(8, 4), (3, 3), (1, 1), (0, 4)],\n    3: [(8, 3), (0, 1), (2, 3)],\n    4: [(8, 3), (5, 1), (7, 2)],\n    5: [(4, 1), (7, 4)],\n    6: [(0, 2), (1, 3), (7, 2)],\n    7: [(0, 1), (4, 2), (5, 4), (6, 2)],\n    8: [(0, 2), (2, 4), (3, 3), (4, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 8, 5)\nprint(shortest_path_length)\n```"}, "217": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (5, 1), (7, 2), (12, 4), (1, 7)],\n    1: [(8, 5), (3, 7), (2, 1), (12, 6), (0, 7)],\n    2: [(5, 2), (12, 2), (1, 1)],\n    3: [(4, 7), (10, 10), (9, 1), (1, 7)],\n    4: [(0, 4), (8, 8), (3, 7)],\n    5: [(0, 1), (8, 7), (7, 10), (2, 2)],\n    6: [(11, 9), (8, 7)],\n    7: [(0, 2), (5, 10), (11, 1)],\n    8: [(1, 5), (4, 8), (5, 7), (6, 7), (9, 3)],\n    9: [(3, 1), (8, 3), (10, 2)],\n    10: [(3, 10), (9, 2), (11, 3)],\n    11: [(6, 9), (7, 1), (10, 3)],\n    12: [(0, 4), (1, 6), (2, 2)]\n}\n\nprint(dijkstra(graph, 6, 12))\n```"}, "218": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 2), (4, 2), (3, 1), (2, 1), (5, 1)],\n    1: [(7, 3), (2, 1), (6, 3), (5, 3)],\n    2: [(0, 1), (1, 1), (8, 2), (4, 4), (6, 3), (5, 4)],\n    3: [(0, 1), (8, 4), (7, 3), (6, 3), (5, 4)],\n    4: [(0, 2), (8, 3), (7, 3), (6, 4), (2, 4)],\n    5: [(0, 1), (1, 3), (2, 4), (3, 4), (7, 4), (6, 3)],\n    6: [(1, 3), (2, 3), (3, 3), (4, 4), (5, 3), (8, 3), (7, 4)],\n    7: [(1, 3), (3, 3), (4, 3), (5, 4), (6, 4)],\n    8: [(0, 2), (2, 2), (3, 4), (4, 3), (6, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 8, 7)\nprint(shortest_path_length)\n```"}, "219": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 5), (10, 10)],\n    1: [(9, 1), (10, 8), (3, 9)],\n    2: [(5, 3), (4, 9), (6, 9)],\n    3: [(11, 9)],\n    4: [(5, 5)],\n    5: [(2, 3), (4, 5), (7, 2), (8, 6), (6, 4), (10, 7)],\n    6: [(2, 9), (5, 4)],\n    7: [(0, 5), (5, 2)],\n    8: [(5, 6)],\n    9: [(1, 1), (11, 5)],\n    10: [(0, 10), (1, 8), (5, 7)],\n    11: [(3, 9), (9, 5)]\n}\n\nstart_node = 6\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "220": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(20)}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(18, 3), (12, 5), (19, 10), (14, 9), (1, 4), (7, 4)],\n    1: [(18, 8), (16, 8), (0, 4)],\n    2: [(3, 6), (12, 5), (14, 1), (16, 9), (10, 5), (5, 6)],\n    3: [(18, 9), (4, 10), (5, 2), (2, 6)],\n    4: [(12, 5), (10, 10), (5, 4), (3, 10)],\n    5: [(12, 1), (2, 6), (3, 2), (4, 4)],\n    6: [(8, 6), (10, 10)],\n    7: [(13, 9), (18, 3), (12, 1), (17, 7), (19, 3), (14, 8), (10, 10), (0, 4)],\n    8: [(13, 2), (6, 6)],\n    9: [(13, 5), (14, 5)],\n    10: [(12, 5), (17, 7), (15, 6), (6, 10), (7, 10), (4, 10), (2, 5)],\n    11: [(12, 8), (17, 2), (19, 4)],\n    12: [(0, 5), (2, 5), (4, 5), (5, 1), (7, 1), (10, 5), (11, 8), (13, 3), (14, 2)],\n    13: [(7, 9), (8, 2), (9, 5), (12, 3)],\n    14: [(0, 9), (2, 1), (7, 8), (9, 5), (12, 2), (17, 5), (16, 9)],\n    15: [(10, 6), (17, 4), (16, 4)],\n    16: [(1, 8), (2, 9), (14, 9), (15, 4), (17, 9)],\n    17: [(7, 7), (10, 7), (11, 2), (14, 5), (15, 4), (16, 9)],\n    18: [(0, 3), (1, 8), (3, 9), (7, 3)],\n    19: [(0, 10), (7, 3), (11, 4)]\n}\n\nprint(dijkstra(graph, 14, 8))\n```"}, "221": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 2), (9, 8), (6, 4), (10, 6)],\n    1: [(12, 4), (8, 9), (9, 4)],\n    2: [(13, 10), (7, 3), (4, 7)],\n    3: [(13, 8), (8, 5)],\n    4: [(13, 2), (2, 7)],\n    5: [(11, 5)],\n    6: [(13, 2), (8, 5), (9, 1), (0, 4)],\n    7: [(8, 3), (2, 3)],\n    8: [(13, 5), (1, 9), (3, 5), (6, 5), (7, 3)],\n    9: [(13, 7), (0, 8), (1, 4), (6, 1)],\n    10: [(0, 6), (11, 9)],\n    11: [(5, 5), (10, 9)],\n    12: [(0, 2), (1, 4), (13, 8)],\n    13: [(2, 10), (3, 8), (4, 2), (6, 2), (8, 5), (9, 7), (12, 8)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 5)\nprint(shortest_path_length)\n```"}, "222": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 6), (2, 4), (13, 7), (1, 8)],\n    1: [(0, 8), (9, 7), (11, 3)],\n    2: [(0, 4), (4, 9)],\n    3: [(0, 6), (10, 10), (13, 2)],\n    4: [(2, 9), (13, 8), (7, 10)],\n    5: [(11, 1), (14, 8)],\n    6: [(8, 9), (14, 10)],\n    7: [(4, 10), (11, 4)],\n    8: [(6, 9), (9, 2), (13, 6)],\n    9: [(1, 7), (8, 2), (14, 6)],\n    10: [(3, 10)],\n    11: [(1, 3), (5, 1), (7, 4)],\n    12: [(14, 10)],\n    13: [(0, 7), (3, 2), (4, 8), (8, 6)],\n    14: [(5, 8), (6, 10), (9, 6), (12, 10)]\n}\n\nstart_node = 8\nend_node = 12\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "223": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 10), (2, 4), (11, 5), (4, 1)],\n    1: [(4, 9)],\n    2: [(0, 4)],\n    3: [(6, 2)],\n    4: [(0, 1), (8, 3), (9, 7), (1, 9)],\n    5: [(12, 1), (7, 6), (11, 7)],\n    6: [(0, 10), (3, 2), (8, 6), (7, 2)],\n    7: [(5, 6), (6, 2)],\n    8: [(4, 3), (6, 6), (11, 10)],\n    9: [(4, 7), (10, 6)],\n    10: [(9, 6)],\n    11: [(0, 5), (5, 7), (8, 10)],\n    12: [(5, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 12, 10)\nprint(shortest_path_length)\n```"}, "224": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 8), (4, 4)],\n    1: [(3, 5), (10, 1)],\n    2: [(3, 1), (5, 4)],\n    3: [(1, 5), (2, 1), (6, 1), (4, 5)],\n    4: [(0, 4), (3, 5), (7, 8), (11, 7), (6, 8), (12, 7)],\n    5: [(2, 4), (13, 9), (10, 7)],\n    6: [(3, 1), (4, 8), (7, 9)],\n    7: [(4, 8), (6, 9), (8, 1)],\n    8: [(7, 1)],\n    9: [(13, 7)],\n    10: [(1, 1), (5, 7), (13, 4)],\n    11: [(4, 7)],\n    12: [(4, 7)],\n    13: [(0, 8), (5, 9), (9, 7), (10, 4)]\n}\n\nstart_node = 8\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "225": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(9, 1), (10, 6), (15, 7)],\n    1: [(6, 4), (12, 5), (7, 6), (3, 9)],\n    2: [(9, 4), (4, 9), (16, 4), (15, 6)],\n    3: [(14, 1), (4, 3), (5, 7), (7, 10), (15, 8)],\n    4: [(12, 9), (10, 1), (3, 3)],\n    5: [(9, 1), (14, 1), (6, 1), (10, 8)],\n    6: [(13, 3), (16, 4), (10, 2), (7, 4), (15, 9), (1, 4), (5, 1)],\n    7: [(1, 6), (3, 10), (6, 4)],\n    8: [(9, 6)],\n    9: [(0, 1), (2, 4), (5, 1), (8, 6), (10, 3), (15, 8)],\n    10: [(0, 6), (4, 1), (5, 8), (6, 2), (9, 3), (12, 3), (11, 9), (15, 1)],\n    11: [(10, 9), (14, 6)],\n    12: [(1, 5), (4, 9), (10, 3), (13, 10), (16, 10), (15, 4)],\n    13: [(6, 3), (12, 10), (16, 5)],\n    14: [(3, 1), (5, 1), (11, 6)],\n    15: [(0, 7), (2, 6), (3, 8), (6, 9), (9, 8), (10, 1), (12, 4)],\n    16: [(2, 4), (6, 4), (12, 10), (13, 5)]\n}\n\nstart_node = 8\nend_node = 12\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "226": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 3), (3, 4), (1, 2), (2, 1)],\n    1: [(0, 2), (4, 4), (3, 3), (2, 3)],\n    2: [(0, 1), (4, 4), (3, 4), (1, 3)],\n    3: [(0, 4), (1, 3), (2, 4)],\n    4: [(0, 3), (1, 4), (2, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 3)\nprint(shortest_path_length)\n```"}, "227": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 8), (17, 7), (1, 3)],\n    1: [(0, 3), (11, 10), (16, 5), (17, 2), (7, 1), (18, 7), (14, 4), (2, 9)],\n    2: [(1, 9), (8, 10), (12, 4), (9, 1), (18, 3)],\n    3: [(10, 4), (7, 5), (18, 6), (14, 3), (13, 1)],\n    4: [(17, 4), (10, 8), (14, 3), (13, 7)],\n    5: [(11, 9), (15, 10)],\n    6: [(19, 1), (17, 4), (14, 2), (15, 9)],\n    7: [(1, 1), (11, 4), (8, 10), (19, 10), (17, 10), (13, 9), (3, 5)],\n    8: [(2, 10), (7, 10), (19, 9)],\n    9: [(2, 1), (12, 7)],\n    10: [(3, 4), (16, 8), (4, 8)],\n    11: [(1, 10), (5, 9), (7, 4), (14, 2), (15, 9)],\n    12: [(0, 8), (2, 4), (9, 7), (18, 9), (14, 8)],\n    13: [(3, 1), (4, 7), (7, 9), (18, 9)],\n    14: [(1, 4), (3, 3), (4, 3), (6, 2), (11, 2), (12, 8), (18, 5)],\n    15: [(5, 10), (6, 9), (11, 9), (19, 6)],\n    16: [(1, 5), (10, 8)],\n    17: [(0, 7), (1, 2), (4, 4), (6, 4), (7, 10), (19, 4)],\n    18: [(1, 7), (2, 3), (3, 6), (12, 9), (13, 9), (14, 5)],\n    19: [(6, 1), (7, 10), (8, 9), (15, 6), (17, 4)]\n}\n\nstart_node = 16\nend_node = 19\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "228": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 1), (3, 3), (4, 3), (1, 1), (2, 1), (9, 4), (8, 1), (5, 4), (6, 3)],\n    1: [(0, 1), (7, 1), (3, 3), (4, 2), (2, 3), (9, 1), (8, 2), (5, 2), (6, 1)],\n    2: [(0, 1), (7, 1), (4, 1), (9, 2), (8, 2), (5, 1), (6, 2), (1, 3)],\n    3: [(0, 3), (7, 4), (4, 1), (9, 2), (8, 4), (5, 2), (6, 4), (1, 3)],\n    4: [(0, 3), (7, 4), (9, 3), (8, 2), (5, 4), (6, 4), (1, 2), (2, 1), (3, 1)],\n    5: [(0, 4), (7, 1), (9, 3), (8, 1), (6, 1), (1, 2), (2, 1), (3, 2), (4, 4)],\n    6: [(0, 3), (7, 4), (9, 1), (8, 4), (5, 1), (1, 1), (2, 2), (3, 4), (4, 4)],\n    7: [(0, 1), (1, 1), (2, 1), (3, 4), (4, 4), (5, 1), (6, 4), (8, 4)],\n    8: [(0, 1), (7, 4), (9, 2), (1, 2), (2, 2), (3, 4), (4, 2), (5, 1), (6, 4)],\n    9: [(0, 4), (7, 4), (1, 1), (2, 2), (3, 2), (4, 3), (5, 3), (6, 1), (8, 2)]\n}\n\nprint(dijkstra(graph, 7, 9))\n```"}, "229": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 3), (2, 3), (5, 3), (4, 2)],\n    1: [(0, 3), (3, 1), (2, 2), (5, 2), (4, 4)],\n    2: [(0, 3), (1, 2), (3, 1), (5, 1), (4, 1)],\n    3: [(1, 1), (2, 1), (5, 4), (4, 3)],\n    4: [(0, 2), (1, 4), (2, 1), (3, 3), (5, 4)],\n    5: [(0, 3), (1, 2), (2, 1), (3, 4), (4, 4)]\n}\n\nprint(dijkstra(graph, 3, 0))\n```"}, "230": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 2), (3, 4), (2, 1), (5, 2)],\n    1: [(4, 3), (6, 1), (3, 4), (2, 1), (5, 4)],\n    2: [(0, 1), (1, 1)],\n    3: [(0, 4), (1, 4), (4, 2), (6, 3)],\n    4: [(1, 3), (3, 2), (6, 1), (5, 3)],\n    5: [(0, 2), (1, 4), (4, 3), (6, 1)],\n    6: [(0, 2), (1, 1), (3, 3), (4, 1), (5, 1)]\n}\n\nprint(dijkstra(graph, 4, 0))\n```"}, "231": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 2)],\n    1: [(10, 1), (9, 3), (5, 8), (8, 3)],\n    2: [(5, 4), (8, 7), (4, 1), (11, 7), (3, 6), (7, 2)],\n    3: [(4, 2), (12, 4), (2, 6)],\n    4: [(3, 2), (10, 3), (8, 4), (2, 1)],\n    5: [(1, 8), (2, 4)],\n    6: [(12, 6)],\n    7: [(2, 2), (9, 1)],\n    8: [(1, 3), (2, 7), (4, 4), (9, 5)],\n    9: [(1, 3), (7, 1), (8, 5)],\n    10: [(0, 2), (1, 1), (4, 3)],\n    11: [(2, 7)],\n    12: [(3, 4), (6, 6)]\n}\n\nprint(dijkstra(graph, 11, 6))\n```"}, "232": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 1), (6, 4)],\n    1: [(5, 3), (7, 1), (4, 3), (6, 3), (2, 2)],\n    2: [(7, 1), (4, 2), (6, 4)],\n    3: [(4, 3), (6, 2)],\n    4: [(0, 1), (1, 3), (2, 2), (3, 3), (5, 3), (6, 2)],\n    5: [(1, 3), (4, 3), (7, 4), (6, 1)],\n    6: [(0, 4), (1, 3), (2, 4), (3, 2), (4, 2), (5, 1), (7, 4)],\n    7: [(1, 1), (2, 1), (5, 4), (6, 4)]\n}\n\nstart_node = 5\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "233": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(16, 5), (1, 2), (11, 9), (13, 5), (15, 6)],\n    1: [(0, 2), (8, 9)],\n    2: [(7, 2), (9, 9)],\n    3: [(18, 5), (17, 3), (10, 1)],\n    4: [(16, 6), (17, 1)],\n    5: [(14, 2)],\n    6: [(13, 2)],\n    7: [(2, 2), (9, 7)],\n    8: [(1, 9), (12, 2), (15, 3)],\n    9: [(2, 9), (7, 7), (12, 8)],\n    10: [(3, 1), (14, 8), (13, 9)],\n    11: [(0, 9)],\n    12: [(8, 2), (9, 8)],\n    13: [(0, 5), (6, 2), (10, 9)],\n    14: [(5, 2), (10, 8), (15, 3)],\n    15: [(0, 6), (8, 3), (14, 3), (18, 5)],\n    16: [(0, 5), (4, 6)],\n    17: [(3, 3), (4, 1)],\n    18: [(3, 5), (15, 5)]\n}\n\nstart_node = 17\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "234": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (2, 4), (3, 2)],\n    1: [(5, 2), (3, 2)],\n    2: [(0, 4)],\n    3: [(0, 2), (1, 2), (5, 2), (4, 4), (7, 4)],\n    4: [(0, 4), (3, 4), (7, 4)],\n    5: [(1, 2), (3, 2), (6, 2)],\n    6: [(5, 2), (7, 3)],\n    7: [(3, 4), (4, 4), (6, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 0)\nprint(shortest_path_length)\n```"}, "235": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(20)}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 7), (11, 5)],\n    1: [(7, 2), (15, 8), (5, 6)],\n    2: [(19, 8), (11, 9), (9, 4)],\n    3: [(16, 1), (15, 9), (8, 6), (13, 8), (14, 8)],\n    4: [(0, 7), (5, 8)],\n    5: [(1, 6), (4, 8), (7, 5), (15, 9)],\n    6: [(11, 8), (8, 2), (17, 6), (13, 5)],\n    7: [(1, 2), (18, 3), (19, 8), (13, 4), (5, 5)],\n    8: [(3, 6), (6, 2), (12, 2), (9, 1), (14, 2)],\n    9: [(2, 4), (8, 1), (16, 6), (11, 5)],\n    10: [(12, 8), (13, 4), (14, 3)],\n    11: [(0, 5), (2, 9), (6, 8), (9, 5)],\n    12: [(8, 2), (10, 8), (17, 9)],\n    13: [(3, 8), (6, 5), (7, 4), (10, 4)],\n    14: [(3, 8), (8, 2), (10, 3)],\n    15: [(1, 8), (3, 9), (5, 9), (19, 2)],\n    16: [(3, 1), (9, 6)],\n    17: [(6, 6), (12, 9), (18, 9)],\n    18: [(7, 3), (17, 9)],\n    19: [(2, 8), (7, 8), (15, 2)]\n}\n\nprint(dijkstra(graph, 12, 4))\n```"}, "236": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 6), (13, 3)],\n    1: [(10, 6), (15, 4)],\n    2: [(12, 10), (3, 9), (4, 3), (8, 6)],\n    3: [(2, 9)],\n    4: [(2, 3), (15, 2)],\n    5: [(12, 5), (13, 2)],\n    6: [(10, 8), (14, 4), (13, 3)],\n    7: [(11, 3), (13, 5), (8, 10)],\n    8: [(2, 6), (10, 7), (12, 9), (11, 2), (7, 10)],\n    9: [(13, 2)],\n    10: [(1, 6), (6, 8), (8, 7), (14, 3)],\n    11: [(7, 3), (8, 2), (13, 9)],\n    12: [(0, 6), (2, 10), (5, 5), (8, 9), (15, 4)],\n    13: [(0, 3), (5, 2), (6, 3), (7, 5), (9, 2), (11, 9), (15, 6), (14, 2)],\n    14: [(6, 4), (10, 3), (13, 2)],\n    15: [(1, 4), (4, 2), (12, 4), (13, 6)]\n}\n\nstart_node = 3\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "237": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (3, 1), (2, 4)],\n    1: [(3, 2)],\n    2: [(0, 4)],\n    3: [(0, 1), (1, 2), (4, 2)],\n    4: [(0, 4), (3, 2), (5, 1)],\n    5: [(4, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 1)\nprint(shortest_path_length)\n```"}, "238": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (6, 1), (4, 4), (2, 1), (3, 1)],\n    1: [(0, 1), (5, 3), (6, 1), (4, 2), (2, 4), (3, 4)],\n    2: [(0, 1), (5, 4), (6, 1), (4, 2), (3, 1), (1, 4)],\n    3: [(0, 1), (5, 2), (6, 3), (4, 1), (2, 1), (1, 4)],\n    4: [(0, 4), (5, 4), (6, 1), (3, 1), (2, 2), (1, 2)],\n    5: [(1, 3), (2, 4), (3, 2), (4, 4), (6, 4)],\n    6: [(0, 1), (1, 1), (2, 1), (3, 3), (4, 1), (5, 4)]\n}\n\nprint(dijkstra(graph, 0, 5))\n```"}, "239": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 8), (1, 9), (14, 6), (2, 4), (8, 8)],\n    1: [(0, 9), (2, 2), (8, 2), (10, 3)],\n    2: [(0, 4), (1, 2), (6, 3)],\n    3: [(14, 3), (11, 10), (4, 9), (7, 10), (10, 1)],\n    4: [(3, 9), (12, 1)],\n    5: [(10, 7)],\n    6: [(0, 8), (2, 3), (12, 8), (8, 1)],\n    7: [(3, 10), (9, 6), (11, 9), (8, 7), (10, 4)],\n    8: [(0, 8), (1, 2), (6, 1), (7, 7), (11, 8)],\n    9: [(7, 6), (12, 3)],\n    10: [(1, 3), (3, 1), (5, 7), (7, 4)],\n    11: [(3, 10), (7, 9), (8, 8), (13, 6)],\n    12: [(4, 1), (6, 8), (9, 3)],\n    13: [(11, 6)],\n    14: [(0, 6), (3, 3)]\n}\n\nprint(dijkstra(graph, 1, 13))\n```"}, "240": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 4), (3, 1), (10, 10)],\n    1: [(5, 9), (7, 5)],\n    2: [(5, 4), (3, 6)],\n    3: [(0, 1), (2, 6), (8, 10)],\n    4: [(10, 7)],\n    5: [(1, 9), (2, 4)],\n    6: [(9, 10)],\n    7: [(1, 5), (8, 7)],\n    8: [(3, 10), (7, 7)],\n    9: [(0, 4), (6, 10)],\n    10: [(0, 10), (4, 7)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 6)\nprint(shortest_path_length)\n```"}, "241": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(8, 3), (7, 1), (2, 6), (14, 3)],\n    1: [(13, 10), (3, 6)],\n    2: [(0, 6), (4, 1), (10, 1)],\n    3: [(1, 6), (8, 6), (7, 9), (10, 10)],\n    4: [(2, 1), (7, 7), (10, 5)],\n    5: [(8, 6)],\n    6: [(12, 10), (8, 3)],\n    7: [(0, 1), (3, 9), (4, 7), (14, 9)],\n    8: [(0, 3), (3, 6), (5, 6), (6, 3), (9, 5)],\n    9: [(8, 5), (14, 3)],\n    10: [(2, 1), (3, 10), (4, 5)],\n    11: [(12, 8)],\n    12: [(6, 10), (11, 8), (13, 9)],\n    13: [(1, 10), (12, 9)],\n    14: [(0, 3), (7, 9), (9, 3)]\n}\n\nstart_node = 4\nend_node = 11\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "242": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 2), (7, 6)],\n    1: [(0, 2), (3, 8), (10, 6)],\n    2: [(3, 7), (6, 5)],\n    3: [(1, 8), (2, 7), (11, 4)],\n    4: [(9, 3)],\n    5: [(10, 4), (11, 3)],\n    6: [(2, 5), (8, 9), (10, 10), (9, 4), (11, 7)],\n    7: [(0, 6), (11, 7)],\n    8: [(6, 9), (10, 8), (11, 4)],\n    9: [(4, 3), (6, 4)],\n    10: [(1, 6), (5, 4), (6, 10), (8, 8)],\n    11: [(3, 4), (5, 3), (6, 7), (7, 7), (8, 4)]\n}\n\nstart_node = 8\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "243": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 2), (1, 1), (3, 2), (5, 3), (2, 1), (6, 1)],\n    1: [(0, 1), (4, 3), (3, 1), (5, 3), (7, 2), (8, 1), (2, 2), (6, 3)],\n    2: [(0, 1), (4, 3), (3, 2), (5, 2), (7, 2), (1, 2)],\n    3: [(0, 2), (4, 3), (5, 2), (7, 2), (8, 3), (6, 1), (1, 1), (2, 2)],\n    4: [(0, 2), (1, 3), (3, 3), (5, 4), (7, 1), (8, 1), (6, 2), (2, 3)],\n    5: [(0, 3), (1, 3), (3, 2), (7, 4), (8, 3), (6, 3), (2, 2), (4, 4)],\n    6: [(0, 1), (1, 3), (3, 1), (4, 2), (5, 3), (7, 1), (8, 4)],\n    7: [(1, 2), (2, 2), (3, 2), (4, 1), (5, 4), (6, 1), (8, 3)],\n    8: [(1, 1), (3, 3), (4, 1), (5, 3), (6, 4), (7, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 0)\nprint(shortest_path_length)\n```"}, "244": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 3), (4, 1), (2, 3), (3, 1)],\n    1: [(0, 3), (4, 1), (2, 3), (3, 2), (5, 2)],\n    2: [(0, 3), (1, 3), (4, 3), (3, 1), (5, 1)],\n    3: [(0, 1), (1, 2), (2, 1), (4, 1), (5, 4)],\n    4: [(0, 1), (1, 1), (2, 3), (3, 1), (5, 1)],\n    5: [(1, 2), (2, 1), (3, 4), (4, 1)]\n}\n\nprint(dijkstra(graph, 0, 5))\n```"}, "245": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(3, 3), (4, 3), (6, 1), (5, 4), (2, 1), (1, 1)],\n    1: [(0, 1), (4, 2), (6, 2), (2, 3)],\n    2: [(0, 1), (1, 3), (3, 2), (4, 4), (6, 3), (5, 1)],\n    3: [(0, 3), (2, 2), (4, 3)],\n    4: [(0, 3), (1, 2), (3, 3), (6, 3), (5, 1)],\n    5: [(0, 4), (2, 1), (4, 1)],\n    6: [(0, 1), (1, 2), (2, 3), (4, 3)]\n}\n\nstart_node = 3\nend_node = 6\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "246": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 5), (16, 4)],\n    1: [(0, 5), (4, 8)],\n    2: [(12, 1), (4, 7), (3, 6), (9, 9), (11, 7), (8, 2), (13, 2)],\n    3: [(2, 6), (5, 10), (9, 10), (14, 2), (17, 5), (10, 7)],\n    4: [(1, 8), (2, 7), (6, 5), (17, 10), (10, 8)],\n    5: [(3, 10)],\n    6: [(4, 5), (14, 1), (17, 2), (13, 6)],\n    7: [(9, 3), (15, 2)],\n    8: [(2, 2)],\n    9: [(2, 9), (3, 10), (7, 3), (13, 6)],\n    10: [(3, 7), (4, 8), (14, 5), (13, 4)],\n    11: [(2, 7), (12, 10), (13, 5)],\n    12: [(2, 1), (11, 10)],\n    13: [(2, 2), (6, 6), (9, 6), (10, 4), (11, 5), (15, 6)],\n    14: [(3, 2), (6, 1), (10, 5)],\n    15: [(7, 2), (13, 6), (17, 1)],\n    16: [(0, 4)],\n    17: [(3, 5), (4, 10), (6, 2), (15, 1)]\n}\n\nprint(dijkstra(graph, 13, 16))\n```"}, "247": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 2), (7, 9), (8, 4), (13, 8)],\n    1: [(4, 10)],\n    2: [(17, 6), (4, 10), (3, 8), (16, 9)],\n    3: [(0, 2), (2, 8), (12, 10)],\n    4: [(1, 10), (2, 10), (6, 9), (12, 3), (9, 5)],\n    5: [(7, 1), (8, 5), (13, 10)],\n    6: [(4, 9), (13, 7)],\n    7: [(0, 9), (5, 1), (11, 1), (14, 9)],\n    8: [(0, 4), (5, 5), (10, 3), (13, 10)],\n    9: [(4, 5), (17, 1), (11, 7), (14, 1)],\n    10: [(8, 3), (17, 3), (11, 2), (16, 10), (15, 10)],\n    11: [(7, 1), (9, 7), (10, 2), (17, 1)],\n    12: [(3, 10), (4, 3)],\n    13: [(0, 8), (5, 10), (6, 7), (8, 10)],\n    14: [(7, 9), (9, 1)],\n    15: [(10, 10)],\n    16: [(2, 9), (10, 10)],\n    17: [(2, 6), (9, 1), (10, 3), (11, 1)]\n}\n\nprint(dijkstra(graph, 1, 15))\n```"}, "248": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 1), (1, 4), (3, 2), (4, 1)],\n    1: [(0, 4), (3, 4), (2, 1)],\n    2: [(1, 1), (5, 4), (3, 2), (4, 1)],\n    3: [(0, 2), (1, 4), (2, 2), (4, 3)],\n    4: [(0, 1), (2, 1), (3, 3), (5, 3)],\n    5: [(0, 1), (2, 4), (4, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 1)\nprint(shortest_path_length)\n```"}, "249": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 6), (3, 3), (11, 4)],\n    1: [(9, 8), (8, 1), (4, 5)],\n    2: [(7, 9), (5, 10), (14, 10), (10, 2)],\n    3: [(0, 3), (12, 1), (14, 1), (11, 7)],\n    4: [(1, 5), (7, 6), (14, 8)],\n    5: [(2, 10), (14, 4), (16, 4)],\n    6: [(8, 10), (13, 2)],\n    7: [(2, 9), (4, 6), (14, 5), (15, 7)],\n    8: [(1, 1), (6, 10), (10, 8)],\n    9: [(1, 8)],\n    10: [(2, 2), (8, 8)],\n    11: [(0, 4), (3, 7)],\n    12: [(0, 6), (3, 1), (14, 9)],\n    13: [(6, 2), (16, 1)],\n    14: [(2, 10), (3, 1), (4, 8), (5, 4), (7, 5), (12, 9), (15, 10)],\n    15: [(7, 7), (14, 10)],\n    16: [(5, 4), (13, 1)]\n}\n\nprint(dijkstra(graph, 0, 13))\n```"}, "250": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(18, 9), (13, 8), (4, 7)],\n    1: [(16, 6), (14, 3)],\n    2: [(8, 4), (5, 3), (4, 5), (3, 1), (14, 3)],\n    3: [(5, 8), (6, 6), (12, 3), (15, 10)],\n    4: [(0, 7), (2, 5), (17, 4), (10, 10)],\n    5: [(2, 3), (3, 8), (14, 5)],\n    6: [(3, 6), (13, 3), (9, 7)],\n    7: [(17, 9), (9, 8), (16, 7), (12, 9)],\n    8: [(2, 4)],\n    9: [(6, 7), (7, 8)],\n    10: [(4, 10), (14, 1)],\n    11: [(17, 4), (15, 8)],\n    12: [(3, 3), (7, 9), (17, 10), (13, 10), (15, 10)],\n    13: [(0, 8), (6, 3), (12, 10), (15, 4)],\n    14: [(1, 3), (2, 3), (5, 5), (10, 1), (17, 1)],\n    15: [(3, 10), (11, 8), (12, 10), (13, 4), (17, 5)],\n    16: [(1, 6), (7, 7)],\n    17: [(4, 4), (7, 9), (11, 4), (12, 10), (14, 1), (15, 5)],\n    18: [(0, 9)]\n}\n\nstart_node = 18\nend_node = 16\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "251": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(len(graph))}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 6), (11, 10), (1, 2), (14, 3), (8, 10), (5, 9), (16, 8)],\n    1: [(13, 8), (8, 4), (4, 3), (3, 6), (0, 2)],\n    2: [(14, 10), (5, 3), (16, 8)],\n    3: [(15, 10), (1, 6)],\n    4: [(13, 2), (8, 8), (16, 10), (15, 5), (6, 2), (1, 3)],\n    5: [(11, 9), (16, 4), (2, 3), (0, 9)],\n    6: [(14, 8), (4, 2)],\n    7: [(11, 7)],\n    8: [(9, 10), (15, 9), (4, 8), (1, 4), (0, 10)],\n    9: [(8, 10)],\n    10: [(14, 5)],\n    11: [(13, 3), (18, 6), (16, 9), (0, 10), (5, 9), (7, 7)],\n    12: [(15, 9)],\n    13: [(18, 8), (0, 6), (1, 8), (4, 2), (11, 3)],\n    14: [(15, 7), (0, 3), (2, 10), (6, 8), (10, 5)],\n    15: [(3, 10), (8, 9), (4, 5), (12, 9), (14, 7)],\n    16: [(17, 3), (0, 8), (2, 8), (4, 10), (5, 4), (11, 9)],\n    17: [(16, 3)],\n    18: [(11, 6), (13, 8)]\n}\n\nstart_node = 4\nend_node = 12\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "252": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 1), (5, 2), (8, 2), (6, 3), (4, 1)],\n    1: [(9, 2), (5, 4), (2, 1), (7, 4), (8, 3), (3, 4), (6, 1), (4, 1)],\n    2: [(7, 1), (8, 2), (3, 4), (4, 4)],\n    3: [(9, 4), (5, 1), (8, 2), (6, 4), (4, 2)],\n    4: [(9, 4), (5, 4), (7, 2), (6, 3)],\n    5: [(9, 1), (7, 2), (6, 1)],\n    6: [(9, 1), (8, 3)],\n    7: [(9, 1)],\n    8: [(9, 1)],\n    9: []\n}\n\n# Add reverse edges since the graph is undirected\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if u not in [x[0] for x in graph[v]]:\n            graph[v].append((u, w))\n\nshortest_path_length = dijkstra(graph, 9, 2)\nprint(shortest_path_length)\n```"}, "253": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 4), (7, 3), (3, 4), (2, 1), (6, 2), (4, 2)],\n    1: [(0, 4), (7, 1), (3, 2), (5, 4), (2, 2), (6, 1), (4, 1)],\n    2: [(0, 1), (7, 4), (3, 4), (5, 3), (6, 3), (4, 2), (1, 2)],\n    3: [(0, 4), (7, 1), (5, 2), (6, 3), (4, 3), (1, 2), (2, 4)],\n    4: [(0, 2), (7, 2), (5, 1), (6, 3), (1, 1), (2, 2), (3, 3)],\n    5: [(1, 4), (2, 3), (3, 2), (4, 1), (7, 3), (6, 3)],\n    6: [(0, 2), (1, 1), (2, 3), (3, 3), (4, 3), (5, 3), (7, 3)],\n    7: [(0, 3), (1, 1), (2, 4), (3, 1), (4, 2), (5, 3), (6, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 0)\nprint(shortest_path_length)\n```"}, "254": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 4), (1, 1), (3, 4)],\n    1: [(0, 1), (4, 4)],\n    2: [(0, 4), (5, 1), (4, 3), (6, 1)],\n    3: [(0, 4), (6, 4)],\n    4: [(1, 4), (2, 3), (5, 2)],\n    5: [(2, 1), (4, 2), (6, 1)],\n    6: [(2, 1), (3, 4), (5, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 1)\nprint(shortest_path_length)\n```"}, "255": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(11, 6), (12, 6), (8, 7)],\n    1: [(13, 3)],\n    2: [(10, 6), (15, 6), (14, 7), (8, 3)],\n    3: [(10, 5), (14, 2)],\n    4: [(11, 6), (15, 4), (6, 10)],\n    5: [(9, 9), (10, 10), (15, 2), (6, 10), (13, 9)],\n    6: [(7, 1), (14, 9)],\n    7: [(15, 6)],\n    8: [(11, 9), (12, 5)],\n    9: [(12, 1), (13, 10)],\n    10: [],\n    11: [],\n    12: [],\n    13: [],\n    14: [(15, 1)],\n    15: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if v not in graph:\n            graph[v] = []\n        graph[v].append((u, w))\n\nshortest_path_length = dijkstra(graph, 7, 0)\nprint(shortest_path_length)\n```"}, "256": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(15, 8), (6, 6), (10, 9), (14, 3)],\n    1: [(5, 2), (14, 4)],\n    2: [(13, 6), (7, 3), (9, 8)],\n    3: [(15, 10), (11, 9), (10, 7), (12, 8)],\n    4: [(15, 5), (8, 5), (9, 8), (14, 1)],\n    5: [(1, 2), (6, 4), (13, 2), (9, 4), (14, 2)],\n    6: [(0, 6), (5, 4), (13, 9), (7, 5), (9, 6)],\n    7: [(2, 3), (6, 5), (13, 2)],\n    8: [(4, 5), (9, 2)],\n    9: [(2, 8), (4, 8), (5, 4), (6, 6), (8, 2), (11, 6)],\n    10: [(0, 9), (3, 7), (13, 6)],\n    11: [(3, 9), (9, 6), (14, 3)],\n    12: [(3, 8)],\n    13: [(2, 6), (5, 2), (6, 9), (7, 2), (10, 6)],\n    14: [(0, 3), (1, 4), (4, 1), (5, 2), (11, 3)],\n    15: [(0, 8), (3, 10), (4, 5)]\n}\n\nprint(dijkstra(graph, 1, 12))\n```"}, "257": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 4), (4, 1), (2, 2)],\n    1: [(0, 4), (4, 1), (2, 4)],\n    2: [(0, 2), (1, 4), (3, 3), (4, 3)],\n    3: [(2, 3), (4, 1)],\n    4: [(0, 1), (1, 1), (2, 3), (3, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 1)\nprint(shortest_path_length)\n```"}, "258": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 3), (5, 10), (10, 2), (11, 1), (1, 8)],\n    1: [(0, 8), (10, 1), (9, 9), (4, 8)],\n    2: [(11, 8)],\n    3: [(10, 9), (8, 1)],\n    4: [(1, 8), (10, 8)],\n    5: [(0, 10)],\n    6: [(9, 9)],\n    7: [(0, 3)],\n    8: [(3, 1)],\n    9: [(1, 9), (6, 9)],\n    10: [(0, 2), (1, 1), (3, 9), (4, 8), (11, 9)],\n    11: [(0, 1), (2, 8), (10, 9)]\n}\n\nstart_node = 9\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "259": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(14, 5), (15, 9), (8, 9)],\n    1: [(14, 3), (11, 5), (5, 7), (3, 4), (9, 2), (7, 4), (8, 10)],\n    2: [(12, 5), (11, 1), (3, 8), (7, 6)],\n    3: [(14, 4), (13, 8)],\n    4: [(6, 1), (11, 8), (10, 1), (13, 1), (7, 3)],\n    5: [(12, 9), (13, 2), (15, 3)],\n    6: [(8, 10)],\n    7: [(9, 3)],\n    8: [(12, 9), (14, 10)],\n    9: [(14, 2), (11, 6), (13, 1), (15, 8)],\n    10: [(12, 2)],\n    11: [],\n    12: [],\n    13: [],\n    14: [],\n    15: []\n}\n\n# Add reverse edges for undirected graph\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if u not in [x[0] for x in graph[v]]:\n            graph[v].append((u, w))\n\nshortest_path_length = dijkstra(graph, 13, 0)\nprint(shortest_path_length)\n```"}, "260": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 3), (3, 4), (2, 1), (6, 1)],\n    1: [(0, 3), (5, 1), (3, 1), (4, 1), (6, 3)],\n    2: [(0, 1), (5, 3), (3, 2), (4, 1), (6, 2)],\n    3: [(0, 4), (1, 1), (2, 2), (5, 1), (4, 1), (6, 4)],\n    4: [(1, 1), (2, 1), (3, 1), (5, 3), (6, 3)],\n    5: [(1, 1), (2, 3), (3, 1), (4, 3), (6, 2)],\n    6: [(0, 1), (1, 3), (2, 2), (3, 4), (4, 3), (5, 2)]\n}\n\nprint(dijkstra(graph, 5, 0))\n```"}, "261": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (3, 3), (6, 4), (1, 3), (7, 1)],\n    1: [(0, 3), (2, 3), (4, 3), (3, 4), (6, 3), (7, 2), (5, 3)],\n    2: [(1, 3), (4, 4), (3, 4), (7, 2), (5, 4)],\n    3: [(0, 3), (1, 4), (2, 4), (4, 3), (5, 4)],\n    4: [(0, 4), (1, 3), (2, 4), (3, 3), (6, 2), (7, 1), (5, 4)],\n    5: [(1, 3), (2, 4), (3, 4), (4, 4), (6, 3)],\n    6: [(0, 4), (1, 3), (4, 2), (5, 3), (7, 4)],\n    7: [(0, 1), (1, 2), (2, 2), (4, 1), (6, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 2, 6)\nprint(shortest_path_length)\n```"}, "262": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 5)],\n    1: [(7, 8), (8, 1), (6, 1)],\n    2: [(10, 6)],\n    3: [(10, 1), (9, 4), (6, 6)],\n    4: [(10, 5)],\n    5: [(0, 5), (10, 6), (9, 9), (6, 2)],\n    6: [(1, 1), (3, 6), (5, 2), (8, 9), (9, 6)],\n    7: [(1, 8)],\n    8: [(1, 1), (6, 9), (11, 3), (10, 2), (9, 2)],\n    9: [(3, 4), (5, 9), (6, 6), (8, 2)],\n    10: [(2, 6), (3, 1), (4, 5), (5, 6), (8, 2)],\n    11: [(8, 3)]\n}\n\nstart_node = 7\nend_node = 3\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "263": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(5, 2), (2, 4), (1, 2), (6, 1)],\n    1: [(0, 2), (3, 2), (2, 3), (4, 1)],\n    2: [(0, 4), (1, 3), (3, 4), (6, 3)],\n    3: [(1, 2), (2, 4), (5, 1)],\n    4: [(1, 1), (5, 2)],\n    5: [(0, 2), (3, 1), (4, 2)],\n    6: [(0, 1), (2, 3)]\n}\n\nstart_node = 3\nend_node = 0\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "264": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 2), (7, 4), (6, 4), (5, 1)],\n    1: [(0, 2), (4, 1), (7, 3), (3, 3), (6, 4)],\n    2: [(7, 2), (3, 2), (6, 2), (5, 1)],\n    3: [(1, 3), (2, 2), (4, 4), (7, 3), (5, 4)],\n    4: [(1, 1), (7, 4), (6, 4), (5, 1)],\n    5: [(0, 1), (2, 1), (3, 4), (4, 1)],\n    6: [(0, 4), (1, 4), (2, 2), (4, 4), (7, 1)],\n    7: [(0, 4), (1, 3), (2, 2), (3, 3), (4, 4), (6, 1)]\n}\n\nstart_node = 4\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "265": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 4), (1, 2), (13, 9)],\n    1: [(0, 2), (10, 10), (12, 10), (2, 8), (5, 9)],\n    2: [(1, 8), (6, 3), (10, 8), (4, 6)],\n    3: [(15, 8), (12, 2), (14, 1)],\n    4: [(6, 9), (12, 10), (13, 5), (7, 7), (11, 9)],\n    5: [(1, 9), (6, 10), (11, 9)],\n    6: [(2, 3), (4, 9), (5, 10)],\n    7: [(4, 7), (15, 1), (13, 3)],\n    8: [(15, 5), (9, 7)],\n    9: [(8, 7), (15, 7), (10, 5)],\n    10: [(1, 10), (2, 8), (9, 5), (15, 7)],\n    11: [(4, 9), (5, 9)],\n    12: [(0, 4), (1, 10), (3, 2), (4, 10)],\n    13: [(0, 9), (4, 5), (7, 3)],\n    14: [(3, 1)],\n    15: [(3, 8), (7, 1), (8, 5), (9, 7), (10, 7)]\n}\n\nstart_node = 11\nend_node = 9\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "266": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 10), (3, 6)],\n    1: [(7, 5), (4, 2)],\n    2: [(10, 6), (7, 3), (4, 4)],\n    3: [(0, 6), (4, 7)],\n    4: [(1, 2), (2, 4), (3, 7), (8, 1)],\n    5: [(10, 6), (9, 6)],\n    6: [(9, 10)],\n    7: [(1, 5), (2, 3), (9, 8)],\n    8: [(4, 1), (10, 6)],\n    9: [(5, 6), (6, 10), (7, 8)],\n    10: [(0, 10), (2, 6), (5, 6), (8, 6)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 10)\nprint(shortest_path_length)\n```"}, "267": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 7)],\n    1: [(5, 6), (13, 9), (12, 2), (2, 10), (9, 3), (4, 6)],\n    2: [(7, 9), (13, 10), (1, 10)],\n    3: [(7, 2), (8, 5), (11, 4)],\n    4: [(7, 5), (12, 3), (8, 5), (9, 10), (1, 6)],\n    5: [(1, 6), (12, 1), (10, 6)],\n    6: [(11, 6)],\n    7: [(2, 9), (3, 2), (4, 5), (10, 3)],\n    8: [(3, 5), (4, 5)],\n    9: [(0, 7), (1, 3), (4, 10)],\n    10: [(5, 6), (7, 3), (13, 4)],\n    11: [(3, 4), (6, 6)],\n    12: [(1, 2), (4, 3), (5, 1), (13, 7)],\n    13: [(1, 9), (2, 10), (10, 4), (12, 7)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 6)\nprint(shortest_path_length)\n```"}, "268": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 5), (8, 6), (9, 2), (1, 2), (11, 8)],\n    1: [(0, 2), (4, 9), (7, 7)],\n    2: [(12, 8), (3, 8)],\n    3: [(2, 8)],\n    4: [(1, 9), (10, 4), (13, 5), (8, 2), (5, 4), (6, 4)],\n    5: [(4, 4), (8, 5), (11, 4)],\n    6: [(4, 4), (13, 8), (8, 4)],\n    7: [(1, 7), (10, 1), (11, 4)],\n    8: [(0, 6), (4, 2), (5, 5), (6, 4), (10, 4), (9, 1), (11, 4)],\n    9: [(0, 2), (8, 1), (12, 9)],\n    10: [(0, 5), (4, 4), (7, 1), (8, 4)],\n    11: [(0, 8), (5, 4), (7, 4), (8, 4), (13, 4)],\n    12: [(2, 8), (9, 9)],\n    13: [(4, 5), (6, 8), (11, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 7)\nprint(shortest_path_length)\n```"}, "269": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 1), (3, 4), (9, 3), (1, 4), (5, 3), (2, 2), (7, 1), (8, 3)],\n    1: [(6, 2), (3, 2), (9, 2), (4, 2), (5, 1), (7, 4), (8, 1), (0, 4)],\n    2: [(6, 4), (3, 3), (4, 1), (5, 1), (7, 1), (8, 1), (0, 2)],\n    3: [(6, 2), (9, 2), (4, 3), (5, 3), (7, 4), (8, 4), (0, 4), (1, 2), (2, 3)],\n    4: [(9, 2), (5, 4), (7, 4), (8, 3), (1, 2), (2, 1), (3, 3)],\n    5: [(6, 1), (9, 2), (8, 3), (0, 3), (1, 1), (2, 1), (3, 3), (4, 4)],\n    6: [(9, 1), (7, 4), (8, 4), (0, 1), (1, 2), (2, 4), (3, 2), (5, 1)],\n    7: [(9, 4), (8, 2), (0, 1), (1, 4), (2, 1), (3, 4), (4, 4), (6, 4)],\n    8: [(9, 1), (0, 3), (1, 1), (2, 1), (3, 4), (4, 3), (5, 3), (6, 4), (7, 2)],\n    9: [(0, 3), (1, 2), (3, 2), (4, 2), (5, 2), (6, 1), (7, 4), (8, 1)]\n}\n\nprint(dijkstra(graph, 6, 4))\n```"}, "270": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 10), (2, 8), (5, 5)],\n    1: [(10, 6), (8, 5), (2, 9)],\n    2: [(0, 8), (1, 9), (11, 5)],\n    3: [(12, 8), (4, 1), (5, 3)],\n    4: [(3, 1)],\n    5: [(0, 5), (3, 3)],\n    6: [(12, 4), (9, 7)],\n    7: [(11, 1)],\n    8: [(1, 5), (9, 3)],\n    9: [(0, 10), (6, 7), (8, 3)],\n    10: [(1, 6)],\n    11: [(2, 5), (7, 1)],\n    12: [(3, 8), (6, 4)]\n}\n\nstart_node = 12\nend_node = 8\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "271": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 6), (7, 10), (3, 7)],\n    1: [(9, 6)],\n    2: [(10, 2), (8, 10), (5, 2)],\n    3: [(9, 8), (8, 10), (5, 4), (0, 7)],\n    4: [(10, 6), (5, 8)],\n    5: [(2, 2), (3, 4), (4, 8)],\n    6: [(7, 2)],\n    7: [(0, 10), (6, 2)],\n    8: [(2, 10), (3, 10), (9, 5)],\n    9: [(1, 6), (3, 8), (8, 5)],\n    10: [(0, 6), (2, 2), (4, 6)]\n}\n\nshortest_path_length = dijkstra(graph, 1, 6)\nprint(shortest_path_length)\n```"}, "272": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 1), (4, 4), (3, 1), (5, 3)],\n    1: [(2, 4), (4, 2), (3, 4), (5, 2)],\n    2: [(0, 1), (1, 4), (4, 3), (3, 2), (5, 1)],\n    3: [(0, 1), (1, 4), (2, 2), (4, 3), (5, 3)],\n    4: [(0, 4), (1, 2), (2, 3), (3, 3), (5, 1)],\n    5: [(0, 3), (1, 2), (2, 1), (3, 3), (4, 1)]\n}\n\nprint(dijkstra(graph, 1, 0))\n```"}, "273": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 2), (2, 4), (6, 2), (3, 3), (4, 4), (1, 3), (7, 4), (5, 3)],\n    1: [(8, 4), (2, 3), (6, 4), (3, 1), (4, 4), (7, 3), (5, 1), (0, 3)],\n    2: [(8, 2), (6, 4), (3, 4), (4, 2), (5, 3), (0, 4), (1, 3)],\n    3: [(8, 2), (4, 3), (7, 3), (5, 3), (0, 3), (1, 1), (2, 4)],\n    4: [(8, 1), (6, 2), (7, 4), (5, 2), (0, 4), (1, 4), (2, 2), (3, 3)],\n    5: [(8, 3), (6, 1), (0, 3), (1, 1), (2, 3), (3, 3), (4, 2)],\n    6: [(8, 3), (7, 1), (0, 2), (1, 4), (2, 4), (4, 2), (5, 1)],\n    7: [(8, 2), (0, 4), (1, 3), (3, 3), (4, 4), (6, 1)],\n    8: [(0, 2), (1, 4), (2, 2), (3, 2), (4, 1), (5, 3), (6, 3), (7, 2)]\n}\n\nprint(dijkstra(graph, 2, 7))\n```"}, "274": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(13, 5), (12, 3), (10, 7)],\n    1: [(4, 10), (2, 6), (13, 3), (8, 4)],\n    2: [(4, 2), (8, 6), (12, 6), (11, 5), (5, 1)],\n    3: [(7, 5), (10, 2)],\n    4: [(7, 2), (8, 4), (5, 1)],\n    5: [],\n    6: [(9, 10), (13, 9), (11, 1)],\n    7: [(9, 5)],\n    8: [],\n    9: [(13, 5), (10, 7)],\n    10: [],\n    11: [(13, 1)],\n    12: [],\n    13: [(14, 3)],\n    14: []\n}\n\nshortest_path_length = dijkstra(graph, 10, 14)\nprint(shortest_path_length)\n```"}, "275": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(12, 7), (14, 5), (4, 4)],\n    1: [(5, 10), (13, 9), (3, 3)],\n    2: [(6, 4), (15, 8), (13, 4), (10, 4)],\n    3: [(8, 5), (14, 4), (1, 3)],\n    4: [(16, 6), (8, 4), (14, 2), (15, 5), (10, 1), (0, 4)],\n    5: [(16, 7), (12, 9), (1, 10)],\n    6: [(10, 4), (2, 4)],\n    7: [(15, 3)],\n    8: [(16, 6), (14, 5), (10, 4), (3, 5), (4, 4)],\n    9: [(16, 7)],\n    10: [(12, 10), (15, 9), (2, 4), (6, 4), (8, 4), (4, 1)],\n    11: [(12, 5)],\n    12: [(0, 7), (5, 9), (10, 10), (11, 5)],\n    13: [(1, 9), (2, 4)],\n    14: [(0, 5), (3, 4), (4, 2), (8, 5), (16, 3)],\n    15: [(2, 8), (7, 3), (4, 5), (10, 9)],\n    16: [(4, 6), (5, 7), (8, 6), (9, 7), (14, 3)]\n}\n\nstart_node = 7\nend_node = 5\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "276": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(4, 2), (3, 2), (2, 3)],\n    1: [(4, 3), (6, 4), (3, 1)],\n    2: [(4, 1), (6, 4), (3, 2)],\n    3: [(0, 2), (1, 1), (2, 2), (4, 2), (6, 4), (5, 3)],\n    4: [(0, 2), (1, 3), (2, 1), (3, 2)],\n    5: [(3, 3), (6, 4)],\n    6: [(1, 4), (2, 4), (3, 4), (5, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 6)\nprint(shortest_path_length)\n```"}, "277": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 2), (2, 3), (4, 2), (5, 2), (6, 3), (8, 2), (3, 3)],\n    1: [(2, 4), (8, 2)],\n    2: [(0, 3), (1, 4), (7, 1), (6, 2), (8, 2), (3, 4)],\n    3: [(0, 3), (2, 4), (7, 4), (4, 4), (5, 2), (8, 2)],\n    4: [(0, 2), (3, 4), (5, 1), (6, 4)],\n    5: [(0, 2), (3, 2), (4, 1), (7, 4), (8, 2)],\n    6: [(0, 3), (2, 2), (4, 4), (7, 2), (8, 2)],\n    7: [(0, 2), (2, 1), (3, 4), (5, 4), (6, 2)],\n    8: [(0, 2), (1, 2), (2, 2), (3, 2), (5, 2), (6, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 4)\nprint(shortest_path_length)\n```"}, "278": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 3), (5, 1), (7, 4), (2, 2)],\n    1: [(5, 2), (3, 2), (4, 2), (7, 2), (2, 4), (6, 1)],\n    2: [(8, 2), (3, 2), (7, 4), (0, 2), (1, 4)],\n    3: [(8, 4), (5, 4), (7, 1), (6, 3), (1, 2), (2, 2)],\n    4: [(8, 4), (7, 2), (6, 3), (1, 2)],\n    5: [(0, 1), (1, 2), (3, 4)],\n    6: [(1, 1), (3, 3), (4, 3), (7, 2)],\n    7: [(0, 4), (1, 2), (2, 4), (3, 1), (4, 2), (6, 2), (8, 4)],\n    8: [(0, 3), (2, 2), (3, 4), (4, 4), (7, 4)]\n}\n\nstart_node = 8\nend_node = 1\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "279": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (5, 4), (6, 2), (4, 2), (2, 2)],\n    1: [(0, 1), (5, 1), (6, 1), (3, 3), (4, 2), (2, 1)],\n    2: [(0, 2), (5, 1), (6, 3), (3, 1), (4, 1), (1, 1)],\n    3: [(1, 3), (5, 4), (6, 2), (2, 1)],\n    4: [(0, 2), (1, 2), (2, 1), (5, 4), (6, 4)],\n    5: [(0, 4), (1, 1), (2, 1), (3, 4), (6, 1), (4, 4)],\n    6: [(0, 2), (1, 1), (2, 3), (3, 2), (5, 1), (4, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 4)\nprint(shortest_path_length)\n```"}, "280": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 9), (11, 6)],\n    1: [(17, 8), (14, 6), (2, 9)],\n    2: [(11, 3), (13, 7), (1, 9)],\n    3: [(8, 8), (4, 8), (6, 5)],\n    4: [(15, 6), (12, 6), (5, 4), (3, 8)],\n    5: [(15, 1), (13, 7), (4, 4)],\n    6: [(3, 5)],\n    7: [(8, 9), (15, 8), (11, 3)],\n    8: [(3, 8), (7, 9)],\n    9: [(0, 9), (10, 2)],\n    10: [(9, 2), (17, 7), (16, 5)],\n    11: [(0, 6), (2, 3), (7, 3)],\n    12: [(4, 6), (17, 7), (16, 2)],\n    13: [(2, 7), (5, 7)],\n    14: [(1, 6)],\n    15: [(4, 6), (5, 1), (7, 8), (17, 7)],\n    16: [(10, 5), (12, 2), (17, 1)],\n    17: [(1, 8), (10, 7), (12, 7), (15, 7), (16, 1)]\n}\n\nstart_node = 6\nend_node = 0\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "281": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(15, 2), (8, 1), (1, 3)],\n    1: [(0, 3), (4, 4), (7, 3), (6, 5), (3, 7), (9, 8), (10, 9)],\n    2: [(11, 8), (14, 9), (7, 2), (8, 3), (9, 9)],\n    3: [(11, 2), (14, 8), (13, 3)],\n    4: [(1, 4), (11, 10), (10, 5)],\n    5: [(7, 10), (8, 10), (9, 3), (12, 3), (10, 9)],\n    6: [(1, 5), (15, 5), (14, 7), (9, 9), (12, 6)],\n    7: [(1, 3), (2, 2), (15, 10), (8, 2), (10, 9)],\n    8: [(0, 1), (2, 3), (5, 10), (7, 2), (14, 5)],\n    9: [(1, 8), (2, 9), (5, 3), (6, 9)],\n    10: [(1, 9), (4, 5), (5, 9), (7, 9), (14, 1), (13, 3)],\n    11: [(2, 8), (3, 2), (4, 10), (13, 4)],\n    12: [(5, 3), (6, 6), (13, 6)],\n    13: [(3, 3), (10, 3), (11, 4), (12, 6)],\n    14: [(2, 9), (3, 8), (6, 7), (8, 5), (10, 1)],\n    15: [(0, 2), (6, 5), (7, 10)]\n}\n\nprint(dijkstra(graph, 5, 11))\n```"}, "282": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 2), (4, 1), (3, 4), (9, 3), (6, 3), (5, 2), (2, 2), (1, 3)],\n    1: [(8, 4), (4, 3), (3, 1), (9, 1), (6, 2), (7, 3), (2, 1), (0, 3)],\n    2: [(8, 2), (4, 4), (3, 3), (9, 1), (6, 4), (7, 4), (5, 3), (0, 2), (1, 1)],\n    3: [(8, 4), (4, 1), (9, 1), (7, 4), (5, 2), (0, 4), (1, 1), (2, 3)],\n    4: [(8, 3), (9, 1), (6, 3), (7, 2), (5, 2), (0, 1), (1, 3), (2, 4), (3, 1)],\n    5: [(8, 1), (9, 4), (6, 2), (7, 2), (0, 2), (2, 3), (3, 2), (4, 2)],\n    6: [(8, 1), (7, 1), (0, 3), (1, 2), (2, 4), (4, 3), (5, 2)],\n    7: [(8, 4), (9, 3), (1, 3), (2, 4), (3, 4), (4, 2), (5, 2), (6, 1)],\n    8: [(0, 2), (1, 4), (2, 2), (3, 4), (4, 3), (5, 1), (6, 1), (7, 4), (9, 3)],\n    9: [(0, 3), (1, 1), (2, 1), (3, 1), (4, 1), (5, 4), (7, 3), (8, 3)]\n}\n\nprint(dijkstra(graph, 3, 6))\n```"}, "283": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 8), (17, 2), (3, 5), (14, 2)],\n    1: [(17, 1), (18, 10), (16, 5)],\n    2: [(6, 2), (14, 4), (7, 2)],\n    3: [(17, 1), (5, 1), (10, 3)],\n    4: [(12, 9), (10, 9), (8, 3), (11, 10)],\n    5: [(12, 6), (17, 1)],\n    6: [(12, 3), (13, 7), (14, 10), (11, 10)],\n    7: [(9, 10)],\n    8: [(13, 4)],\n    9: [(16, 3)],\n    10: [(12, 1), (13, 8)],\n    11: [(18, 3), (13, 5)],\n    12: [(13, 9), (15, 8)],\n    13: [(14, 4)],\n    14: [(15, 5)],\n    15: [],\n    16: [],\n    17: [],\n    18: []\n}\n\nprint(dijkstra(graph, 11, 15))\n```"}, "284": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(4, 5)],\n    1: [(2, 5), (10, 4), (3, 2), (6, 3)],\n    2: [(1, 5), (3, 2), (8, 9)],\n    3: [(1, 2), (2, 2), (7, 6), (6, 1), (5, 5)],\n    4: [(0, 5), (7, 9), (5, 7)],\n    5: [(3, 5), (4, 7), (10, 2), (6, 5)],\n    6: [(1, 3), (3, 1), (5, 5), (7, 1), (9, 7)],\n    7: [(3, 6), (4, 9), (6, 1), (10, 3)],\n    8: [(2, 9)],\n    9: [(6, 7)],\n    10: [(1, 4), (5, 2), (7, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 8)\nprint(shortest_path_length)\n```"}, "285": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(len(graph))}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 7), (7, 10), (4, 3), (8, 2), (16, 1), (6, 4), (19, 4), (15, 8)],\n    1: [(13, 9), (15, 2)],\n    2: [(17, 3), (19, 1), (11, 9), (15, 8), (18, 5), (12, 5)],\n    3: [(17, 4)],\n    4: [(7, 2), (9, 4), (13, 10), (6, 7), (19, 2), (15, 5), (12, 8)],\n    5: [(14, 3), (8, 8), (9, 1), (10, 4)],\n    6: [(7, 5), (16, 6), (13, 3), (15, 8), (18, 3)],\n    7: [(14, 5), (8, 8), (15, 4), (18, 2), (12, 4)],\n    8: [(13, 6)],\n    9: [(14, 6), (12, 7)],\n    10: [(16, 2)],\n    11: [(14, 2)],\n    12: [(16, 1)],\n    13: [(17, 7), (19, 3)],\n    14: [],\n    15: [(16, 9), (19, 5)],\n    16: [(19, 7)],\n    17: [],\n    18: [(19, 8)],\n    19: []\n}\n\nprint(dijkstra(graph, 3, 10))\n```"}, "286": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (9, 3), (5, 2), (8, 3)],\n    1: [(2, 2), (3, 4), (9, 2), (6, 4), (7, 4)],\n    2: [(0, 2), (1, 2), (3, 4), (9, 3), (6, 3), (5, 4), (8, 2), (7, 2), (4, 1)],\n    3: [(1, 4), (2, 4), (9, 4), (6, 3), (8, 3), (7, 2)],\n    4: [(2, 1), (9, 1), (6, 4), (5, 4), (7, 4)],\n    5: [(0, 2), (2, 4), (9, 3), (6, 2), (8, 3)],\n    6: [(1, 4), (2, 3), (3, 3), (4, 4), (5, 2), (8, 1), (7, 1)],\n    7: [(1, 4), (2, 2), (3, 2), (4, 4), (6, 1), (9, 4)],\n    8: [(0, 3), (2, 2), (3, 3), (5, 3), (6, 1)],\n    9: [(0, 3), (1, 2), (2, 3), (3, 4), (4, 1), (5, 3), (7, 4)]\n}\n\nprint(dijkstra(graph, 1, 0))\n```"}, "287": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(4, 4), (3, 4), (2, 3)],\n    1: [(4, 4), (3, 3), (5, 1), (2, 3)],\n    2: [(0, 3), (1, 3), (3, 3)],\n    3: [(0, 4), (1, 3), (2, 3), (4, 1), (5, 4)],\n    4: [(0, 4), (1, 4), (3, 1), (5, 1)],\n    5: [(1, 1), (3, 4), (4, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 2)\nprint(shortest_path_length)\n```"}, "288": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(9, 7), (13, 4)],\n    1: [(2, 10), (5, 6), (12, 2), (14, 3), (10, 4), (11, 3)],\n    2: [(1, 10), (11, 3)],\n    3: [(7, 7), (10, 9), (11, 7), (6, 1)],\n    4: [(8, 6), (13, 8)],\n    5: [(1, 6), (13, 4), (10, 7), (6, 6)],\n    6: [(3, 1), (5, 6), (11, 4)],\n    7: [(3, 7)],\n    8: [(4, 6)],\n    9: [(0, 7), (13, 9)],\n    10: [(1, 4), (3, 9), (5, 7), (13, 7), (11, 1)],\n    11: [(1, 3), (2, 3), (3, 7), (6, 4), (10, 1), (14, 5)],\n    12: [(1, 2)],\n    13: [(0, 4), (4, 8), (5, 4), (9, 9), (10, 7)],\n    14: [(1, 3), (11, 5)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 12)\nprint(shortest_path_length)\n```"}, "289": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(4, 1), (3, 3), (2, 4), (5, 4)],\n    1: [(4, 1), (3, 2), (6, 2)],\n    2: [(0, 4), (4, 2), (5, 3)],\n    3: [(0, 3), (1, 2), (4, 4), (6, 1)],\n    4: [(0, 1), (1, 1), (2, 2), (3, 4), (5, 2), (6, 3)],\n    5: [(0, 4), (2, 3), (4, 2), (7, 3)],\n    6: [(1, 2), (3, 1), (4, 3), (7, 2)],\n    7: [(5, 3), (6, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 7, 4)\nprint(shortest_path_length)\n```"}, "290": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (5, 2), (6, 4), (3, 4), (7, 2), (4, 4)],\n    1: [(2, 1), (6, 1), (7, 1)],\n    2: [(0, 2), (1, 1), (5, 3), (6, 3), (3, 2), (7, 3), (4, 3)],\n    3: [(0, 4), (2, 2), (5, 3), (6, 2), (7, 1)],\n    4: [(0, 4), (2, 3), (6, 1), (7, 1)],\n    5: [(0, 2), (2, 3), (3, 3), (6, 1)],\n    6: [(0, 4), (1, 1), (2, 3), (3, 2), (4, 1), (5, 1), (7, 2)],\n    7: [(0, 2), (1, 1), (2, 3), (3, 1), (4, 1), (6, 2)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 7)\nprint(shortest_path_length)\n```"}, "291": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 9)],\n    1: [(3, 7), (8, 7)],\n    2: [(4, 6), (5, 10), (6, 6)],\n    3: [(1, 7)],\n    4: [(2, 6), (10, 9)],\n    5: [(2, 10), (13, 7), (10, 4)],\n    6: [(2, 6), (11, 9)],\n    7: [(11, 3), (8, 4)],\n    8: [(0, 9), (1, 7), (7, 4), (12, 1), (9, 7)],\n    9: [(8, 7)],\n    10: [(4, 9), (5, 4)],\n    11: [(6, 9), (7, 3), (13, 7)],\n    12: [(8, 1)],\n    13: [(5, 7), (11, 7)]\n}\n\nstart_node = 12\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "292": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 6), (4, 8), (9, 3)],\n    1: [(4, 8)],\n    2: [(0, 6), (10, 7)],\n    3: [(12, 5)],\n    4: [(0, 8), (1, 8), (8, 7), (11, 1), (10, 1)],\n    5: [(7, 4), (10, 3)],\n    6: [(13, 4), (8, 5), (10, 10)],\n    7: [(5, 4)],\n    8: [(4, 7), (6, 5), (12, 4)],\n    9: [(0, 3)],\n    10: [(2, 7), (4, 1), (5, 3), (6, 10)],\n    11: [(4, 1), (13, 2)],\n    12: [(3, 5), (8, 4)],\n    13: [(6, 4), (11, 2)]\n}\n\nstart_node = 13\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "293": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 2), (12, 8), (10, 8)],\n    1: [(10, 9), (2, 3)],\n    2: [(5, 8), (8, 3), (10, 8), (4, 4), (11, 7), (7, 8)],\n    3: [(12, 4), (8, 9)],\n    4: [(15, 9), (13, 9), (11, 1), (14, 5), (9, 10)],\n    5: [(0, 2), (12, 3), (15, 5), (13, 9)],\n    6: [(7, 4)],\n    7: [(6, 4), (12, 1), (8, 3), (14, 3)],\n    8: [(2, 3), (3, 9), (10, 3), (7, 3), (14, 7)],\n    9: [(4, 10), (15, 5), (14, 3)],\n    10: [(0, 8), (1, 9), (2, 8), (8, 3)],\n    11: [(2, 7), (4, 1)],\n    12: [(0, 8), (3, 4), (5, 3), (7, 1), (15, 8)],\n    13: [(4, 9), (5, 9)],\n    14: [(4, 5), (7, 3), (8, 7), (9, 3), (15, 10)],\n    15: [(4, 9), (5, 5), (9, 5), (12, 8), (14, 10)]\n}\n\nshortest_path_length = dijkstra(graph, 6, 8)\nprint(shortest_path_length)\n```"}, "294": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 5), (15, 3), (12, 7), (5, 2)],\n    1: [(4, 6)],\n    2: [(11, 10), (7, 6)],\n    3: [(0, 5), (7, 3), (9, 3)],\n    4: [(1, 6), (13, 10)],\n    5: [(0, 2)],\n    6: [(12, 6), (14, 8), (8, 3)],\n    7: [(2, 6), (3, 3), (11, 9), (10, 4)],\n    8: [(6, 3)],\n    9: [(3, 3)],\n    10: [(7, 4)],\n    11: [(2, 10), (7, 9), (13, 2)],\n    12: [(0, 7), (6, 6), (15, 10)],\n    13: [(4, 10), (11, 2)],\n    14: [(6, 8), (15, 5)],\n    15: [(0, 3), (12, 10), (14, 5)]\n}\n\nshortest_path_length = dijkstra(graph, 4, 14)\nprint(shortest_path_length)\n```"}, "295": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (2, 1)],\n    1: [(0, 1), (4, 1), (2, 3)],\n    2: [(0, 1), (1, 3), (3, 3)],\n    3: [(2, 3)],\n    4: [(1, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 1)\nprint(shortest_path_length)\n```"}, "296": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 3), (3, 4), (5, 4), (2, 3), (1, 3), (4, 3)],\n    1: [(7, 3), (3, 2), (5, 4), (6, 4), (4, 1)],\n    2: [(8, 1), (6, 1), (4, 1)],\n    3: [(7, 4)],\n    4: [(7, 1)],\n    5: [(8, 2)],\n    6: [(7, 2)],\n    7: [],\n    8: []\n}\n\n# Add reverse edges since the graph is undirected\nfor u in list(graph.keys()):\n    for v, w in graph[u]:\n        if u not in [x[0] for x in graph[v]]:\n            graph[v].append((u, w))\n\nshortest_path_length = dijkstra(graph, 7, 5)\nprint(shortest_path_length)\n```"}, "297": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in range(20)}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_node == end:\n            return current_distance\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return float('inf')\n\nedges = [\n    (0, 10, 5), (0, 6, 9), (0, 13, 5), (1, 4, 5), (1, 2, 8), (1, 14, 3),\n    (1, 7, 9), (1, 12, 1), (2, 8, 8), (2, 19, 10), (2, 11, 3), (2, 5, 6),\n    (2, 7, 3), (2, 12, 3), (3, 10, 6), (3, 12, 2), (4, 17, 5), (5, 11, 7),\n    (5, 15, 5), (6, 14, 8), (6, 7, 5), (7, 9, 5), (7, 18, 3), (8, 11, 10),\n    (8, 17, 9), (8, 14, 7), (8, 18, 3), (8, 12, 3), (9, 11, 4), (9, 17, 7),\n    (10, 19, 1), (10, 15, 9), (10, 17, 4), (10, 12, 7), (11, 12, 1), (12, 15, 10),\n    (13, 16, 9), (14, 19, 5), (14, 15, 5), (14, 18, 6), (15, 16, 4)\n]\n\ngraph = {i: [] for i in range(20)}\nfor u, v, w in edges:\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\nshortest_path_length = dijkstra(graph, 7, 13)\nprint(shortest_path_length)\n```"}, "298": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(4, 3), (1, 4)],\n    1: [(0, 4), (4, 4), (2, 2)],\n    2: [(1, 2), (4, 1)],\n    3: [(4, 4)],\n    4: [(0, 3), (1, 4), (2, 1), (3, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 3)\nprint(shortest_path_length)\n```"}, "299": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(2, 2), (1, 4)],\n    1: [(0, 4), (3, 4), (2, 4)],\n    2: [(0, 2), (1, 4), (3, 2)],\n    3: [(1, 4), (2, 2), (4, 4)],\n    4: [(3, 4)]\n}\n\nshortest_path_length = dijkstra(graph, 0, 3)\nprint(shortest_path_length)\n```"}, "300": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(10, 7), (3, 8)],\n    1: [(10, 1), (5, 2), (2, 3), (3, 6), (7, 4)],\n    2: [(9, 3), (5, 1)],\n    4: [(6, 2)],\n    6: [(4, 2), (8, 5)],\n    8: [(6, 5), (10, 5)],\n    9: [(2, 3)],\n    10: [(0, 7), (1, 1), (8, 5)],\n    3: [(0, 8), (1, 6)],\n    5: [(1, 2), (2, 1)],\n    7: [(1, 4)]\n}\n\nstart_node = 9\nend_node = 4\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "301": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(5, 7), (15, 4), (7, 5), (10, 5), (1, 2)],\n    1: [(0, 2), (3, 10), (17, 7), (14, 8)],\n    2: [(5, 10), (15, 8), (16, 9), (6, 9)],\n    3: [(1, 10), (15, 2), (10, 2), (14, 5)],\n    4: [(11, 4), (8, 5), (16, 6), (10, 2), (17, 1)],\n    5: [(0, 7), (2, 10), (11, 5), (15, 10)],\n    6: [(2, 9), (13, 1), (12, 6), (14, 8)],\n    7: [(0, 5), (11, 3)],\n    8: [(4, 5)],\n    9: [(15, 9), (10, 7)],\n    10: [(0, 5), (3, 2), (4, 2), (9, 7), (15, 5)],\n    11: [(4, 4), (5, 5), (7, 3)],\n    12: [(6, 6), (13, 8)],\n    13: [(6, 1), (12, 8)],\n    14: [(1, 8), (3, 5), (6, 8)],\n    15: [(0, 4), (2, 8), (3, 2), (5, 10), (9, 9), (10, 5)],\n    16: [(2, 9), (4, 6), (17, 9)],\n    17: [(1, 7), (4, 1), (16, 9)]\n}\n\nstart_node = 8\nend_node = 12\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "302": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(7, 10)],\n    1: [(10, 8), (7, 4)],\n    2: [(10, 4), (7, 10), (8, 2), (3, 1)],\n    3: [(9, 1), (6, 9), (2, 1)],\n    4: [(5, 3), (8, 8)],\n    5: [(4, 3), (8, 6)],\n    6: [(3, 9), (10, 1)],\n    7: [(0, 10), (1, 4), (2, 10), (9, 6)],\n    8: [(2, 2), (4, 8), (5, 6)],\n    9: [(3, 1), (7, 6), (10, 3)],\n    10: [(1, 8), (2, 4), (6, 1), (9, 3)]\n}\n\nshortest_path_length = dijkstra(graph, 9, 4)\nprint(shortest_path_length)\n```"}, "303": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 1), (15, 8), (9, 9), (11, 8)],\n    1: [(0, 1), (9, 2), (14, 1)],\n    2: [(4, 3), (9, 6), (5, 1)],\n    3: [(10, 2), (12, 9), (17, 6), (11, 3), (5, 1)],\n    4: [(2, 3), (13, 4), (8, 7)],\n    5: [(2, 1), (3, 1), (13, 10), (8, 3), (6, 10)],\n    6: [(5, 10), (15, 5), (11, 3)],\n    7: [(16, 9), (11, 6), (14, 1)],\n    8: [(4, 7), (5, 3), (13, 8)],\n    9: [(0, 9), (1, 2), (2, 6)],\n    10: [(3, 2), (12, 1), (17, 7)],\n    11: [(0, 8), (3, 3), (6, 3), (7, 6), (16, 9)],\n    12: [(3, 9), (10, 1), (13, 5), (14, 1)],\n    13: [(4, 4), (5, 10), (8, 8), (12, 5), (17, 10), (14, 3)],\n    14: [(1, 1), (7, 1), (12, 1), (13, 3), (16, 9)],\n    15: [(0, 8), (6, 5)],\n    16: [(7, 9), (11, 9), (14, 9)],\n    17: [(3, 6), (10, 7), (13, 10)]\n}\n\nstart_node = 8\nend_node = 12\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "304": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 4), (3, 4), (5, 4), (4, 4)],\n    1: [(6, 2), (7, 2)],\n    2: [(0, 4), (7, 1), (3, 4), (4, 2)],\n    3: [(0, 4), (2, 4)],\n    4: [(0, 4), (2, 2), (5, 1)],\n    5: [(0, 4), (4, 1), (6, 2)],\n    6: [(1, 2), (5, 2), (7, 1)],\n    7: [(1, 2), (2, 1), (6, 1)]\n}\n\nprint(dijkstra(graph, 1, 2))\n```"}, "305": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 9), (6, 6)],\n    1: [(5, 6)],\n    2: [(12, 6), (8, 9)],\n    3: [(0, 9), (10, 6), (4, 9), (9, 3), (12, 6), (8, 8), (11, 9)],\n    4: [(3, 9), (7, 9), (11, 2)],\n    5: [(1, 6), (12, 7)],\n    6: [(0, 6)],\n    7: [(4, 9)],\n    8: [(2, 9), (10, 4)],\n    9: [(3, 3), (12, 9)],\n    10: [(3, 6), (8, 4)],\n    11: [(3, 9), (4, 2)],\n    12: [(2, 6), (3, 6), (5, 7), (9, 9)]\n}\n\nstart_node = 1\nend_node = 7\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "306": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 3), (4, 1)],\n    1: [(5, 2), (3, 3), (4, 4)],\n    2: [(0, 3), (5, 1), (3, 1), (4, 2)],\n    3: [(1, 3), (2, 1), (4, 3)],\n    4: [(0, 1), (1, 4), (2, 2), (3, 3)],\n    5: [(1, 2), (2, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 5, 3)\nprint(shortest_path_length)\n```"}, "307": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(11, 7), (14, 1), (3, 8), (12, 3)],\n    1: [(5, 5), (14, 9), (9, 4)],\n    2: [(4, 8), (9, 2), (3, 1), (7, 5)],\n    3: [(0, 8), (2, 1), (8, 7), (10, 4)],\n    4: [(2, 8), (10, 2), (9, 1), (13, 4)],\n    5: [(1, 5), (13, 10), (7, 4), (12, 9)],\n    6: [(14, 9)],\n    7: [(2, 5), (5, 4), (11, 7), (8, 7), (12, 1)],\n    8: [(3, 7), (7, 7), (14, 7), (10, 8), (9, 5), (12, 4)],\n    9: [(1, 4), (2, 2), (4, 1), (8, 5), (13, 2)],\n    10: [(3, 4), (4, 2), (8, 8), (11, 9)],\n    11: [(0, 7), (7, 7), (10, 9)],\n    12: [(0, 3), (5, 9), (7, 1), (8, 4)],\n    13: [(4, 4), (5, 10), (9, 2)],\n    14: [(0, 1), (1, 9), (6, 9), (8, 7)]\n}\n\nstart_node = 6\nend_node = 2\nshortest_path_length = dijkstra(graph, start_node, end_node)\nprint(shortest_path_length)\n```"}, "308": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]\n\ngraph = {\n    0: [(4, 1), (1, 1), (5, 2)],\n    1: [(0, 1), (4, 2), (2, 3)],\n    2: [(1, 3), (3, 4), (4, 3), (5, 4)],\n    3: [(2, 4), (4, 2), (5, 2)],\n    4: [(0, 1), (1, 2), (2, 3), (3, 2), (5, 3)],\n    5: [(0, 2), (2, 4), (3, 2), (4, 3)]\n}\n\nprint(dijkstra(graph, 3, 0))\n```"}, "309": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(2, 5)],\n    1: [(3, 1), (5, 1), (11, 10), (4, 2), (10, 10)],\n    2: [(0, 5), (4, 10)],\n    3: [(1, 1), (9, 5), (8, 2), (6, 7)],\n    4: [(1, 2), (2, 10), (12, 3)],\n    5: [(1, 1), (7, 10), (10, 8), (6, 6)],\n    6: [(3, 7), (5, 6), (8, 5)],\n    7: [(5, 10), (9, 8)],\n    8: [(3, 2), (6, 5), (9, 5)],\n    9: [(3, 5), (7, 8), (8, 5)],\n    10: [(1, 10), (5, 8), (11, 8), (12, 5)],\n    11: [(1, 10), (10, 8), (12, 5)],\n    12: [(4, 3), (10, 5), (11, 5)]\n}\n\nshortest_path_length = dijkstra(graph, 8, 0)\nprint(shortest_path_length)\n```"}, "310": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(1, 8), (11, 8), (8, 3), (16, 8), (5, 4), (19, 6), (13, 2), (18, 7), (4, 7)],\n    1: [(9, 2), (3, 7), (11, 9), (8, 9), (15, 5), (5, 2), (19, 5), (13, 5), (7, 9), (2, 4)],\n    2: [(12, 10)],\n    3: [(16, 7), (10, 3), (7, 2)],\n    4: [(9, 3), (8, 7), (15, 3), (17, 6), (13, 1)],\n    5: [(16, 6), (18, 5), (6, 1)],\n    6: [(17, 1), (10, 10)],\n    7: [(9, 9), (11, 9), (16, 7), (17, 6), (19, 7), (13, 9), (18, 9)],\n    8: [(11, 9)],\n    9: [(16, 5), (12, 3)],\n    10: [(15, 6)],\n    11: [(16, 9), (17, 6), (13, 9)],\n    12: [(14, 6)],\n    13: [(18, 5)],\n    16: [(19, 3)],\n    17: [],\n    18: [],\n    19: []\n}\n\nprint(dijkstra(graph, 9, 10))\n```"}, "311": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 1), (5, 4), (6, 1), (2, 3), (1, 2)],\n    1: [(0, 2), (4, 4), (7, 3), (8, 3), (3, 4), (2, 2)],\n    2: [(0, 3), (1, 2), (4, 3), (7, 3), (8, 3), (3, 1), (5, 4), (6, 3)],\n    3: [(1, 4), (2, 1), (7, 2), (5, 3), (6, 1)],\n    4: [(1, 4), (2, 3), (7, 3), (8, 4), (5, 4), (6, 3)],\n    5: [(0, 4), (2, 4), (3, 3), (4, 4), (7, 1), (8, 2), (6, 3)],\n    6: [(0, 1), (2, 3), (3, 1), (4, 3), (5, 3), (8, 3)],\n    7: [(1, 3), (2, 3), (3, 2), (4, 3), (5, 1), (8, 2)],\n    8: [(0, 1), (1, 3), (2, 3), (4, 4), (5, 2), (6, 3), (7, 2)]\n}\n\nprint(dijkstra(graph, 0, 4))\n```"}, "312": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(3, 3), (4, 2), (8, 1), (2, 2), (5, 3), (9, 3)],\n    1: [(8, 2), (7, 4)],\n    2: [(0, 2), (3, 3), (8, 4)],\n    3: [(0, 3), (2, 3), (8, 4), (7, 2), (6, 1)],\n    4: [(0, 2), (6, 4)],\n    5: [(0, 3), (7, 4), (6, 4)],\n    6: [(3, 1), (4, 4), (5, 4), (8, 1), (7, 3)],\n    7: [(1, 4), (3, 2), (5, 4), (6, 3)],\n    8: [(0, 1), (1, 2), (2, 4), (3, 4), (6, 1), (9, 1)],\n    9: [(0, 3), (8, 1)]\n}\n\nshortest_path_length = dijkstra(graph, 3, 4)\nprint(shortest_path_length)\n```"}, "313": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(11, 6), (5, 6), (16, 3)],\n    1: [(7, 2)],\n    2: [(5, 2), (15, 1), (3, 4), (16, 6)],\n    3: [(2, 4), (4, 9), (14, 8), (16, 2)],\n    4: [(3, 9)],\n    5: [(0, 6), (2, 2), (16, 9), (6, 9)],\n    6: [(5, 9), (9, 1), (16, 9)],\n    7: [(1, 2), (9, 10), (15, 2)],\n    8: [(12, 5), (9, 4), (16, 10)],\n    9: [(6, 1), (7, 10), (8, 4)],\n    10: [(14, 7)],\n    11: [(0, 6)],\n    12: [(8, 5)],\n    13: [(16, 5)],\n    14: [(3, 8), (10, 7), (16, 9)],\n    15: [(2, 1), (7, 2), (16, 6)],\n    16: [(0, 3), (2, 6), (3, 2), (5, 9), (6, 9), (8, 10), (13, 5), (14, 9), (15, 6)]\n}\n\nprint(dijkstra(graph, 3, 1))\n```"}, "314": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(6, 1), (2, 4), (7, 3), (5, 4), (8, 3)],\n    1: [(4, 4), (2, 1), (5, 4)],\n    2: [(0, 4), (1, 1), (6, 1), (4, 4), (3, 1), (7, 1), (5, 3), (8, 2)],\n    3: [(2, 1), (6, 3), (4, 4), (7, 2)],\n    4: [(1, 4), (2, 4), (3, 4), (5, 3), (8, 2)],\n    5: [(0, 4), (1, 4), (2, 3), (4, 3), (6, 4)],\n    6: [(0, 1), (2, 1), (3, 3), (5, 4), (7, 1), (8, 1)],\n    7: [(0, 3), (2, 1), (3, 2), (6, 1), (8, 4)],\n    8: [(0, 3), (2, 2), (4, 2), (6, 1), (7, 4)]\n}\n\nprint(dijkstra(graph, 6, 4))\n```"}, "315": {"gpt4": "```python\nimport heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[end]\n\ngraph = {\n    0: [(8, 4), (12, 7)],\n    1: [(4, 3), (12, 5)],\n    2: [(11, 7), (10, 5)],\n    3: [(6, 5), (7, 10), (12, 9), (9, 2)],\n    4: [(1, 3)],\n    5: [(11, 3)],\n    6: [(3, 5)],\n    7: [(3, 10), (10, 3), (9, 8)],\n    8: [(0, 4), (12, 6)],\n    9: [(3, 2), (7, 8)],\n    10: [(2, 5), (7, 3)],\n    11: [(2, 7), (5, 3)],\n    12: [(0, 7), (1, 5), (3, 9), (8, 6)]\n}\n\nshortest_path_length = dijkstra(graph, 12, 5)\nprint(shortest_path_length)\n```"}}